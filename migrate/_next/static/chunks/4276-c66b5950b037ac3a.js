(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [4276], {
        56335: function(l, c, x) {
            "use strict";
            x.d(c, {
                Z: function() {
                    return createCache
                }
            });
            var N = function() {
                    function StyleSheet(l) {
                        var c = this;
                        this._insertTag = function(l) {
                            var x;
                            x = 0 === c.tags.length ? c.insertionPoint ? c.insertionPoint.nextSibling : c.prepend ? c.container.firstChild : c.before : c.tags[c.tags.length - 1].nextSibling, c.container.insertBefore(l, x), c.tags.push(l)
                        }, this.isSpeedy = void 0 === l.speedy || l.speedy, this.tags = [], this.ctr = 0, this.nonce = l.nonce, this.key = l.key, this.container = l.container, this.prepend = l.prepend, this.insertionPoint = l.insertionPoint, this.before = null
                    }
                    var l = StyleSheet.prototype;
                    return l.hydrate = function(l) {
                        l.forEach(this._insertTag)
                    }, l.insert = function(l) {
                        if (this.ctr % (this.isSpeedy ? 65e3 : 1) == 0) {
                            var c;
                            this._insertTag(((c = document.createElement("style")).setAttribute("data-emotion", this.key), void 0 !== this.nonce && c.setAttribute("nonce", this.nonce), c.appendChild(document.createTextNode("")), c.setAttribute("data-s", ""), c))
                        }
                        var x = this.tags[this.tags.length - 1];
                        if (this.isSpeedy) {
                            var N = function(l) {
                                if (l.sheet) return l.sheet;
                                for (var c = 0; c < document.styleSheets.length; c++)
                                    if (document.styleSheets[c].ownerNode === l) return document.styleSheets[c]
                            }(x);
                            try {
                                N.insertRule(l, N.cssRules.length)
                            } catch (l) {}
                        } else x.appendChild(document.createTextNode(l));
                        this.ctr++
                    }, l.flush = function() {
                        this.tags.forEach(function(l) {
                            return l.parentNode && l.parentNode.removeChild(l)
                        }), this.tags = [], this.ctr = 0
                    }, StyleSheet
                }(),
                U = Math.abs,
                Z = String.fromCharCode,
                $ = Object.assign;

            function Utility_replace(l, c, x) {
                return l.replace(c, x)
            }

            function indexof(l, c) {
                return l.indexOf(c)
            }

            function Utility_charat(l, c) {
                return 0 | l.charCodeAt(c)
            }

            function Utility_substr(l, c, x) {
                return l.slice(c, x)
            }

            function Utility_strlen(l) {
                return l.length
            }

            function Utility_append(l, c) {
                return c.push(l), l
            }
            var Y = 1,
                q = 1,
                J = 0,
                X = 0,
                en = 0,
                er = "";

            function node(l, c, x, N, U, Z, $) {
                return {
                    value: l,
                    root: c,
                    parent: x,
                    type: N,
                    props: U,
                    children: Z,
                    line: Y,
                    column: q,
                    length: $,
                    return: ""
                }
            }

            function Tokenizer_copy(l, c) {
                return $(node("", null, null, "", null, null, 0), l, {
                    length: -l.length
                }, c)
            }

            function next() {
                return en = X < J ? Utility_charat(er, X++) : 0, q++, 10 === en && (q = 1, Y++), en
            }

            function peek() {
                return Utility_charat(er, X)
            }

            function token(l) {
                switch (l) {
                    case 0:
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                        return 5;
                    case 33:
                    case 43:
                    case 44:
                    case 47:
                    case 62:
                    case 64:
                    case 126:
                    case 59:
                    case 123:
                    case 125:
                        return 4;
                    case 58:
                        return 3;
                    case 34:
                    case 39:
                    case 40:
                    case 91:
                        return 2;
                    case 41:
                    case 93:
                        return 1
                }
                return 0
            }

            function alloc(l) {
                return Y = q = 1, J = Utility_strlen(er = l), X = 0, []
            }

            function delimit(l) {
                var c, x;
                return (c = X - 1, x = function delimiter(l) {
                    for (; next();) switch (en) {
                        case l:
                            return X;
                        case 34:
                        case 39:
                            34 !== l && 39 !== l && delimiter(en);
                            break;
                        case 40:
                            41 === l && delimiter(l);
                            break;
                        case 92:
                            next()
                    }
                    return X
                }(91 === l ? l + 2 : 40 === l ? l + 1 : l), Utility_substr(er, c, x)).trim()
            }
            var ea = "-ms-",
                eo = "-moz-",
                el = "-webkit-",
                ec = "comm",
                eu = "rule",
                ed = "decl",
                ep = "@keyframes";

            function Serializer_serialize(l, c) {
                for (var x = "", N = l.length, U = 0; U < N; U++) x += c(l[U], U, l, c) || "";
                return x
            }

            function stringify(l, c, x, N) {
                switch (l.type) {
                    case "@layer":
                        if (l.children.length) break;
                    case "@import":
                    case ed:
                        return l.return = l.return || l.value;
                    case ec:
                        return "";
                    case ep:
                        return l.return = l.value + "{" + Serializer_serialize(l.children, N) + "}";
                    case eu:
                        l.value = l.props.join(",")
                }
                return Utility_strlen(x = Serializer_serialize(l.children, N)) ? l.return = l.value + "{" + x + "}" : ""
            }

            function ruleset(l, c, x, N, Z, $, Y, q, J, X, en) {
                for (var er = Z - 1, ea = 0 === Z ? $ : [""], eo = ea.length, el = 0, ec = 0, ed = 0; el < N; ++el)
                    for (var ep = 0, eh = Utility_substr(l, er + 1, er = U(ec = Y[el])), ey = l; ep < eo; ++ep)(ey = (ec > 0 ? ea[ep] + " " + eh : Utility_replace(eh, /&\f/g, ea[ep])).trim()) && (J[ed++] = ey);
                return node(l, c, x, 0 === Z ? eu : q, J, X, en)
            }

            function declaration(l, c, x, N) {
                return node(l, c, x, ed, Utility_substr(l, 0, N), Utility_substr(l, N + 1, -1), N)
            }
            var identifierWithPointTracking = function(l, c, x) {
                    for (var N = 0, U = 0; N = U, U = peek(), 38 === N && 12 === U && (c[x] = 1), !token(U);) next();
                    return Utility_substr(er, l, X)
                },
                toRules = function(l, c) {
                    var x = -1,
                        N = 44;
                    do switch (token(N)) {
                        case 0:
                            38 === N && 12 === peek() && (c[x] = 1), l[x] += identifierWithPointTracking(X - 1, c, x);
                            break;
                        case 2:
                            l[x] += delimit(N);
                            break;
                        case 4:
                            if (44 === N) {
                                l[++x] = 58 === peek() ? "&\f" : "", c[x] = l[x].length;
                                break
                            }
                        default:
                            l[x] += Z(N)
                    }
                    while (N = next());
                    return l
                },
                getRules = function(l, c) {
                    var x;
                    return x = toRules(alloc(l), c), er = "", x
                },
                eh = new WeakMap,
                compat = function(l) {
                    if ("rule" === l.type && l.parent && !(l.length < 1)) {
                        for (var c = l.value, x = l.parent, N = l.column === x.column && l.line === x.line;
                            "rule" !== x.type;)
                            if (!(x = x.parent)) return;
                        if ((1 !== l.props.length || 58 === c.charCodeAt(0) || eh.get(x)) && !N) {
                            eh.set(l, !0);
                            for (var U = [], Z = getRules(c, U), $ = x.props, Y = 0, q = 0; Y < Z.length; Y++)
                                for (var J = 0; J < $.length; J++, q++) l.props[q] = U[Y] ? Z[Y].replace(/&\f/g, $[J]) : $[J] + " " + Z[Y]
                        }
                    }
                },
                removeLabel = function(l) {
                    if ("decl" === l.type) {
                        var c = l.value;
                        108 === c.charCodeAt(0) && 98 === c.charCodeAt(2) && (l.return = "", l.value = "")
                    }
                },
                ey = [function(l, c, x, N) {
                    if (l.length > -1 && !l.return) switch (l.type) {
                        case ed:
                            l.return = function emotion_cache_browser_esm_prefix(l, c) {
                                switch (45 ^ Utility_charat(l, 0) ? (((c << 2 ^ Utility_charat(l, 0)) << 2 ^ Utility_charat(l, 1)) << 2 ^ Utility_charat(l, 2)) << 2 ^ Utility_charat(l, 3) : 0) {
                                    case 5103:
                                        return el + "print-" + l + l;
                                    case 5737:
                                    case 4201:
                                    case 3177:
                                    case 3433:
                                    case 1641:
                                    case 4457:
                                    case 2921:
                                    case 5572:
                                    case 6356:
                                    case 5844:
                                    case 3191:
                                    case 6645:
                                    case 3005:
                                    case 6391:
                                    case 5879:
                                    case 5623:
                                    case 6135:
                                    case 4599:
                                    case 4855:
                                    case 4215:
                                    case 6389:
                                    case 5109:
                                    case 5365:
                                    case 5621:
                                    case 3829:
                                        return el + l + l;
                                    case 5349:
                                    case 4246:
                                    case 4810:
                                    case 6968:
                                    case 2756:
                                        return el + l + eo + l + ea + l + l;
                                    case 6828:
                                    case 4268:
                                        return el + l + ea + l + l;
                                    case 6165:
                                        return el + l + ea + "flex-" + l + l;
                                    case 5187:
                                        return el + l + Utility_replace(l, /(\w+).+(:[^]+)/, el + "box-$1$2" + ea + "flex-$1$2") + l;
                                    case 5443:
                                        return el + l + ea + "flex-item-" + Utility_replace(l, /flex-|-self/, "") + l;
                                    case 4675:
                                        return el + l + ea + "flex-line-pack" + Utility_replace(l, /align-content|flex-|-self/, "") + l;
                                    case 5548:
                                        return el + l + ea + Utility_replace(l, "shrink", "negative") + l;
                                    case 5292:
                                        return el + l + ea + Utility_replace(l, "basis", "preferred-size") + l;
                                    case 6060:
                                        return el + "box-" + Utility_replace(l, "-grow", "") + el + l + ea + Utility_replace(l, "grow", "positive") + l;
                                    case 4554:
                                        return el + Utility_replace(l, /([^-])(transform)/g, "$1" + el + "$2") + l;
                                    case 6187:
                                        return Utility_replace(Utility_replace(Utility_replace(l, /(zoom-|grab)/, el + "$1"), /(image-set)/, el + "$1"), l, "") + l;
                                    case 5495:
                                    case 3959:
                                        return Utility_replace(l, /(image-set\([^]*)/, el + "$1$`$1");
                                    case 4968:
                                        return Utility_replace(Utility_replace(l, /(.+:)(flex-)?(.*)/, el + "box-pack:$3" + ea + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + el + l + l;
                                    case 4095:
                                    case 3583:
                                    case 4068:
                                    case 2532:
                                        return Utility_replace(l, /(.+)-inline(.+)/, el + "$1$2") + l;
                                    case 8116:
                                    case 7059:
                                    case 5753:
                                    case 5535:
                                    case 5445:
                                    case 5701:
                                    case 4933:
                                    case 4677:
                                    case 5533:
                                    case 5789:
                                    case 5021:
                                    case 4765:
                                        if (Utility_strlen(l) - 1 - c > 6) switch (Utility_charat(l, c + 1)) {
                                            case 109:
                                                if (45 !== Utility_charat(l, c + 4)) break;
                                            case 102:
                                                return Utility_replace(l, /(.+:)(.+)-([^]+)/, "$1" + el + "$2-$3$1" + eo + (108 == Utility_charat(l, c + 3) ? "$3" : "$2-$3")) + l;
                                            case 115:
                                                return ~indexof(l, "stretch") ? emotion_cache_browser_esm_prefix(Utility_replace(l, "stretch", "fill-available"), c) + l : l
                                        }
                                        break;
                                    case 4949:
                                        if (115 !== Utility_charat(l, c + 1)) break;
                                    case 6444:
                                        switch (Utility_charat(l, Utility_strlen(l) - 3 - (~indexof(l, "!important") && 10))) {
                                            case 107:
                                                return Utility_replace(l, ":", ":" + el) + l;
                                            case 101:
                                                return Utility_replace(l, /(.+:)([^;!]+)(;|!.+)?/, "$1" + el + (45 === Utility_charat(l, 14) ? "inline-" : "") + "box$3$1" + el + "$2$3$1" + ea + "$2box$3") + l
                                        }
                                        break;
                                    case 5936:
                                        switch (Utility_charat(l, c + 11)) {
                                            case 114:
                                                return el + l + ea + Utility_replace(l, /[svh]\w+-[tblr]{2}/, "tb") + l;
                                            case 108:
                                                return el + l + ea + Utility_replace(l, /[svh]\w+-[tblr]{2}/, "tb-rl") + l;
                                            case 45:
                                                return el + l + ea + Utility_replace(l, /[svh]\w+-[tblr]{2}/, "lr") + l
                                        }
                                        return el + l + ea + l + l
                                }
                                return l
                            }(l.value, l.length);
                            break;
                        case ep:
                            return Serializer_serialize([Tokenizer_copy(l, {
                                value: Utility_replace(l.value, "@", "@" + el)
                            })], N);
                        case eu:
                            if (l.length) return l.props.map(function(c) {
                                var x;
                                switch (x = c, (x = /(::plac\w+|:read-\w+)/.exec(x)) ? x[0] : x) {
                                    case ":read-only":
                                    case ":read-write":
                                        return Serializer_serialize([Tokenizer_copy(l, {
                                            props: [Utility_replace(c, /:(read-\w+)/, ":" + eo + "$1")]
                                        })], N);
                                    case "::placeholder":
                                        return Serializer_serialize([Tokenizer_copy(l, {
                                            props: [Utility_replace(c, /:(plac\w+)/, ":" + el + "input-$1")]
                                        }), Tokenizer_copy(l, {
                                            props: [Utility_replace(c, /:(plac\w+)/, ":" + eo + "$1")]
                                        }), Tokenizer_copy(l, {
                                            props: [Utility_replace(c, /:(plac\w+)/, ea + "input-$1")]
                                        })], N)
                                }
                                return ""
                            }).join("")
                    }
                }],
                createCache = function(l) {
                    var c, x, U, $, J, ea = l.key;
                    if ("css" === ea) {
                        var eo = document.querySelectorAll("style[data-emotion]:not([data-s])");
                        Array.prototype.forEach.call(eo, function(l) {
                            -1 !== l.getAttribute("data-emotion").indexOf(" ") && (document.head.appendChild(l), l.setAttribute("data-s", ""))
                        })
                    }
                    var el = l.stylisPlugins || ey,
                        eu = {},
                        ed = [];
                    $ = l.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + ea + ' "]'), function(l) {
                        for (var c = l.getAttribute("data-emotion").split(" "), x = 1; x < c.length; x++) eu[c[x]] = !0;
                        ed.push(l)
                    });
                    var ep = (x = (c = [compat, removeLabel].concat(el, [stringify, (U = function(l) {
                            J.insert(l)
                        }, function(l) {
                            !l.root && (l = l.return) && U(l)
                        })])).length, function(l, N, U, Z) {
                            for (var $ = "", Y = 0; Y < x; Y++) $ += c[Y](l, N, U, Z) || "";
                            return $
                        }),
                        stylis = function(l) {
                            var c, x;
                            return Serializer_serialize((x = function parse(l, c, x, N, U, $, J, ea, eo) {
                                for (var el, eu = 0, ed = 0, ep = J, eh = 0, ey = 0, ef = 0, em = 1, eg = 1, eb = 1, ev = 0, ew = "", eT = U, eM = $, eI = N, ex = ew; eg;) switch (ef = ev, ev = next()) {
                                    case 40:
                                        if (108 != ef && 58 == Utility_charat(ex, ep - 1)) {
                                            -1 != indexof(ex += Utility_replace(delimit(ev), "&", "&\f"), "&\f") && (eb = -1);
                                            break
                                        }
                                    case 34:
                                    case 39:
                                    case 91:
                                        ex += delimit(ev);
                                        break;
                                    case 9:
                                    case 10:
                                    case 13:
                                    case 32:
                                        ex += function(l) {
                                            for (; en = peek();)
                                                if (en < 33) next();
                                                else break;
                                            return token(l) > 2 || token(en) > 3 ? "" : " "
                                        }(ef);
                                        break;
                                    case 92:
                                        ex += function(l, c) {
                                            for (var x; --c && next() && !(en < 48) && !(en > 102) && (!(en > 57) || !(en < 65)) && (!(en > 70) || !(en < 97)););
                                            return x = X + (c < 6 && 32 == peek() && 32 == next()), Utility_substr(er, l, x)
                                        }(X - 1, 7);
                                        continue;
                                    case 47:
                                        switch (peek()) {
                                            case 42:
                                            case 47:
                                                Utility_append(node(el = function(l, c) {
                                                    for (; next();)
                                                        if (l + en === 57) break;
                                                        else if (l + en === 84 && 47 === peek()) break;
                                                    return "/*" + Utility_substr(er, c, X - 1) + "*" + Z(47 === l ? l : next())
                                                }(next(), X), c, x, ec, Z(en), Utility_substr(el, 2, -2), 0), eo);
                                                break;
                                            default:
                                                ex += "/"
                                        }
                                        break;
                                    case 123 * em:
                                        ea[eu++] = Utility_strlen(ex) * eb;
                                    case 125 * em:
                                    case 59:
                                    case 0:
                                        switch (ev) {
                                            case 0:
                                            case 125:
                                                eg = 0;
                                            case 59 + ed:
                                                -1 == eb && (ex = Utility_replace(ex, /\f/g, "")), ey > 0 && Utility_strlen(ex) - ep && Utility_append(ey > 32 ? declaration(ex + ";", N, x, ep - 1) : declaration(Utility_replace(ex, " ", "") + ";", N, x, ep - 2), eo);
                                                break;
                                            case 59:
                                                ex += ";";
                                            default:
                                                if (Utility_append(eI = ruleset(ex, c, x, eu, ed, U, ea, ew, eT = [], eM = [], ep), $), 123 === ev) {
                                                    if (0 === ed) parse(ex, c, eI, eI, eT, $, ep, ea, eM);
                                                    else switch (99 === eh && 110 === Utility_charat(ex, 3) ? 100 : eh) {
                                                        case 100:
                                                        case 108:
                                                        case 109:
                                                        case 115:
                                                            parse(l, eI, eI, N && Utility_append(ruleset(l, eI, eI, 0, 0, U, ea, ew, U, eT = [], ep), eM), U, eM, ep, ea, N ? eT : eM);
                                                            break;
                                                        default:
                                                            parse(ex, eI, eI, eI, [""], eM, 0, ea, eM)
                                                    }
                                                }
                                        }
                                        eu = ed = ey = 0, em = eb = 1, ew = ex = "", ep = J;
                                        break;
                                    case 58:
                                        ep = 1 + Utility_strlen(ex), ey = ef;
                                    default:
                                        if (em < 1) {
                                            if (123 == ev) --em;
                                            else if (125 == ev && 0 == em++ && 125 == (en = X > 0 ? Utility_charat(er, --X) : 0, q--, 10 === en && (q = 1, Y--), en)) continue
                                        }
                                        switch (ex += Z(ev), ev * em) {
                                            case 38:
                                                eb = ed > 0 ? 1 : (ex += "\f", -1);
                                                break;
                                            case 44:
                                                ea[eu++] = (Utility_strlen(ex) - 1) * eb, eb = 1;
                                                break;
                                            case 64:
                                                45 === peek() && (ex += delimit(next())), eh = peek(), ed = ep = Utility_strlen(ew = ex += function(l) {
                                                    for (; !token(peek());) next();
                                                    return Utility_substr(er, l, X)
                                                }(X)), ev++;
                                                break;
                                            case 45:
                                                45 === ef && 2 == Utility_strlen(ex) && (em = 0)
                                        }
                                }
                                return $
                            }("", null, null, null, [""], c = alloc(c = l), 0, [0], c), er = "", x), ep)
                        },
                        eh = {
                            key: ea,
                            sheet: new N({
                                key: ea,
                                container: $,
                                nonce: l.nonce,
                                speedy: l.speedy,
                                prepend: l.prepend,
                                insertionPoint: l.insertionPoint
                            }),
                            nonce: l.nonce,
                            inserted: eu,
                            registered: {},
                            insert: function(l, c, x, N) {
                                J = x, stylis(l ? l + "{" + c.styles + "}" : c.styles), N && (eh.inserted[c.name] = !0)
                            }
                        };
                    return eh.sheet.hydrate(ed), eh
                }
        },
        44935: function(l, c, x) {
            "use strict";

            function memoize(l) {
                var c = Object.create(null);
                return function(x) {
                    return void 0 === c[x] && (c[x] = l(x)), c[x]
                }
            }
            x.d(c, {
                Z: function() {
                    return memoize
                }
            })
        },
        36530: function(l, c, x) {
            "use strict";
            x.d(c, {
                T: function() {
                    return Y
                },
                a: function() {
                    return ThemeProvider
                },
                u: function() {
                    return useTheme
                },
                w: function() {
                    return withEmotionCache
                }
            });
            var N = x(2265),
                U = x(56335),
                Z = x(13428),
                weakMemoize = function(l) {
                    var c = new WeakMap;
                    return function(x) {
                        if (c.has(x)) return c.get(x);
                        var N = l(x);
                        return c.set(x, N), N
                    }
                };
            x(68654), x(7599);
            var $ = N.createContext("undefined" != typeof HTMLElement ? (0, U.Z)({
                key: "css"
            }) : null);
            $.Provider;
            var withEmotionCache = function(l) {
                    return (0, N.forwardRef)(function(c, x) {
                        return l(c, (0, N.useContext)($), x)
                    })
                },
                Y = N.createContext({}),
                useTheme = function() {
                    return N.useContext(Y)
                },
                q = weakMemoize(function(l) {
                    return weakMemoize(function(c) {
                        return "function" == typeof c ? c(l) : (0, Z.Z)({}, l, c)
                    })
                }),
                ThemeProvider = function(l) {
                    var c = N.useContext(Y);
                    return l.theme !== c && (c = q(c)(l.theme)), N.createElement(Y.Provider, {
                        value: c
                    }, l.children)
                }
        },
        99538: function(l, c, x) {
            "use strict";
            x.d(c, {
                F4: function() {
                    return keyframes
                }
            }), x(2265), x(7599);
            var N = x(68654);

            function css() {
                for (var l = arguments.length, c = Array(l), x = 0; x < l; x++) c[x] = arguments[x];
                return (0, N.O)(c)
            }
            x(56335), x(55487);
            var keyframes = function() {
                var l = css.apply(void 0, arguments),
                    c = "animation-" + l.name;
                return {
                    name: c,
                    styles: "@keyframes " + c + "{" + l.styles + "}",
                    anim: 1,
                    toString: function() {
                        return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
                    }
                }
            }
        },
        68654: function(l, c, x) {
            "use strict";
            x.d(c, {
                O: function() {
                    return serializeStyles
                }
            });
            var N, U = {
                    animationIterationCount: 1,
                    aspectRatio: 1,
                    borderImageOutset: 1,
                    borderImageSlice: 1,
                    borderImageWidth: 1,
                    boxFlex: 1,
                    boxFlexGroup: 1,
                    boxOrdinalGroup: 1,
                    columnCount: 1,
                    columns: 1,
                    flex: 1,
                    flexGrow: 1,
                    flexPositive: 1,
                    flexShrink: 1,
                    flexNegative: 1,
                    flexOrder: 1,
                    gridRow: 1,
                    gridRowEnd: 1,
                    gridRowSpan: 1,
                    gridRowStart: 1,
                    gridColumn: 1,
                    gridColumnEnd: 1,
                    gridColumnSpan: 1,
                    gridColumnStart: 1,
                    msGridRow: 1,
                    msGridRowSpan: 1,
                    msGridColumn: 1,
                    msGridColumnSpan: 1,
                    fontWeight: 1,
                    lineHeight: 1,
                    opacity: 1,
                    order: 1,
                    orphans: 1,
                    tabSize: 1,
                    widows: 1,
                    zIndex: 1,
                    zoom: 1,
                    WebkitLineClamp: 1,
                    fillOpacity: 1,
                    floodOpacity: 1,
                    stopOpacity: 1,
                    strokeDasharray: 1,
                    strokeDashoffset: 1,
                    strokeMiterlimit: 1,
                    strokeOpacity: 1,
                    strokeWidth: 1
                },
                Z = x(44935),
                $ = /[A-Z]|^ms/g,
                Y = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
                isCustomProperty = function(l) {
                    return 45 === l.charCodeAt(1)
                },
                isProcessableValue = function(l) {
                    return null != l && "boolean" != typeof l
                },
                q = (0, Z.Z)(function(l) {
                    return isCustomProperty(l) ? l : l.replace($, "-$&").toLowerCase()
                }),
                processStyleValue = function(l, c) {
                    switch (l) {
                        case "animation":
                        case "animationName":
                            if ("string" == typeof c) return c.replace(Y, function(l, c, x) {
                                return N = {
                                    name: c,
                                    styles: x,
                                    next: N
                                }, c
                            })
                    }
                    return 1 === U[l] || isCustomProperty(l) || "number" != typeof c || 0 === c ? c : c + "px"
                };

            function handleInterpolation(l, c, x) {
                if (null == x) return "";
                if (void 0 !== x.__emotion_styles) return x;
                switch (typeof x) {
                    case "boolean":
                        return "";
                    case "object":
                        if (1 === x.anim) return N = {
                            name: x.name,
                            styles: x.styles,
                            next: N
                        }, x.name;
                        if (void 0 !== x.styles) {
                            var U = x.next;
                            if (void 0 !== U)
                                for (; void 0 !== U;) N = {
                                    name: U.name,
                                    styles: U.styles,
                                    next: N
                                }, U = U.next;
                            return x.styles + ";"
                        }
                        return function(l, c, x) {
                            var N = "";
                            if (Array.isArray(x))
                                for (var U = 0; U < x.length; U++) N += handleInterpolation(l, c, x[U]) + ";";
                            else
                                for (var Z in x) {
                                    var $ = x[Z];
                                    if ("object" != typeof $) null != c && void 0 !== c[$] ? N += Z + "{" + c[$] + "}" : isProcessableValue($) && (N += q(Z) + ":" + processStyleValue(Z, $) + ";");
                                    else if (Array.isArray($) && "string" == typeof $[0] && (null == c || void 0 === c[$[0]]))
                                        for (var Y = 0; Y < $.length; Y++) isProcessableValue($[Y]) && (N += q(Z) + ":" + processStyleValue(Z, $[Y]) + ";");
                                    else {
                                        var J = handleInterpolation(l, c, $);
                                        switch (Z) {
                                            case "animation":
                                            case "animationName":
                                                N += q(Z) + ":" + J + ";";
                                                break;
                                            default:
                                                N += Z + "{" + J + "}"
                                        }
                                    }
                                }
                            return N
                        }(l, c, x);
                    case "function":
                        if (void 0 !== l) {
                            var Z = N,
                                $ = x(l);
                            return N = Z, handleInterpolation(l, c, $)
                        }
                }
                if (null == c) return x;
                var Y = c[x];
                return void 0 !== Y ? Y : x
            }
            var J = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
                serializeStyles = function(l, c, x) {
                    if (1 === l.length && "object" == typeof l[0] && null !== l[0] && void 0 !== l[0].styles) return l[0];
                    var U, Z = !0,
                        $ = "";
                    N = void 0;
                    var Y = l[0];
                    null == Y || void 0 === Y.raw ? (Z = !1, $ += handleInterpolation(x, c, Y)) : $ += Y[0];
                    for (var q = 1; q < l.length; q++) $ += handleInterpolation(x, c, l[q]), Z && ($ += Y[q]);
                    J.lastIndex = 0;
                    for (var X = ""; null !== (U = J.exec($));) X += "-" + U[1];
                    return {
                        name: function(l) {
                            for (var c, x = 0, N = 0, U = l.length; U >= 4; ++N, U -= 4) c = (65535 & (c = 255 & l.charCodeAt(N) | (255 & l.charCodeAt(++N)) << 8 | (255 & l.charCodeAt(++N)) << 16 | (255 & l.charCodeAt(++N)) << 24)) * 1540483477 + ((c >>> 16) * 59797 << 16), c ^= c >>> 24, x = (65535 & c) * 1540483477 + ((c >>> 16) * 59797 << 16) ^ (65535 & x) * 1540483477 + ((x >>> 16) * 59797 << 16);
                            switch (U) {
                                case 3:
                                    x ^= (255 & l.charCodeAt(N + 2)) << 16;
                                case 2:
                                    x ^= (255 & l.charCodeAt(N + 1)) << 8;
                                case 1:
                                    x ^= 255 & l.charCodeAt(N), x = (65535 & x) * 1540483477 + ((x >>> 16) * 59797 << 16)
                            }
                            return x ^= x >>> 13, (((x = (65535 & x) * 1540483477 + ((x >>> 16) * 59797 << 16)) ^ x >>> 15) >>> 0).toString(36)
                        }($) + X,
                        styles: $,
                        next: N
                    }
                }
        },
        8801: function(l, c, x) {
            "use strict";
            x.d(c, {
                Z: function() {
                    return en
                }
            });
            var N = x(13428),
                U = x(2265),
                Z = x(44935),
                $ = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
                Y = (0, Z.Z)(function(l) {
                    return $.test(l) || 111 === l.charCodeAt(0) && 110 === l.charCodeAt(1) && 91 > l.charCodeAt(2)
                }),
                q = x(36530),
                registerStyles = function(l, c, x) {
                    var N = l.key + "-" + c.name;
                    !1 === x && void 0 === l.registered[N] && (l.registered[N] = c.styles)
                },
                insertStyles = function(l, c, x) {
                    registerStyles(l, c, x);
                    var N = l.key + "-" + c.name;
                    if (void 0 === l.inserted[c.name]) {
                        var U = c;
                        do l.insert(c === U ? "." + N : "", U, l.sheet, !0), U = U.next; while (void 0 !== U)
                    }
                },
                J = x(68654),
                X = x(7599),
                testOmitPropsOnComponent = function(l) {
                    return "theme" !== l
                },
                getDefaultShouldForwardProp = function(l) {
                    return "string" == typeof l && l.charCodeAt(0) > 96 ? Y : testOmitPropsOnComponent
                },
                composeShouldForwardProps = function(l, c, x) {
                    var N;
                    if (c) {
                        var U = c.shouldForwardProp;
                        N = l.__emotion_forwardProp && U ? function(c) {
                            return l.__emotion_forwardProp(c) && U(c)
                        } : U
                    }
                    return "function" != typeof N && x && (N = l.__emotion_forwardProp), N
                },
                Insertion = function(l) {
                    var c = l.cache,
                        x = l.serialized,
                        N = l.isStringTag;
                    return registerStyles(c, x, N), (0, X.L)(function() {
                        return insertStyles(c, x, N)
                    }), null
                },
                en = (function createStyled(l, c) {
                    var x, Z, $ = l.__emotion_real === l,
                        Y = $ && l.__emotion_base || l;
                    void 0 !== c && (x = c.label, Z = c.target);
                    var X = composeShouldForwardProps(l, c, $),
                        en = X || getDefaultShouldForwardProp(Y),
                        er = !en("as");
                    return function() {
                        var ea = arguments,
                            eo = $ && void 0 !== l.__emotion_styles ? l.__emotion_styles.slice(0) : [];
                        if (void 0 !== x && eo.push("label:" + x + ";"), null == ea[0] || void 0 === ea[0].raw) eo.push.apply(eo, ea);
                        else {
                            eo.push(ea[0][0]);
                            for (var el = ea.length, ec = 1; ec < el; ec++) eo.push(ea[ec], ea[0][ec])
                        }
                        var eu = (0, q.w)(function(l, c, x) {
                            var N, $, ea, el = er && l.as || Y,
                                ec = "",
                                eu = [],
                                ed = l;
                            if (null == l.theme) {
                                for (var ep in ed = {}, l) ed[ep] = l[ep];
                                ed.theme = U.useContext(q.T)
                            }
                            "string" == typeof l.className ? (N = c.registered, $ = l.className, ea = "", $.split(" ").forEach(function(l) {
                                void 0 !== N[l] ? eu.push(N[l] + ";") : ea += l + " "
                            }), ec = ea) : null != l.className && (ec = l.className + " ");
                            var eh = (0, J.O)(eo.concat(eu), c.registered, ed);
                            ec += c.key + "-" + eh.name, void 0 !== Z && (ec += " " + Z);
                            var ey = er && void 0 === X ? getDefaultShouldForwardProp(el) : en,
                                ef = {};
                            for (var em in l)(!er || "as" !== em) && ey(em) && (ef[em] = l[em]);
                            return ef.className = ec, ef.ref = x, U.createElement(U.Fragment, null, U.createElement(Insertion, {
                                cache: c,
                                serialized: eh,
                                isStringTag: "string" == typeof el
                            }), U.createElement(el, ef))
                        });
                        return eu.displayName = void 0 !== x ? x : "Styled(" + ("string" == typeof Y ? Y : Y.displayName || Y.name || "Component") + ")", eu.defaultProps = l.defaultProps, eu.__emotion_real = eu, eu.__emotion_base = Y, eu.__emotion_styles = eo, eu.__emotion_forwardProp = X, Object.defineProperty(eu, "toString", {
                            value: function() {
                                return "." + Z
                            }
                        }), eu.withComponent = function(l, x) {
                            return createStyled(l, (0, N.Z)({}, c, x, {
                                shouldForwardProp: composeShouldForwardProps(eu, x, !0)
                            })).apply(void 0, eo)
                        }, eu
                    }
                }).bind();
            ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"].forEach(function(l) {
                en[l] = en(l)
            })
        },
        7599: function(l, c, x) {
            "use strict";
            x.d(c, {
                L: function() {
                    return $
                }
            });
            var N, U = x(2265),
                Z = !!(N || (N = x.t(U, 2))).useInsertionEffect && (N || (N = x.t(U, 2))).useInsertionEffect,
                $ = Z || function(l) {
                    return l()
                };
            Z || U.useLayoutEffect
        },
        39219: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                AbiCoder: function() {
                    return U.R
                },
                ConstructorFragment: function() {
                    return N.Xg
                },
                ErrorFragment: function() {
                    return N.IC
                },
                EventFragment: function() {
                    return N.QV
                },
                FormatTypes: function() {
                    return N.pc
                },
                Fragment: function() {
                    return N.HY
                },
                FunctionFragment: function() {
                    return N.YW
                },
                Indexed: function() {
                    return Z.Hk
                },
                Interface: function() {
                    return Z.vU
                },
                LogDescription: function() {
                    return Z.CC
                },
                ParamType: function() {
                    return N._R
                },
                TransactionDescription: function() {
                    return Z.vk
                },
                checkResultErrors: function() {
                    return $.BR
                },
                defaultAbiCoder: function() {
                    return U.$
                }
            });
            var N = x(55725),
                U = x(77273),
                Z = x(98291),
                $ = x(11035)
        },
        30101: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                decode: function() {
                    return N.J
                },
                encode: function() {
                    return N.c
                }
            });
            var N = x(72275)
        },
        89613: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                _TypedDataEncoder: function() {
                    return $.E
                },
                dnsEncode: function() {
                    return U.Kn
                },
                ensNormalize: function() {
                    return U.w3
                },
                hashMessage: function() {
                    return Z.r
                },
                id: function() {
                    return N.id
                },
                isValidName: function() {
                    return U.r1
                },
                messagePrefix: function() {
                    return Z.B
                },
                namehash: function() {
                    return U.VM
                }
            });
            var N = x(36339),
                U = x(66007),
                Z = x(91798),
                $ = x(31822)
        },
        91798: function(l, c, x) {
            "use strict";
            x.d(c, {
                B: function() {
                    return $
                },
                r: function() {
                    return hashMessage
                }
            });
            var N = x(57273),
                U = x(14184),
                Z = x(58337);
            let $ = "\x19Ethereum Signed Message:\n";

            function hashMessage(l) {
                return "string" == typeof l && (l = (0, Z.Y0)(l)), (0, U.keccak256)((0, N.concat)([(0, Z.Y0)($), (0, Z.Y0)(String(l.length)), l]))
            }
        },
        30686: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                HDNode: function() {
                    return HDNode
                },
                defaultPath: function() {
                    return ep
                },
                entropyToMnemonic: function() {
                    return entropyToMnemonic
                },
                getAccountPath: function() {
                    return getAccountPath
                },
                isValidMnemonic: function() {
                    return isValidMnemonic
                },
                mnemonicToEntropy: function() {
                    return mnemonicToEntropy
                },
                mnemonicToSeed: function() {
                    return mnemonicToSeed
                }
            });
            var N = x(63221),
                U = x(57273),
                Z = x(92598),
                $ = x(58337),
                Y = x(52298),
                q = x(17213),
                J = x(74731),
                X = x(37815),
                en = x(67557),
                er = x(12060),
                ea = x(74506),
                eo = x(36288);
            let el = new eo.Logger("hdnode/5.7.0"),
                ec = Z.O$.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                eu = (0, $.Y0)("Bitcoin seed");

            function getUpperMask(l) {
                return (1 << l) - 1 << 8 - l
            }

            function bytes32(l) {
                return (0, U.hexZeroPad)((0, U.hexlify)(l), 32)
            }

            function base58check(l) {
                return N.Base58.encode((0, U.concat)([l, (0, U.hexDataSlice)((0, X.JQ)((0, X.JQ)(l)), 0, 4)]))
            }

            function getWordlist(l) {
                if (null == l) return ea.E.en;
                if ("string" == typeof l) {
                    let c = ea.E[l];
                    return null == c && el.throwArgumentError("unknown locale", "wordlist", l), c
                }
                return l
            }
            let ed = {},
                ep = "m/44'/60'/0'/0/0";
            let HDNode = class HDNode {
                constructor(l, c, x, N, Z, $, Y, en) {
                    if (l !== ed) throw Error("HDNode constructor cannot be called directly");
                    if (c) {
                        let l = new J.SigningKey(c);
                        (0, q.defineReadOnly)(this, "privateKey", l.privateKey), (0, q.defineReadOnly)(this, "publicKey", l.compressedPublicKey)
                    } else(0, q.defineReadOnly)(this, "privateKey", null), (0, q.defineReadOnly)(this, "publicKey", (0, U.hexlify)(x));
                    (0, q.defineReadOnly)(this, "parentFingerprint", N), (0, q.defineReadOnly)(this, "fingerprint", (0, U.hexDataSlice)((0, X.bP)((0, X.JQ)(this.publicKey)), 0, 4)), (0, q.defineReadOnly)(this, "address", (0, er.computeAddress)(this.publicKey)), (0, q.defineReadOnly)(this, "chainCode", Z), (0, q.defineReadOnly)(this, "index", $), (0, q.defineReadOnly)(this, "depth", Y), null == en ? ((0, q.defineReadOnly)(this, "mnemonic", null), (0, q.defineReadOnly)(this, "path", null)) : "string" == typeof en ? ((0, q.defineReadOnly)(this, "mnemonic", null), (0, q.defineReadOnly)(this, "path", en)) : ((0, q.defineReadOnly)(this, "mnemonic", en), (0, q.defineReadOnly)(this, "path", en.path))
                }
                get extendedKey() {
                    if (this.depth >= 256) throw Error("Depth too large!");
                    return base58check((0, U.concat)([null != this.privateKey ? "0x0488ADE4" : "0x0488B21E", (0, U.hexlify)(this.depth), this.parentFingerprint, (0, U.hexZeroPad)((0, U.hexlify)(this.index), 4), this.chainCode, null != this.privateKey ? (0, U.concat)(["0x00", this.privateKey]) : this.publicKey]))
                }
                neuter() {
                    return new HDNode(ed, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path)
                }
                _derive(l) {
                    if (l > 4294967295) throw Error("invalid index - " + String(l));
                    let c = this.path;
                    c && (c += "/" + (2147483647 & l));
                    let x = new Uint8Array(37);
                    if (2147483648 & l) {
                        if (!this.privateKey) throw Error("cannot derive child of neutered node");
                        x.set((0, U.arrayify)(this.privateKey), 1), c && (c += "'")
                    } else x.set((0, U.arrayify)(this.publicKey));
                    for (let c = 24; c >= 0; c -= 8) x[33 + (c >> 3)] = l >> 24 - c & 255;
                    let N = (0, U.arrayify)((0, X.Gy)(en.p.sha512, this.chainCode, x)),
                        $ = N.slice(0, 32),
                        Y = N.slice(32),
                        q = null,
                        er = null;
                    if (this.privateKey) q = bytes32(Z.O$.from($).add(this.privateKey).mod(ec));
                    else {
                        let l = new J.SigningKey((0, U.hexlify)($));
                        er = l._addPoint(this.publicKey)
                    }
                    let ea = c,
                        eo = this.mnemonic;
                    return eo && (ea = Object.freeze({
                        phrase: eo.phrase,
                        path: c,
                        locale: eo.locale || "en"
                    })), new HDNode(ed, q, er, this.fingerprint, bytes32(Y), l, this.depth + 1, ea)
                }
                derivePath(l) {
                    let c = l.split("/");
                    if (0 === c.length || "m" === c[0] && 0 !== this.depth) throw Error("invalid path - " + l);
                    "m" === c[0] && c.shift();
                    let x = this;
                    for (let l = 0; l < c.length; l++) {
                        let N = c[l];
                        if (N.match(/^[0-9]+'$/)) {
                            let l = parseInt(N.substring(0, N.length - 1));
                            if (l >= 2147483648) throw Error("invalid path index - " + N);
                            x = x._derive(2147483648 + l)
                        } else if (N.match(/^[0-9]+$/)) {
                            let l = parseInt(N);
                            if (l >= 2147483648) throw Error("invalid path index - " + N);
                            x = x._derive(l)
                        } else throw Error("invalid path component - " + N)
                    }
                    return x
                }
                static _fromSeed(l, c) {
                    let x = (0, U.arrayify)(l);
                    if (x.length < 16 || x.length > 64) throw Error("invalid seed");
                    let N = (0, U.arrayify)((0, X.Gy)(en.p.sha512, eu, x));
                    return new HDNode(ed, bytes32(N.slice(0, 32)), null, "0x00000000", bytes32(N.slice(32)), 0, 0, c)
                }
                static fromMnemonic(l, c, x) {
                    return x = getWordlist(x), l = entropyToMnemonic(mnemonicToEntropy(l, x), x), HDNode._fromSeed(mnemonicToSeed(l, c), {
                        phrase: l,
                        path: "m",
                        locale: x.locale
                    })
                }
                static fromSeed(l) {
                    return HDNode._fromSeed(l, null)
                }
                static fromExtendedKey(l) {
                    let c = N.Base58.decode(l);
                    (82 !== c.length || base58check(c.slice(0, 78)) !== l) && el.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
                    let x = c[4],
                        Z = (0, U.hexlify)(c.slice(5, 9)),
                        $ = parseInt((0, U.hexlify)(c.slice(9, 13)).substring(2), 16),
                        Y = (0, U.hexlify)(c.slice(13, 45)),
                        q = c.slice(45, 78);
                    switch ((0, U.hexlify)(c.slice(0, 4))) {
                        case "0x0488b21e":
                        case "0x043587cf":
                            return new HDNode(ed, null, (0, U.hexlify)(q), Z, Y, $, x, null);
                        case "0x0488ade4":
                        case "0x04358394 ":
                            if (0 !== q[0]) break;
                            return new HDNode(ed, (0, U.hexlify)(q.slice(1)), null, Z, Y, $, x, null)
                    }
                    return el.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]")
                }
            };

            function mnemonicToSeed(l, c) {
                c || (c = "");
                let x = (0, $.Y0)("mnemonic" + c, $.Uj.NFKD);
                return (0, Y.n)((0, $.Y0)(l, $.Uj.NFKD), x, 2048, 64, "sha512")
            }

            function mnemonicToEntropy(l, c) {
                c = getWordlist(c), el.checkNormalize();
                let x = c.split(l);
                if (x.length % 3 != 0) throw Error("invalid mnemonic");
                let N = (0, U.arrayify)(new Uint8Array(Math.ceil(11 * x.length / 8))),
                    Z = 0;
                for (let l = 0; l < x.length; l++) {
                    let U = c.getWordIndex(x[l].normalize("NFKD"));
                    if (-1 === U) throw Error("invalid mnemonic");
                    for (let l = 0; l < 11; l++) U & 1 << 10 - l && (N[Z >> 3] |= 1 << 7 - Z % 8), Z++
                }
                let $ = 32 * x.length / 3,
                    Y = x.length / 3,
                    q = getUpperMask(Y),
                    J = (0, U.arrayify)((0, X.JQ)(N.slice(0, $ / 8)))[0] & q;
                if (J !== (N[N.length - 1] & q)) throw Error("invalid checksum");
                return (0, U.hexlify)(N.slice(0, $ / 8))
            }

            function entropyToMnemonic(l, c) {
                if (c = getWordlist(c), (l = (0, U.arrayify)(l)).length % 4 != 0 || l.length < 16 || l.length > 32) throw Error("invalid entropy");
                let x = [0],
                    N = 11;
                for (let c = 0; c < l.length; c++) N > 8 ? (x[x.length - 1] <<= 8, x[x.length - 1] |= l[c], N -= 8) : (x[x.length - 1] <<= N, x[x.length - 1] |= l[c] >> 8 - N, x.push(l[c] & (1 << 8 - N) - 1), N += 3);
                let Z = l.length / 4,
                    $ = (0, U.arrayify)((0, X.JQ)(l))[0] & getUpperMask(Z);
                return x[x.length - 1] <<= Z, x[x.length - 1] |= $ >> 8 - Z, c.join(x.map(l => c.getWord(l)))
            }

            function isValidMnemonic(l, c) {
                try {
                    return mnemonicToEntropy(l, c), !0
                } catch (l) {}
                return !1
            }

            function getAccountPath(l) {
                return ("number" != typeof l || l < 0 || l >= 2147483648 || l % 1) && el.throwArgumentError("invalid account index", "index", l), `m/44'/60'/${l}'/0/0`
            }
        },
        37478: function(l, c, x) {
            "use strict";
            x.d(c, {
                i: function() {
                    return N
                }
            });
            let N = "json-wallets/5.7.0"
        },
        80948: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                decryptCrowdsale: function() {
                    return decrypt
                },
                decryptJsonWallet: function() {
                    return decryptJsonWallet
                },
                decryptJsonWalletSync: function() {
                    return decryptJsonWalletSync
                },
                decryptKeystore: function() {
                    return ec.pe
                },
                decryptKeystoreSync: function() {
                    return ec.hb
                },
                encryptKeystore: function() {
                    return ec.HI
                },
                getJsonWalletAddress: function() {
                    return el.Rb
                },
                isCrowdsaleWallet: function() {
                    return el.LW
                },
                isKeystoreWallet: function() {
                    return el.aO
                }
            });
            var N = x(66179),
                U = x.n(N),
                Z = x(18994),
                $ = x(57273),
                Y = x(14184),
                q = x(52298),
                J = x(58337),
                X = x(17213),
                en = x(36288),
                er = x(37478),
                ea = x(59113);
            let eo = new en.Logger(er.i);
            let CrowdsaleAccount = class CrowdsaleAccount extends X.Description {
                isCrowdsaleAccount(l) {
                    return !!(l && l._isCrowdsaleAccount)
                }
            };

            function decrypt(l, c) {
                let x = JSON.parse(l);
                c = (0, ea.Ij)(c);
                let N = (0, Z.getAddress)((0, ea.gx)(x, "ethaddr")),
                    X = (0, ea.p3)((0, ea.gx)(x, "encseed"));
                X && X.length % 16 == 0 || eo.throwArgumentError("invalid encseed", "json", l);
                let en = (0, $.arrayify)((0, q.n)(c, c, 2e3, 32, "sha256")).slice(0, 16),
                    er = X.slice(0, 16),
                    el = X.slice(16),
                    ec = new(U()).ModeOfOperation.cbc(en, er),
                    eu = U().padding.pkcs7.strip((0, $.arrayify)(ec.decrypt(el))),
                    ed = "";
                for (let l = 0; l < eu.length; l++) ed += String.fromCharCode(eu[l]);
                let ep = (0, J.Y0)(ed),
                    eh = (0, Y.keccak256)(ep);
                return new CrowdsaleAccount({
                    _isCrowdsaleAccount: !0,
                    address: N,
                    privateKey: eh
                })
            }
            var el = x(71600),
                ec = x(50596);

            function decryptJsonWallet(l, c, x) {
                if ((0, el.LW)(l)) {
                    x && x(0);
                    let N = decrypt(l, c);
                    return x && x(1), Promise.resolve(N)
                }
                return (0, el.aO)(l) ? (0, ec.pe)(l, c, x) : Promise.reject(Error("invalid JSON wallet"))
            }

            function decryptJsonWalletSync(l, c) {
                if ((0, el.LW)(l)) return decrypt(l, c);
                if ((0, el.aO)(l)) return (0, ec.hb)(l, c);
                throw Error("invalid JSON wallet")
            }
        },
        71600: function(l, c, x) {
            "use strict";
            x.d(c, {
                LW: function() {
                    return isCrowdsaleWallet
                },
                Rb: function() {
                    return getJsonWalletAddress
                },
                aO: function() {
                    return isKeystoreWallet
                }
            });
            var N = x(18994);

            function isCrowdsaleWallet(l) {
                let c = null;
                try {
                    c = JSON.parse(l)
                } catch (l) {
                    return !1
                }
                return c.encseed && c.ethaddr
            }

            function isKeystoreWallet(l) {
                let c = null;
                try {
                    c = JSON.parse(l)
                } catch (l) {
                    return !1
                }
                return !!c.version && parseInt(c.version) === c.version && 3 === parseInt(c.version)
            }

            function getJsonWalletAddress(l) {
                if (isCrowdsaleWallet(l)) try {
                    return (0, N.getAddress)(JSON.parse(l).ethaddr)
                } catch (l) {
                    return null
                }
                if (isKeystoreWallet(l)) try {
                    return (0, N.getAddress)(JSON.parse(l).address)
                } catch (l) {}
                return null
            }
        },
        50596: function(l, c, x) {
            "use strict";
            x.d(c, {
                HI: function() {
                    return encrypt
                },
                hb: function() {
                    return decryptSync
                },
                pe: function() {
                    return decrypt
                }
            });
            var N = x(66179),
                U = x.n(N),
                Z = x(29150),
                $ = x.n(Z),
                Y = x(18994),
                q = x(57273),
                J = x(30686),
                X = x(14184),
                en = x(52298),
                er = x(19796),
                ea = x(17213),
                eo = x(12060),
                el = x(59113),
                ec = x(36288),
                eu = x(37478);
            let ed = new ec.Logger(eu.i);

            function hasMnemonic(l) {
                return null != l && l.mnemonic && l.mnemonic.phrase
            }
            let KeystoreAccount = class KeystoreAccount extends ea.Description {
                isKeystoreAccount(l) {
                    return !!(l && l._isKeystoreAccount)
                }
            };

            function _getAccount(l, c) {
                let x = (0, el.p3)((0, el.gx)(l, "crypto/ciphertext")),
                    N = (0, q.hexlify)((0, X.keccak256)((0, q.concat)([c.slice(16, 32), x]))).substring(2);
                if (N !== (0, el.gx)(l, "crypto/mac").toLowerCase()) throw Error("invalid password");
                let Z = function(l, c, x) {
                    let N = (0, el.gx)(l, "crypto/cipher");
                    if ("aes-128-ctr" === N) {
                        let N = (0, el.p3)((0, el.gx)(l, "crypto/cipherparams/iv")),
                            Z = new(U()).Counter(N),
                            $ = new(U()).ModeOfOperation.ctr(c, Z);
                        return (0, q.arrayify)($.decrypt(x))
                    }
                    return null
                }(l, c.slice(0, 16), x);
                Z || ed.throwError("unsupported cipher", ec.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "decrypt"
                });
                let $ = c.slice(32, 64),
                    en = (0, eo.computeAddress)(Z);
                if (l.address) {
                    let c = l.address.toLowerCase();
                    if ("0x" !== c.substring(0, 2) && (c = "0x" + c), (0, Y.getAddress)(c) !== en) throw Error("address mismatch")
                }
                let er = {
                    _isKeystoreAccount: !0,
                    address: en,
                    privateKey: (0, q.hexlify)(Z)
                };
                if ("0.1" === (0, el.gx)(l, "x-ethers/version")) {
                    let c = (0, el.p3)((0, el.gx)(l, "x-ethers/mnemonicCiphertext")),
                        x = (0, el.p3)((0, el.gx)(l, "x-ethers/mnemonicCounter")),
                        N = new(U()).Counter(x),
                        Z = new(U()).ModeOfOperation.ctr($, N),
                        Y = (0, el.gx)(l, "x-ethers/path") || J.defaultPath,
                        X = (0, el.gx)(l, "x-ethers/locale") || "en",
                        en = (0, q.arrayify)(Z.decrypt(c));
                    try {
                        let l = (0, J.entropyToMnemonic)(en, X),
                            c = J.HDNode.fromMnemonic(l, null, X).derivePath(Y);
                        if (c.privateKey != er.privateKey) throw Error("mnemonic mismatch");
                        er.mnemonic = c.mnemonic
                    } catch (l) {
                        if (l.code !== ec.Logger.errors.INVALID_ARGUMENT || "wordlist" !== l.argument) throw l
                    }
                }
                return new KeystoreAccount(er)
            }

            function pbkdf2Sync(l, c, x, N, U) {
                return (0, q.arrayify)((0, en.n)(l, c, x, N, U))
            }

            function pbkdf2(l, c, x, N, U) {
                return Promise.resolve(pbkdf2Sync(l, c, x, N, U))
            }

            function _computeKdfKey(l, c, x, N, U) {
                let Z = (0, el.Ij)(c),
                    $ = (0, el.gx)(l, "crypto/kdf");
                if ($ && "string" == typeof $) {
                    let throwError = function(l, c) {
                        return ed.throwArgumentError("invalid key-derivation function parameters", l, c)
                    };
                    if ("scrypt" === $.toLowerCase()) {
                        let c = (0, el.p3)((0, el.gx)(l, "crypto/kdfparams/salt")),
                            x = parseInt((0, el.gx)(l, "crypto/kdfparams/n")),
                            Y = parseInt((0, el.gx)(l, "crypto/kdfparams/r")),
                            q = parseInt((0, el.gx)(l, "crypto/kdfparams/p"));
                        x && Y && q || throwError("kdf", $), (x & x - 1) != 0 && throwError("N", x);
                        let J = parseInt((0, el.gx)(l, "crypto/kdfparams/dklen"));
                        return 32 !== J && throwError("dklen", J), N(Z, c, x, Y, q, 64, U)
                    }
                    if ("pbkdf2" === $.toLowerCase()) {
                        let c = (0, el.p3)((0, el.gx)(l, "crypto/kdfparams/salt")),
                            N = null,
                            U = (0, el.gx)(l, "crypto/kdfparams/prf");
                        "hmac-sha256" === U ? N = "sha256" : "hmac-sha512" === U ? N = "sha512" : throwError("prf", U);
                        let $ = parseInt((0, el.gx)(l, "crypto/kdfparams/c")),
                            Y = parseInt((0, el.gx)(l, "crypto/kdfparams/dklen"));
                        return 32 !== Y && throwError("dklen", Y), x(Z, c, $, Y, N)
                    }
                }
                return ed.throwArgumentError("unsupported key-derivation function", "kdf", $)
            }

            function decryptSync(l, c) {
                let x = JSON.parse(l),
                    N = _computeKdfKey(x, c, pbkdf2Sync, $().syncScrypt);
                return _getAccount(x, N)
            }

            function decrypt(l, c, x) {
                var N, U, Z, Y;
                return N = this, U = void 0, Z = void 0, Y = function*() {
                    let N = JSON.parse(l),
                        U = yield _computeKdfKey(N, c, pbkdf2, $().scrypt, x);
                    return _getAccount(N, U)
                }, new(Z || (Z = Promise))(function(l, c) {
                    function fulfilled(l) {
                        try {
                            step(Y.next(l))
                        } catch (l) {
                            c(l)
                        }
                    }

                    function rejected(l) {
                        try {
                            step(Y.throw(l))
                        } catch (l) {
                            c(l)
                        }
                    }

                    function step(c) {
                        var x;
                        c.done ? l(c.value) : ((x = c.value) instanceof Z ? x : new Z(function(l) {
                            l(x)
                        })).then(fulfilled, rejected)
                    }
                    step((Y = Y.apply(N, U || [])).next())
                })
            }

            function encrypt(l, c, x, N) {
                try {
                    if ((0, Y.getAddress)(l.address) !== (0, eo.computeAddress)(l.privateKey)) throw Error("address/privateKey mismatch");
                    if (hasMnemonic(l)) {
                        let c = l.mnemonic,
                            x = J.HDNode.fromMnemonic(c.phrase, null, c.locale).derivePath(c.path || J.defaultPath);
                        if (x.privateKey != l.privateKey) throw Error("mnemonic mismatch")
                    }
                } catch (l) {
                    return Promise.reject(l)
                }
                "function" != typeof x || N || (N = x, x = {}), x || (x = {});
                let Z = (0, q.arrayify)(l.privateKey),
                    en = (0, el.Ij)(c),
                    ea = null,
                    ec = null,
                    eu = null;
                if (hasMnemonic(l)) {
                    let c = l.mnemonic;
                    ea = (0, q.arrayify)((0, J.mnemonicToEntropy)(c.phrase, c.locale || "en")), ec = c.path || J.defaultPath, eu = c.locale || "en"
                }
                let ed = x.client;
                ed || (ed = "ethers.js");
                let ep = null;
                ep = x.salt ? (0, q.arrayify)(x.salt) : (0, er.O)(32);
                let eh = null;
                if (x.iv) {
                    if (16 !== (eh = (0, q.arrayify)(x.iv)).length) throw Error("invalid iv")
                } else eh = (0, er.O)(16);
                let ey = null;
                if (x.uuid) {
                    if (16 !== (ey = (0, q.arrayify)(x.uuid)).length) throw Error("invalid uuid")
                } else ey = (0, er.O)(16);
                let ef = 131072,
                    em = 8,
                    eg = 1;
                return x.scrypt && (x.scrypt.N && (ef = x.scrypt.N), x.scrypt.r && (em = x.scrypt.r), x.scrypt.p && (eg = x.scrypt.p)), $().scrypt(en, ep, ef, em, eg, 64, N).then(c => {
                    c = (0, q.arrayify)(c);
                    let x = c.slice(0, 16),
                        N = c.slice(16, 32),
                        $ = c.slice(32, 64),
                        Y = new(U()).Counter(eh),
                        J = new(U()).ModeOfOperation.ctr(x, Y),
                        en = (0, q.arrayify)(J.encrypt(Z)),
                        eo = (0, X.keccak256)((0, q.concat)([N, en])),
                        eb = {
                            address: l.address.substring(2).toLowerCase(),
                            id: (0, el.EH)(ey),
                            version: 3,
                            crypto: {
                                cipher: "aes-128-ctr",
                                cipherparams: {
                                    iv: (0, q.hexlify)(eh).substring(2)
                                },
                                ciphertext: (0, q.hexlify)(en).substring(2),
                                kdf: "scrypt",
                                kdfparams: {
                                    salt: (0, q.hexlify)(ep).substring(2),
                                    n: ef,
                                    dklen: 32,
                                    p: eg,
                                    r: em
                                },
                                mac: eo.substring(2)
                            }
                        };
                    if (ea) {
                        let l = (0, er.O)(16),
                            c = new(U()).Counter(l),
                            x = new(U()).ModeOfOperation.ctr($, c),
                            N = (0, q.arrayify)(x.encrypt(ea)),
                            Z = new Date,
                            Y = Z.getUTCFullYear() + "-" + (0, el.VP)(Z.getUTCMonth() + 1, 2) + "-" + (0, el.VP)(Z.getUTCDate(), 2) + "T" + (0, el.VP)(Z.getUTCHours(), 2) + "-" + (0, el.VP)(Z.getUTCMinutes(), 2) + "-" + (0, el.VP)(Z.getUTCSeconds(), 2) + ".0Z";
                        eb["x-ethers"] = {
                            client: ed,
                            gethFilename: "UTC--" + Y + "--" + eb.address,
                            mnemonicCounter: (0, q.hexlify)(l).substring(2),
                            mnemonicCiphertext: (0, q.hexlify)(N).substring(2),
                            path: ec,
                            locale: eu,
                            version: "0.1"
                        }
                    }
                    return JSON.stringify(eb)
                })
            }
        },
        59113: function(l, c, x) {
            "use strict";
            x.d(c, {
                EH: function() {
                    return uuidV4
                },
                Ij: function() {
                    return getPassword
                },
                VP: function() {
                    return zpad
                },
                gx: function() {
                    return searchPath
                },
                p3: function() {
                    return looseArrayify
                }
            });
            var N = x(57273),
                U = x(58337);

            function looseArrayify(l) {
                return "string" == typeof l && "0x" !== l.substring(0, 2) && (l = "0x" + l), (0, N.arrayify)(l)
            }

            function zpad(l, c) {
                for (l = String(l); l.length < c;) l = "0" + l;
                return l
            }

            function getPassword(l) {
                return "string" == typeof l ? (0, U.Y0)(l, U.Uj.NFKC) : (0, N.arrayify)(l)
            }

            function searchPath(l, c) {
                let x = l,
                    N = c.toLowerCase().split("/");
                for (let l = 0; l < N.length; l++) {
                    let c = null;
                    for (let U in x)
                        if (U.toLowerCase() === N[l]) {
                            c = x[U];
                            break
                        }
                    if (null === c) return null;
                    x = c
                }
                return x
            }

            function uuidV4(l) {
                let c = (0, N.arrayify)(l);
                c[6] = 15 & c[6] | 64, c[8] = 63 & c[8] | 128;
                let x = (0, N.hexlify)(c);
                return [x.substring(2, 10), x.substring(10, 14), x.substring(14, 18), x.substring(18, 22), x.substring(22, 34)].join("-")
            }
        },
        52298: function(l, c, x) {
            "use strict";
            x.d(c, {
                n: function() {
                    return pbkdf2
                }
            });
            var N = x(57273),
                U = x(37815);

            function pbkdf2(l, c, x, Z, $) {
                let Y, q, J;
                l = (0, N.arrayify)(l), c = (0, N.arrayify)(c);
                let X = 1,
                    en = new Uint8Array(Z),
                    er = new Uint8Array(c.length + 4);
                er.set(c);
                for (let ea = 1; ea <= X; ea++) {
                    er[c.length] = ea >> 24 & 255, er[c.length + 1] = ea >> 16 & 255, er[c.length + 2] = ea >> 8 & 255, er[c.length + 3] = 255 & ea;
                    let eo = (0, N.arrayify)((0, U.Gy)($, l, er));
                    Y || (Y = eo.length, J = new Uint8Array(Y), X = Math.ceil(Z / Y), q = Z - (X - 1) * Y), J.set(eo);
                    for (let c = 1; c < x; c++) {
                        eo = (0, N.arrayify)((0, U.Gy)($, l, eo));
                        for (let l = 0; l < Y; l++) J[l] ^= eo[l]
                    }
                    let el = (ea - 1) * Y,
                        ec = ea === X ? q : Y;
                    en.set((0, N.arrayify)(J).slice(0, ec), el)
                }
                return (0, N.hexlify)(en)
            }
        },
        86816: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                AlchemyProvider: function() {
                    return AlchemyProvider
                },
                AlchemyWebSocketProvider: function() {
                    return AlchemyWebSocketProvider
                },
                AnkrProvider: function() {
                    return AnkrProvider
                },
                BaseProvider: function() {
                    return Z.Zk
                },
                CloudflareProvider: function() {
                    return CloudflareProvider
                },
                EtherscanProvider: function() {
                    return EtherscanProvider
                },
                FallbackProvider: function() {
                    return FallbackProvider
                },
                Formatter: function() {
                    return Y.Mb
                },
                InfuraProvider: function() {
                    return InfuraProvider
                },
                InfuraWebSocketProvider: function() {
                    return InfuraWebSocketProvider
                },
                IpcProvider: function() {
                    return ew
                },
                JsonRpcBatchProvider: function() {
                    return ex.I
                },
                JsonRpcProvider: function() {
                    return eI.r
                },
                JsonRpcSigner: function() {
                    return eI.C
                },
                NodesmithProvider: function() {
                    return NodesmithProvider
                },
                PocketProvider: function() {
                    return PocketProvider
                },
                Provider: function() {
                    return N.zt
                },
                Resolver: function() {
                    return Z.H2
                },
                StaticJsonRpcProvider: function() {
                    return en.c
                },
                UrlJsonRpcProvider: function() {
                    return en.l
                },
                Web3Provider: function() {
                    return eS.Q
                },
                WebSocketProvider: function() {
                    return q.q
                },
                getDefaultProvider: function() {
                    return getDefaultProvider
                },
                getNetwork: function() {
                    return U.H
                },
                isCommunityResourcable: function() {
                    return Y.Ed
                },
                isCommunityResource: function() {
                    return Y.Gp
                },
                showThrottleMessage: function() {
                    return Y.vh
                }
            });
            var N = x(94999),
                U = x(30795),
                Z = x(26790),
                $ = x(17213),
                Y = x(54259),
                q = x(99227),
                J = x(36288),
                X = x(12312),
                en = x(61127);
            let er = new J.Logger(X.i),
                ea = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
            let AlchemyWebSocketProvider = class AlchemyWebSocketProvider extends q.q {
                constructor(l, c) {
                    let x = new AlchemyProvider(l, c),
                        N = x.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
                    super(N, x.network), (0, $.defineReadOnly)(this, "apiKey", x.apiKey)
                }
                isCommunityResource() {
                    return this.apiKey === ea
                }
            };
            let AlchemyProvider = class AlchemyProvider extends en.l {
                static getWebSocketProvider(l, c) {
                    return new AlchemyWebSocketProvider(l, c)
                }
                static getApiKey(l) {
                    return null == l ? ea : (l && "string" != typeof l && er.throwArgumentError("invalid apiKey", "apiKey", l), l)
                }
                static getUrl(l, c) {
                    let x = null;
                    switch (l.name) {
                        case "homestead":
                            x = "eth-mainnet.alchemyapi.io/v2/";
                            break;
                        case "goerli":
                            x = "eth-goerli.g.alchemy.com/v2/";
                            break;
                        case "matic":
                            x = "polygon-mainnet.g.alchemy.com/v2/";
                            break;
                        case "maticmum":
                            x = "polygon-mumbai.g.alchemy.com/v2/";
                            break;
                        case "arbitrum":
                            x = "arb-mainnet.g.alchemy.com/v2/";
                            break;
                        case "arbitrum-goerli":
                            x = "arb-goerli.g.alchemy.com/v2/";
                            break;
                        case "optimism":
                            x = "opt-mainnet.g.alchemy.com/v2/";
                            break;
                        case "optimism-goerli":
                            x = "opt-goerli.g.alchemy.com/v2/";
                            break;
                        default:
                            er.throwArgumentError("unsupported network", "network", arguments[0])
                    }
                    return {
                        allowGzip: !0,
                        url: "https://" + x + c,
                        throttleCallback: (l, x) => (c === ea && (0, Y.vh)(), Promise.resolve(!0))
                    }
                }
                isCommunityResource() {
                    return this.apiKey === ea
                }
            };
            let eo = new J.Logger(X.i),
                el = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
            let AnkrProvider = class AnkrProvider extends en.l {
                isCommunityResource() {
                    return this.apiKey === el
                }
                static getApiKey(l) {
                    return null == l ? el : l
                }
                static getUrl(l, c) {
                    null == c && (c = el);
                    let x = {
                        allowGzip: !0,
                        url: "https://" + function(l) {
                            switch (l) {
                                case "homestead":
                                    return "rpc.ankr.com/eth/";
                                case "ropsten":
                                    return "rpc.ankr.com/eth_ropsten/";
                                case "rinkeby":
                                    return "rpc.ankr.com/eth_rinkeby/";
                                case "goerli":
                                    return "rpc.ankr.com/eth_goerli/";
                                case "matic":
                                    return "rpc.ankr.com/polygon/";
                                case "arbitrum":
                                    return "rpc.ankr.com/arbitrum/"
                            }
                            return eo.throwArgumentError("unsupported network", "name", l)
                        }(l.name) + c,
                        throttleCallback: (l, x) => (c.apiKey === el && (0, Y.vh)(), Promise.resolve(!0))
                    };
                    return null != c.projectSecret && (x.user = "", x.password = c.projectSecret), x
                }
            };
            let ec = new J.Logger(X.i);
            let CloudflareProvider = class CloudflareProvider extends en.l {
                static getApiKey(l) {
                    return null != l && ec.throwArgumentError("apiKey not supported for cloudflare", "apiKey", l), null
                }
                static getUrl(l, c) {
                    let x = null;
                    return "homestead" === l.name ? x = "https://cloudflare-eth.com/" : ec.throwArgumentError("unsupported network", "network", arguments[0]), x
                }
                perform(l, c) {
                    var x, N, U, Z;
                    let $ = Object.create(null, {
                        perform: {
                            get: () => super.perform
                        }
                    });
                    return x = this, N = void 0, U = void 0, Z = function*() {
                        if ("getBlockNumber" === l) {
                            let l = yield $.perform.call(this, "getBlock", {
                                blockTag: "latest"
                            });
                            return l.number
                        }
                        return $.perform.call(this, l, c)
                    }, new(U || (U = Promise))(function(l, c) {
                        function fulfilled(l) {
                            try {
                                step(Z.next(l))
                            } catch (l) {
                                c(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(Z.throw(l))
                            } catch (l) {
                                c(l)
                            }
                        }

                        function step(c) {
                            var x;
                            c.done ? l(c.value) : ((x = c.value) instanceof U ? x : new U(function(l) {
                                l(x)
                            })).then(fulfilled, rejected)
                        }
                        step((Z = Z.apply(x, N || [])).next())
                    })
                }
            };
            var eu = x(57273),
                ed = x(12060),
                ep = x(39318),
                etherscan_provider_awaiter = function(l, c, x, N) {
                    return new(x || (x = Promise))(function(U, Z) {
                        function fulfilled(l) {
                            try {
                                step(N.next(l))
                            } catch (l) {
                                Z(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(N.throw(l))
                            } catch (l) {
                                Z(l)
                            }
                        }

                        function step(l) {
                            var c;
                            l.done ? U(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                                l(c)
                            })).then(fulfilled, rejected)
                        }
                        step((N = N.apply(l, c || [])).next())
                    })
                };
            let eh = new J.Logger(X.i);

            function getTransactionPostData(l) {
                let c = {};
                for (let x in l) {
                    if (null == l[x]) continue;
                    let N = l[x];
                    ("type" !== x || 0 !== N) && (N = ({
                        type: !0,
                        gasLimit: !0,
                        gasPrice: !0,
                        maxFeePerGs: !0,
                        maxPriorityFeePerGas: !0,
                        nonce: !0,
                        value: !0
                    })[x] ? (0, eu.hexValue)((0, eu.hexlify)(N)) : "accessList" === x ? "[" + (0, ed.accessListify)(N).map(l => `{address:"${l.address}",storageKeys:["${l.storageKeys.join('","')}"]}`).join(",") + "]" : (0, eu.hexlify)(N), c[x] = N)
                }
                return c
            }

            function getResult(l) {
                if (0 == l.status && ("No records found" === l.message || "No transactions found" === l.message)) return l.result;
                if (1 != l.status || "string" != typeof l.message || !l.message.match(/^OK/)) {
                    let c = Error("invalid response");
                    throw c.result = JSON.stringify(l), (l.result || "").toLowerCase().indexOf("rate limit") >= 0 && (c.throttleRetry = !0), c
                }
                return l.result
            }

            function getJsonResult(l) {
                if (l && 0 == l.status && "NOTOK" == l.message && (l.result || "").toLowerCase().indexOf("rate limit") >= 0) {
                    let c = Error("throttled response");
                    throw c.result = JSON.stringify(l), c.throttleRetry = !0, c
                }
                if ("2.0" != l.jsonrpc) {
                    let c = Error("invalid response");
                    throw c.result = JSON.stringify(l), c
                }
                if (l.error) {
                    let c = Error(l.error.message || "unknown error");
                    throw l.error.code && (c.code = l.error.code), l.error.data && (c.data = l.error.data), c
                }
                return l.result
            }

            function checkLogTag(l) {
                if ("pending" === l) throw Error("pending not supported");
                return "latest" === l ? l : parseInt(l.substring(2), 16)
            }

            function checkError(l, c, x) {
                if ("call" === l && c.code === J.Logger.errors.SERVER_ERROR) {
                    let l = c.error;
                    if (l && (l.message.match(/reverted/i) || l.message.match(/VM execution error/i))) {
                        let x = l.data;
                        if (x && (x = "0x" + x.replace(/^.*0x/i, "")), (0, eu.isHexString)(x)) return x;
                        eh.throwError("missing revert data in call exception", J.Logger.errors.CALL_EXCEPTION, {
                            error: c,
                            data: "0x"
                        })
                    }
                }
                let N = c.message;
                throw c.code === J.Logger.errors.SERVER_ERROR && (c.error && "string" == typeof c.error.message ? N = c.error.message : "string" == typeof c.body ? N = c.body : "string" == typeof c.responseText && (N = c.responseText)), (N = (N || "").toLowerCase()).match(/insufficient funds/) && eh.throwError("insufficient funds for intrinsic transaction cost", J.Logger.errors.INSUFFICIENT_FUNDS, {
                    error: c,
                    method: l,
                    transaction: x
                }), N.match(/same hash was already imported|transaction nonce is too low|nonce too low/) && eh.throwError("nonce has already been used", J.Logger.errors.NONCE_EXPIRED, {
                    error: c,
                    method: l,
                    transaction: x
                }), N.match(/another transaction with same nonce/) && eh.throwError("replacement fee too low", J.Logger.errors.REPLACEMENT_UNDERPRICED, {
                    error: c,
                    method: l,
                    transaction: x
                }), N.match(/execution failed due to an exception|execution reverted/) && eh.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", J.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: c,
                    method: l,
                    transaction: x
                }), c
            }
            let EtherscanProvider = class EtherscanProvider extends Z.Zk {
                constructor(l, c) {
                    super(l), (0, $.defineReadOnly)(this, "baseUrl", this.getBaseUrl()), (0, $.defineReadOnly)(this, "apiKey", c || null)
                }
                getBaseUrl() {
                    switch (this.network ? this.network.name : "invalid") {
                        case "homestead":
                            return "https://api.etherscan.io";
                        case "goerli":
                            return "https://api-goerli.etherscan.io";
                        case "sepolia":
                            return "https://api-sepolia.etherscan.io";
                        case "matic":
                            return "https://api.polygonscan.com";
                        case "maticmum":
                            return "https://api-testnet.polygonscan.com";
                        case "arbitrum":
                            return "https://api.arbiscan.io";
                        case "arbitrum-goerli":
                            return "https://api-goerli.arbiscan.io";
                        case "optimism":
                            return "https://api-optimistic.etherscan.io";
                        case "optimism-goerli":
                            return "https://api-goerli-optimistic.etherscan.io"
                    }
                    return eh.throwArgumentError("unsupported network", "network", this.network.name)
                }
                getUrl(l, c) {
                    let x = Object.keys(c).reduce((l, x) => {
                            let N = c[x];
                            return null != N && (l += `&${x}=${N}`), l
                        }, ""),
                        N = this.apiKey ? `&apikey=${this.apiKey}` : "";
                    return `${this.baseUrl}/api?module=${l}${x}${N}`
                }
                getPostUrl() {
                    return `${this.baseUrl}/api`
                }
                getPostData(l, c) {
                    return c.module = l, c.apikey = this.apiKey, c
                }
                fetch(l, c, x) {
                    return etherscan_provider_awaiter(this, void 0, void 0, function*() {
                        let N = x ? this.getPostUrl() : this.getUrl(l, c),
                            U = x ? this.getPostData(l, c) : null,
                            Z = "proxy" === l ? getJsonResult : getResult;
                        this.emit("debug", {
                            action: "request",
                            request: N,
                            provider: this
                        });
                        let q = {
                                url: N,
                                throttleSlotInterval: 1e3,
                                throttleCallback: (l, c) => (this.isCommunityResource() && (0, Y.vh)(), Promise.resolve(!0))
                            },
                            J = null;
                        U && (q.headers = {
                            "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
                        }, J = Object.keys(U).map(l => `${l}=${U[l]}`).join("&"));
                        let X = yield(0, ep.fetchJson)(q, J, Z || getJsonResult);
                        return this.emit("debug", {
                            action: "response",
                            request: N,
                            response: (0, $.deepCopy)(X),
                            provider: this
                        }), X
                    })
                }
                detectNetwork() {
                    return etherscan_provider_awaiter(this, void 0, void 0, function*() {
                        return this.network
                    })
                }
                perform(l, c) {
                    let x = Object.create(null, {
                        perform: {
                            get: () => super.perform
                        }
                    });
                    return etherscan_provider_awaiter(this, void 0, void 0, function*() {
                        switch (l) {
                            case "getBlockNumber":
                                return this.fetch("proxy", {
                                    action: "eth_blockNumber"
                                });
                            case "getGasPrice":
                                return this.fetch("proxy", {
                                    action: "eth_gasPrice"
                                });
                            case "getBalance":
                                return this.fetch("account", {
                                    action: "balance",
                                    address: c.address,
                                    tag: c.blockTag
                                });
                            case "getTransactionCount":
                                return this.fetch("proxy", {
                                    action: "eth_getTransactionCount",
                                    address: c.address,
                                    tag: c.blockTag
                                });
                            case "getCode":
                                return this.fetch("proxy", {
                                    action: "eth_getCode",
                                    address: c.address,
                                    tag: c.blockTag
                                });
                            case "getStorageAt":
                                return this.fetch("proxy", {
                                    action: "eth_getStorageAt",
                                    address: c.address,
                                    position: c.position,
                                    tag: c.blockTag
                                });
                            case "sendTransaction":
                                return this.fetch("proxy", {
                                    action: "eth_sendRawTransaction",
                                    hex: c.signedTransaction
                                }, !0).catch(l => checkError("sendTransaction", l, c.signedTransaction));
                            case "getBlock":
                                if (c.blockTag) return this.fetch("proxy", {
                                    action: "eth_getBlockByNumber",
                                    tag: c.blockTag,
                                    boolean: c.includeTransactions ? "true" : "false"
                                });
                                throw Error("getBlock by blockHash not implemented");
                            case "getTransaction":
                                return this.fetch("proxy", {
                                    action: "eth_getTransactionByHash",
                                    txhash: c.transactionHash
                                });
                            case "getTransactionReceipt":
                                return this.fetch("proxy", {
                                    action: "eth_getTransactionReceipt",
                                    txhash: c.transactionHash
                                });
                            case "call":
                                {
                                    if ("latest" !== c.blockTag) throw Error("EtherscanProvider does not support blockTag for call");
                                    let l = getTransactionPostData(c.transaction);l.module = "proxy",
                                    l.action = "eth_call";
                                    try {
                                        return yield this.fetch("proxy", l, !0)
                                    } catch (l) {
                                        return checkError("call", l, c.transaction)
                                    }
                                }
                            case "estimateGas":
                                {
                                    let l = getTransactionPostData(c.transaction);l.module = "proxy",
                                    l.action = "eth_estimateGas";
                                    try {
                                        return yield this.fetch("proxy", l, !0)
                                    } catch (l) {
                                        return checkError("estimateGas", l, c.transaction)
                                    }
                                }
                            case "getLogs":
                                {
                                    let l = {
                                        action: "getLogs"
                                    };
                                    if (c.filter.fromBlock && (l.fromBlock = checkLogTag(c.filter.fromBlock)), c.filter.toBlock && (l.toBlock = checkLogTag(c.filter.toBlock)), c.filter.address && (l.address = c.filter.address), c.filter.topics && c.filter.topics.length > 0 && (c.filter.topics.length > 1 && eh.throwError("unsupported topic count", J.Logger.errors.UNSUPPORTED_OPERATION, {
                                            topics: c.filter.topics
                                        }), 1 === c.filter.topics.length)) {
                                        let x = c.filter.topics[0];
                                        ("string" != typeof x || 66 !== x.length) && eh.throwError("unsupported topic format", J.Logger.errors.UNSUPPORTED_OPERATION, {
                                            topic0: x
                                        }), l.topic0 = x
                                    }
                                    let x = yield this.fetch("logs", l), N = {};
                                    for (let l = 0; l < x.length; l++) {
                                        let c = x[l];
                                        if (null == c.blockHash) {
                                            if (null == N[c.blockNumber]) {
                                                let l = yield this.getBlock(c.blockNumber);
                                                l && (N[c.blockNumber] = l.hash)
                                            }
                                            c.blockHash = N[c.blockNumber]
                                        }
                                    }
                                    return x
                                }
                            case "getEtherPrice":
                                if ("homestead" !== this.network.name) return 0;
                                return parseFloat((yield this.fetch("stats", {
                                    action: "ethprice"
                                })).ethusd)
                        }
                        return x.perform.call(this, l, c)
                    })
                }
                getHistory(l, c, x) {
                    return etherscan_provider_awaiter(this, void 0, void 0, function*() {
                        let N = {
                                action: "txlist",
                                address: yield this.resolveName(l), startblock: null == c ? 0 : c, endblock: null == x ? 99999999 : x, sort: "asc"
                            },
                            U = yield this.fetch("account", N);
                        return U.map(l => {
                            ["contractAddress", "to"].forEach(function(c) {
                                "" == l[c] && delete l[c]
                            }), null == l.creates && null != l.contractAddress && (l.creates = l.contractAddress);
                            let c = this.formatter.transactionResponse(l);
                            return l.timeStamp && (c.timestamp = parseInt(l.timeStamp)), c
                        })
                    })
                }
                isCommunityResource() {
                    return null == this.apiKey
                }
            };
            var ey = x(92598),
                ef = x(7135),
                fallback_provider_awaiter = function(l, c, x, N) {
                    return new(x || (x = Promise))(function(U, Z) {
                        function fulfilled(l) {
                            try {
                                step(N.next(l))
                            } catch (l) {
                                Z(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(N.throw(l))
                            } catch (l) {
                                Z(l)
                            }
                        }

                        function step(l) {
                            var c;
                            l.done ? U(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                                l(c)
                            })).then(fulfilled, rejected)
                        }
                        step((N = N.apply(l, c || [])).next())
                    })
                };
            let em = new J.Logger(X.i);

            function now() {
                return new Date().getTime()
            }

            function checkNetworks(l) {
                let c = null;
                for (let x = 0; x < l.length; x++) {
                    let N = l[x];
                    if (null == N) return null;
                    c ? c.name === N.name && c.chainId === N.chainId && (c.ensAddress === N.ensAddress || null == c.ensAddress && null == N.ensAddress) || em.throwArgumentError("provider mismatch", "networks", l) : c = N
                }
                return c
            }

            function median(l, c) {
                l = l.slice().sort();
                let x = Math.floor(l.length / 2);
                if (l.length % 2) return l[x];
                let N = l[x - 1],
                    U = l[x];
                return null != c && Math.abs(N - U) > c ? null : (N + U) / 2
            }

            function serialize(l) {
                if (null === l) return "null";
                if ("number" == typeof l || "boolean" == typeof l) return JSON.stringify(l);
                if ("string" == typeof l) return l;
                if (ey.O$.isBigNumber(l)) return l.toString();
                if (Array.isArray(l)) return JSON.stringify(l.map(l => serialize(l)));
                if ("object" == typeof l) {
                    let c = Object.keys(l);
                    return c.sort(), "{" + c.map(c => {
                        let x = l[c];
                        return x = "function" == typeof x ? "[function]" : serialize(x), JSON.stringify(c) + ":" + x
                    }).join(",") + "}"
                }
                throw Error("unknown value type: " + typeof l)
            }
            let eg = 1;

            function stall(l) {
                let c = null,
                    x = null,
                    N = new Promise(N => {
                        x = setTimeout(c = function() {
                            x && (clearTimeout(x), x = null), N()
                        }, l)
                    });
                return {
                    cancel: c,
                    getPromise: function() {
                        return N
                    },
                    wait: l => N = N.then(l)
                }
            }
            let eb = [J.Logger.errors.CALL_EXCEPTION, J.Logger.errors.INSUFFICIENT_FUNDS, J.Logger.errors.NONCE_EXPIRED, J.Logger.errors.REPLACEMENT_UNDERPRICED, J.Logger.errors.UNPREDICTABLE_GAS_LIMIT],
                ev = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"];

            function exposeDebugConfig(l, c) {
                let x = {
                    weight: l.weight
                };
                return Object.defineProperty(x, "provider", {
                    get: () => l.provider
                }), l.start && (x.start = l.start), c && (x.duration = c - l.start), l.done && (l.error ? x.error = l.error : x.result = l.result || null), x
            }

            function waitForSync(l, c) {
                return fallback_provider_awaiter(this, void 0, void 0, function*() {
                    let x = l.provider;
                    return null != x.blockNumber && x.blockNumber >= c || -1 === c ? x : (0, ep.poll)(() => new Promise((N, U) => {
                        setTimeout(function() {
                            return x.blockNumber >= c ? N(x) : l.cancelled ? N(null) : N(void 0)
                        }, 0)
                    }), {
                        oncePoll: x
                    })
                })
            }
            let FallbackProvider = class FallbackProvider extends Z.Zk {
                constructor(l, c) {
                    0 === l.length && em.throwArgumentError("missing providers", "providers", l);
                    let x = l.map((l, c) => {
                            if (N.zt.isProvider(l)) {
                                let c = (0, Y.Gp)(l) ? 2e3 : 750;
                                return Object.freeze({
                                    provider: l,
                                    weight: 1,
                                    stallTimeout: c,
                                    priority: 1
                                })
                            }
                            let x = (0, $.shallowCopy)(l);
                            null == x.priority && (x.priority = 1), null == x.stallTimeout && (x.stallTimeout = (0, Y.Gp)(l) ? 2e3 : 750), null == x.weight && (x.weight = 1);
                            let U = x.weight;
                            return (U % 1 || U > 512 || U < 1) && em.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${c}].weight`, U), Object.freeze(x)
                        }),
                        U = x.reduce((l, c) => l + c.weight, 0);
                    null == c ? c = U / 2 : c > U && em.throwArgumentError("quorum will always fail; larger than total weight", "quorum", c);
                    let Z = checkNetworks(x.map(l => l.provider.network));
                    null == Z && (Z = new Promise((l, c) => {
                        setTimeout(() => {
                            this.detectNetwork().then(l, c)
                        }, 0)
                    })), super(Z), (0, $.defineReadOnly)(this, "providerConfigs", Object.freeze(x)), (0, $.defineReadOnly)(this, "quorum", c), this._highestBlockNumber = -1
                }
                detectNetwork() {
                    return fallback_provider_awaiter(this, void 0, void 0, function*() {
                        let l = yield Promise.all(this.providerConfigs.map(l => l.provider.getNetwork()));
                        return checkNetworks(l)
                    })
                }
                perform(l, c) {
                    return fallback_provider_awaiter(this, void 0, void 0, function*() {
                        if ("sendTransaction" === l) {
                            let l = yield Promise.all(this.providerConfigs.map(l => l.provider.sendTransaction(c.signedTransaction).then(l => l.hash, l => l)));
                            for (let c = 0; c < l.length; c++) {
                                let x = l[c];
                                if ("string" == typeof x) return x
                            }
                            throw l[0]
                        } - 1 === this._highestBlockNumber && "getBlockNumber" !== l && (yield this.getBlockNumber());
                        let x = function(l, c, x) {
                                var N, U;
                                let Z = serialize;
                                switch (c) {
                                    case "getBlockNumber":
                                        return function(c) {
                                            let x = c.map(l => l.result),
                                                N = median(c.map(l => l.result), 2);
                                            if (null != N) return N = Math.ceil(N), x.indexOf(N + 1) >= 0 && N++, N >= l._highestBlockNumber && (l._highestBlockNumber = N), l._highestBlockNumber
                                        };
                                    case "getGasPrice":
                                        return function(l) {
                                            let c = l.map(l => l.result);
                                            return c.sort(), c[Math.floor(c.length / 2)]
                                        };
                                    case "getEtherPrice":
                                        return function(l) {
                                            return median(l.map(l => l.result))
                                        };
                                    case "getBalance":
                                    case "getTransactionCount":
                                    case "getCode":
                                    case "getStorageAt":
                                    case "call":
                                    case "estimateGas":
                                    case "getLogs":
                                        break;
                                    case "getTransaction":
                                    case "getTransactionReceipt":
                                        Z = function(l) {
                                            return null == l ? null : ((l = (0, $.shallowCopy)(l)).confirmations = -1, serialize(l))
                                        };
                                        break;
                                    case "getBlock":
                                        Z = x.includeTransactions ? function(l) {
                                            return null == l ? null : ((l = (0, $.shallowCopy)(l)).transactions = l.transactions.map(l => ((l = (0, $.shallowCopy)(l)).confirmations = -1, l)), serialize(l))
                                        } : function(l) {
                                            return null == l ? null : serialize(l)
                                        };
                                        break;
                                    default:
                                        throw Error("unknown method: " + c)
                                }
                                return N = Z, U = l.quorum,
                                    function(l) {
                                        let c = {};
                                        l.forEach(l => {
                                            let x = N(l.result);
                                            c[x] || (c[x] = {
                                                count: 0,
                                                result: l.result
                                            }), c[x].count++
                                        });
                                        let x = Object.keys(c);
                                        for (let l = 0; l < x.length; l++) {
                                            let N = c[x[l]];
                                            if (N.count >= U) return N.result
                                        }
                                    }
                            }(this, l, c),
                            N = (0, ef.y)(this.providerConfigs.map($.shallowCopy));
                        N.sort((l, c) => l.priority - c.priority);
                        let U = this._highestBlockNumber,
                            Z = 0,
                            Y = !0;
                        for (;;) {
                            let q = now(),
                                X = N.filter(l => l.runner && q - l.start < l.stallTimeout).reduce((l, c) => l + c.weight, 0);
                            for (; X < this.quorum && Z < N.length;) {
                                let x = N[Z++],
                                    Y = eg++;
                                x.start = now(), x.staller = stall(x.stallTimeout), x.staller.wait(() => {
                                    x.staller = null
                                }), x.runner = (function(l, c, x, N) {
                                    return fallback_provider_awaiter(this, void 0, void 0, function*() {
                                        let U = l.provider;
                                        switch (x) {
                                            case "getBlockNumber":
                                            case "getGasPrice":
                                                return U[x]();
                                            case "getEtherPrice":
                                                if (U.getEtherPrice) return U.getEtherPrice();
                                                break;
                                            case "getBalance":
                                            case "getTransactionCount":
                                            case "getCode":
                                                return N.blockTag && (0, eu.isHexString)(N.blockTag) && (U = yield waitForSync(l, c)), U[x](N.address, N.blockTag || "latest");
                                            case "getStorageAt":
                                                return N.blockTag && (0, eu.isHexString)(N.blockTag) && (U = yield waitForSync(l, c)), U.getStorageAt(N.address, N.position, N.blockTag || "latest");
                                            case "getBlock":
                                                return N.blockTag && (0, eu.isHexString)(N.blockTag) && (U = yield waitForSync(l, c)), U[N.includeTransactions ? "getBlockWithTransactions" : "getBlock"](N.blockTag || N.blockHash);
                                            case "call":
                                            case "estimateGas":
                                                if (N.blockTag && (0, eu.isHexString)(N.blockTag) && (U = yield waitForSync(l, c)), "call" === x && N.blockTag) return U[x](N.transaction, N.blockTag);
                                                return U[x](N.transaction);
                                            case "getTransaction":
                                            case "getTransactionReceipt":
                                                return U[x](N.transactionHash);
                                            case "getLogs":
                                                {
                                                    let x = N.filter;
                                                    return (x.fromBlock && (0, eu.isHexString)(x.fromBlock) || x.toBlock && (0, eu.isHexString)(x.toBlock)) && (U = yield waitForSync(l, c)),
                                                    U.getLogs(x)
                                                }
                                        }
                                        return em.throwError("unknown method error", J.Logger.errors.UNKNOWN_ERROR, {
                                            method: x,
                                            params: N
                                        })
                                    })
                                })(x, U, l, c).then(N => {
                                    x.done = !0, x.result = N, this.listenerCount("debug") && this.emit("debug", {
                                        action: "request",
                                        rid: Y,
                                        backend: exposeDebugConfig(x, now()),
                                        request: {
                                            method: l,
                                            params: (0, $.deepCopy)(c)
                                        },
                                        provider: this
                                    })
                                }, N => {
                                    x.done = !0, x.error = N, this.listenerCount("debug") && this.emit("debug", {
                                        action: "request",
                                        rid: Y,
                                        backend: exposeDebugConfig(x, now()),
                                        request: {
                                            method: l,
                                            params: (0, $.deepCopy)(c)
                                        },
                                        provider: this
                                    })
                                }), this.listenerCount("debug") && this.emit("debug", {
                                    action: "request",
                                    rid: Y,
                                    backend: exposeDebugConfig(x, null),
                                    request: {
                                        method: l,
                                        params: (0, $.deepCopy)(c)
                                    },
                                    provider: this
                                }), X += x.weight
                            }
                            let en = [];
                            N.forEach(l => {
                                !l.done && l.runner && (en.push(l.runner), l.staller && en.push(l.staller.getPromise()))
                            }), en.length && (yield Promise.race(en));
                            let er = N.filter(l => l.done && null == l.error);
                            if (er.length >= this.quorum) {
                                let l = x(er);
                                if (void 0 !== l) return N.forEach(l => {
                                    l.staller && l.staller.cancel(), l.cancelled = !0
                                }), l;
                                Y || (yield stall(100).getPromise()), Y = !1
                            }
                            let ea = N.reduce((l, c) => {
                                if (!c.done || null == c.error) return l;
                                let x = c.error.code;
                                return eb.indexOf(x) >= 0 && (l[x] || (l[x] = {
                                    error: c.error,
                                    weight: 0
                                }), l[x].weight += c.weight), l
                            }, {});
                            if (Object.keys(ea).forEach(l => {
                                    let c = ea[l];
                                    if (c.weight < this.quorum) return;
                                    N.forEach(l => {
                                        l.staller && l.staller.cancel(), l.cancelled = !0
                                    });
                                    let x = c.error,
                                        U = {};
                                    ev.forEach(l => {
                                        null != x[l] && (U[l] = x[l])
                                    }), em.throwError(x.reason || x.message, l, U)
                                }), 0 === N.filter(l => !l.done).length) break
                        }
                        return N.forEach(l => {
                            l.staller && l.staller.cancel(), l.cancelled = !0
                        }), em.throwError("failed to meet quorum", J.Logger.errors.SERVER_ERROR, {
                            method: l,
                            params: c,
                            results: N.map(l => exposeDebugConfig(l)),
                            provider: this
                        })
                    })
                }
            };
            let ew = null,
                eT = new J.Logger(X.i),
                eM = "84842078b09946638c03157f83405213";
            let InfuraWebSocketProvider = class InfuraWebSocketProvider extends q.q {
                constructor(l, c) {
                    let x = new InfuraProvider(l, c),
                        N = x.connection;
                    N.password && eT.throwError("INFURA WebSocket project secrets unsupported", J.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "InfuraProvider.getWebSocketProvider()"
                    });
                    let U = N.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
                    super(U, l), (0, $.defineReadOnly)(this, "apiKey", x.projectId), (0, $.defineReadOnly)(this, "projectId", x.projectId), (0, $.defineReadOnly)(this, "projectSecret", x.projectSecret)
                }
                isCommunityResource() {
                    return this.projectId === eM
                }
            };
            let InfuraProvider = class InfuraProvider extends en.l {
                static getWebSocketProvider(l, c) {
                    return new InfuraWebSocketProvider(l, c)
                }
                static getApiKey(l) {
                    let c = {
                        apiKey: eM,
                        projectId: eM,
                        projectSecret: null
                    };
                    return null == l || ("string" == typeof l ? c.projectId = l : null != l.projectSecret ? (eT.assertArgument("string" == typeof l.projectId, "projectSecret requires a projectId", "projectId", l.projectId), eT.assertArgument("string" == typeof l.projectSecret, "invalid projectSecret", "projectSecret", "[REDACTED]"), c.projectId = l.projectId, c.projectSecret = l.projectSecret) : l.projectId && (c.projectId = l.projectId), c.apiKey = c.projectId), c
                }
                static getUrl(l, c) {
                    let x = null;
                    switch (l ? l.name : "unknown") {
                        case "homestead":
                            x = "mainnet.infura.io";
                            break;
                        case "goerli":
                            x = "goerli.infura.io";
                            break;
                        case "sepolia":
                            x = "sepolia.infura.io";
                            break;
                        case "matic":
                            x = "polygon-mainnet.infura.io";
                            break;
                        case "maticmum":
                            x = "polygon-mumbai.infura.io";
                            break;
                        case "optimism":
                            x = "optimism-mainnet.infura.io";
                            break;
                        case "optimism-goerli":
                            x = "optimism-goerli.infura.io";
                            break;
                        case "arbitrum":
                            x = "arbitrum-mainnet.infura.io";
                            break;
                        case "arbitrum-goerli":
                            x = "arbitrum-goerli.infura.io";
                            break;
                        default:
                            eT.throwError("unsupported network", J.Logger.errors.INVALID_ARGUMENT, {
                                argument: "network",
                                value: l
                            })
                    }
                    let N = {
                        allowGzip: !0,
                        url: "https://" + x + "/v3/" + c.projectId,
                        throttleCallback: (l, x) => (c.projectId === eM && (0, Y.vh)(), Promise.resolve(!0))
                    };
                    return null != c.projectSecret && (N.user = "", N.password = c.projectSecret), N
                }
                isCommunityResource() {
                    return this.projectId === eM
                }
            };
            var eI = x(46795),
                ex = x(13010);
            let eC = new J.Logger(X.i);
            let NodesmithProvider = class NodesmithProvider extends en.l {
                static getApiKey(l) {
                    return l && "string" != typeof l && eC.throwArgumentError("invalid apiKey", "apiKey", l), l || "ETHERS_JS_SHARED"
                }
                static getUrl(l, c) {
                    eC.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
                    let x = null;
                    switch (l.name) {
                        case "homestead":
                            x = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
                            break;
                        case "ropsten":
                            x = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
                            break;
                        case "rinkeby":
                            x = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
                            break;
                        case "goerli":
                            x = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
                            break;
                        case "kovan":
                            x = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
                            break;
                        default:
                            eC.throwArgumentError("unsupported network", "network", arguments[0])
                    }
                    return x + "?apiKey=" + c
                }
            };
            let e_ = new J.Logger(X.i),
                eD = "62e1ad51b37b8e00394bda3b";
            let PocketProvider = class PocketProvider extends en.l {
                static getApiKey(l) {
                    let c = {
                        applicationId: null,
                        loadBalancer: !0,
                        applicationSecretKey: null
                    };
                    return null == l ? c.applicationId = eD : "string" == typeof l ? c.applicationId = l : null != l.applicationSecretKey ? (c.applicationId = l.applicationId, c.applicationSecretKey = l.applicationSecretKey) : l.applicationId ? c.applicationId = l.applicationId : e_.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", l), c
                }
                static getUrl(l, c) {
                    let x = null;
                    switch (l ? l.name : "unknown") {
                        case "goerli":
                            x = "eth-goerli.gateway.pokt.network";
                            break;
                        case "homestead":
                            x = "eth-mainnet.gateway.pokt.network";
                            break;
                        case "kovan":
                            x = "poa-kovan.gateway.pokt.network";
                            break;
                        case "matic":
                            x = "poly-mainnet.gateway.pokt.network";
                            break;
                        case "maticmum":
                            x = "polygon-mumbai-rpc.gateway.pokt.network";
                            break;
                        case "rinkeby":
                            x = "eth-rinkeby.gateway.pokt.network";
                            break;
                        case "ropsten":
                            x = "eth-ropsten.gateway.pokt.network";
                            break;
                        default:
                            e_.throwError("unsupported network", J.Logger.errors.INVALID_ARGUMENT, {
                                argument: "network",
                                value: l
                            })
                    }
                    let N = `https://${x}/v1/lb/${c.applicationId}`,
                        U = {
                            headers: {},
                            url: N
                        };
                    return null != c.applicationSecretKey && (U.user = "", U.password = c.applicationSecretKey), U
                }
                isCommunityResource() {
                    return this.applicationId === eD
                }
            };
            var eS = x(56955);
            let ek = new J.Logger(X.i);

            function getDefaultProvider(l, c) {
                if (null == l && (l = "homestead"), "string" == typeof l) {
                    let c = l.match(/^(ws|http)s?:/i);
                    if (c) switch (c[1].toLowerCase()) {
                        case "http":
                        case "https":
                            return new eI.r(l);
                        case "ws":
                        case "wss":
                            return new q.q(l);
                        default:
                            ek.throwArgumentError("unsupported URL scheme", "network", l)
                    }
                }
                let x = (0, U.H)(l);
                return x && x._defaultProvider || ek.throwError("unsupported getDefaultProvider network", J.Logger.errors.NETWORK_ERROR, {
                    operation: "getDefaultProvider",
                    network: l
                }), x._defaultProvider({
                    FallbackProvider: FallbackProvider,
                    AlchemyProvider: AlchemyProvider,
                    AnkrProvider: AnkrProvider,
                    CloudflareProvider: CloudflareProvider,
                    EtherscanProvider: EtherscanProvider,
                    InfuraProvider: InfuraProvider,
                    JsonRpcProvider: eI.r,
                    NodesmithProvider: NodesmithProvider,
                    PocketProvider: PocketProvider,
                    Web3Provider: eS.Q,
                    IpcProvider: ew
                }, c)
            }
        },
        13010: function(l, c, x) {
            "use strict";
            x.d(c, {
                I: function() {
                    return JsonRpcBatchProvider
                }
            });
            var N = x(17213),
                U = x(39318),
                Z = x(46795);
            let JsonRpcBatchProvider = class JsonRpcBatchProvider extends Z.r {
                send(l, c) {
                    let x = {
                        method: l,
                        params: c,
                        id: this._nextId++,
                        jsonrpc: "2.0"
                    };
                    null == this._pendingBatch && (this._pendingBatch = []);
                    let Z = {
                            request: x,
                            resolve: null,
                            reject: null
                        },
                        $ = new Promise((l, c) => {
                            Z.resolve = l, Z.reject = c
                        });
                    return this._pendingBatch.push(Z), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => {
                        let l = this._pendingBatch;
                        this._pendingBatch = null, this._pendingBatchAggregator = null;
                        let c = l.map(l => l.request);
                        return this.emit("debug", {
                            action: "requestBatch",
                            request: (0, N.deepCopy)(c),
                            provider: this
                        }), (0, U.fetchJson)(this.connection, JSON.stringify(c)).then(x => {
                            this.emit("debug", {
                                action: "response",
                                request: c,
                                response: x,
                                provider: this
                            }), l.forEach((l, c) => {
                                let N = x[c];
                                if (N.error) {
                                    let c = Error(N.error.message);
                                    c.code = N.error.code, c.data = N.error.data, l.reject(c)
                                } else l.resolve(N.result)
                            })
                        }, x => {
                            this.emit("debug", {
                                action: "response",
                                error: x,
                                request: c,
                                provider: this
                            }), l.forEach(l => {
                                l.reject(x)
                            })
                        })
                    }, 10)), $
                }
            }
        },
        61127: function(l, c, x) {
            "use strict";
            x.d(c, {
                c: function() {
                    return StaticJsonRpcProvider
                },
                l: function() {
                    return UrlJsonRpcProvider
                }
            });
            var N = x(17213),
                U = x(36288),
                Z = x(12312),
                $ = x(46795);
            let Y = new U.Logger(Z.i);
            let StaticJsonRpcProvider = class StaticJsonRpcProvider extends $.r {
                detectNetwork() {
                    var l, c, x, Z;
                    let $ = Object.create(null, {
                        detectNetwork: {
                            get: () => super.detectNetwork
                        }
                    });
                    return l = this, c = void 0, x = void 0, Z = function*() {
                        let l = this.network;
                        return null == l && ((l = yield $.detectNetwork.call(this)) || Y.throwError("no network detected", U.Logger.errors.UNKNOWN_ERROR, {}), null == this._network && ((0, N.defineReadOnly)(this, "_network", l), this.emit("network", l, null))), l
                    }, new(x || (x = Promise))(function(N, U) {
                        function fulfilled(l) {
                            try {
                                step(Z.next(l))
                            } catch (l) {
                                U(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(Z.throw(l))
                            } catch (l) {
                                U(l)
                            }
                        }

                        function step(l) {
                            var c;
                            l.done ? N(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                                l(c)
                            })).then(fulfilled, rejected)
                        }
                        step((Z = Z.apply(l, c || [])).next())
                    })
                }
            };
            let UrlJsonRpcProvider = class UrlJsonRpcProvider extends StaticJsonRpcProvider {
                constructor(l, c) {
                    Y.checkAbstract(new.target, UrlJsonRpcProvider), l = (0, N.getStatic)(new.target, "getNetwork")(l), c = (0, N.getStatic)(new.target, "getApiKey")(c);
                    let x = (0, N.getStatic)(new.target, "getUrl")(l, c);
                    super(x, l), "string" == typeof c ? (0, N.defineReadOnly)(this, "apiKey", c) : null != c && Object.keys(c).forEach(l => {
                        (0, N.defineReadOnly)(this, l, c[l])
                    })
                }
                _startPending() {
                    Y.warn("WARNING: API provider does not support pending filters")
                }
                isCommunityResource() {
                    return !1
                }
                getSigner(l) {
                    return Y.throwError("API provider does not support signing", U.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "getSigner"
                    })
                }
                listAccounts() {
                    return Promise.resolve([])
                }
                static getApiKey(l) {
                    return l
                }
                static getUrl(l, c) {
                    return Y.throwError("not implemented; sub-classes must override getUrl", U.Logger.errors.NOT_IMPLEMENTED, {
                        operation: "getUrl"
                    })
                }
            }
        },
        99227: function(l, c, x) {
            "use strict";
            x.d(c, {
                q: function() {
                    return WebSocketProvider
                }
            });
            var N = x(92598),
                U = x(17213),
                Z = x(46795),
                $ = x(36288),
                Y = x(12312);
            let q = null;
            try {
                if (q = WebSocket, null == q) throw Error("inject please")
            } catch (c) {
                let l = new $.Logger(Y.i);
                q = function() {
                    l.throwError("WebSockets not supported in this environment", $.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "new WebSocket()"
                    })
                }
            }
            var __awaiter = function(l, c, x, N) {
                return new(x || (x = Promise))(function(U, Z) {
                    function fulfilled(l) {
                        try {
                            step(N.next(l))
                        } catch (l) {
                            Z(l)
                        }
                    }

                    function rejected(l) {
                        try {
                            step(N.throw(l))
                        } catch (l) {
                            Z(l)
                        }
                    }

                    function step(l) {
                        var c;
                        l.done ? U(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                            l(c)
                        })).then(fulfilled, rejected)
                    }
                    step((N = N.apply(l, c || [])).next())
                })
            };
            let J = new $.Logger(Y.i),
                X = 1;
            let WebSocketProvider = class WebSocketProvider extends Z.r {
                constructor(l, c) {
                    "any" === c && J.throwError("WebSocketProvider does not support 'any' network yet", $.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "network:any"
                    }), "string" == typeof l ? super(l, c) : super("_websocket", c), this._pollingInterval = -1, this._wsReady = !1, "string" == typeof l ? (0, U.defineReadOnly)(this, "_websocket", new q(this.connection.url)) : (0, U.defineReadOnly)(this, "_websocket", l), (0, U.defineReadOnly)(this, "_requests", {}), (0, U.defineReadOnly)(this, "_subs", {}), (0, U.defineReadOnly)(this, "_subIds", {}), (0, U.defineReadOnly)(this, "_detectNetwork", super.detectNetwork()), this.websocket.onopen = () => {
                        this._wsReady = !0, Object.keys(this._requests).forEach(l => {
                            this.websocket.send(this._requests[l].payload)
                        })
                    }, this.websocket.onmessage = l => {
                        let c = l.data,
                            x = JSON.parse(c);
                        if (null != x.id) {
                            let l = String(x.id),
                                N = this._requests[l];
                            if (delete this._requests[l], void 0 !== x.result) N.callback(null, x.result), this.emit("debug", {
                                action: "response",
                                request: JSON.parse(N.payload),
                                response: x.result,
                                provider: this
                            });
                            else {
                                let l = null;
                                x.error ? (l = Error(x.error.message || "unknown error"), (0, U.defineReadOnly)(l, "code", x.error.code || null), (0, U.defineReadOnly)(l, "response", c)) : l = Error("unknown error"), N.callback(l, void 0), this.emit("debug", {
                                    action: "response",
                                    error: l,
                                    request: JSON.parse(N.payload),
                                    provider: this
                                })
                            }
                        } else if ("eth_subscription" === x.method) {
                            let l = this._subs[x.params.subscription];
                            l && l.processFunc(x.params.result)
                        } else console.warn("this should not happen")
                    };
                    let x = setInterval(() => {
                        this.emit("poll")
                    }, 1e3);
                    x.unref && x.unref()
                }
                get websocket() {
                    return this._websocket
                }
                detectNetwork() {
                    return this._detectNetwork
                }
                get pollingInterval() {
                    return 0
                }
                resetEventsBlock(l) {
                    J.throwError("cannot reset events block on WebSocketProvider", $.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "resetEventBlock"
                    })
                }
                set pollingInterval(l) {
                    J.throwError("cannot set polling interval on WebSocketProvider", $.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "setPollingInterval"
                    })
                }
                poll() {
                    return __awaiter(this, void 0, void 0, function*() {
                        return null
                    })
                }
                set polling(l) {
                    l && J.throwError("cannot set polling on WebSocketProvider", $.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "setPolling"
                    })
                }
                send(l, c) {
                    let x = X++;
                    return new Promise((N, U) => {
                        let Z = JSON.stringify({
                            method: l,
                            params: c,
                            id: x,
                            jsonrpc: "2.0"
                        });
                        this.emit("debug", {
                            action: "request",
                            request: JSON.parse(Z),
                            provider: this
                        }), this._requests[String(x)] = {
                            callback: function(l, c) {
                                return l ? U(l) : N(c)
                            },
                            payload: Z
                        }, this._wsReady && this.websocket.send(Z)
                    })
                }
                static defaultUrl() {
                    return "ws://localhost:8546"
                }
                _subscribe(l, c, x) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let N = this._subIds[l];
                        null == N && (N = Promise.all(c).then(l => this.send("eth_subscribe", l)), this._subIds[l] = N);
                        let U = yield N;
                        this._subs[U] = {
                            tag: l,
                            processFunc: x
                        }
                    })
                }
                _startEvent(l) {
                    switch (l.type) {
                        case "block":
                            this._subscribe("block", ["newHeads"], l => {
                                let c = N.O$.from(l.number).toNumber();
                                this._emitted.block = c, this.emit("block", c)
                            });
                            break;
                        case "pending":
                            this._subscribe("pending", ["newPendingTransactions"], l => {
                                this.emit("pending", l)
                            });
                            break;
                        case "filter":
                            this._subscribe(l.tag, ["logs", this._getFilter(l.filter)], c => {
                                null == c.removed && (c.removed = !1), this.emit(l.filter, this.formatter.filterLog(c))
                            });
                            break;
                        case "tx":
                            {
                                let emitReceipt = l => {
                                    let c = l.hash;
                                    this.getTransactionReceipt(c).then(l => {
                                        l && this.emit(c, l)
                                    })
                                };emitReceipt(l),
                                this._subscribe("tx", ["newHeads"], l => {
                                    this._events.filter(l => "tx" === l.type).forEach(emitReceipt)
                                });
                                break
                            }
                        case "debug":
                        case "poll":
                        case "willPoll":
                        case "didPoll":
                        case "error":
                            break;
                        default:
                            console.log("unhandled:", l)
                    }
                }
                _stopEvent(l) {
                    let c = l.tag;
                    if ("tx" === l.type) {
                        if (this._events.filter(l => "tx" === l.type).length) return;
                        c = "tx"
                    } else if (this.listenerCount(l.event)) return;
                    let x = this._subIds[c];
                    x && (delete this._subIds[c], x.then(l => {
                        this._subs[l] && (delete this._subs[l], this.send("eth_unsubscribe", [l]))
                    }))
                }
                destroy() {
                    return __awaiter(this, void 0, void 0, function*() {
                        this.websocket.readyState === q.CONNECTING && (yield new Promise(l => {
                            this.websocket.onopen = function() {
                                l(!0)
                            }, this.websocket.onerror = function() {
                                l(!1)
                            }
                        })), this.websocket.close(1e3)
                    })
                }
            }
        },
        64791: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                randomBytes: function() {
                    return N.O
                },
                shuffled: function() {
                    return U.y
                }
            });
            var N = x(19796),
                U = x(7135)
        },
        19796: function(l, c, x) {
            "use strict";
            x.d(c, {
                O: function() {
                    return randomBytes
                }
            });
            var N = x(57273),
                U = x(36288);
            let Z = new U.Logger("random/5.7.0"),
                $ = function() {
                    if ("undefined" != typeof self) return self;
                    if ("undefined" != typeof window) return window;
                    if (void 0 !== x.g) return x.g;
                    throw Error("unable to locate global object")
                }(),
                Y = $.crypto || $.msCrypto;

            function randomBytes(l) {
                (l <= 0 || l > 1024 || l % 1 || l != l) && Z.throwArgumentError("invalid length", "length", l);
                let c = new Uint8Array(l);
                return Y.getRandomValues(c), (0, N.arrayify)(c)
            }
            Y && Y.getRandomValues || (Z.warn("WARNING: Missing strong random number source"), Y = {
                getRandomValues: function(l) {
                    return Z.throwError("no secure random source avaialble", U.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "crypto.getRandomValues"
                    })
                }
            })
        },
        7135: function(l, c, x) {
            "use strict";

            function shuffled(l) {
                l = l.slice();
                for (let c = l.length - 1; c > 0; c--) {
                    let x = Math.floor(Math.random() * (c + 1)),
                        N = l[c];
                    l[c] = l[x], l[x] = N
                }
                return l
            }
            x.d(c, {
                y: function() {
                    return shuffled
                }
            })
        },
        85766: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                SupportedAlgorithm: function() {
                    return U.p
                },
                computeHmac: function() {
                    return N.Gy
                },
                ripemd160: function() {
                    return N.bP
                },
                sha256: function() {
                    return N.JQ
                },
                sha512: function() {
                    return N.o
                }
            });
            var N = x(37815),
                U = x(67557)
        },
        47293: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                keccak256: function() {
                    return keccak256
                },
                pack: function() {
                    return pack
                },
                sha256: function() {
                    return sha256
                }
            });
            var N = x(92598),
                U = x(57273),
                Z = x(14184),
                $ = x(37815),
                Y = x(58337),
                q = x(36288);
            let J = RegExp("^bytes([0-9]+)$"),
                X = RegExp("^(u?int)([0-9]*)$"),
                en = RegExp("^(.*)\\[([0-9]*)\\]$"),
                er = new q.Logger("solidity/5.7.0");

            function pack(l, c) {
                l.length != c.length && er.throwArgumentError("wrong number of values; expected ${ types.length }", "values", c);
                let x = [];
                return l.forEach(function(l, Z) {
                    x.push(function _pack(l, c, x) {
                        switch (l) {
                            case "address":
                                if (x) return (0, U.zeroPad)(c, 32);
                                return (0, U.arrayify)(c);
                            case "string":
                                return (0, Y.Y0)(c);
                            case "bytes":
                                return (0, U.arrayify)(c);
                            case "bool":
                                if (c = c ? "0x01" : "0x00", x) return (0, U.zeroPad)(c, 32);
                                return (0, U.arrayify)(c)
                        }
                        let Z = l.match(X);
                        if (Z) {
                            let $ = parseInt(Z[2] || "256");
                            return (Z[2] && String($) !== Z[2] || $ % 8 != 0 || 0 === $ || $ > 256) && er.throwArgumentError("invalid number type", "type", l), x && ($ = 256), c = N.O$.from(c).toTwos($), (0, U.zeroPad)(c, $ / 8)
                        }
                        if (Z = l.match(J)) {
                            let N = parseInt(Z[1]);
                            return ((String(N) !== Z[1] || 0 === N || N > 32) && er.throwArgumentError("invalid bytes type", "type", l), (0, U.arrayify)(c).byteLength !== N && er.throwArgumentError(`invalid value for ${l}`, "value", c), x) ? (0, U.arrayify)((c + "0000000000000000000000000000000000000000000000000000000000000000").substring(0, 66)) : c
                        }
                        if ((Z = l.match(en)) && Array.isArray(c)) {
                            let x = Z[1],
                                N = parseInt(Z[2] || String(c.length));
                            N != c.length && er.throwArgumentError(`invalid array length for ${l}`, "value", c);
                            let $ = [];
                            return c.forEach(function(l) {
                                $.push(_pack(x, l, !0))
                            }), (0, U.concat)($)
                        }
                        return er.throwArgumentError("invalid type", "type", l)
                    }(l, c[Z]))
                }), (0, U.hexlify)((0, U.concat)(x))
            }

            function keccak256(l, c) {
                return (0, Z.keccak256)(pack(l, c))
            }

            function sha256(l, c) {
                return (0, $.JQ)(pack(l, c))
            }
        },
        94287: function(l, c, x) {
            "use strict";
            x.d(c, {
                F: function() {
                    return parseBytes32String
                },
                s: function() {
                    return formatBytes32String
                }
            });
            var N = x(76726),
                U = x(57273),
                Z = x(58337);

            function formatBytes32String(l) {
                let c = (0, Z.Y0)(l);
                if (c.length > 31) throw Error("bytes32 string must be less than 32 bytes");
                return (0, U.hexlify)((0, U.concat)([c, N.R]).slice(0, 32))
            }

            function parseBytes32String(l) {
                let c = (0, U.arrayify)(l);
                if (32 !== c.length) throw Error("invalid bytes32 - not 32 bytes long");
                if (0 !== c[31]) throw Error("invalid bytes32 string - no null terminator");
                let x = 31;
                for (; 0 === c[x - 1];) x--;
                return (0, Z.ZN)(c.slice(0, x))
            }
        },
        76819: function(l, c, x) {
            "use strict";
            x.d(c, {
                Ll: function() {
                    return nameprep
                }
            });
            var N = x(58337);

            function createTable(l, c) {
                c || (c = function(l) {
                    return [parseInt(l, 16)]
                });
                let x = 0,
                    N = {};
                return l.split(",").forEach(l => {
                    let U = l.split(":");
                    N[x += parseInt(U[0], 16)] = c(U[1])
                }), N
            }

            function createRangeTable(l) {
                let c = 0;
                return l.split(",").map(l => {
                    let x = l.split("-");
                    return 1 === x.length ? x[1] = "0" : "" === x[1] && (x[1] = "1"), {
                        l: c + parseInt(x[0], 16),
                        h: c = parseInt(x[1], 16)
                    }
                })
            }

            function matchMap(l, c) {
                let x = 0;
                for (let N = 0; N < c.length; N++) {
                    let U = c[N];
                    if (l >= (x += U.l) && l <= x + U.h && (l - x) % (U.d || 1) == 0) {
                        if (U.e && -1 !== U.e.indexOf(l - x)) continue;
                        return U
                    }
                }
                return null
            }
            let U = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"),
                Z = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(l => parseInt(l, 16)),
                $ = [{
                    h: 25,
                    s: 32,
                    l: 65
                }, {
                    h: 30,
                    s: 32,
                    e: [23],
                    l: 127
                }, {
                    h: 54,
                    s: 1,
                    e: [48],
                    l: 64,
                    d: 2
                }, {
                    h: 14,
                    s: 1,
                    l: 57,
                    d: 2
                }, {
                    h: 44,
                    s: 1,
                    l: 17,
                    d: 2
                }, {
                    h: 10,
                    s: 1,
                    e: [2, 6, 8],
                    l: 61,
                    d: 2
                }, {
                    h: 16,
                    s: 1,
                    l: 68,
                    d: 2
                }, {
                    h: 84,
                    s: 1,
                    e: [18, 24, 66],
                    l: 19,
                    d: 2
                }, {
                    h: 26,
                    s: 32,
                    e: [17],
                    l: 435
                }, {
                    h: 22,
                    s: 1,
                    l: 71,
                    d: 2
                }, {
                    h: 15,
                    s: 80,
                    l: 40
                }, {
                    h: 31,
                    s: 32,
                    l: 16
                }, {
                    h: 32,
                    s: 1,
                    l: 80,
                    d: 2
                }, {
                    h: 52,
                    s: 1,
                    l: 42,
                    d: 2
                }, {
                    h: 12,
                    s: 1,
                    l: 55,
                    d: 2
                }, {
                    h: 40,
                    s: 1,
                    e: [38],
                    l: 15,
                    d: 2
                }, {
                    h: 14,
                    s: 1,
                    l: 48,
                    d: 2
                }, {
                    h: 37,
                    s: 48,
                    l: 49
                }, {
                    h: 148,
                    s: 1,
                    l: 6351,
                    d: 2
                }, {
                    h: 88,
                    s: 1,
                    l: 160,
                    d: 2
                }, {
                    h: 15,
                    s: 16,
                    l: 704
                }, {
                    h: 25,
                    s: 26,
                    l: 854
                }, {
                    h: 25,
                    s: 32,
                    l: 55915
                }, {
                    h: 37,
                    s: 40,
                    l: 1247
                }, {
                    h: 25,
                    s: -119711,
                    l: 53248
                }, {
                    h: 25,
                    s: -119763,
                    l: 52
                }, {
                    h: 25,
                    s: -119815,
                    l: 52
                }, {
                    h: 25,
                    s: -119867,
                    e: [1, 4, 5, 7, 8, 11, 12, 17],
                    l: 52
                }, {
                    h: 25,
                    s: -119919,
                    l: 52
                }, {
                    h: 24,
                    s: -119971,
                    e: [2, 7, 8, 17],
                    l: 52
                }, {
                    h: 24,
                    s: -120023,
                    e: [2, 7, 13, 15, 16, 17],
                    l: 52
                }, {
                    h: 25,
                    s: -120075,
                    l: 52
                }, {
                    h: 25,
                    s: -120127,
                    l: 52
                }, {
                    h: 25,
                    s: -120179,
                    l: 52
                }, {
                    h: 25,
                    s: -120231,
                    l: 52
                }, {
                    h: 25,
                    s: -120283,
                    l: 52
                }, {
                    h: 25,
                    s: -120335,
                    l: 52
                }, {
                    h: 24,
                    s: -119543,
                    e: [17],
                    l: 56
                }, {
                    h: 24,
                    s: -119601,
                    e: [17],
                    l: 58
                }, {
                    h: 24,
                    s: -119659,
                    e: [17],
                    l: 58
                }, {
                    h: 24,
                    s: -119717,
                    e: [17],
                    l: 58
                }, {
                    h: 24,
                    s: -119775,
                    e: [17],
                    l: 58
                }],
                Y = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"),
                q = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"),
                J = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", function(l) {
                    if (l.length % 4 != 0) throw Error("bad data");
                    let c = [];
                    for (let x = 0; x < l.length; x += 4) c.push(parseInt(l.substring(x, x + 4), 16));
                    return c
                }),
                X = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

            function nameprep(l) {
                if (l.match(/^[a-z0-9-]*$/i) && l.length <= 59) return l.toLowerCase();
                let c = (0, N.XL)(l);
                c = c.map(l => Z.indexOf(l) >= 0 || l >= 65024 && l <= 65039 ? [] : function(l) {
                    let c = matchMap(l, $);
                    if (c) return [l + c.s];
                    let x = Y[l];
                    if (x) return x;
                    let N = q[l];
                    return N ? [l + N[0]] : J[l] || null
                }(l) || [l]).reduce((l, c) => (c.forEach(c => {
                    l.push(c)
                }), l), []), (c = (0, N.XL)((0, N.uu)(c), N.Uj.NFKC)).forEach(l => {
                    if (matchMap(l, X)) throw Error("STRINGPREP_CONTAINS_PROHIBITED")
                }), c.forEach(l => {
                    if (matchMap(l, U)) throw Error("STRINGPREP_CONTAINS_UNASSIGNED")
                });
                let x = (0, N.uu)(c);
                if ("-" === x.substring(0, 1) || "--" === x.substring(2, 4) || "-" === x.substring(x.length - 1)) throw Error("invalid hyphen");
                return x
            }
        },
        10914: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                UnicodeNormalizationForm: function() {
                    return Z.Uj
                },
                Utf8ErrorFuncs: function() {
                    return Z.te
                },
                Utf8ErrorReason: function() {
                    return Z.Uw
                },
                _toEscapedUtf8String: function() {
                    return Z.U$
                },
                formatBytes32String: function() {
                    return N.s
                },
                nameprep: function() {
                    return U.Ll
                },
                parseBytes32String: function() {
                    return N.F
                },
                toUtf8Bytes: function() {
                    return Z.Y0
                },
                toUtf8CodePoints: function() {
                    return Z.XL
                },
                toUtf8String: function() {
                    return Z.ZN
                }
            });
            var N = x(94287),
                U = x(76819),
                Z = x(58337)
        },
        61678: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                Wallet: function() {
                    return Wallet
                },
                verifyMessage: function() {
                    return verifyMessage
                },
                verifyTypedData: function() {
                    return verifyTypedData
                }
            });
            var N = x(18994),
                U = x(94999),
                Z = x(14941),
                $ = x(57273),
                Y = x(91798),
                q = x(31822),
                J = x(30686),
                X = x(14184),
                en = x(17213),
                er = x(19796),
                ea = x(74731),
                eo = x(50596),
                el = x(80948),
                ec = x(12060),
                eu = x(36288),
                __awaiter = function(l, c, x, N) {
                    return new(x || (x = Promise))(function(U, Z) {
                        function fulfilled(l) {
                            try {
                                step(N.next(l))
                            } catch (l) {
                                Z(l)
                            }
                        }

                        function rejected(l) {
                            try {
                                step(N.throw(l))
                            } catch (l) {
                                Z(l)
                            }
                        }

                        function step(l) {
                            var c;
                            l.done ? U(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                                l(c)
                            })).then(fulfilled, rejected)
                        }
                        step((N = N.apply(l, c || [])).next())
                    })
                };
            let ed = new eu.Logger("wallet/5.7.0");
            let Wallet = class Wallet extends Z.Signer {
                constructor(l, c) {
                    var x;
                    if (super(), null != (x = l) && (0, $.isHexString)(x.privateKey, 32) && null != x.address) {
                        let c = new ea.SigningKey(l.privateKey);
                        if ((0, en.defineReadOnly)(this, "_signingKey", () => c), (0, en.defineReadOnly)(this, "address", (0, ec.computeAddress)(this.publicKey)), this.address !== (0, N.getAddress)(l.address) && ed.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), function(l) {
                                let c = l.mnemonic;
                                return c && c.phrase
                            }(l)) {
                            let c = l.mnemonic;
                            (0, en.defineReadOnly)(this, "_mnemonic", () => ({
                                phrase: c.phrase,
                                path: c.path || J.defaultPath,
                                locale: c.locale || "en"
                            }));
                            let x = this.mnemonic,
                                N = J.HDNode.fromMnemonic(x.phrase, null, x.locale).derivePath(x.path);
                            (0, ec.computeAddress)(N.privateKey) !== this.address && ed.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]")
                        } else(0, en.defineReadOnly)(this, "_mnemonic", () => null)
                    } else {
                        if (ea.SigningKey.isSigningKey(l)) "secp256k1" !== l.curve && ed.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), (0, en.defineReadOnly)(this, "_signingKey", () => l);
                        else {
                            "string" == typeof l && l.match(/^[0-9a-f]*$/i) && 64 === l.length && (l = "0x" + l);
                            let c = new ea.SigningKey(l);
                            (0, en.defineReadOnly)(this, "_signingKey", () => c)
                        }(0, en.defineReadOnly)(this, "_mnemonic", () => null), (0, en.defineReadOnly)(this, "address", (0, ec.computeAddress)(this.publicKey))
                    }
                    c && !U.zt.isProvider(c) && ed.throwArgumentError("invalid provider", "provider", c), (0, en.defineReadOnly)(this, "provider", c || null)
                }
                get mnemonic() {
                    return this._mnemonic()
                }
                get privateKey() {
                    return this._signingKey().privateKey
                }
                get publicKey() {
                    return this._signingKey().publicKey
                }
                getAddress() {
                    return Promise.resolve(this.address)
                }
                connect(l) {
                    return new Wallet(this, l)
                }
                signTransaction(l) {
                    return (0, en.resolveProperties)(l).then(c => {
                        null != c.from && ((0, N.getAddress)(c.from) !== this.address && ed.throwArgumentError("transaction from address mismatch", "transaction.from", l.from), delete c.from);
                        let x = this._signingKey().signDigest((0, X.keccak256)((0, ec.serialize)(c)));
                        return (0, ec.serialize)(c, x)
                    })
                }
                signMessage(l) {
                    return __awaiter(this, void 0, void 0, function*() {
                        return (0, $.joinSignature)(this._signingKey().signDigest((0, Y.r)(l)))
                    })
                }
                _signTypedData(l, c, x) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let N = yield q.E.resolveNames(l, c, x, l => (null == this.provider && ed.throwError("cannot resolve ENS names without a provider", eu.Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "resolveName",
                            value: l
                        }), this.provider.resolveName(l)));
                        return (0, $.joinSignature)(this._signingKey().signDigest(q.E.hash(N.domain, c, N.value)))
                    })
                }
                encrypt(l, c, x) {
                    if ("function" != typeof c || x || (x = c, c = {}), x && "function" != typeof x) throw Error("invalid callback");
                    return c || (c = {}), (0, eo.HI)(this, l, c, x)
                }
                static createRandom(l) {
                    let c = (0, er.O)(16);
                    l || (l = {}), l.extraEntropy && (c = (0, $.arrayify)((0, $.hexDataSlice)((0, X.keccak256)((0, $.concat)([c, l.extraEntropy])), 0, 16)));
                    let x = (0, J.entropyToMnemonic)(c, l.locale);
                    return Wallet.fromMnemonic(x, l.path, l.locale)
                }
                static fromEncryptedJson(l, c, x) {
                    return (0, el.decryptJsonWallet)(l, c, x).then(l => new Wallet(l))
                }
                static fromEncryptedJsonSync(l, c) {
                    return new Wallet((0, el.decryptJsonWalletSync)(l, c))
                }
                static fromMnemonic(l, c, x) {
                    return c || (c = J.defaultPath), new Wallet(J.HDNode.fromMnemonic(l, null, x).derivePath(c))
                }
            };

            function verifyMessage(l, c) {
                return (0, ec.recoverAddress)((0, Y.r)(l), c)
            }

            function verifyTypedData(l, c, x, N) {
                return (0, ec.recoverAddress)(q.E.hash(l, c, x), N)
            }
        },
        52504: function(l, c, x) {
            "use strict";
            x.d(c, {
                D: function() {
                    return Wordlist
                }
            });
            var N = x(36339),
                U = x(17213),
                Z = x(36288);
            let $ = new Z.Logger("wordlists/5.7.0");
            let Wordlist = class Wordlist {
                constructor(l) {
                    $.checkAbstract(new.target, Wordlist), (0, U.defineReadOnly)(this, "locale", l)
                }
                split(l) {
                    return l.toLowerCase().split(/ +/g)
                }
                join(l) {
                    return l.join(" ")
                }
                static check(l) {
                    let c = [];
                    for (let x = 0; x < 2048; x++) {
                        let N = l.getWord(x);
                        if (x !== l.getWordIndex(N)) return "0x";
                        c.push(N)
                    }
                    return (0, N.id)(c.join("\n") + "\n")
                }
                static register(l, c) {
                    c || (c = l.locale)
                }
            }
        },
        74506: function(l, c, x) {
            "use strict";
            x.d(c, {
                E: function() {
                    return $
                }
            });
            var N = x(52504);
            let U = null;

            function loadWords(l) {
                if (null == U && (U = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60" !== N.D.check(l))) throw U = null, Error("BIP39 Wordlist for en (English) FAILED")
            }
            let LangEn = class LangEn extends N.D {
                constructor() {
                    super("en")
                }
                getWord(l) {
                    return loadWords(this), U[l]
                }
                getWordIndex(l) {
                    return loadWords(this), U.indexOf(l)
                }
            };
            let Z = new LangEn;
            N.D.register(Z);
            let $ = {
                en: Z
            }
        },
        27081: function(l) {
            "use strict";
            l.exports = function(l) {
                if (l.length >= 255) throw TypeError("Alphabet too long");
                for (var c = new Uint8Array(256), x = 0; x < c.length; x++) c[x] = 255;
                for (var N = 0; N < l.length; N++) {
                    var U = l.charAt(N),
                        Z = U.charCodeAt(0);
                    if (255 !== c[Z]) throw TypeError(U + " is ambiguous");
                    c[Z] = N
                }
                var $ = l.length,
                    Y = l.charAt(0),
                    q = Math.log($) / Math.log(256),
                    J = Math.log(256) / Math.log($);

                function decodeUnsafe(l) {
                    if ("string" != typeof l) throw TypeError("Expected String");
                    if (0 === l.length) return new Uint8Array;
                    var x = 0;
                    if (" " !== l[0]) {
                        for (var N = 0, U = 0; l[x] === Y;) N++, x++;
                        for (var Z = (l.length - x) * q + 1 >>> 0, J = new Uint8Array(Z); l[x];) {
                            var X = c[l.charCodeAt(x)];
                            if (255 === X) return;
                            for (var en = 0, er = Z - 1;
                                (0 !== X || en < U) && -1 !== er; er--, en++) X += $ * J[er] >>> 0, J[er] = X % 256 >>> 0, X = X / 256 >>> 0;
                            if (0 !== X) throw Error("Non-zero carry");
                            U = en, x++
                        }
                        if (" " !== l[x]) {
                            for (var ea = Z - U; ea !== Z && 0 === J[ea];) ea++;
                            for (var eo = new Uint8Array(N + (Z - ea)), el = N; ea !== Z;) eo[el++] = J[ea++];
                            return eo
                        }
                    }
                }
                return {
                    encode: function(c) {
                        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                        if (0 === c.length) return "";
                        for (var x = 0, N = 0, U = 0, Z = c.length; U !== Z && 0 === c[U];) U++, x++;
                        for (var q = (Z - U) * J + 1 >>> 0, X = new Uint8Array(q); U !== Z;) {
                            for (var en = c[U], er = 0, ea = q - 1;
                                (0 !== en || er < N) && -1 !== ea; ea--, er++) en += 256 * X[ea] >>> 0, X[ea] = en % $ >>> 0, en = en / $ >>> 0;
                            if (0 !== en) throw Error("Non-zero carry");
                            N = er, U++
                        }
                        for (var eo = q - N; eo !== q && 0 === X[eo];) eo++;
                        for (var el = Y.repeat(x); eo < q; ++eo) el += l.charAt(X[eo]);
                        return el
                    },
                    decodeUnsafe: decodeUnsafe,
                    decode: function(l) {
                        var c = decodeUnsafe(l);
                        if (c) return c;
                        throw Error("Non-base" + $ + " character")
                    }
                }
            }
        },
        34310: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var N = x(62140);

            function writeUint16BE(l, c, x) {
                return void 0 === c && (c = new Uint8Array(2)), void 0 === x && (x = 0), c[x + 0] = l >>> 8, c[x + 1] = l >>> 0, c
            }

            function writeUint16LE(l, c, x) {
                return void 0 === c && (c = new Uint8Array(2)), void 0 === x && (x = 0), c[x + 0] = l >>> 0, c[x + 1] = l >>> 8, c
            }

            function readInt32BE(l, c) {
                return void 0 === c && (c = 0), l[c] << 24 | l[c + 1] << 16 | l[c + 2] << 8 | l[c + 3]
            }

            function readUint32BE(l, c) {
                return void 0 === c && (c = 0), (l[c] << 24 | l[c + 1] << 16 | l[c + 2] << 8 | l[c + 3]) >>> 0
            }

            function readInt32LE(l, c) {
                return void 0 === c && (c = 0), l[c + 3] << 24 | l[c + 2] << 16 | l[c + 1] << 8 | l[c]
            }

            function readUint32LE(l, c) {
                return void 0 === c && (c = 0), (l[c + 3] << 24 | l[c + 2] << 16 | l[c + 1] << 8 | l[c]) >>> 0
            }

            function writeUint32BE(l, c, x) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === x && (x = 0), c[x + 0] = l >>> 24, c[x + 1] = l >>> 16, c[x + 2] = l >>> 8, c[x + 3] = l >>> 0, c
            }

            function writeUint32LE(l, c, x) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === x && (x = 0), c[x + 0] = l >>> 0, c[x + 1] = l >>> 8, c[x + 2] = l >>> 16, c[x + 3] = l >>> 24, c
            }

            function writeUint64BE(l, c, x) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === x && (x = 0), writeUint32BE(l / 4294967296 >>> 0, c, x), writeUint32BE(l >>> 0, c, x + 4), c
            }

            function writeUint64LE(l, c, x) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === x && (x = 0), writeUint32LE(l >>> 0, c, x), writeUint32LE(l / 4294967296 >>> 0, c, x + 4), c
            }
            c.readInt16BE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 0] << 8 | l[c + 1]) << 16 >> 16
            }, c.readUint16BE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 0] << 8 | l[c + 1]) >>> 0
            }, c.readInt16LE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 1] << 8 | l[c]) << 16 >> 16
            }, c.readUint16LE = function(l, c) {
                return void 0 === c && (c = 0), (l[c + 1] << 8 | l[c]) >>> 0
            }, c.writeUint16BE = writeUint16BE, c.writeInt16BE = writeUint16BE, c.writeUint16LE = writeUint16LE, c.writeInt16LE = writeUint16LE, c.readInt32BE = readInt32BE, c.readUint32BE = readUint32BE, c.readInt32LE = readInt32LE, c.readUint32LE = readUint32LE, c.writeUint32BE = writeUint32BE, c.writeInt32BE = writeUint32BE, c.writeUint32LE = writeUint32LE, c.writeInt32LE = writeUint32LE, c.readInt64BE = function(l, c) {
                void 0 === c && (c = 0);
                var x = readInt32BE(l, c),
                    N = readInt32BE(l, c + 4);
                return 4294967296 * x + N - (N >> 31) * 4294967296
            }, c.readUint64BE = function(l, c) {
                return void 0 === c && (c = 0), 4294967296 * readUint32BE(l, c) + readUint32BE(l, c + 4)
            }, c.readInt64LE = function(l, c) {
                void 0 === c && (c = 0);
                var x = readInt32LE(l, c);
                return 4294967296 * readInt32LE(l, c + 4) + x - (x >> 31) * 4294967296
            }, c.readUint64LE = function(l, c) {
                void 0 === c && (c = 0);
                var x = readUint32LE(l, c);
                return 4294967296 * readUint32LE(l, c + 4) + x
            }, c.writeUint64BE = writeUint64BE, c.writeInt64BE = writeUint64BE, c.writeUint64LE = writeUint64LE, c.writeInt64LE = writeUint64LE, c.readUintBE = function(l, c, x) {
                if (void 0 === x && (x = 0), l % 8 != 0) throw Error("readUintBE supports only bitLengths divisible by 8");
                if (l / 8 > c.length - x) throw Error("readUintBE: array is too short for the given bitLength");
                for (var N = 0, U = 1, Z = l / 8 + x - 1; Z >= x; Z--) N += c[Z] * U, U *= 256;
                return N
            }, c.readUintLE = function(l, c, x) {
                if (void 0 === x && (x = 0), l % 8 != 0) throw Error("readUintLE supports only bitLengths divisible by 8");
                if (l / 8 > c.length - x) throw Error("readUintLE: array is too short for the given bitLength");
                for (var N = 0, U = 1, Z = x; Z < x + l / 8; Z++) N += c[Z] * U, U *= 256;
                return N
            }, c.writeUintBE = function(l, c, x, U) {
                if (void 0 === x && (x = new Uint8Array(l / 8)), void 0 === U && (U = 0), l % 8 != 0) throw Error("writeUintBE supports only bitLengths divisible by 8");
                if (!N.isSafeInteger(c)) throw Error("writeUintBE value must be an integer");
                for (var Z = 1, $ = l / 8 + U - 1; $ >= U; $--) x[$] = c / Z & 255, Z *= 256;
                return x
            }, c.writeUintLE = function(l, c, x, U) {
                if (void 0 === x && (x = new Uint8Array(l / 8)), void 0 === U && (U = 0), l % 8 != 0) throw Error("writeUintLE supports only bitLengths divisible by 8");
                if (!N.isSafeInteger(c)) throw Error("writeUintLE value must be an integer");
                for (var Z = 1, $ = U; $ < U + l / 8; $++) x[$] = c / Z & 255, Z *= 256;
                return x
            }, c.readFloat32BE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat32(c)
            }, c.readFloat32LE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat32(c, !0)
            }, c.readFloat64BE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat64(c)
            }, c.readFloat64LE = function(l, c) {
                return void 0 === c && (c = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).getFloat64(c, !0)
            }, c.writeFloat32BE = function(l, c, x) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === x && (x = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat32(x, l), c
            }, c.writeFloat32LE = function(l, c, x) {
                return void 0 === c && (c = new Uint8Array(4)), void 0 === x && (x = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat32(x, l, !0), c
            }, c.writeFloat64BE = function(l, c, x) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === x && (x = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat64(x, l), c
            }, c.writeFloat64LE = function(l, c, x) {
                return void 0 === c && (c = new Uint8Array(8)), void 0 === x && (x = 0), new DataView(c.buffer, c.byteOffset, c.byteLength).setFloat64(x, l, !0), c
            }
        },
        48733: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var N = x(34310),
                U = x(55277);

            function streamXOR(l, c, x, Z, $) {
                if (void 0 === $ && ($ = 0), 32 !== l.length) throw Error("ChaCha: key size must be 32 bytes");
                if (Z.length < x.length) throw Error("ChaCha: destination is shorter than source");
                if (0 === $) {
                    if (8 !== c.length && 12 !== c.length) throw Error("ChaCha nonce must be 8 or 12 bytes");
                    q = (Y = new Uint8Array(16)).length - c.length, Y.set(c, q)
                } else {
                    if (16 !== c.length) throw Error("ChaCha nonce with counter must be 16 bytes");
                    Y = c, q = $
                }
                for (var Y, q, J = new Uint8Array(64), X = 0; X < x.length; X += 64) {
                    ! function(l, c, x) {
                        for (var U = x[3] << 24 | x[2] << 16 | x[1] << 8 | x[0], Z = x[7] << 24 | x[6] << 16 | x[5] << 8 | x[4], $ = x[11] << 24 | x[10] << 16 | x[9] << 8 | x[8], Y = x[15] << 24 | x[14] << 16 | x[13] << 8 | x[12], q = x[19] << 24 | x[18] << 16 | x[17] << 8 | x[16], J = x[23] << 24 | x[22] << 16 | x[21] << 8 | x[20], X = x[27] << 24 | x[26] << 16 | x[25] << 8 | x[24], en = x[31] << 24 | x[30] << 16 | x[29] << 8 | x[28], er = c[3] << 24 | c[2] << 16 | c[1] << 8 | c[0], ea = c[7] << 24 | c[6] << 16 | c[5] << 8 | c[4], eo = c[11] << 24 | c[10] << 16 | c[9] << 8 | c[8], el = c[15] << 24 | c[14] << 16 | c[13] << 8 | c[12], ec = 1634760805, eu = 857760878, ed = 2036477234, ep = 1797285236, eh = U, ey = Z, ef = $, em = Y, eg = q, eb = J, ev = X, ew = en, eT = er, eM = ea, eI = eo, ex = el, eC = 0; eC < 20; eC += 2) eT ^= ec = ec + eh | 0, eh ^= eg = eg + (eT = eT >>> 16 | eT << 16) | 0, eh = eh >>> 20 | eh << 12, eM ^= eu = eu + ey | 0, ey ^= eb = eb + (eM = eM >>> 16 | eM << 16) | 0, ey = ey >>> 20 | ey << 12, eI ^= ed = ed + ef | 0, ef ^= ev = ev + (eI = eI >>> 16 | eI << 16) | 0, ef = ef >>> 20 | ef << 12, ex ^= ep = ep + em | 0, em ^= ew = ew + (ex = ex >>> 16 | ex << 16) | 0, em = em >>> 20 | em << 12, eI ^= ed = ed + ef | 0, ef ^= ev = ev + (eI = eI >>> 24 | eI << 8) | 0, ef = ef >>> 25 | ef << 7, ex ^= ep = ep + em | 0, em ^= ew = ew + (ex = ex >>> 24 | ex << 8) | 0, em = em >>> 25 | em << 7, eM ^= eu = eu + ey | 0, ey ^= eb = eb + (eM = eM >>> 24 | eM << 8) | 0, ey = ey >>> 25 | ey << 7, eT ^= ec = ec + eh | 0, eh ^= eg = eg + (eT = eT >>> 24 | eT << 8) | 0, eh = eh >>> 25 | eh << 7, ex ^= ec = ec + ey | 0, ey ^= ev = ev + (ex = ex >>> 16 | ex << 16) | 0, ey = ey >>> 20 | ey << 12, eT ^= eu = eu + ef | 0, ef ^= ew = ew + (eT = eT >>> 16 | eT << 16) | 0, ef = ef >>> 20 | ef << 12, eM ^= ed = ed + em | 0, em ^= eg = eg + (eM = eM >>> 16 | eM << 16) | 0, em = em >>> 20 | em << 12, eI ^= ep = ep + eh | 0, eh ^= eb = eb + (eI = eI >>> 16 | eI << 16) | 0, eh = eh >>> 20 | eh << 12, eM ^= ed = ed + em | 0, em ^= eg = eg + (eM = eM >>> 24 | eM << 8) | 0, em = em >>> 25 | em << 7, eI ^= ep = ep + eh | 0, eh ^= eb = eb + (eI = eI >>> 24 | eI << 8) | 0, eh = eh >>> 25 | eh << 7, eT ^= eu = eu + ef | 0, ef ^= ew = ew + (eT = eT >>> 24 | eT << 8) | 0, ef = ef >>> 25 | ef << 7, ex ^= ec = ec + ey | 0, ey ^= ev = ev + (ex = ex >>> 24 | ex << 8) | 0, ey = ey >>> 25 | ey << 7;
                        N.writeUint32LE(ec + 1634760805 | 0, l, 0), N.writeUint32LE(eu + 857760878 | 0, l, 4), N.writeUint32LE(ed + 2036477234 | 0, l, 8), N.writeUint32LE(ep + 1797285236 | 0, l, 12), N.writeUint32LE(eh + U | 0, l, 16), N.writeUint32LE(ey + Z | 0, l, 20), N.writeUint32LE(ef + $ | 0, l, 24), N.writeUint32LE(em + Y | 0, l, 28), N.writeUint32LE(eg + q | 0, l, 32), N.writeUint32LE(eb + J | 0, l, 36), N.writeUint32LE(ev + X | 0, l, 40), N.writeUint32LE(ew + en | 0, l, 44), N.writeUint32LE(eT + er | 0, l, 48), N.writeUint32LE(eM + ea | 0, l, 52), N.writeUint32LE(eI + eo | 0, l, 56), N.writeUint32LE(ex + el | 0, l, 60)
                    }(J, Y, l);
                    for (var en = X; en < X + 64 && en < x.length; en++) Z[en] = x[en] ^ J[en - X];
                    ! function(l, c, x) {
                        for (var N = 1; x--;) N = N + (255 & l[c]) | 0, l[c] = 255 & N, N >>>= 8, c++;
                        if (N > 0) throw Error("ChaCha: counter overflow")
                    }(Y, 0, q)
                }
                return U.wipe(J), 0 === $ && U.wipe(Y), Z
            }
            c.streamXOR = streamXOR, c.stream = function(l, c, x, N) {
                return void 0 === N && (N = 0), U.wipe(x), streamXOR(l, c, x, x, N)
            }
        },
        51040: function(l, c, x) {
            "use strict";
            var N = x(48733),
                U = x(66508),
                Z = x(55277),
                $ = x(34310),
                Y = x(51448);
            c.Cv = 32, c.WH = 12, c.pg = 16;
            var q = new Uint8Array(16),
                J = function() {
                    function ChaCha20Poly1305(l) {
                        if (this.nonceLength = c.WH, this.tagLength = c.pg, l.length !== c.Cv) throw Error("ChaCha20Poly1305 needs 32-byte key");
                        this._key = new Uint8Array(l)
                    }
                    return ChaCha20Poly1305.prototype.seal = function(l, c, x, U) {
                        if (l.length > 16) throw Error("ChaCha20Poly1305: incorrect nonce length");
                        var $, Y = new Uint8Array(16);
                        Y.set(l, Y.length - l.length);
                        var q = new Uint8Array(32);
                        N.stream(this._key, Y, q, 4);
                        var J = c.length + this.tagLength;
                        if (U) {
                            if (U.length !== J) throw Error("ChaCha20Poly1305: incorrect destination length");
                            $ = U
                        } else $ = new Uint8Array(J);
                        return N.streamXOR(this._key, Y, c, $, 4), this._authenticate($.subarray($.length - this.tagLength, $.length), q, $.subarray(0, $.length - this.tagLength), x), Z.wipe(Y), $
                    }, ChaCha20Poly1305.prototype.open = function(l, c, x, U) {
                        if (l.length > 16) throw Error("ChaCha20Poly1305: incorrect nonce length");
                        if (c.length < this.tagLength) return null;
                        var $, q = new Uint8Array(16);
                        q.set(l, q.length - l.length);
                        var J = new Uint8Array(32);
                        N.stream(this._key, q, J, 4);
                        var X = new Uint8Array(this.tagLength);
                        if (this._authenticate(X, J, c.subarray(0, c.length - this.tagLength), x), !Y.equal(X, c.subarray(c.length - this.tagLength, c.length))) return null;
                        var en = c.length - this.tagLength;
                        if (U) {
                            if (U.length !== en) throw Error("ChaCha20Poly1305: incorrect destination length");
                            $ = U
                        } else $ = new Uint8Array(en);
                        return N.streamXOR(this._key, q, c.subarray(0, c.length - this.tagLength), $, 4), Z.wipe(q), $
                    }, ChaCha20Poly1305.prototype.clean = function() {
                        return Z.wipe(this._key), this
                    }, ChaCha20Poly1305.prototype._authenticate = function(l, c, x, N) {
                        var Y = new U.Poly1305(c);
                        N && (Y.update(N), N.length % 16 > 0 && Y.update(q.subarray(N.length % 16))), Y.update(x), x.length % 16 > 0 && Y.update(q.subarray(x.length % 16));
                        var J = new Uint8Array(8);
                        N && $.writeUint64LE(N.length, J), Y.update(J), $.writeUint64LE(x.length, J), Y.update(J);
                        for (var X = Y.digest(), en = 0; en < X.length; en++) l[en] = X[en];
                        Y.clean(), Z.wipe(X), Z.wipe(J)
                    }, ChaCha20Poly1305
                }();
            c.OK = J
        },
        51448: function(l, c) {
            "use strict";

            function compare(l, c) {
                if (l.length !== c.length) return 0;
                for (var x = 0, N = 0; N < l.length; N++) x |= l[N] ^ c[N];
                return 1 & x - 1 >>> 8
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.select = function(l, c, x) {
                return ~(l - 1) & c | l - 1 & x
            }, c.lessOrEqual = function(l, c) {
                return (0 | l) - (0 | c) - 1 >>> 31 & 1
            }, c.compare = compare, c.equal = function(l, c) {
                return 0 !== l.length && 0 !== c.length && 0 !== compare(l, c)
            }
        },
        80237: function(l, c, x) {
            "use strict";
            c.Xx = c._w = c.aP = c.KS = c.jQ = void 0, x(35077);
            let N = x(52564);

            function gf(l) {
                let c = new Float64Array(16);
                if (l)
                    for (let x = 0; x < l.length; x++) c[x] = l[x];
                return c
            }
            x(55277), c.jQ = 64, c.KS = 64, c.aP = 32;
            let U = new Uint8Array(32);
            U[0] = 9;
            let Z = gf(),
                $ = gf([1]),
                Y = (gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])),
                q = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
                J = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);

            function set25519(l, c) {
                for (let x = 0; x < 16; x++) l[x] = 0 | c[x]
            }

            function car25519(l) {
                let c = 1;
                for (let x = 0; x < 16; x++) {
                    let N = l[x] + c + 65535;
                    c = Math.floor(N / 65536), l[x] = N - 65536 * c
                }
                l[0] += c - 1 + 37 * (c - 1)
            }

            function sel25519(l, c, x) {
                let N = ~(x - 1);
                for (let x = 0; x < 16; x++) {
                    let U = N & (l[x] ^ c[x]);
                    l[x] ^= U, c[x] ^= U
                }
            }

            function pack25519(l, c) {
                let x = gf(),
                    N = gf();
                for (let l = 0; l < 16; l++) N[l] = c[l];
                car25519(N), car25519(N), car25519(N);
                for (let l = 0; l < 2; l++) {
                    x[0] = N[0] - 65517;
                    for (let l = 1; l < 15; l++) x[l] = N[l] - 65535 - (x[l - 1] >> 16 & 1), x[l - 1] &= 65535;
                    x[15] = N[15] - 32767 - (x[14] >> 16 & 1);
                    let l = x[15] >> 16 & 1;
                    x[14] &= 65535, sel25519(N, x, 1 - l)
                }
                for (let c = 0; c < 16; c++) l[2 * c] = 255 & N[c], l[2 * c + 1] = N[c] >> 8
            }
            gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

            function add(l, c, x) {
                for (let N = 0; N < 16; N++) l[N] = c[N] + x[N]
            }

            function sub(l, c, x) {
                for (let N = 0; N < 16; N++) l[N] = c[N] - x[N]
            }

            function mul(l, c, x) {
                let N, U, Z = 0,
                    $ = 0,
                    Y = 0,
                    q = 0,
                    J = 0,
                    X = 0,
                    en = 0,
                    er = 0,
                    ea = 0,
                    eo = 0,
                    el = 0,
                    ec = 0,
                    eu = 0,
                    ed = 0,
                    ep = 0,
                    eh = 0,
                    ey = 0,
                    ef = 0,
                    em = 0,
                    eg = 0,
                    eb = 0,
                    ev = 0,
                    ew = 0,
                    eT = 0,
                    eM = 0,
                    eI = 0,
                    ex = 0,
                    eC = 0,
                    e_ = 0,
                    eD = 0,
                    eS = 0,
                    ek = x[0],
                    eE = x[1],
                    eN = x[2],
                    eA = x[3],
                    ej = x[4],
                    eO = x[5],
                    eP = x[6],
                    ez = x[7],
                    eR = x[8],
                    eL = x[9],
                    eB = x[10],
                    eU = x[11],
                    eF = x[12],
                    eW = x[13],
                    eZ = x[14],
                    eQ = x[15];
                Z += (N = c[0]) * ek, $ += N * eE, Y += N * eN, q += N * eA, J += N * ej, X += N * eO, en += N * eP, er += N * ez, ea += N * eR, eo += N * eL, el += N * eB, ec += N * eU, eu += N * eF, ed += N * eW, ep += N * eZ, eh += N * eQ, $ += (N = c[1]) * ek, Y += N * eE, q += N * eN, J += N * eA, X += N * ej, en += N * eO, er += N * eP, ea += N * ez, eo += N * eR, el += N * eL, ec += N * eB, eu += N * eU, ed += N * eF, ep += N * eW, eh += N * eZ, ey += N * eQ, Y += (N = c[2]) * ek, q += N * eE, J += N * eN, X += N * eA, en += N * ej, er += N * eO, ea += N * eP, eo += N * ez, el += N * eR, ec += N * eL, eu += N * eB, ed += N * eU, ep += N * eF, eh += N * eW, ey += N * eZ, ef += N * eQ, q += (N = c[3]) * ek, J += N * eE, X += N * eN, en += N * eA, er += N * ej, ea += N * eO, eo += N * eP, el += N * ez, ec += N * eR, eu += N * eL, ed += N * eB, ep += N * eU, eh += N * eF, ey += N * eW, ef += N * eZ, em += N * eQ, J += (N = c[4]) * ek, X += N * eE, en += N * eN, er += N * eA, ea += N * ej, eo += N * eO, el += N * eP, ec += N * ez, eu += N * eR, ed += N * eL, ep += N * eB, eh += N * eU, ey += N * eF, ef += N * eW, em += N * eZ, eg += N * eQ, X += (N = c[5]) * ek, en += N * eE, er += N * eN, ea += N * eA, eo += N * ej, el += N * eO, ec += N * eP, eu += N * ez, ed += N * eR, ep += N * eL, eh += N * eB, ey += N * eU, ef += N * eF, em += N * eW, eg += N * eZ, eb += N * eQ, en += (N = c[6]) * ek, er += N * eE, ea += N * eN, eo += N * eA, el += N * ej, ec += N * eO, eu += N * eP, ed += N * ez, ep += N * eR, eh += N * eL, ey += N * eB, ef += N * eU, em += N * eF, eg += N * eW, eb += N * eZ, ev += N * eQ, er += (N = c[7]) * ek, ea += N * eE, eo += N * eN, el += N * eA, ec += N * ej, eu += N * eO, ed += N * eP, ep += N * ez, eh += N * eR, ey += N * eL, ef += N * eB, em += N * eU, eg += N * eF, eb += N * eW, ev += N * eZ, ew += N * eQ, ea += (N = c[8]) * ek, eo += N * eE, el += N * eN, ec += N * eA, eu += N * ej, ed += N * eO, ep += N * eP, eh += N * ez, ey += N * eR, ef += N * eL, em += N * eB, eg += N * eU, eb += N * eF, ev += N * eW, ew += N * eZ, eT += N * eQ, eo += (N = c[9]) * ek, el += N * eE, ec += N * eN, eu += N * eA, ed += N * ej, ep += N * eO, eh += N * eP, ey += N * ez, ef += N * eR, em += N * eL, eg += N * eB, eb += N * eU, ev += N * eF, ew += N * eW, eT += N * eZ, eM += N * eQ, el += (N = c[10]) * ek, ec += N * eE, eu += N * eN, ed += N * eA, ep += N * ej, eh += N * eO, ey += N * eP, ef += N * ez, em += N * eR, eg += N * eL, eb += N * eB, ev += N * eU, ew += N * eF, eT += N * eW, eM += N * eZ, eI += N * eQ, ec += (N = c[11]) * ek, eu += N * eE, ed += N * eN, ep += N * eA, eh += N * ej, ey += N * eO, ef += N * eP, em += N * ez, eg += N * eR, eb += N * eL, ev += N * eB, ew += N * eU, eT += N * eF, eM += N * eW, eI += N * eZ, ex += N * eQ, eu += (N = c[12]) * ek, ed += N * eE, ep += N * eN, eh += N * eA, ey += N * ej, ef += N * eO, em += N * eP, eg += N * ez, eb += N * eR, ev += N * eL, ew += N * eB, eT += N * eU, eM += N * eF, eI += N * eW, ex += N * eZ, eC += N * eQ, ed += (N = c[13]) * ek, ep += N * eE, eh += N * eN, ey += N * eA, ef += N * ej, em += N * eO, eg += N * eP, eb += N * ez, ev += N * eR, ew += N * eL, eT += N * eB, eM += N * eU, eI += N * eF, ex += N * eW, eC += N * eZ, e_ += N * eQ, ep += (N = c[14]) * ek, eh += N * eE, ey += N * eN, ef += N * eA, em += N * ej, eg += N * eO, eb += N * eP, ev += N * ez, ew += N * eR, eT += N * eL, eM += N * eB, eI += N * eU, ex += N * eF, eC += N * eW, e_ += N * eZ, eD += N * eQ, eh += (N = c[15]) * ek, ey += N * eE, ef += N * eN, em += N * eA, eg += N * ej, eb += N * eO, ev += N * eP, ew += N * ez, eT += N * eR, eM += N * eL, eI += N * eB, ex += N * eU, eC += N * eF, e_ += N * eW, eD += N * eZ, eS += N * eQ, Z += 38 * ey, $ += 38 * ef, Y += 38 * em, q += 38 * eg, J += 38 * eb, X += 38 * ev, en += 38 * ew, er += 38 * eT, ea += 38 * eM, eo += 38 * eI, el += 38 * ex, ec += 38 * eC, eu += 38 * e_, ed += 38 * eD, ep += 38 * eS, U = Math.floor((N = Z + (U = 1) + 65535) / 65536), Z = N - 65536 * U, U = Math.floor((N = $ + U + 65535) / 65536), $ = N - 65536 * U, U = Math.floor((N = Y + U + 65535) / 65536), Y = N - 65536 * U, U = Math.floor((N = q + U + 65535) / 65536), q = N - 65536 * U, U = Math.floor((N = J + U + 65535) / 65536), J = N - 65536 * U, U = Math.floor((N = X + U + 65535) / 65536), X = N - 65536 * U, U = Math.floor((N = en + U + 65535) / 65536), en = N - 65536 * U, U = Math.floor((N = er + U + 65535) / 65536), er = N - 65536 * U, U = Math.floor((N = ea + U + 65535) / 65536), ea = N - 65536 * U, U = Math.floor((N = eo + U + 65535) / 65536), eo = N - 65536 * U, U = Math.floor((N = el + U + 65535) / 65536), el = N - 65536 * U, U = Math.floor((N = ec + U + 65535) / 65536), ec = N - 65536 * U, U = Math.floor((N = eu + U + 65535) / 65536), eu = N - 65536 * U, U = Math.floor((N = ed + U + 65535) / 65536), ed = N - 65536 * U, U = Math.floor((N = ep + U + 65535) / 65536), ep = N - 65536 * U, U = Math.floor((N = eh + U + 65535) / 65536), eh = N - 65536 * U, Z += U - 1 + 37 * (U - 1), U = Math.floor((N = Z + (U = 1) + 65535) / 65536), Z = N - 65536 * U, U = Math.floor((N = $ + U + 65535) / 65536), $ = N - 65536 * U, U = Math.floor((N = Y + U + 65535) / 65536), Y = N - 65536 * U, U = Math.floor((N = q + U + 65535) / 65536), q = N - 65536 * U, U = Math.floor((N = J + U + 65535) / 65536), J = N - 65536 * U, U = Math.floor((N = X + U + 65535) / 65536), X = N - 65536 * U, U = Math.floor((N = en + U + 65535) / 65536), en = N - 65536 * U, U = Math.floor((N = er + U + 65535) / 65536), er = N - 65536 * U, U = Math.floor((N = ea + U + 65535) / 65536), ea = N - 65536 * U, U = Math.floor((N = eo + U + 65535) / 65536), eo = N - 65536 * U, U = Math.floor((N = el + U + 65535) / 65536), el = N - 65536 * U, U = Math.floor((N = ec + U + 65535) / 65536), ec = N - 65536 * U, U = Math.floor((N = eu + U + 65535) / 65536), eu = N - 65536 * U, U = Math.floor((N = ed + U + 65535) / 65536), ed = N - 65536 * U, U = Math.floor((N = ep + U + 65535) / 65536), ep = N - 65536 * U, U = Math.floor((N = eh + U + 65535) / 65536), eh = N - 65536 * U, Z += U - 1 + 37 * (U - 1), l[0] = Z, l[1] = $, l[2] = Y, l[3] = q, l[4] = J, l[5] = X, l[6] = en, l[7] = er, l[8] = ea, l[9] = eo, l[10] = el, l[11] = ec, l[12] = eu, l[13] = ed, l[14] = ep, l[15] = eh
            }

            function edadd(l, c) {
                let x = gf(),
                    N = gf(),
                    U = gf(),
                    Z = gf(),
                    $ = gf(),
                    q = gf(),
                    J = gf(),
                    X = gf(),
                    en = gf();
                sub(x, l[1], l[0]), sub(en, c[1], c[0]), mul(x, x, en), add(N, l[0], l[1]), add(en, c[0], c[1]), mul(N, N, en), mul(U, l[3], c[3]), mul(U, U, Y), mul(Z, l[2], c[2]), add(Z, Z, Z), sub($, N, x), sub(q, Z, U), add(J, Z, U), add(X, N, x), mul(l[0], $, q), mul(l[1], X, J), mul(l[2], J, q), mul(l[3], $, X)
            }

            function cswap(l, c, x) {
                for (let N = 0; N < 4; N++) sel25519(l[N], c[N], x)
            }

            function pack(l, c) {
                let x = gf(),
                    N = gf(),
                    U = gf();
                (function(l, c) {
                    let x;
                    let N = gf();
                    for (x = 0; x < 16; x++) N[x] = c[x];
                    for (x = 253; x >= 0; x--) mul(N, N, N), 2 !== x && 4 !== x && mul(N, N, c);
                    for (x = 0; x < 16; x++) l[x] = N[x]
                })(U, c[2]), mul(x, c[0], U), mul(N, c[1], U), pack25519(l, N), l[31] ^= function(l) {
                    let c = new Uint8Array(32);
                    return pack25519(c, l), 1 & c[0]
                }(x) << 7
            }

            function scalarbase(l, c) {
                let x = [gf(), gf(), gf(), gf()];
                set25519(x[0], q), set25519(x[1], J), set25519(x[2], $), mul(x[3], q, J),
                    function(l, c, x) {
                        set25519(l[0], Z), set25519(l[1], $), set25519(l[2], $), set25519(l[3], Z);
                        for (let N = 255; N >= 0; --N) {
                            let U = x[N / 8 | 0] >> (7 & N) & 1;
                            cswap(l, c, U), edadd(c, l), edadd(l, l), cswap(l, c, U)
                        }
                    }(l, x, c)
            }
            c._w = function(l) {
                if (l.length !== c.aP) throw Error(`ed25519: seed must be ${c.aP} bytes`);
                let x = (0, N.hash)(l);
                x[0] &= 248, x[31] &= 127, x[31] |= 64;
                let U = new Uint8Array(32),
                    Z = [gf(), gf(), gf(), gf()];
                scalarbase(Z, x), pack(U, Z);
                let $ = new Uint8Array(64);
                return $.set(l), $.set(U, 32), {
                    publicKey: U,
                    secretKey: $
                }
            };
            let X = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

            function modL(l, c) {
                let x, N, U, Z;
                for (N = 63; N >= 32; --N) {
                    for (x = 0, U = N - 32, Z = N - 12; U < Z; ++U) c[U] += x - 16 * c[N] * X[U - (N - 32)], x = Math.floor((c[U] + 128) / 256), c[U] -= 256 * x;
                    c[U] += x, c[N] = 0
                }
                for (U = 0, x = 0; U < 32; U++) c[U] += x - (c[31] >> 4) * X[U], x = c[U] >> 8, c[U] &= 255;
                for (U = 0; U < 32; U++) c[U] -= x * X[U];
                for (N = 0; N < 32; N++) c[N + 1] += c[N] >> 8, l[N] = 255 & c[N]
            }

            function reduce(l) {
                let c = new Float64Array(64);
                for (let x = 0; x < 64; x++) c[x] = l[x];
                for (let c = 0; c < 64; c++) l[c] = 0;
                modL(l, c)
            }
            c.Xx = function(l, c) {
                let x = new Float64Array(64),
                    U = [gf(), gf(), gf(), gf()],
                    Z = (0, N.hash)(l.subarray(0, 32));
                Z[0] &= 248, Z[31] &= 127, Z[31] |= 64;
                let $ = new Uint8Array(64);
                $.set(Z.subarray(32), 32);
                let Y = new N.SHA512;
                Y.update($.subarray(32)), Y.update(c);
                let q = Y.digest();
                Y.clean(), reduce(q), scalarbase(U, q), pack($, U), Y.reset(), Y.update($.subarray(0, 32)), Y.update(l.subarray(32)), Y.update(c);
                let J = Y.digest();
                reduce(J);
                for (let l = 0; l < 32; l++) x[l] = q[l];
                for (let l = 0; l < 32; l++)
                    for (let c = 0; c < 32; c++) x[l + c] += J[l] * Z[c];
                return modL($.subarray(32), x), $
            }
        },
        12621: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.isSerializableHash = function(l) {
                return void 0 !== l.saveState && void 0 !== l.restoreState && void 0 !== l.cleanSavedState
            }
        },
        20342: function(l, c, x) {
            "use strict";
            var N = x(9922),
                U = x(55277),
                Z = function() {
                    function HKDF(l, c, x, U) {
                        void 0 === x && (x = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = l, this._info = U;
                        var Z = N.hmac(this._hash, x, c);
                        this._hmac = new N.HMAC(l, Z), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
                    }
                    return HKDF.prototype._fillBuffer = function() {
                        this._counter[0]++;
                        var l = this._counter[0];
                        if (0 === l) throw Error("hkdf: cannot expand more");
                        this._hmac.reset(), l > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
                    }, HKDF.prototype.expand = function(l) {
                        for (var c = new Uint8Array(l), x = 0; x < c.length; x++) this._bufpos === this._buffer.length && this._fillBuffer(), c[x] = this._buffer[this._bufpos++];
                        return c
                    }, HKDF.prototype.clean = function() {
                        this._hmac.clean(), U.wipe(this._buffer), U.wipe(this._counter), this._bufpos = 0
                    }, HKDF
                }();
            c.t = Z
        },
        9922: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var N = x(12621),
                U = x(51448),
                Z = x(55277),
                $ = function() {
                    function HMAC(l, c) {
                        this._finished = !1, this._inner = new l, this._outer = new l, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
                        var x = new Uint8Array(this.blockSize);
                        c.length > this.blockSize ? this._inner.update(c).finish(x).clean() : x.set(c);
                        for (var U = 0; U < x.length; U++) x[U] ^= 54;
                        this._inner.update(x);
                        for (var U = 0; U < x.length; U++) x[U] ^= 106;
                        this._outer.update(x), N.isSerializableHash(this._inner) && N.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Z.wipe(x)
                    }
                    return HMAC.prototype.reset = function() {
                        if (!N.isSerializableHash(this._inner) || !N.isSerializableHash(this._outer)) throw Error("hmac: can't reset() because hash doesn't implement restoreState()");
                        return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, HMAC.prototype.clean = function() {
                        N.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), N.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
                    }, HMAC.prototype.update = function(l) {
                        return this._inner.update(l), this
                    }, HMAC.prototype.finish = function(l) {
                        return this._finished ? this._outer.finish(l) : (this._inner.finish(l), this._outer.update(l.subarray(0, this.digestLength)).finish(l), this._finished = !0), this
                    }, HMAC.prototype.digest = function() {
                        var l = new Uint8Array(this.digestLength);
                        return this.finish(l), l
                    }, HMAC.prototype.saveState = function() {
                        if (!N.isSerializableHash(this._inner)) throw Error("hmac: can't saveState() because hash doesn't implement it");
                        return this._inner.saveState()
                    }, HMAC.prototype.restoreState = function(l) {
                        if (!N.isSerializableHash(this._inner) || !N.isSerializableHash(this._outer)) throw Error("hmac: can't restoreState() because hash doesn't implement it");
                        return this._inner.restoreState(l), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, HMAC.prototype.cleanSavedState = function(l) {
                        if (!N.isSerializableHash(this._inner)) throw Error("hmac: can't cleanSavedState() because hash doesn't implement it");
                        this._inner.cleanSavedState(l)
                    }, HMAC
                }();
            c.HMAC = $, c.hmac = function(l, c, x) {
                var N = new $(l, c);
                N.update(x);
                var U = N.digest();
                return N.clean(), U
            }, c.equal = U.equal
        },
        62140: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.mul = Math.imul || function(l, c) {
                var x = 65535 & l,
                    N = 65535 & c;
                return x * N + ((l >>> 16 & 65535) * N + x * (c >>> 16 & 65535) << 16 >>> 0) | 0
            }, c.add = function(l, c) {
                return l + c | 0
            }, c.sub = function(l, c) {
                return l - c | 0
            }, c.rotl = function(l, c) {
                return l << c | l >>> 32 - c
            }, c.rotr = function(l, c) {
                return l << 32 - c | l >>> c
            }, c.isInteger = Number.isInteger || function(l) {
                return "number" == typeof l && isFinite(l) && Math.floor(l) === l
            }, c.MAX_SAFE_INTEGER = 9007199254740991, c.isSafeInteger = function(l) {
                return c.isInteger(l) && l >= -c.MAX_SAFE_INTEGER && l <= c.MAX_SAFE_INTEGER
            }
        },
        66508: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var N = x(51448),
                U = x(55277);
            c.DIGEST_LENGTH = 16;
            var Z = function() {
                function Poly1305(l) {
                    this.digestLength = c.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
                    var x = l[0] | l[1] << 8;
                    this._r[0] = 8191 & x;
                    var N = l[2] | l[3] << 8;
                    this._r[1] = (x >>> 13 | N << 3) & 8191;
                    var U = l[4] | l[5] << 8;
                    this._r[2] = (N >>> 10 | U << 6) & 7939;
                    var Z = l[6] | l[7] << 8;
                    this._r[3] = (U >>> 7 | Z << 9) & 8191;
                    var $ = l[8] | l[9] << 8;
                    this._r[4] = (Z >>> 4 | $ << 12) & 255, this._r[5] = $ >>> 1 & 8190;
                    var Y = l[10] | l[11] << 8;
                    this._r[6] = ($ >>> 14 | Y << 2) & 8191;
                    var q = l[12] | l[13] << 8;
                    this._r[7] = (Y >>> 11 | q << 5) & 8065;
                    var J = l[14] | l[15] << 8;
                    this._r[8] = (q >>> 8 | J << 8) & 8191, this._r[9] = J >>> 5 & 127, this._pad[0] = l[16] | l[17] << 8, this._pad[1] = l[18] | l[19] << 8, this._pad[2] = l[20] | l[21] << 8, this._pad[3] = l[22] | l[23] << 8, this._pad[4] = l[24] | l[25] << 8, this._pad[5] = l[26] | l[27] << 8, this._pad[6] = l[28] | l[29] << 8, this._pad[7] = l[30] | l[31] << 8
                }
                return Poly1305.prototype._blocks = function(l, c, x) {
                    for (var N = this._fin ? 0 : 2048, U = this._h[0], Z = this._h[1], $ = this._h[2], Y = this._h[3], q = this._h[4], J = this._h[5], X = this._h[6], en = this._h[7], er = this._h[8], ea = this._h[9], eo = this._r[0], el = this._r[1], ec = this._r[2], eu = this._r[3], ed = this._r[4], ep = this._r[5], eh = this._r[6], ey = this._r[7], ef = this._r[8], em = this._r[9]; x >= 16;) {
                        var eg, eb = l[c + 0] | l[c + 1] << 8;
                        U += 8191 & eb;
                        var ev = l[c + 2] | l[c + 3] << 8;
                        Z += (eb >>> 13 | ev << 3) & 8191;
                        var ew = l[c + 4] | l[c + 5] << 8;
                        $ += (ev >>> 10 | ew << 6) & 8191;
                        var eT = l[c + 6] | l[c + 7] << 8;
                        Y += (ew >>> 7 | eT << 9) & 8191;
                        var eM = l[c + 8] | l[c + 9] << 8;
                        q += (eT >>> 4 | eM << 12) & 8191, J += eM >>> 1 & 8191;
                        var eI = l[c + 10] | l[c + 11] << 8;
                        X += (eM >>> 14 | eI << 2) & 8191;
                        var ex = l[c + 12] | l[c + 13] << 8;
                        en += (eI >>> 11 | ex << 5) & 8191;
                        var eC = l[c + 14] | l[c + 15] << 8;
                        er += (ex >>> 8 | eC << 8) & 8191, ea += eC >>> 5 | N;
                        var e_ = 0;
                        e_ = (eg = 0 + U * eo + Z * (5 * em) + $ * (5 * ef) + Y * (5 * ey) + q * (5 * eh)) >>> 13, eg &= 8191, eg += J * (5 * ep) + X * (5 * ed) + en * (5 * eu) + er * (5 * ec) + ea * (5 * el), e_ += eg >>> 13, eg &= 8191;
                        var eD = e_;
                        eD += U * el + Z * eo + $ * (5 * em) + Y * (5 * ef) + q * (5 * ey), e_ = eD >>> 13, eD &= 8191, eD += J * (5 * eh) + X * (5 * ep) + en * (5 * ed) + er * (5 * eu) + ea * (5 * ec), e_ += eD >>> 13, eD &= 8191;
                        var eS = e_;
                        eS += U * ec + Z * el + $ * eo + Y * (5 * em) + q * (5 * ef), e_ = eS >>> 13, eS &= 8191, eS += J * (5 * ey) + X * (5 * eh) + en * (5 * ep) + er * (5 * ed) + ea * (5 * eu), e_ += eS >>> 13, eS &= 8191;
                        var ek = e_;
                        ek += U * eu + Z * ec + $ * el + Y * eo + q * (5 * em), e_ = ek >>> 13, ek &= 8191, ek += J * (5 * ef) + X * (5 * ey) + en * (5 * eh) + er * (5 * ep) + ea * (5 * ed), e_ += ek >>> 13, ek &= 8191;
                        var eE = e_;
                        eE += U * ed + Z * eu + $ * ec + Y * el + q * eo, e_ = eE >>> 13, eE &= 8191, eE += J * (5 * em) + X * (5 * ef) + en * (5 * ey) + er * (5 * eh) + ea * (5 * ep), e_ += eE >>> 13, eE &= 8191;
                        var eN = e_;
                        eN += U * ep + Z * ed + $ * eu + Y * ec + q * el, e_ = eN >>> 13, eN &= 8191, eN += J * eo + X * (5 * em) + en * (5 * ef) + er * (5 * ey) + ea * (5 * eh), e_ += eN >>> 13, eN &= 8191;
                        var eA = e_;
                        eA += U * eh + Z * ep + $ * ed + Y * eu + q * ec, e_ = eA >>> 13, eA &= 8191, eA += J * el + X * eo + en * (5 * em) + er * (5 * ef) + ea * (5 * ey), e_ += eA >>> 13, eA &= 8191;
                        var ej = e_;
                        ej += U * ey + Z * eh + $ * ep + Y * ed + q * eu, e_ = ej >>> 13, ej &= 8191, ej += J * ec + X * el + en * eo + er * (5 * em) + ea * (5 * ef), e_ += ej >>> 13, ej &= 8191;
                        var eO = e_;
                        eO += U * ef + Z * ey + $ * eh + Y * ep + q * ed, e_ = eO >>> 13, eO &= 8191, eO += J * eu + X * ec + en * el + er * eo + ea * (5 * em), e_ += eO >>> 13, eO &= 8191;
                        var eP = e_;
                        eP += U * em + Z * ef + $ * ey + Y * eh + q * ep, e_ = eP >>> 13, eP &= 8191, eP += J * ed + X * eu + en * ec + er * el + ea * eo, e_ += eP >>> 13, eP &= 8191, eg = 8191 & (e_ = (e_ = (e_ << 2) + e_ | 0) + eg | 0), e_ >>>= 13, eD += e_, U = eg, Z = eD, $ = eS, Y = ek, q = eE, J = eN, X = eA, en = ej, er = eO, ea = eP, c += 16, x -= 16
                    }
                    this._h[0] = U, this._h[1] = Z, this._h[2] = $, this._h[3] = Y, this._h[4] = q, this._h[5] = J, this._h[6] = X, this._h[7] = en, this._h[8] = er, this._h[9] = ea
                }, Poly1305.prototype.finish = function(l, c) {
                    void 0 === c && (c = 0);
                    var x, N, U, Z, $ = new Uint16Array(10);
                    if (this._leftover) {
                        for (Z = this._leftover, this._buffer[Z++] = 1; Z < 16; Z++) this._buffer[Z] = 0;
                        this._fin = 1, this._blocks(this._buffer, 0, 16)
                    }
                    for (x = this._h[1] >>> 13, this._h[1] &= 8191, Z = 2; Z < 10; Z++) this._h[Z] += x, x = this._h[Z] >>> 13, this._h[Z] &= 8191;
                    for (this._h[0] += 5 * x, x = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += x, x = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += x, $[0] = this._h[0] + 5, x = $[0] >>> 13, $[0] &= 8191, Z = 1; Z < 10; Z++) $[Z] = this._h[Z] + x, x = $[Z] >>> 13, $[Z] &= 8191;
                    for ($[9] -= 8192, N = (1 ^ x) - 1, Z = 0; Z < 10; Z++) $[Z] &= N;
                    for (Z = 0, N = ~N; Z < 10; Z++) this._h[Z] = this._h[Z] & N | $[Z];
                    for (Z = 1, this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, U = this._h[0] + this._pad[0], this._h[0] = 65535 & U; Z < 8; Z++) U = (this._h[Z] + this._pad[Z] | 0) + (U >>> 16) | 0, this._h[Z] = 65535 & U;
                    return l[c + 0] = this._h[0] >>> 0, l[c + 1] = this._h[0] >>> 8, l[c + 2] = this._h[1] >>> 0, l[c + 3] = this._h[1] >>> 8, l[c + 4] = this._h[2] >>> 0, l[c + 5] = this._h[2] >>> 8, l[c + 6] = this._h[3] >>> 0, l[c + 7] = this._h[3] >>> 8, l[c + 8] = this._h[4] >>> 0, l[c + 9] = this._h[4] >>> 8, l[c + 10] = this._h[5] >>> 0, l[c + 11] = this._h[5] >>> 8, l[c + 12] = this._h[6] >>> 0, l[c + 13] = this._h[6] >>> 8, l[c + 14] = this._h[7] >>> 0, l[c + 15] = this._h[7] >>> 8, this._finished = !0, this
                }, Poly1305.prototype.update = function(l) {
                    var c, x = 0,
                        N = l.length;
                    if (this._leftover) {
                        (c = 16 - this._leftover) > N && (c = N);
                        for (var U = 0; U < c; U++) this._buffer[this._leftover + U] = l[x + U];
                        if (N -= c, x += c, this._leftover += c, this._leftover < 16) return this;
                        this._blocks(this._buffer, 0, 16), this._leftover = 0
                    }
                    if (N >= 16 && (c = N - N % 16, this._blocks(l, x, c), x += c, N -= c), N) {
                        for (var U = 0; U < N; U++) this._buffer[this._leftover + U] = l[x + U];
                        this._leftover += N
                    }
                    return this
                }, Poly1305.prototype.digest = function() {
                    if (this._finished) throw Error("Poly1305 was finished");
                    var l = new Uint8Array(16);
                    return this.finish(l), l
                }, Poly1305.prototype.clean = function() {
                    return U.wipe(this._buffer), U.wipe(this._r), U.wipe(this._h), U.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
                }, Poly1305
            }();
            c.Poly1305 = Z, c.oneTimeAuth = function(l, c) {
                var x = new Z(l);
                x.update(c);
                var N = x.digest();
                return x.clean(), N
            }, c.equal = function(l, x) {
                return l.length === c.DIGEST_LENGTH && x.length === c.DIGEST_LENGTH && N.equal(l, x)
            }
        },
        35077: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.randomStringForEntropy = c.randomString = c.randomUint32 = c.randomBytes = c.defaultRandomSource = void 0;
            let N = x(62739),
                U = x(34310),
                Z = x(55277);

            function randomBytes(l, x = c.defaultRandomSource) {
                return x.randomBytes(l)
            }
            c.defaultRandomSource = new N.SystemRandomSource, c.randomBytes = randomBytes, c.randomUint32 = function(l = c.defaultRandomSource) {
                let x = randomBytes(4, l),
                    N = (0, U.readUint32LE)(x);
                return (0, Z.wipe)(x), N
            };
            let $ = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

            function randomString(l, x = $, N = c.defaultRandomSource) {
                if (x.length < 2) throw Error("randomString charset is too short");
                if (x.length > 256) throw Error("randomString charset is too long");
                let U = "",
                    Y = x.length,
                    q = 256 - 256 % Y;
                for (; l > 0;) {
                    let c = randomBytes(Math.ceil(256 * l / q), N);
                    for (let N = 0; N < c.length && l > 0; N++) {
                        let Z = c[N];
                        Z < q && (U += x.charAt(Z % Y), l--)
                    }(0, Z.wipe)(c)
                }
                return U
            }
            c.randomString = randomString, c.randomStringForEntropy = function(l, x = $, N = c.defaultRandomSource) {
                let U = Math.ceil(l / (Math.log(x.length) / Math.LN2));
                return randomString(U, x, N)
            }
        },
        85183: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.BrowserRandomSource = void 0, c.BrowserRandomSource = class {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1;
                    let l = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
                    l && void 0 !== l.getRandomValues && (this._crypto = l, this.isAvailable = !0, this.isInstantiated = !0)
                }
                randomBytes(l) {
                    if (!this.isAvailable || !this._crypto) throw Error("Browser random byte generator is not available.");
                    let c = new Uint8Array(l);
                    for (let l = 0; l < c.length; l += 65536) this._crypto.getRandomValues(c.subarray(l, l + Math.min(c.length - l, 65536)));
                    return c
                }
            }
        },
        32586: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.NodeRandomSource = void 0;
            let N = x(55277);
            c.NodeRandomSource = class {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1; {
                        let l = x(35883);
                        l && l.randomBytes && (this._crypto = l, this.isAvailable = !0, this.isInstantiated = !0)
                    }
                }
                randomBytes(l) {
                    if (!this.isAvailable || !this._crypto) throw Error("Node.js random byte generator is not available.");
                    let c = this._crypto.randomBytes(l);
                    if (c.length !== l) throw Error("NodeRandomSource: got fewer bytes than requested");
                    let x = new Uint8Array(l);
                    for (let l = 0; l < x.length; l++) x[l] = c[l];
                    return (0, N.wipe)(c), x
                }
            }
        },
        62739: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.SystemRandomSource = void 0;
            let N = x(85183),
                U = x(32586);
            c.SystemRandomSource = class {
                constructor() {
                    if (this.isAvailable = !1, this.name = "", this._source = new N.BrowserRandomSource, this._source.isAvailable) {
                        this.isAvailable = !0, this.name = "Browser";
                        return
                    }
                    if (this._source = new U.NodeRandomSource, this._source.isAvailable) {
                        this.isAvailable = !0, this.name = "Node";
                        return
                    }
                }
                randomBytes(l) {
                    if (!this.isAvailable) throw Error("System random byte generator is not available.");
                    return this._source.randomBytes(l)
                }
            }
        },
        87853: function(l, c, x) {
            "use strict";
            var N = x(34310),
                U = x(55277);
            c.k = 32, c.cn = 64;
            var Z = function() {
                function SHA256() {
                    this.digestLength = c.k, this.blockSize = c.cn, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return SHA256.prototype._initState = function() {
                    this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
                }, SHA256.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, SHA256.prototype.clean = function() {
                    U.wipe(this._buffer), U.wipe(this._temp), this.reset()
                }, SHA256.prototype.update = function(l, c) {
                    if (void 0 === c && (c = l.length), this._finished) throw Error("SHA256: can't update because hash was finished.");
                    var x = 0;
                    if (this._bytesHashed += c, this._bufferLength > 0) {
                        for (; this._bufferLength < this.blockSize && c > 0;) this._buffer[this._bufferLength++] = l[x++], c--;
                        this._bufferLength === this.blockSize && (hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (c >= this.blockSize && (x = hashBlocks(this._temp, this._state, l, x, c), c %= this.blockSize); c > 0;) this._buffer[this._bufferLength++] = l[x++], c--;
                    return this
                }, SHA256.prototype.finish = function(l) {
                    if (!this._finished) {
                        var c = this._bytesHashed,
                            x = this._bufferLength,
                            U = c % 64 < 56 ? 64 : 128;
                        this._buffer[x] = 128;
                        for (var Z = x + 1; Z < U - 8; Z++) this._buffer[Z] = 0;
                        N.writeUint32BE(c / 536870912 | 0, this._buffer, U - 8), N.writeUint32BE(c << 3, this._buffer, U - 4), hashBlocks(this._temp, this._state, this._buffer, 0, U), this._finished = !0
                    }
                    for (var Z = 0; Z < this.digestLength / 4; Z++) N.writeUint32BE(this._state[Z], l, 4 * Z);
                    return this
                }, SHA256.prototype.digest = function() {
                    var l = new Uint8Array(this.digestLength);
                    return this.finish(l), l
                }, SHA256.prototype.saveState = function() {
                    if (this._finished) throw Error("SHA256: cannot save finished state");
                    return {
                        state: new Int32Array(this._state),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, SHA256.prototype.restoreState = function(l) {
                    return this._state.set(l.state), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this
                }, SHA256.prototype.cleanSavedState = function(l) {
                    U.wipe(l.state), l.buffer && U.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0
                }, SHA256
            }();
            c.mE = Z;
            var $ = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

            function hashBlocks(l, c, x, U, Z) {
                for (; Z >= 64;) {
                    for (var Y = c[0], q = c[1], J = c[2], X = c[3], en = c[4], er = c[5], ea = c[6], eo = c[7], el = 0; el < 16; el++) {
                        var ec = U + 4 * el;
                        l[el] = N.readUint32BE(x, ec)
                    }
                    for (var el = 16; el < 64; el++) {
                        var eu = l[el - 2],
                            ed = (eu >>> 17 | eu << 15) ^ (eu >>> 19 | eu << 13) ^ eu >>> 10,
                            ep = ((eu = l[el - 15]) >>> 7 | eu << 25) ^ (eu >>> 18 | eu << 14) ^ eu >>> 3;
                        l[el] = (ed + l[el - 7] | 0) + (ep + l[el - 16] | 0)
                    }
                    for (var el = 0; el < 64; el++) {
                        var ed = (((en >>> 6 | en << 26) ^ (en >>> 11 | en << 21) ^ (en >>> 25 | en << 7)) + (en & er ^ ~en & ea) | 0) + (eo + ($[el] + l[el] | 0) | 0) | 0,
                            ep = ((Y >>> 2 | Y << 30) ^ (Y >>> 13 | Y << 19) ^ (Y >>> 22 | Y << 10)) + (Y & q ^ Y & J ^ q & J) | 0;
                        eo = ea, ea = er, er = en, en = X + ed | 0, X = J, J = q, q = Y, Y = ed + ep | 0
                    }
                    c[0] += Y, c[1] += q, c[2] += J, c[3] += X, c[4] += en, c[5] += er, c[6] += ea, c[7] += eo, U += 64, Z -= 64
                }
                return U
            }
            c.vp = function(l) {
                var c = new Z;
                c.update(l);
                var x = c.digest();
                return c.clean(), x
            }
        },
        52564: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            var N = x(34310),
                U = x(55277);
            c.DIGEST_LENGTH = 64, c.BLOCK_SIZE = 128;
            var Z = function() {
                function SHA512() {
                    this.digestLength = c.DIGEST_LENGTH, this.blockSize = c.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return SHA512.prototype._initState = function() {
                    this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209
                }, SHA512.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, SHA512.prototype.clean = function() {
                    U.wipe(this._buffer), U.wipe(this._tempHi), U.wipe(this._tempLo), this.reset()
                }, SHA512.prototype.update = function(l, x) {
                    if (void 0 === x && (x = l.length), this._finished) throw Error("SHA512: can't update because hash was finished.");
                    var N = 0;
                    if (this._bytesHashed += x, this._bufferLength > 0) {
                        for (; this._bufferLength < c.BLOCK_SIZE && x > 0;) this._buffer[this._bufferLength++] = l[N++], x--;
                        this._bufferLength === this.blockSize && (hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (x >= this.blockSize && (N = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, l, N, x), x %= this.blockSize); x > 0;) this._buffer[this._bufferLength++] = l[N++], x--;
                    return this
                }, SHA512.prototype.finish = function(l) {
                    if (!this._finished) {
                        var c = this._bytesHashed,
                            x = this._bufferLength,
                            U = c % 128 < 112 ? 128 : 256;
                        this._buffer[x] = 128;
                        for (var Z = x + 1; Z < U - 8; Z++) this._buffer[Z] = 0;
                        N.writeUint32BE(c / 536870912 | 0, this._buffer, U - 8), N.writeUint32BE(c << 3, this._buffer, U - 4), hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, U), this._finished = !0
                    }
                    for (var Z = 0; Z < this.digestLength / 8; Z++) N.writeUint32BE(this._stateHi[Z], l, 8 * Z), N.writeUint32BE(this._stateLo[Z], l, 8 * Z + 4);
                    return this
                }, SHA512.prototype.digest = function() {
                    var l = new Uint8Array(this.digestLength);
                    return this.finish(l), l
                }, SHA512.prototype.saveState = function() {
                    if (this._finished) throw Error("SHA256: cannot save finished state");
                    return {
                        stateHi: new Int32Array(this._stateHi),
                        stateLo: new Int32Array(this._stateLo),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, SHA512.prototype.restoreState = function(l) {
                    return this._stateHi.set(l.stateHi), this._stateLo.set(l.stateLo), this._bufferLength = l.bufferLength, l.buffer && this._buffer.set(l.buffer), this._bytesHashed = l.bytesHashed, this._finished = !1, this
                }, SHA512.prototype.cleanSavedState = function(l) {
                    U.wipe(l.stateHi), U.wipe(l.stateLo), l.buffer && U.wipe(l.buffer), l.bufferLength = 0, l.bytesHashed = 0
                }, SHA512
            }();
            c.SHA512 = Z;
            var $ = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);

            function hashBlocks(l, c, x, U, Z, Y, q) {
                for (var J, X, en, er, ea, eo, el, ec, eu = x[0], ed = x[1], ep = x[2], eh = x[3], ey = x[4], ef = x[5], em = x[6], eg = x[7], eb = U[0], ev = U[1], ew = U[2], eT = U[3], eM = U[4], eI = U[5], ex = U[6], eC = U[7]; q >= 128;) {
                    for (var e_ = 0; e_ < 16; e_++) {
                        var eD = 8 * e_ + Y;
                        l[e_] = N.readUint32BE(Z, eD), c[e_] = N.readUint32BE(Z, eD + 4)
                    }
                    for (var e_ = 0; e_ < 80; e_++) {
                        var eS = eu,
                            ek = ed,
                            eE = ep,
                            eN = eh,
                            eA = ey,
                            ej = ef,
                            eO = em,
                            eP = eg,
                            ez = eb,
                            eR = ev,
                            eL = ew,
                            eB = eT,
                            eU = eM,
                            eF = eI,
                            eW = ex,
                            eZ = eC;
                        if (J = eg, ea = 65535 & (X = eC), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = (ey >>> 14 | eM << 18) ^ (ey >>> 18 | eM << 14) ^ (eM >>> 9 | ey << 23), ea += 65535 & (X = (eM >>> 14 | ey << 18) ^ (eM >>> 18 | ey << 14) ^ (ey >>> 9 | eM << 23)), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, J = ey & ef ^ ~ey & em, ea += 65535 & (X = eM & eI ^ ~eM & ex), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, J = $[2 * e_], ea += 65535 & (X = $[2 * e_ + 1]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, J = l[e_ % 16], ea += 65535 & (X = c[e_ % 16]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, en = 65535 & el | ec << 16, er = 65535 & ea | eo << 16, J = en, ea = 65535 & (X = er), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = (eu >>> 28 | eb << 4) ^ (eb >>> 2 | eu << 30) ^ (eb >>> 7 | eu << 25), ea += 65535 & (X = (eb >>> 28 | eu << 4) ^ (eu >>> 2 | eb << 30) ^ (eu >>> 7 | eb << 25)), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, J = eu & ed ^ eu & ep ^ ed & ep, ea += 65535 & (X = eb & ev ^ eb & ew ^ ev & ew), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, eP = 65535 & el | ec << 16, eZ = 65535 & ea | eo << 16, J = eN, ea = 65535 & (X = eB), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = en, ea += 65535 & (X = er), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, eN = 65535 & el | ec << 16, eB = 65535 & ea | eo << 16, ed = eS, ep = ek, eh = eE, ey = eN, ef = eA, em = ej, eg = eO, eu = eP, ev = ez, ew = eR, eT = eL, eM = eB, eI = eU, ex = eF, eC = eW, eb = eZ, e_ % 16 == 15)
                            for (var eD = 0; eD < 16; eD++) J = l[eD], ea = 65535 & (X = c[eD]), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = l[(eD + 9) % 16], ea += 65535 & (X = c[(eD + 9) % 16]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, J = ((en = l[(eD + 1) % 16]) >>> 1 | (er = c[(eD + 1) % 16]) << 31) ^ (en >>> 8 | er << 24) ^ en >>> 7, ea += 65535 & (X = (er >>> 1 | en << 31) ^ (er >>> 8 | en << 24) ^ (er >>> 7 | en << 25)), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, J = ((en = l[(eD + 14) % 16]) >>> 19 | (er = c[(eD + 14) % 16]) << 13) ^ (er >>> 29 | en << 3) ^ en >>> 6, ea += 65535 & (X = (er >>> 19 | en << 13) ^ (en >>> 29 | er << 3) ^ (er >>> 6 | en << 26)), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, l[eD] = 65535 & el | ec << 16, c[eD] = 65535 & ea | eo << 16
                    }
                    J = eu, ea = 65535 & (X = eb), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[0], ea += 65535 & (X = U[0]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[0] = eu = 65535 & el | ec << 16, U[0] = eb = 65535 & ea | eo << 16, J = ed, ea = 65535 & (X = ev), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[1], ea += 65535 & (X = U[1]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[1] = ed = 65535 & el | ec << 16, U[1] = ev = 65535 & ea | eo << 16, J = ep, ea = 65535 & (X = ew), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[2], ea += 65535 & (X = U[2]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[2] = ep = 65535 & el | ec << 16, U[2] = ew = 65535 & ea | eo << 16, J = eh, ea = 65535 & (X = eT), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[3], ea += 65535 & (X = U[3]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[3] = eh = 65535 & el | ec << 16, U[3] = eT = 65535 & ea | eo << 16, J = ey, ea = 65535 & (X = eM), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[4], ea += 65535 & (X = U[4]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[4] = ey = 65535 & el | ec << 16, U[4] = eM = 65535 & ea | eo << 16, J = ef, ea = 65535 & (X = eI), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[5], ea += 65535 & (X = U[5]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[5] = ef = 65535 & el | ec << 16, U[5] = eI = 65535 & ea | eo << 16, J = em, ea = 65535 & (X = ex), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[6], ea += 65535 & (X = U[6]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[6] = em = 65535 & el | ec << 16, U[6] = ex = 65535 & ea | eo << 16, J = eg, ea = 65535 & (X = eC), eo = X >>> 16, el = 65535 & J, ec = J >>> 16, J = x[7], ea += 65535 & (X = U[7]), eo += X >>> 16, el += 65535 & J, ec += J >>> 16, eo += ea >>> 16, el += eo >>> 16, ec += el >>> 16, x[7] = eg = 65535 & el | ec << 16, U[7] = eC = 65535 & ea | eo << 16, Y += 128, q -= 128
                }
                return Y
            }
            c.hash = function(l) {
                var c = new Z;
                c.update(l);
                var x = c.digest();
                return c.clean(), x
            }
        },
        55277: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.wipe = function(l) {
                for (var c = 0; c < l.length; c++) l[c] = 0;
                return l
            }
        },
        38195: function(l, c, x) {
            "use strict";
            c.gi = c.Au = c.KS = c.kz = void 0;
            let N = x(35077),
                U = x(55277);

            function gf(l) {
                let c = new Float64Array(16);
                if (l)
                    for (let x = 0; x < l.length; x++) c[x] = l[x];
                return c
            }
            c.kz = 32, c.KS = 32;
            let Z = new Uint8Array(32);
            Z[0] = 9;
            let $ = gf([56129, 1]);

            function car25519(l) {
                let c = 1;
                for (let x = 0; x < 16; x++) {
                    let N = l[x] + c + 65535;
                    c = Math.floor(N / 65536), l[x] = N - 65536 * c
                }
                l[0] += c - 1 + 37 * (c - 1)
            }

            function sel25519(l, c, x) {
                let N = ~(x - 1);
                for (let x = 0; x < 16; x++) {
                    let U = N & (l[x] ^ c[x]);
                    l[x] ^= U, c[x] ^= U
                }
            }

            function add(l, c, x) {
                for (let N = 0; N < 16; N++) l[N] = c[N] + x[N]
            }

            function sub(l, c, x) {
                for (let N = 0; N < 16; N++) l[N] = c[N] - x[N]
            }

            function mul(l, c, x) {
                let N, U, Z = 0,
                    $ = 0,
                    Y = 0,
                    q = 0,
                    J = 0,
                    X = 0,
                    en = 0,
                    er = 0,
                    ea = 0,
                    eo = 0,
                    el = 0,
                    ec = 0,
                    eu = 0,
                    ed = 0,
                    ep = 0,
                    eh = 0,
                    ey = 0,
                    ef = 0,
                    em = 0,
                    eg = 0,
                    eb = 0,
                    ev = 0,
                    ew = 0,
                    eT = 0,
                    eM = 0,
                    eI = 0,
                    ex = 0,
                    eC = 0,
                    e_ = 0,
                    eD = 0,
                    eS = 0,
                    ek = x[0],
                    eE = x[1],
                    eN = x[2],
                    eA = x[3],
                    ej = x[4],
                    eO = x[5],
                    eP = x[6],
                    ez = x[7],
                    eR = x[8],
                    eL = x[9],
                    eB = x[10],
                    eU = x[11],
                    eF = x[12],
                    eW = x[13],
                    eZ = x[14],
                    eQ = x[15];
                Z += (N = c[0]) * ek, $ += N * eE, Y += N * eN, q += N * eA, J += N * ej, X += N * eO, en += N * eP, er += N * ez, ea += N * eR, eo += N * eL, el += N * eB, ec += N * eU, eu += N * eF, ed += N * eW, ep += N * eZ, eh += N * eQ, $ += (N = c[1]) * ek, Y += N * eE, q += N * eN, J += N * eA, X += N * ej, en += N * eO, er += N * eP, ea += N * ez, eo += N * eR, el += N * eL, ec += N * eB, eu += N * eU, ed += N * eF, ep += N * eW, eh += N * eZ, ey += N * eQ, Y += (N = c[2]) * ek, q += N * eE, J += N * eN, X += N * eA, en += N * ej, er += N * eO, ea += N * eP, eo += N * ez, el += N * eR, ec += N * eL, eu += N * eB, ed += N * eU, ep += N * eF, eh += N * eW, ey += N * eZ, ef += N * eQ, q += (N = c[3]) * ek, J += N * eE, X += N * eN, en += N * eA, er += N * ej, ea += N * eO, eo += N * eP, el += N * ez, ec += N * eR, eu += N * eL, ed += N * eB, ep += N * eU, eh += N * eF, ey += N * eW, ef += N * eZ, em += N * eQ, J += (N = c[4]) * ek, X += N * eE, en += N * eN, er += N * eA, ea += N * ej, eo += N * eO, el += N * eP, ec += N * ez, eu += N * eR, ed += N * eL, ep += N * eB, eh += N * eU, ey += N * eF, ef += N * eW, em += N * eZ, eg += N * eQ, X += (N = c[5]) * ek, en += N * eE, er += N * eN, ea += N * eA, eo += N * ej, el += N * eO, ec += N * eP, eu += N * ez, ed += N * eR, ep += N * eL, eh += N * eB, ey += N * eU, ef += N * eF, em += N * eW, eg += N * eZ, eb += N * eQ, en += (N = c[6]) * ek, er += N * eE, ea += N * eN, eo += N * eA, el += N * ej, ec += N * eO, eu += N * eP, ed += N * ez, ep += N * eR, eh += N * eL, ey += N * eB, ef += N * eU, em += N * eF, eg += N * eW, eb += N * eZ, ev += N * eQ, er += (N = c[7]) * ek, ea += N * eE, eo += N * eN, el += N * eA, ec += N * ej, eu += N * eO, ed += N * eP, ep += N * ez, eh += N * eR, ey += N * eL, ef += N * eB, em += N * eU, eg += N * eF, eb += N * eW, ev += N * eZ, ew += N * eQ, ea += (N = c[8]) * ek, eo += N * eE, el += N * eN, ec += N * eA, eu += N * ej, ed += N * eO, ep += N * eP, eh += N * ez, ey += N * eR, ef += N * eL, em += N * eB, eg += N * eU, eb += N * eF, ev += N * eW, ew += N * eZ, eT += N * eQ, eo += (N = c[9]) * ek, el += N * eE, ec += N * eN, eu += N * eA, ed += N * ej, ep += N * eO, eh += N * eP, ey += N * ez, ef += N * eR, em += N * eL, eg += N * eB, eb += N * eU, ev += N * eF, ew += N * eW, eT += N * eZ, eM += N * eQ, el += (N = c[10]) * ek, ec += N * eE, eu += N * eN, ed += N * eA, ep += N * ej, eh += N * eO, ey += N * eP, ef += N * ez, em += N * eR, eg += N * eL, eb += N * eB, ev += N * eU, ew += N * eF, eT += N * eW, eM += N * eZ, eI += N * eQ, ec += (N = c[11]) * ek, eu += N * eE, ed += N * eN, ep += N * eA, eh += N * ej, ey += N * eO, ef += N * eP, em += N * ez, eg += N * eR, eb += N * eL, ev += N * eB, ew += N * eU, eT += N * eF, eM += N * eW, eI += N * eZ, ex += N * eQ, eu += (N = c[12]) * ek, ed += N * eE, ep += N * eN, eh += N * eA, ey += N * ej, ef += N * eO, em += N * eP, eg += N * ez, eb += N * eR, ev += N * eL, ew += N * eB, eT += N * eU, eM += N * eF, eI += N * eW, ex += N * eZ, eC += N * eQ, ed += (N = c[13]) * ek, ep += N * eE, eh += N * eN, ey += N * eA, ef += N * ej, em += N * eO, eg += N * eP, eb += N * ez, ev += N * eR, ew += N * eL, eT += N * eB, eM += N * eU, eI += N * eF, ex += N * eW, eC += N * eZ, e_ += N * eQ, ep += (N = c[14]) * ek, eh += N * eE, ey += N * eN, ef += N * eA, em += N * ej, eg += N * eO, eb += N * eP, ev += N * ez, ew += N * eR, eT += N * eL, eM += N * eB, eI += N * eU, ex += N * eF, eC += N * eW, e_ += N * eZ, eD += N * eQ, eh += (N = c[15]) * ek, ey += N * eE, ef += N * eN, em += N * eA, eg += N * ej, eb += N * eO, ev += N * eP, ew += N * ez, eT += N * eR, eM += N * eL, eI += N * eB, ex += N * eU, eC += N * eF, e_ += N * eW, eD += N * eZ, eS += N * eQ, Z += 38 * ey, $ += 38 * ef, Y += 38 * em, q += 38 * eg, J += 38 * eb, X += 38 * ev, en += 38 * ew, er += 38 * eT, ea += 38 * eM, eo += 38 * eI, el += 38 * ex, ec += 38 * eC, eu += 38 * e_, ed += 38 * eD, ep += 38 * eS, U = Math.floor((N = Z + (U = 1) + 65535) / 65536), Z = N - 65536 * U, U = Math.floor((N = $ + U + 65535) / 65536), $ = N - 65536 * U, U = Math.floor((N = Y + U + 65535) / 65536), Y = N - 65536 * U, U = Math.floor((N = q + U + 65535) / 65536), q = N - 65536 * U, U = Math.floor((N = J + U + 65535) / 65536), J = N - 65536 * U, U = Math.floor((N = X + U + 65535) / 65536), X = N - 65536 * U, U = Math.floor((N = en + U + 65535) / 65536), en = N - 65536 * U, U = Math.floor((N = er + U + 65535) / 65536), er = N - 65536 * U, U = Math.floor((N = ea + U + 65535) / 65536), ea = N - 65536 * U, U = Math.floor((N = eo + U + 65535) / 65536), eo = N - 65536 * U, U = Math.floor((N = el + U + 65535) / 65536), el = N - 65536 * U, U = Math.floor((N = ec + U + 65535) / 65536), ec = N - 65536 * U, U = Math.floor((N = eu + U + 65535) / 65536), eu = N - 65536 * U, U = Math.floor((N = ed + U + 65535) / 65536), ed = N - 65536 * U, U = Math.floor((N = ep + U + 65535) / 65536), ep = N - 65536 * U, U = Math.floor((N = eh + U + 65535) / 65536), eh = N - 65536 * U, Z += U - 1 + 37 * (U - 1), U = Math.floor((N = Z + (U = 1) + 65535) / 65536), Z = N - 65536 * U, U = Math.floor((N = $ + U + 65535) / 65536), $ = N - 65536 * U, U = Math.floor((N = Y + U + 65535) / 65536), Y = N - 65536 * U, U = Math.floor((N = q + U + 65535) / 65536), q = N - 65536 * U, U = Math.floor((N = J + U + 65535) / 65536), J = N - 65536 * U, U = Math.floor((N = X + U + 65535) / 65536), X = N - 65536 * U, U = Math.floor((N = en + U + 65535) / 65536), en = N - 65536 * U, U = Math.floor((N = er + U + 65535) / 65536), er = N - 65536 * U, U = Math.floor((N = ea + U + 65535) / 65536), ea = N - 65536 * U, U = Math.floor((N = eo + U + 65535) / 65536), eo = N - 65536 * U, U = Math.floor((N = el + U + 65535) / 65536), el = N - 65536 * U, U = Math.floor((N = ec + U + 65535) / 65536), ec = N - 65536 * U, U = Math.floor((N = eu + U + 65535) / 65536), eu = N - 65536 * U, U = Math.floor((N = ed + U + 65535) / 65536), ed = N - 65536 * U, U = Math.floor((N = ep + U + 65535) / 65536), ep = N - 65536 * U, U = Math.floor((N = eh + U + 65535) / 65536), eh = N - 65536 * U, Z += U - 1 + 37 * (U - 1), l[0] = Z, l[1] = $, l[2] = Y, l[3] = q, l[4] = J, l[5] = X, l[6] = en, l[7] = er, l[8] = ea, l[9] = eo, l[10] = el, l[11] = ec, l[12] = eu, l[13] = ed, l[14] = ep, l[15] = eh
            }

            function scalarMult(l, c) {
                let x = new Uint8Array(32),
                    N = new Float64Array(80),
                    U = gf(),
                    Z = gf(),
                    Y = gf(),
                    q = gf(),
                    J = gf(),
                    X = gf();
                for (let c = 0; c < 31; c++) x[c] = l[c];
                x[31] = 127 & l[31] | 64, x[0] &= 248,
                    function(l, c) {
                        for (let x = 0; x < 16; x++) l[x] = c[2 * x] + (c[2 * x + 1] << 8);
                        l[15] &= 32767
                    }(N, c);
                for (let l = 0; l < 16; l++) Z[l] = N[l];
                U[0] = q[0] = 1;
                for (let l = 254; l >= 0; --l) {
                    let c = x[l >>> 3] >>> (7 & l) & 1;
                    sel25519(U, Z, c), sel25519(Y, q, c), add(J, U, Y), sub(U, U, Y), add(Y, Z, q), sub(Z, Z, q), mul(q, J, J), mul(X, U, U), mul(U, Y, U), mul(Y, Z, J), add(J, U, Y), sub(U, U, Y), mul(Z, U, U), sub(Y, q, X), mul(U, Y, $), add(U, U, q), mul(Y, Y, U), mul(U, q, X), mul(q, Z, N), mul(Z, J, J), sel25519(U, Z, c), sel25519(Y, q, c)
                }
                for (let l = 0; l < 16; l++) N[l + 16] = U[l], N[l + 32] = Y[l], N[l + 48] = Z[l], N[l + 64] = q[l];
                let en = N.subarray(32),
                    er = N.subarray(16);
                ! function(l, c) {
                    let x = gf();
                    for (let l = 0; l < 16; l++) x[l] = c[l];
                    for (let l = 253; l >= 0; l--) mul(x, x, x), 2 !== l && 4 !== l && mul(x, x, c);
                    for (let c = 0; c < 16; c++) l[c] = x[c]
                }(en, en), mul(er, er, en);
                let ea = new Uint8Array(32);
                return ! function(l, c) {
                    let x = gf(),
                        N = gf();
                    for (let l = 0; l < 16; l++) N[l] = c[l];
                    car25519(N), car25519(N), car25519(N);
                    for (let l = 0; l < 2; l++) {
                        x[0] = N[0] - 65517;
                        for (let l = 1; l < 15; l++) x[l] = N[l] - 65535 - (x[l - 1] >> 16 & 1), x[l - 1] &= 65535;
                        x[15] = N[15] - 32767 - (x[14] >> 16 & 1);
                        let l = x[15] >> 16 & 1;
                        x[14] &= 65535, sel25519(N, x, 1 - l)
                    }
                    for (let c = 0; c < 16; c++) l[2 * c] = 255 & N[c], l[2 * c + 1] = N[c] >> 8
                }(ea, er), ea
            }
            c.Au = function(l) {
                let x = (0, N.randomBytes)(32, l),
                    $ = function(l) {
                        if (l.length !== c.KS) throw Error(`x25519: seed must be ${c.KS} bytes`);
                        let x = new Uint8Array(l),
                            N = scalarMult(x, Z);
                        return {
                            publicKey: N,
                            secretKey: x
                        }
                    }(x);
                return (0, U.wipe)(x), $
            }, c.gi = function(l, x, N = !1) {
                if (l.length !== c.kz) throw Error("X25519: incorrect secret key length");
                if (x.length !== c.kz) throw Error("X25519: incorrect public key length");
                let U = scalarMult(l, x);
                if (N) {
                    let l = 0;
                    for (let c = 0; c < U.length; c++) l |= U[c];
                    if (0 === l) throw Error("X25519: invalid shared key")
                }
                return U
            }
        },
        55026: function(l, c, x) {
            "use strict";
            x.d(c, {
                T: function() {
                    return ThirdwebAuth
                },
                s: function() {
                    return signLoginPayload
                }
            });
            var N = x(74578),
                U = x(51872),
                Z = x(18994);
            let $ = N.z.union([N.z.string(), N.z.number(), N.z.boolean(), N.z.null()]),
                Y = N.z.lazy(() => N.z.union([$, N.z.array(Y), N.z.record(Y)]), {
                    invalid_type_error: "Provided value was not valid JSON"
                }),
                q = N.z.string().refine(l => Z.isAddress(l), l => ({
                    message: `${l} is not a valid address`
                })),
                J = N.z.date().transform(l => Math.floor(l.getTime() / 1e3)),
                X = N.z.union([N.z.literal("evm"), N.z.literal("solana")]),
                en = N.z.object({
                    iss: N.z.string(),
                    sub: N.z.string(),
                    aud: N.z.string(),
                    exp: J,
                    nbf: J,
                    iat: J,
                    jti: N.z.string().default((0, U.Z)()),
                    ctx: Y.optional()
                });
            N.z.object({
                payload: en,
                signature: N.z.string()
            });
            let er = N.z.object({
                    domain: N.z.string(),
                    issuerAddress: q.optional(),
                    validateTokenId: N.z.function().args(N.z.string()).optional()
                }),
                ea = N.z.object({
                    domain: N.z.string(),
                    statement: N.z.string().optional(),
                    uri: N.z.string().optional(),
                    version: N.z.string().optional(),
                    chainId: N.z.string().optional(),
                    validateNonce: N.z.function().args(N.z.string()).optional(),
                    resources: N.z.array(N.z.string()).optional()
                }),
                eo = N.z.object({
                    domain: N.z.string(),
                    tokenId: N.z.string().optional(),
                    expirationTime: N.z.date().default(() => new Date(Date.now() + 864e5)),
                    invalidBefore: N.z.date().optional(),
                    session: N.z.union([Y, N.z.function().args(N.z.string())]).optional(),
                    verifyOptions: ea.omit({
                        domain: !0
                    }).optional()
                }),
                el = N.z.object({
                    expirationTime: N.z.date().default(() => new Date(Date.now() + 864e5))
                }),
                ec = N.z.object({
                    domain: N.z.string(),
                    address: N.z.string().optional(),
                    statement: N.z.string().optional(),
                    uri: N.z.string().optional(),
                    version: N.z.string().optional(),
                    chainId: N.z.string().optional(),
                    nonce: N.z.string().optional(),
                    expirationTime: N.z.date().default(() => new Date(Date.now() + 6e5)),
                    invalidBefore: N.z.date().default(() => new Date(Date.now() - 6e5)),
                    resources: N.z.array(N.z.string()).optional()
                }),
                eu = N.z.object({
                    type: X,
                    domain: N.z.string(),
                    address: N.z.string(),
                    statement: N.z.string().default("Please ensure that the domain above matches the URL of the current website."),
                    uri: N.z.string().optional(),
                    version: N.z.string().default("1"),
                    chain_id: N.z.string().optional(),
                    nonce: N.z.string().default((0, U.Z)()),
                    issued_at: N.z.date().default(new Date).transform(l => l.toISOString()),
                    expiration_time: N.z.date().transform(l => l.toISOString()),
                    invalid_before: N.z.date().default(new Date).transform(l => l.toISOString()),
                    resources: N.z.array(N.z.string()).optional()
                }),
                ed = N.z.object({
                    payload: eu,
                    signature: N.z.string()
                });

            function createLoginMessage(l) {
                let c = "evm" === l.type ? "Ethereum" : "Solana",
                    x = `${l.domain} wants you to sign in with your ${c} account:`,
                    N = [x, l.address].join("\n");
                N = [N, l.statement].join("\n\n"), l.statement && (N += "\n");
                let U = [];
                if (l.uri) {
                    let c = `URI: ${l.uri}`;
                    U.push(c)
                }
                let Z = `Version: ${l.version}`;
                if (U.push(Z), l.chain_id) {
                    let c = "Chain ID: " + l.chain_id;
                    U.push(c)
                }
                let $ = `Nonce: ${l.nonce}`;
                U.push($);
                let Y = `Issued At: ${l.issued_at}`;
                U.push(Y);
                let q = `Expiration Time: ${l.expiration_time}`;
                if (U.push(q), l.invalid_before) {
                    let c = `Not Before: ${l.invalid_before}`;
                    U.push(c)
                }
                l.resources && U.push(["Resources:", ...l.resources.map(l => `- ${l}`)].join("\n"));
                let J = U.join("\n");
                return [N, J].join("\n")
            }
            async function buildLoginPayload(l) {
                let {
                    wallet: c,
                    options: x
                } = l, N = ec.parse(x), U = N ? .chainId;
                if (!U && c.getChainId) try {
                    U = (await c.getChainId()).toString()
                } catch {}
                return eu.parse({
                    type: c.type,
                    domain: N.domain,
                    address: N ? .address || await c.getAddress(),
                    statement: N ? .statement,
                    version: N ? .version,
                    uri: N ? .uri,
                    chain_id: U,
                    nonce: N ? .nonce,
                    expiration_time: N.expirationTime,
                    invalid_before: N.invalidBefore,
                    resources: N ? .resources
                })
            }
            async function signLoginPayload(l) {
                let {
                    wallet: c,
                    payload: x
                } = l, N = createLoginMessage(x), U = await c.signMessage(N);
                return {
                    payload: x,
                    signature: U
                }
            }
            async function buildAndSignLoginPayload(l) {
                let {
                    wallet: c,
                    options: x
                } = l, N = await buildLoginPayload({
                    wallet: c,
                    options: x
                });
                return signLoginPayload({
                    wallet: c,
                    payload: N
                })
            }
            async function verifyLoginPayload(l) {
                let {
                    wallet: c,
                    payload: x,
                    options: N
                } = l, U = ea.parse(N);
                if (x.payload.type !== c.type) throw Error(`Expected chain type '${c.type}' does not match chain type on payload '${x.payload.type}'`);
                if (x.payload.domain !== U.domain) throw Error(`Expected domain '${U.domain}' does not match domain on payload '${x.payload.domain}'`);
                if (U ? .statement && x.payload.statement !== U.statement) throw Error(`Expected statement '${U.statement}' does not match statement on payload '${x.payload.statement}'`);
                if (U ? .uri && x.payload.uri !== U.uri) throw Error(`Expected URI '${U.uri}' does not match URI on payload '${x.payload.uri}'`);
                if (U ? .version && x.payload.version !== U.version) throw Error(`Expected version '${U.version}' does not match version on payload '${x.payload.version}'`);
                if (U ? .chainId && x.payload.chain_id !== U.chainId) throw Error(`Expected chain ID '${U.chainId}' does not match chain ID on payload '${x.payload.chain_id}'`);
                if (U ? .validateNonce !== void 0) try {
                    await U.validateNonce(x.payload.nonce)
                } catch (l) {
                    throw Error("Login request nonce is invalid")
                }
                let Z = new Date;
                if (Z < new Date(x.payload.invalid_before)) throw Error("Login request is not yet valid");
                if (Z > new Date(x.payload.expiration_time)) throw Error("Login request has expired");
                if (U ? .resources) {
                    let l = U.resources.filter(l => !x.payload.resources ? .includes(l));
                    if (l.length > 0) throw Error(`Login request is missing required resources: ${l.join(", ")}`)
                }
                let $ = createLoginMessage(x.payload),
                    Y = "evm" === c.type && x.payload.chain_id ? parseInt(x.payload.chain_id) : void 0,
                    q = await c.verifySignature($, x.signature, x.payload.address, Y);
                if (!q) throw Error(`Signer address does not match payload address '${x.payload.address.toLowerCase()}'`);
                return x.payload.address
            }

            function base64encode(l) {
                return window.btoa(l)
            }

            function base64decode(l) {
                return window.atob(l)
            }
            async function buildJWT(l) {
                let {
                    wallet: c,
                    payload: x
                } = l, N = en.parse(x), U = JSON.stringify(N), Z = await c.signMessage(U), $ = base64encode(JSON.stringify({
                    alg: "ES256",
                    typ: "JWT"
                })), Y = base64encode(JSON.stringify(N)), q = base64encode(Z), J = `${$}.${Y}.${q}`;
                return J
            }
            async function generateJWT(l) {
                let c, {
                        wallet: x,
                        payload: N,
                        options: U
                    } = l,
                    Z = eo.parse(U),
                    $ = await verifyLoginPayload({
                        wallet: x,
                        payload: N,
                        options: {
                            domain: Z.domain,
                            ...Z.verifyOptions
                        }
                    });
                if ("function" == typeof Z ? .session) {
                    let l = await Z.session($);
                    l && (c = l)
                } else c = Z ? .session;
                let Y = await x.getAddress();
                return buildJWT({
                    wallet: x,
                    payload: {
                        iss: Y,
                        sub: $,
                        aud: Z.domain,
                        nbf: Z ? .invalidBefore || new Date,
                        exp: Z.expirationTime,
                        iat: new Date,
                        jti: Z ? .tokenId,
                        ctx: c
                    }
                })
            }

            function parseJWT(l) {
                let c = l.split(".")[1],
                    x = l.split(".")[2],
                    N = JSON.parse(base64decode(c)),
                    U = base64decode(x);
                return {
                    payload: N,
                    signature: U
                }
            }
            async function refreshJWT(l) {
                let {
                    wallet: c,
                    jwt: x,
                    options: N
                } = l, {
                    payload: U
                } = parseJWT(x), Z = el.parse(N);
                return buildJWT({
                    wallet: c,
                    payload: {
                        iss: U.iss,
                        sub: U.sub,
                        aud: U.aud,
                        nbf: new Date,
                        exp: Z.expirationTime,
                        iat: new Date,
                        ctx: U.ctx
                    }
                })
            }
            async function authenticateJWT(l) {
                let c, {
                        wallet: x,
                        jwt: N,
                        options: U
                    } = l,
                    Z = er.parse(U),
                    {
                        payload: $,
                        signature: Y
                    } = parseJWT(N);
                if (Z ? .validateTokenId !== void 0) try {
                    await Z.validateTokenId($.jti)
                } catch (l) {
                    throw Error("Token ID is invalid")
                }
                if ($.aud !== Z.domain) throw Error(`Expected token to be for the domain '${Z.domain}', but found token with domain '${$.aud}'`);
                let q = Math.floor(new Date().getTime() / 1e3);
                if (q < $.nbf) throw Error(`This token is invalid before epoch time '${$.nbf}', current epoch time is '${q}'`);
                if (q > $.exp) throw Error(`This token expired at epoch time '${$.exp}', current epoch time is '${q}'`);
                let J = Z.issuerAddress ? Z.issuerAddress : await x.getAddress();
                if (J.toLowerCase() !== $.iss.toLowerCase()) throw Error(`The expected issuer address '${J}' did not match the token issuer address '${$.iss}'`);
                if (x.getChainId) try {
                    c = await x.getChainId()
                } catch {}
                let X = await x.verifySignature(JSON.stringify($), Y, J, c);
                if (!X) throw Error(`The expected signer address '${J}' did not sign the token`);
                return {
                    address: $.sub,
                    session: $.ctx
                }
            }
            ed.extend({
                payload: eu.extend({
                    issued_at: N.z.string(),
                    expiration_time: N.z.string(),
                    invalid_before: N.z.string()
                })
            });
            let ThirdwebAuth = class ThirdwebAuth {
                constructor(l, c) {
                    this.wallet = l, this.domain = c
                }
                updateWallet(l) {
                    this.wallet = l
                }
                async payload(l) {
                    return buildLoginPayload({
                        wallet: this.wallet,
                        options: this.formatOptions(l)
                    })
                }
                async loginWithPayload(l) {
                    return signLoginPayload({
                        wallet: this.wallet,
                        payload: l
                    })
                }
                async login(l) {
                    return buildAndSignLoginPayload({
                        wallet: this.wallet,
                        options: this.formatOptions(l)
                    })
                }
                async verify(l, c) {
                    return verifyLoginPayload({
                        wallet: this.wallet,
                        payload: l,
                        options: this.formatOptions(c)
                    })
                }
                async generate(l, c) {
                    return generateJWT({
                        wallet: this.wallet,
                        payload: l,
                        options: this.formatOptions(c)
                    })
                }
                async refresh(l, c) {
                    return refreshJWT({
                        wallet: this.wallet,
                        jwt: l,
                        options: {
                            expirationTime: c
                        }
                    })
                }
                async authenticate(l, c) {
                    return authenticateJWT({
                        wallet: this.wallet,
                        jwt: l,
                        options: this.formatOptions(c)
                    })
                }
                parseToken(l) {
                    return parseJWT(l)
                }
                formatOptions(l) {
                    return l ? { ...l,
                        domain: l ? .domain || this.domain
                    } : {
                        domain: this.domain
                    }
                }
            }
        },
        42840: function(l, c, x) {
            "use strict";
            x.d(c, {
                Z: function() {
                    return N
                }
            });
            let N = {}
        },
        1361: function(l, c, x) {
            "use strict";
            x.d(c, {
                Q: function() {
                    return QueryClientProviderWithDefault
                },
                n: function() {
                    return neverPersist
                },
                r: function() {
                    return requiredParamInvariant
                }
            });
            var N = x(46504),
                U = x(58810),
                Z = x(17156),
                $ = x(43238),
                Y = x(11909);
            let Query = class Query extends Y.F {
                constructor(l) {
                    super(), this.abortSignalConsumed = !1, this.defaultOptions = l.defaultOptions, this.setOptions(l.options), this.observers = [], this.cache = l.cache, this.logger = l.logger || U._, this.queryKey = l.queryKey, this.queryHash = l.queryHash, this.initialState = l.state || function(l) {
                        let c = "function" == typeof l.initialData ? l.initialData() : l.initialData,
                            x = void 0 !== c,
                            N = x ? "function" == typeof l.initialDataUpdatedAt ? l.initialDataUpdatedAt() : l.initialDataUpdatedAt : 0;
                        return {
                            data: c,
                            dataUpdateCount: 0,
                            dataUpdatedAt: x ? null != N ? N : Date.now() : 0,
                            error: null,
                            errorUpdateCount: 0,
                            errorUpdatedAt: 0,
                            fetchFailureCount: 0,
                            fetchFailureReason: null,
                            fetchMeta: null,
                            isInvalidated: !1,
                            status: x ? "success" : "loading",
                            fetchStatus: "idle"
                        }
                    }(this.options), this.state = this.initialState, this.scheduleGc()
                }
                get meta() {
                    return this.options.meta
                }
                setOptions(l) {
                    this.options = { ...this.defaultOptions,
                        ...l
                    }, this.updateCacheTime(this.options.cacheTime)
                }
                optionalRemove() {
                    this.observers.length || "idle" !== this.state.fetchStatus || this.cache.remove(this)
                }
                setData(l, c) {
                    let x = (0, N.oE)(this.state.data, l, this.options);
                    return this.dispatch({
                        data: x,
                        type: "success",
                        dataUpdatedAt: null == c ? void 0 : c.updatedAt,
                        manual: null == c ? void 0 : c.manual
                    }), x
                }
                setState(l, c) {
                    this.dispatch({
                        type: "setState",
                        state: l,
                        setStateOptions: c
                    })
                }
                cancel(l) {
                    var c;
                    let x = this.promise;
                    return null == (c = this.retryer) || c.cancel(l), x ? x.then(N.ZT).catch(N.ZT) : Promise.resolve()
                }
                destroy() {
                    super.destroy(), this.cancel({
                        silent: !0
                    })
                }
                reset() {
                    this.destroy(), this.setState(this.initialState)
                }
                isActive() {
                    return this.observers.some(l => !1 !== l.options.enabled)
                }
                isDisabled() {
                    return this.getObserversCount() > 0 && !this.isActive()
                }
                isStale() {
                    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(l => l.getCurrentResult().isStale)
                }
                isStaleByTime(l = 0) {
                    return this.state.isInvalidated || !this.state.dataUpdatedAt || !(0, N.Kp)(this.state.dataUpdatedAt, l)
                }
                onFocus() {
                    var l;
                    let c = this.observers.find(l => l.shouldFetchOnWindowFocus());
                    c && c.refetch({
                        cancelRefetch: !1
                    }), null == (l = this.retryer) || l.continue()
                }
                onOnline() {
                    var l;
                    let c = this.observers.find(l => l.shouldFetchOnReconnect());
                    c && c.refetch({
                        cancelRefetch: !1
                    }), null == (l = this.retryer) || l.continue()
                }
                addObserver(l) {
                    this.observers.includes(l) || (this.observers.push(l), this.clearGcTimeout(), this.cache.notify({
                        type: "observerAdded",
                        query: this,
                        observer: l
                    }))
                }
                removeObserver(l) {
                    this.observers.includes(l) && (this.observers = this.observers.filter(c => c !== l), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
                        revert: !0
                    }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({
                        type: "observerRemoved",
                        query: this,
                        observer: l
                    }))
                }
                getObserversCount() {
                    return this.observers.length
                }
                invalidate() {
                    this.state.isInvalidated || this.dispatch({
                        type: "invalidate"
                    })
                }
                fetch(l, c) {
                    var x, U, Z, Y;
                    if ("idle" !== this.state.fetchStatus) {
                        if (this.state.dataUpdatedAt && null != c && c.cancelRefetch) this.cancel({
                            silent: !0
                        });
                        else if (this.promise) return null == (Z = this.retryer) || Z.continueRetry(), this.promise
                    }
                    if (l && this.setOptions(l), !this.options.queryFn) {
                        let l = this.observers.find(l => l.options.queryFn);
                        l && this.setOptions(l.options)
                    }
                    let q = (0, N.G9)(),
                        J = {
                            queryKey: this.queryKey,
                            pageParam: void 0,
                            meta: this.meta
                        },
                        addSignalProperty = l => {
                            Object.defineProperty(l, "signal", {
                                enumerable: !0,
                                get: () => {
                                    if (q) return this.abortSignalConsumed = !0, q.signal
                                }
                            })
                        };
                    addSignalProperty(J);
                    let X = {
                        fetchOptions: c,
                        options: this.options,
                        queryKey: this.queryKey,
                        state: this.state,
                        fetchFn: () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(J)) : Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'")
                    };
                    addSignalProperty(X), null == (x = this.options.behavior) || x.onFetch(X), this.revertState = this.state, ("idle" === this.state.fetchStatus || this.state.fetchMeta !== (null == (U = X.fetchOptions) ? void 0 : U.meta)) && this.dispatch({
                        type: "fetch",
                        meta: null == (Y = X.fetchOptions) ? void 0 : Y.meta
                    });
                    let onError = l => {
                        if ((0, $.DV)(l) && l.silent || this.dispatch({
                                type: "error",
                                error: l
                            }), !(0, $.DV)(l)) {
                            var c, x, N, U;
                            null == (c = (x = this.cache.config).onError) || c.call(x, l, this), null == (N = (U = this.cache.config).onSettled) || N.call(U, this.state.data, l, this)
                        }
                        this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
                    };
                    return this.retryer = (0, $.Mz)({
                        fn: X.fetchFn,
                        abort: null == q ? void 0 : q.abort.bind(q),
                        onSuccess: l => {
                            var c, x, N, U;
                            if (void 0 === l) {
                                onError(Error(this.queryHash + " data is undefined"));
                                return
                            }
                            this.setData(l), null == (c = (x = this.cache.config).onSuccess) || c.call(x, l, this), null == (N = (U = this.cache.config).onSettled) || N.call(U, l, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
                        },
                        onError,
                        onFail: (l, c) => {
                            this.dispatch({
                                type: "failed",
                                failureCount: l,
                                error: c
                            })
                        },
                        onPause: () => {
                            this.dispatch({
                                type: "pause"
                            })
                        },
                        onContinue: () => {
                            this.dispatch({
                                type: "continue"
                            })
                        },
                        retry: X.options.retry,
                        retryDelay: X.options.retryDelay,
                        networkMode: X.options.networkMode
                    }), this.promise = this.retryer.promise, this.promise
                }
                dispatch(l) {
                    this.state = (c => {
                        var x, N;
                        switch (l.type) {
                            case "failed":
                                return { ...c,
                                    fetchFailureCount: l.failureCount,
                                    fetchFailureReason: l.error
                                };
                            case "pause":
                                return { ...c,
                                    fetchStatus: "paused"
                                };
                            case "continue":
                                return { ...c,
                                    fetchStatus: "fetching"
                                };
                            case "fetch":
                                return { ...c,
                                    fetchFailureCount: 0,
                                    fetchFailureReason: null,
                                    fetchMeta: null != (x = l.meta) ? x : null,
                                    fetchStatus: (0, $.Kw)(this.options.networkMode) ? "fetching" : "paused",
                                    ...!c.dataUpdatedAt && {
                                        error: null,
                                        status: "loading"
                                    }
                                };
                            case "success":
                                return { ...c,
                                    data: l.data,
                                    dataUpdateCount: c.dataUpdateCount + 1,
                                    dataUpdatedAt: null != (N = l.dataUpdatedAt) ? N : Date.now(),
                                    error: null,
                                    isInvalidated: !1,
                                    status: "success",
                                    ...!l.manual && {
                                        fetchStatus: "idle",
                                        fetchFailureCount: 0,
                                        fetchFailureReason: null
                                    }
                                };
                            case "error":
                                let U = l.error;
                                if ((0, $.DV)(U) && U.revert && this.revertState) return { ...this.revertState,
                                    fetchStatus: "idle"
                                };
                                return { ...c,
                                    error: U,
                                    errorUpdateCount: c.errorUpdateCount + 1,
                                    errorUpdatedAt: Date.now(),
                                    fetchFailureCount: c.fetchFailureCount + 1,
                                    fetchFailureReason: U,
                                    fetchStatus: "idle",
                                    status: "error"
                                };
                            case "invalidate":
                                return { ...c,
                                    isInvalidated: !0
                                };
                            case "setState":
                                return { ...c,
                                    ...l.state
                                }
                        }
                    })(this.state), Z.V.batch(() => {
                        this.observers.forEach(c => {
                            c.onQueryUpdate(l)
                        }), this.cache.notify({
                            query: this,
                            type: "updated",
                            action: l
                        })
                    })
                }
            };
            var q = x(29492);
            let QueryCache = class QueryCache extends q.l {
                constructor(l) {
                    super(), this.config = l || {}, this.queries = [], this.queriesMap = {}
                }
                build(l, c, x) {
                    var U;
                    let Z = c.queryKey,
                        $ = null != (U = c.queryHash) ? U : (0, N.Rm)(Z, c),
                        Y = this.get($);
                    return Y || (Y = new Query({
                        cache: this,
                        logger: l.getLogger(),
                        queryKey: Z,
                        queryHash: $,
                        options: l.defaultQueryOptions(c),
                        state: x,
                        defaultOptions: l.getQueryDefaults(Z)
                    }), this.add(Y)), Y
                }
                add(l) {
                    this.queriesMap[l.queryHash] || (this.queriesMap[l.queryHash] = l, this.queries.push(l), this.notify({
                        type: "added",
                        query: l
                    }))
                }
                remove(l) {
                    let c = this.queriesMap[l.queryHash];
                    c && (l.destroy(), this.queries = this.queries.filter(c => c !== l), c === l && delete this.queriesMap[l.queryHash], this.notify({
                        type: "removed",
                        query: l
                    }))
                }
                clear() {
                    Z.V.batch(() => {
                        this.queries.forEach(l => {
                            this.remove(l)
                        })
                    })
                }
                get(l) {
                    return this.queriesMap[l]
                }
                getAll() {
                    return this.queries
                }
                find(l, c) {
                    let [x] = (0, N.I6)(l, c);
                    return void 0 === x.exact && (x.exact = !0), this.queries.find(l => (0, N._x)(x, l))
                }
                findAll(l, c) {
                    let [x] = (0, N.I6)(l, c);
                    return Object.keys(x).length > 0 ? this.queries.filter(l => (0, N._x)(x, l)) : this.queries
                }
                notify(l) {
                    Z.V.batch(() => {
                        this.listeners.forEach(({
                            listener: c
                        }) => {
                            c(l)
                        })
                    })
                }
                onFocus() {
                    Z.V.batch(() => {
                        this.queries.forEach(l => {
                            l.onFocus()
                        })
                    })
                }
                onOnline() {
                    Z.V.batch(() => {
                        this.queries.forEach(l => {
                            l.onOnline()
                        })
                    })
                }
            };
            var J = x(20172);
            let MutationCache = class MutationCache extends q.l {
                constructor(l) {
                    super(), this.config = l || {}, this.mutations = [], this.mutationId = 0
                }
                build(l, c, x) {
                    let N = new J.m({
                        mutationCache: this,
                        logger: l.getLogger(),
                        mutationId: ++this.mutationId,
                        options: l.defaultMutationOptions(c),
                        state: x,
                        defaultOptions: c.mutationKey ? l.getMutationDefaults(c.mutationKey) : void 0
                    });
                    return this.add(N), N
                }
                add(l) {
                    this.mutations.push(l), this.notify({
                        type: "added",
                        mutation: l
                    })
                }
                remove(l) {
                    this.mutations = this.mutations.filter(c => c !== l), this.notify({
                        type: "removed",
                        mutation: l
                    })
                }
                clear() {
                    Z.V.batch(() => {
                        this.mutations.forEach(l => {
                            this.remove(l)
                        })
                    })
                }
                getAll() {
                    return this.mutations
                }
                find(l) {
                    return void 0 === l.exact && (l.exact = !0), this.mutations.find(c => (0, N.X7)(l, c))
                }
                findAll(l) {
                    return this.mutations.filter(c => (0, N.X7)(l, c))
                }
                notify(l) {
                    Z.V.batch(() => {
                        this.listeners.forEach(({
                            listener: c
                        }) => {
                            c(l)
                        })
                    })
                }
                resumePausedMutations() {
                    var l;
                    return this.resuming = (null != (l = this.resuming) ? l : Promise.resolve()).then(() => {
                        let l = this.mutations.filter(l => l.state.isPaused);
                        return Z.V.batch(() => l.reduce((l, c) => l.then(() => c.continue().catch(N.ZT)), Promise.resolve()))
                    }).then(() => {
                        this.resuming = void 0
                    }), this.resuming
                }
            };
            var X = x(88202),
                en = x(23864);

            function getNextPageParam(l, c) {
                return null == l.getNextPageParam ? void 0 : l.getNextPageParam(c[c.length - 1], c)
            }
            let QueryClient = class QueryClient {
                constructor(l = {}) {
                    this.queryCache = l.queryCache || new QueryCache, this.mutationCache = l.mutationCache || new MutationCache, this.logger = l.logger || U._, this.defaultOptions = l.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [], this.mountCount = 0
                }
                mount() {
                    this.mountCount++, 1 === this.mountCount && (this.unsubscribeFocus = X.j.subscribe(() => {
                        X.j.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus())
                    }), this.unsubscribeOnline = en.N.subscribe(() => {
                        en.N.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline())
                    }))
                }
                unmount() {
                    var l, c;
                    this.mountCount--, 0 === this.mountCount && (null == (l = this.unsubscribeFocus) || l.call(this), this.unsubscribeFocus = void 0, null == (c = this.unsubscribeOnline) || c.call(this), this.unsubscribeOnline = void 0)
                }
                isFetching(l, c) {
                    let [x] = (0, N.I6)(l, c);
                    return x.fetchStatus = "fetching", this.queryCache.findAll(x).length
                }
                isMutating(l) {
                    return this.mutationCache.findAll({ ...l,
                        fetching: !0
                    }).length
                }
                getQueryData(l, c) {
                    var x;
                    return null == (x = this.queryCache.find(l, c)) ? void 0 : x.state.data
                }
                ensureQueryData(l, c, x) {
                    let U = (0, N._v)(l, c, x),
                        Z = this.getQueryData(U.queryKey);
                    return Z ? Promise.resolve(Z) : this.fetchQuery(U)
                }
                getQueriesData(l) {
                    return this.getQueryCache().findAll(l).map(({
                        queryKey: l,
                        state: c
                    }) => {
                        let x = c.data;
                        return [l, x]
                    })
                }
                setQueryData(l, c, x) {
                    let U = this.queryCache.find(l),
                        Z = null == U ? void 0 : U.state.data,
                        $ = (0, N.SE)(c, Z);
                    if (void 0 === $) return;
                    let Y = (0, N._v)(l),
                        q = this.defaultQueryOptions(Y);
                    return this.queryCache.build(this, q).setData($, { ...x,
                        manual: !0
                    })
                }
                setQueriesData(l, c, x) {
                    return Z.V.batch(() => this.getQueryCache().findAll(l).map(({
                        queryKey: l
                    }) => [l, this.setQueryData(l, c, x)]))
                }
                getQueryState(l, c) {
                    var x;
                    return null == (x = this.queryCache.find(l, c)) ? void 0 : x.state
                }
                removeQueries(l, c) {
                    let [x] = (0, N.I6)(l, c), U = this.queryCache;
                    Z.V.batch(() => {
                        U.findAll(x).forEach(l => {
                            U.remove(l)
                        })
                    })
                }
                resetQueries(l, c, x) {
                    let [U, $] = (0, N.I6)(l, c, x), Y = this.queryCache, q = {
                        type: "active",
                        ...U
                    };
                    return Z.V.batch(() => (Y.findAll(U).forEach(l => {
                        l.reset()
                    }), this.refetchQueries(q, $)))
                }
                cancelQueries(l, c, x) {
                    let [U, $ = {}] = (0, N.I6)(l, c, x);
                    void 0 === $.revert && ($.revert = !0);
                    let Y = Z.V.batch(() => this.queryCache.findAll(U).map(l => l.cancel($)));
                    return Promise.all(Y).then(N.ZT).catch(N.ZT)
                }
                invalidateQueries(l, c, x) {
                    let [U, $] = (0, N.I6)(l, c, x);
                    return Z.V.batch(() => {
                        var l, c;
                        if (this.queryCache.findAll(U).forEach(l => {
                                l.invalidate()
                            }), "none" === U.refetchType) return Promise.resolve();
                        let x = { ...U,
                            type: null != (l = null != (c = U.refetchType) ? c : U.type) ? l : "active"
                        };
                        return this.refetchQueries(x, $)
                    })
                }
                refetchQueries(l, c, x) {
                    let [U, $] = (0, N.I6)(l, c, x), Y = Z.V.batch(() => this.queryCache.findAll(U).filter(l => !l.isDisabled()).map(l => {
                        var c;
                        return l.fetch(void 0, { ...$,
                            cancelRefetch: null == (c = null == $ ? void 0 : $.cancelRefetch) || c,
                            meta: {
                                refetchPage: U.refetchPage
                            }
                        })
                    })), q = Promise.all(Y).then(N.ZT);
                    return null != $ && $.throwOnError || (q = q.catch(N.ZT)), q
                }
                fetchQuery(l, c, x) {
                    let U = (0, N._v)(l, c, x),
                        Z = this.defaultQueryOptions(U);
                    void 0 === Z.retry && (Z.retry = !1);
                    let $ = this.queryCache.build(this, Z);
                    return $.isStaleByTime(Z.staleTime) ? $.fetch(Z) : Promise.resolve($.state.data)
                }
                prefetchQuery(l, c, x) {
                    return this.fetchQuery(l, c, x).then(N.ZT).catch(N.ZT)
                }
                fetchInfiniteQuery(l, c, x) {
                    let U = (0, N._v)(l, c, x);
                    return U.behavior = {
                        onFetch: l => {
                            l.fetchFn = () => {
                                var c, x, N, U, Z, $, Y;
                                let q;
                                let J = null == (c = l.fetchOptions) ? void 0 : null == (x = c.meta) ? void 0 : x.refetchPage,
                                    X = null == (N = l.fetchOptions) ? void 0 : null == (U = N.meta) ? void 0 : U.fetchMore,
                                    en = null == X ? void 0 : X.pageParam,
                                    er = (null == X ? void 0 : X.direction) === "forward",
                                    ea = (null == X ? void 0 : X.direction) === "backward",
                                    eo = (null == (Z = l.state.data) ? void 0 : Z.pages) || [],
                                    el = (null == ($ = l.state.data) ? void 0 : $.pageParams) || [],
                                    ec = el,
                                    eu = !1,
                                    addSignalProperty = c => {
                                        Object.defineProperty(c, "signal", {
                                            enumerable: !0,
                                            get: () => {
                                                var c, x;
                                                return null != (c = l.signal) && c.aborted ? eu = !0 : null == (x = l.signal) || x.addEventListener("abort", () => {
                                                    eu = !0
                                                }), l.signal
                                            }
                                        })
                                    },
                                    ed = l.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + l.options.queryHash + "'")),
                                    buildNewPages = (l, c, x, N) => (ec = N ? [c, ...ec] : [...ec, c], N ? [x, ...l] : [...l, x]),
                                    fetchPage = (c, x, N, U) => {
                                        if (eu) return Promise.reject("Cancelled");
                                        if (void 0 === N && !x && c.length) return Promise.resolve(c);
                                        let Z = {
                                            queryKey: l.queryKey,
                                            pageParam: N,
                                            meta: l.options.meta
                                        };
                                        addSignalProperty(Z);
                                        let $ = ed(Z),
                                            Y = Promise.resolve($).then(l => buildNewPages(c, N, l, U));
                                        return Y
                                    };
                                if (eo.length) {
                                    if (er) {
                                        let c = void 0 !== en,
                                            x = c ? en : getNextPageParam(l.options, eo);
                                        q = fetchPage(eo, c, x)
                                    } else if (ea) {
                                        let c = void 0 !== en,
                                            x = c ? en : null == (Y = l.options).getPreviousPageParam ? void 0 : Y.getPreviousPageParam(eo[0], eo);
                                        q = fetchPage(eo, c, x, !0)
                                    } else {
                                        ec = [];
                                        let c = void 0 === l.options.getNextPageParam,
                                            x = !J || !eo[0] || J(eo[0], 0, eo);
                                        q = x ? fetchPage([], c, el[0]) : Promise.resolve(buildNewPages([], el[0], eo[0]));
                                        for (let x = 1; x < eo.length; x++) q = q.then(N => {
                                            let U = !J || !eo[x] || J(eo[x], x, eo);
                                            if (U) {
                                                let U = c ? el[x] : getNextPageParam(l.options, N);
                                                return fetchPage(N, c, U)
                                            }
                                            return Promise.resolve(buildNewPages(N, el[x], eo[x]))
                                        })
                                    }
                                } else q = fetchPage([]);
                                let ep = q.then(l => ({
                                    pages: l,
                                    pageParams: ec
                                }));
                                return ep
                            }
                        }
                    }, this.fetchQuery(U)
                }
                prefetchInfiniteQuery(l, c, x) {
                    return this.fetchInfiniteQuery(l, c, x).then(N.ZT).catch(N.ZT)
                }
                resumePausedMutations() {
                    return this.mutationCache.resumePausedMutations()
                }
                getQueryCache() {
                    return this.queryCache
                }
                getMutationCache() {
                    return this.mutationCache
                }
                getLogger() {
                    return this.logger
                }
                getDefaultOptions() {
                    return this.defaultOptions
                }
                setDefaultOptions(l) {
                    this.defaultOptions = l
                }
                setQueryDefaults(l, c) {
                    let x = this.queryDefaults.find(c => (0, N.yF)(l) === (0, N.yF)(c.queryKey));
                    x ? x.defaultOptions = c : this.queryDefaults.push({
                        queryKey: l,
                        defaultOptions: c
                    })
                }
                getQueryDefaults(l) {
                    if (!l) return;
                    let c = this.queryDefaults.find(c => (0, N.to)(l, c.queryKey));
                    return null == c ? void 0 : c.defaultOptions
                }
                setMutationDefaults(l, c) {
                    let x = this.mutationDefaults.find(c => (0, N.yF)(l) === (0, N.yF)(c.mutationKey));
                    x ? x.defaultOptions = c : this.mutationDefaults.push({
                        mutationKey: l,
                        defaultOptions: c
                    })
                }
                getMutationDefaults(l) {
                    if (!l) return;
                    let c = this.mutationDefaults.find(c => (0, N.to)(l, c.mutationKey));
                    return null == c ? void 0 : c.defaultOptions
                }
                defaultQueryOptions(l) {
                    if (null != l && l._defaulted) return l;
                    let c = { ...this.defaultOptions.queries,
                        ...this.getQueryDefaults(null == l ? void 0 : l.queryKey),
                        ...l,
                        _defaulted: !0
                    };
                    return !c.queryHash && c.queryKey && (c.queryHash = (0, N.Rm)(c.queryKey, c)), void 0 === c.refetchOnReconnect && (c.refetchOnReconnect = "always" !== c.networkMode), void 0 === c.useErrorBoundary && (c.useErrorBoundary = !!c.suspense), c
                }
                defaultMutationOptions(l) {
                    return null != l && l._defaulted ? l : { ...this.defaultOptions.mutations,
                        ...this.getMutationDefaults(null == l ? void 0 : l.mutationKey),
                        ...l,
                        _defaulted: !0
                    }
                }
                clear() {
                    this.queryCache.clear(), this.mutationCache.clear()
                }
            };
            var er = x(5060),
                ea = x(2265),
                eo = x(57437),
                el = x(22130);
            let QueryClientProviderWithDefault = l => {
                    let {
                        queryClient: c,
                        children: x
                    } = l, N = (0, ea.useMemo)(() => c || new QueryClient, [c]);
                    return (0, eo.jsx)(er.aH, {
                        client: N,
                        children: x
                    })
                },
                ec = {
                    persist: !1
                };

            function neverPersist(l) {
                return [...l, ec]
            }

            function requiredParamInvariant(l, c) {
                (0, el.Z)(null !== l || void 0 !== l, c)
            }
        },
        41282: function(l, c, x) {
            "use strict";
            x.d(c, {
                $4A: function() {
                    return N.b
                },
                AbE: function() {
                    return N.s
                },
                DUm: function() {
                    return N.bu
                },
                EnH: function() {
                    return N.bx
                },
                GGd: function() {
                    return N.Z
                },
                Jgv: function() {
                    return N.t
                },
                KQd: function() {
                    return N.m
                },
                Osb: function() {
                    return N.u
                },
                SFn: function() {
                    return N.o
                },
                UvD: function() {
                    return N.bB
                },
                WPQ: function() {
                    return N.r
                },
                aCi: function() {
                    return N.be
                },
                aFb: function() {
                    return N.bd
                },
                aU_: function() {
                    return N.bc
                },
                c4c: function() {
                    return N.j
                },
                cqn: function() {
                    return N.U
                },
                doQ: function() {
                    return N.Y
                },
                eC: function() {
                    return N.bD
                },
                f0v: function() {
                    return N.bb
                },
                gtM: function() {
                    return N.a
                },
                o$C: function() {
                    return N.f
                },
                pX8: function() {
                    return N.c
                },
                qL0: function() {
                    return N.e
                },
                rBi: function() {
                    return N.g
                },
                tNP: function() {
                    return N.l
                },
                tZ_: function() {
                    return N.i
                },
                w_p: function() {
                    return N.h
                },
                xUo: function() {
                    return N.d
                },
                xxU: function() {
                    return N.p
                },
                y$C: function() {
                    return N.bt
                }
            });
            var N = x(89351);
            x(1361), x(58499), x(2265), x(57437), x(63112), x(9581)
        },
        80464: function(l, c, x) {
            "use strict";
            x.d(c, {
                I: function() {
                    return InputSelectionUI
                }
            });
            var N = x(2265),
                U = x(67327),
                Z = x(57437);

            function InputSelectionUI(l) {
                let [c, x] = (0, N.useState)(""), [$, Y] = (0, N.useState)(), [q, J] = (0, N.useState)(!1), handleSelect = () => {
                    J(!0), c && !$ && l.onSelect(c)
                }, X = q && !!$ || !c && !!l.emptyErrorMessage && q;
                return (0, Z.jsxs)("div", {
                    children: [!l.noInput && (0, Z.jsx)("div", {
                        style: {
                            position: "relative"
                        },
                        children: (0, Z.jsx)(U.A, {
                            tabIndex: -1,
                            placeholder: l.placeholder,
                            variant: "outline",
                            type: l.type,
                            name: l.name,
                            value: c,
                            "data-error": X,
                            onChange: c => {
                                x(c.target.value), l.errorMessage ? Y(l.errorMessage(c.target.value)) : Y(void 0)
                            },
                            onKeyDown: l => {
                                "Enter" === l.key && handleSelect()
                            }
                        })
                    }), q && $ && (0, Z.jsxs)(Z.Fragment, {
                        children: [(0, Z.jsx)(U.S, {
                            y: "xs"
                        }), (0, Z.jsx)(U.b, {
                            color: "danger",
                            size: "sm",
                            children: $
                        })]
                    }), !(q && $) && !c && l.emptyErrorMessage && q && (0, Z.jsxs)(Z.Fragment, {
                        children: [(0, Z.jsx)(U.S, {
                            y: "xs"
                        }), (0, Z.jsx)(U.b, {
                            color: "danger",
                            size: "sm",
                            children: l.emptyErrorMessage
                        })]
                    }), (0, Z.jsx)(U.S, {
                        y: "md"
                    }), (0, Z.jsx)(U.B, {
                        variant: "accent",
                        onClick: handleSelect,
                        fullWidth: !0,
                        children: "Continue"
                    }), l.footer, l.showOrSeparator && (0, Z.jsxs)(Z.Fragment, {
                        children: [(0, Z.jsx)(U.S, {
                            y: "lg"
                        }), (0, Z.jsx)(U.T, {
                            children: (0, Z.jsx)("span", {
                                children: " OR "
                            })
                        }), (0, Z.jsx)(U.S, {
                            y: "md"
                        })]
                    })]
                })
            }
        },
        78698: function(l, c, x) {
            "use strict";
            x.d(c, {
                T: function() {
                    return ToolTip
                },
                a: function() {
                    return eR
                },
                e: function() {
                    return eP
                },
                p: function() {
                    return ez
                },
                s: function() {
                    return eL
                }
            });
            var N = x(67327),
                U = x(99538),
                Z = x(8801),
                $ = x(13428),
                Y = x(2265),
                q = x(85744),
                J = x(42210),
                X = x(56989),
                en = x(79249),
                er = x(20966),
                ea = x(83995),
                eo = x(52730),
                el = x(85606),
                ec = x(9381),
                eu = x(67256),
                ed = x(73763),
                ep = x(8281);
            let [eh, ey] = (0, X.b)("Tooltip", [ea.D7]), ef = (0, ea.D7)(), em = "tooltip.open", [eg, eb] = eh("TooltipProvider"), ev = "Tooltip", [ew, eT] = eh(ev), eM = "TooltipTrigger", eI = (0, Y.forwardRef)((l, c) => {
                let {
                    __scopeTooltip: x,
                    ...N
                } = l, U = eT(eM, x), Z = eb(eM, x), X = ef(x), en = (0, Y.useRef)(null), er = (0, J.e)(c, en, U.onTriggerChange), eo = (0, Y.useRef)(!1), el = (0, Y.useRef)(!1), eu = (0, Y.useCallback)(() => eo.current = !1, []);
                return (0, Y.useEffect)(() => () => document.removeEventListener("pointerup", eu), [eu]), (0, Y.createElement)(ea.ee, (0, $.Z)({
                    asChild: !0
                }, X), (0, Y.createElement)(ec.WV.button, (0, $.Z)({
                    "aria-describedby": U.open ? U.contentId : void 0,
                    "data-state": U.stateAttribute
                }, N, {
                    ref: er,
                    onPointerMove: (0, q.M)(l.onPointerMove, l => {
                        "touch" === l.pointerType || el.current || Z.isPointerInTransitRef.current || (U.onTriggerEnter(), el.current = !0)
                    }),
                    onPointerLeave: (0, q.M)(l.onPointerLeave, () => {
                        U.onTriggerLeave(), el.current = !1
                    }),
                    onPointerDown: (0, q.M)(l.onPointerDown, () => {
                        eo.current = !0, document.addEventListener("pointerup", eu, {
                            once: !0
                        })
                    }),
                    onFocus: (0, q.M)(l.onFocus, () => {
                        eo.current || U.onOpen()
                    }),
                    onBlur: (0, q.M)(l.onBlur, U.onClose),
                    onClick: (0, q.M)(l.onClick, U.onClose)
                })))
            }), ex = "TooltipPortal", [eC, e_] = eh(ex, {
                forceMount: void 0
            }), eD = "TooltipContent", eS = (0, Y.forwardRef)((l, c) => {
                let x = e_(eD, l.__scopeTooltip),
                    {
                        forceMount: N = x.forceMount,
                        side: U = "top",
                        ...Z
                    } = l,
                    q = eT(eD, l.__scopeTooltip);
                return (0, Y.createElement)(el.z, {
                    present: N || q.open
                }, q.disableHoverableContent ? (0, Y.createElement)(eA, (0, $.Z)({
                    side: U
                }, Z, {
                    ref: c
                })) : (0, Y.createElement)(ek, (0, $.Z)({
                    side: U
                }, Z, {
                    ref: c
                })))
            }), ek = (0, Y.forwardRef)((l, c) => {
                let x = eT(eD, l.__scopeTooltip),
                    N = eb(eD, l.__scopeTooltip),
                    U = (0, Y.useRef)(null),
                    Z = (0, J.e)(c, U),
                    [q, X] = (0, Y.useState)(null),
                    {
                        trigger: en,
                        onClose: er
                    } = x,
                    ea = U.current,
                    {
                        onPointerInTransitChange: eo
                    } = N,
                    el = (0, Y.useCallback)(() => {
                        X(null), eo(!1)
                    }, [eo]),
                    ec = (0, Y.useCallback)((l, c) => {
                        let x = l.currentTarget,
                            N = {
                                x: l.clientX,
                                y: l.clientY
                            },
                            U = function(l, c) {
                                let x = Math.abs(c.top - l.y),
                                    N = Math.abs(c.bottom - l.y),
                                    U = Math.abs(c.right - l.x),
                                    Z = Math.abs(c.left - l.x);
                                switch (Math.min(x, N, U, Z)) {
                                    case Z:
                                        return "left";
                                    case U:
                                        return "right";
                                    case x:
                                        return "top";
                                    case N:
                                        return "bottom";
                                    default:
                                        throw Error("unreachable")
                                }
                            }(N, x.getBoundingClientRect()),
                            Z = function(l, c, x = 5) {
                                let N = [];
                                switch (c) {
                                    case "top":
                                        N.push({
                                            x: l.x - x,
                                            y: l.y + x
                                        }, {
                                            x: l.x + x,
                                            y: l.y + x
                                        });
                                        break;
                                    case "bottom":
                                        N.push({
                                            x: l.x - x,
                                            y: l.y - x
                                        }, {
                                            x: l.x + x,
                                            y: l.y - x
                                        });
                                        break;
                                    case "left":
                                        N.push({
                                            x: l.x + x,
                                            y: l.y - x
                                        }, {
                                            x: l.x + x,
                                            y: l.y + x
                                        });
                                        break;
                                    case "right":
                                        N.push({
                                            x: l.x - x,
                                            y: l.y - x
                                        }, {
                                            x: l.x - x,
                                            y: l.y + x
                                        })
                                }
                                return N
                            }(N, U),
                            $ = function(l) {
                                let {
                                    top: c,
                                    right: x,
                                    bottom: N,
                                    left: U
                                } = l;
                                return [{
                                    x: U,
                                    y: c
                                }, {
                                    x: x,
                                    y: c
                                }, {
                                    x: x,
                                    y: N
                                }, {
                                    x: U,
                                    y: N
                                }]
                            }(c.getBoundingClientRect()),
                            Y = function(l) {
                                let c = l.slice();
                                return c.sort((l, c) => l.x < c.x ? -1 : l.x > c.x ? 1 : l.y < c.y ? -1 : l.y > c.y ? 1 : 0),
                                    function(l) {
                                        if (l.length <= 1) return l.slice();
                                        let c = [];
                                        for (let x = 0; x < l.length; x++) {
                                            let N = l[x];
                                            for (; c.length >= 2;) {
                                                let l = c[c.length - 1],
                                                    x = c[c.length - 2];
                                                if ((l.x - x.x) * (N.y - x.y) >= (l.y - x.y) * (N.x - x.x)) c.pop();
                                                else break
                                            }
                                            c.push(N)
                                        }
                                        c.pop();
                                        let x = [];
                                        for (let c = l.length - 1; c >= 0; c--) {
                                            let N = l[c];
                                            for (; x.length >= 2;) {
                                                let l = x[x.length - 1],
                                                    c = x[x.length - 2];
                                                if ((l.x - c.x) * (N.y - c.y) >= (l.y - c.y) * (N.x - c.x)) x.pop();
                                                else break
                                            }
                                            x.push(N)
                                        }
                                        return (x.pop(), 1 === c.length && 1 === x.length && c[0].x === x[0].x && c[0].y === x[0].y) ? c : c.concat(x)
                                    }(c)
                            }([...Z, ...$]);
                        X(Y), eo(!0)
                    }, [eo]);
                return (0, Y.useEffect)(() => () => el(), [el]), (0, Y.useEffect)(() => {
                    if (en && ea) {
                        let handleTriggerLeave = l => ec(l, ea),
                            handleContentLeave = l => ec(l, en);
                        return en.addEventListener("pointerleave", handleTriggerLeave), ea.addEventListener("pointerleave", handleContentLeave), () => {
                            en.removeEventListener("pointerleave", handleTriggerLeave), ea.removeEventListener("pointerleave", handleContentLeave)
                        }
                    }
                }, [en, ea, ec, el]), (0, Y.useEffect)(() => {
                    if (q) {
                        let handleTrackPointerGrace = l => {
                            let c = l.target,
                                x = {
                                    x: l.clientX,
                                    y: l.clientY
                                },
                                N = (null == en ? void 0 : en.contains(c)) || (null == ea ? void 0 : ea.contains(c)),
                                U = ! function(l, c) {
                                    let {
                                        x: x,
                                        y: N
                                    } = l, U = !1;
                                    for (let l = 0, Z = c.length - 1; l < c.length; Z = l++) {
                                        let $ = c[l].x,
                                            Y = c[l].y,
                                            q = c[Z].x,
                                            J = c[Z].y,
                                            X = Y > N != J > N && x < (q - $) * (N - Y) / (J - Y) + $;
                                        X && (U = !U)
                                    }
                                    return U
                                }(x, q);
                            N ? el() : U && (el(), er())
                        };
                        return document.addEventListener("pointermove", handleTrackPointerGrace), () => document.removeEventListener("pointermove", handleTrackPointerGrace)
                    }
                }, [en, ea, q, er, el]), (0, Y.createElement)(eA, (0, $.Z)({}, l, {
                    ref: Z
                }))
            }), [eE, eN] = eh(ev, {
                isInside: !1
            }), eA = (0, Y.forwardRef)((l, c) => {
                let {
                    __scopeTooltip: x,
                    children: N,
                    "aria-label": U,
                    onEscapeKeyDown: Z,
                    onPointerDownOutside: q,
                    ...J
                } = l, X = eT(eD, x), er = ef(x), {
                    onClose: eo
                } = X;
                return (0, Y.useEffect)(() => (document.addEventListener(em, eo), () => document.removeEventListener(em, eo)), [eo]), (0, Y.useEffect)(() => {
                    if (X.trigger) {
                        let handleScroll = l => {
                            let c = l.target;
                            null != c && c.contains(X.trigger) && eo()
                        };
                        return window.addEventListener("scroll", handleScroll, {
                            capture: !0
                        }), () => window.removeEventListener("scroll", handleScroll, {
                            capture: !0
                        })
                    }
                }, [X.trigger, eo]), (0, Y.createElement)(en.XB, {
                    asChild: !0,
                    disableOutsidePointerEvents: !1,
                    onEscapeKeyDown: Z,
                    onPointerDownOutside: q,
                    onFocusOutside: l => l.preventDefault(),
                    onDismiss: eo
                }, (0, Y.createElement)(ea.VY, (0, $.Z)({
                    "data-state": X.stateAttribute
                }, er, J, {
                    ref: c,
                    style: { ...J.style,
                        "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                        "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                        "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                        "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                        "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
                    }
                }), (0, Y.createElement)(eu.A4, null, N), (0, Y.createElement)(eE, {
                    scope: x,
                    isInside: !0
                }, (0, Y.createElement)(ep.f, {
                    id: X.contentId,
                    role: "tooltip"
                }, U || N))))
            }), ej = (0, Y.forwardRef)((l, c) => {
                let {
                    __scopeTooltip: x,
                    ...N
                } = l, U = ef(x), Z = eN("TooltipArrow", x);
                return Z.isInside ? null : (0, Y.createElement)(ea.Eh, (0, $.Z)({}, U, N, {
                    ref: c
                }))
            }), $a093c7e1ec25a057$export$2881499e37b75b9a = l => {
                let {
                    __scopeTooltip: c,
                    delayDuration: x = 700,
                    skipDelayDuration: N = 300,
                    disableHoverableContent: U = !1,
                    children: Z
                } = l, [$, q] = (0, Y.useState)(!0), J = (0, Y.useRef)(!1), X = (0, Y.useRef)(0);
                return (0, Y.useEffect)(() => {
                    let l = X.current;
                    return () => window.clearTimeout(l)
                }, []), (0, Y.createElement)(eg, {
                    scope: c,
                    isOpenDelayed: $,
                    delayDuration: x,
                    onOpen: (0, Y.useCallback)(() => {
                        window.clearTimeout(X.current), q(!1)
                    }, []),
                    onClose: (0, Y.useCallback)(() => {
                        window.clearTimeout(X.current), X.current = window.setTimeout(() => q(!0), N)
                    }, [N]),
                    isPointerInTransitRef: J,
                    onPointerInTransitChange: (0, Y.useCallback)(l => {
                        J.current = l
                    }, []),
                    disableHoverableContent: U
                }, Z)
            }, $a093c7e1ec25a057$export$be92b6f5f03c0fe9 = l => {
                let {
                    __scopeTooltip: c,
                    children: x,
                    open: N,
                    defaultOpen: U = !1,
                    onOpenChange: Z,
                    disableHoverableContent: $,
                    delayDuration: q
                } = l, J = eb(ev, l.__scopeTooltip), X = ef(c), [en, eo] = (0, Y.useState)(null), el = (0, er.M)(), ec = (0, Y.useRef)(0), eu = null != $ ? $ : J.disableHoverableContent, ep = null != q ? q : J.delayDuration, eh = (0, Y.useRef)(!1), [ey = !1, eg] = (0, ed.T)({
                    prop: N,
                    defaultProp: U,
                    onChange: l => {
                        l ? (J.onOpen(), document.dispatchEvent(new CustomEvent(em))) : J.onClose(), null == Z || Z(l)
                    }
                }), eT = (0, Y.useMemo)(() => ey ? eh.current ? "delayed-open" : "instant-open" : "closed", [ey]), eM = (0, Y.useCallback)(() => {
                    window.clearTimeout(ec.current), eh.current = !1, eg(!0)
                }, [eg]), eI = (0, Y.useCallback)(() => {
                    window.clearTimeout(ec.current), eg(!1)
                }, [eg]), ex = (0, Y.useCallback)(() => {
                    window.clearTimeout(ec.current), ec.current = window.setTimeout(() => {
                        eh.current = !0, eg(!0)
                    }, ep)
                }, [ep, eg]);
                return (0, Y.useEffect)(() => () => window.clearTimeout(ec.current), []), (0, Y.createElement)(ea.fC, X, (0, Y.createElement)(ew, {
                    scope: c,
                    contentId: el,
                    open: ey,
                    stateAttribute: eT,
                    trigger: en,
                    onTriggerChange: eo,
                    onTriggerEnter: (0, Y.useCallback)(() => {
                        J.isOpenDelayed ? ex() : eM()
                    }, [J.isOpenDelayed, ex, eM]),
                    onTriggerLeave: (0, Y.useCallback)(() => {
                        eu ? eI() : window.clearTimeout(ec.current)
                    }, [eI, eu]),
                    onOpen: eM,
                    onClose: eI,
                    disableHoverableContent: eu
                }, x))
            }, $a093c7e1ec25a057$export$602eac185826482c = l => {
                let {
                    __scopeTooltip: c,
                    forceMount: x,
                    children: N,
                    container: U
                } = l, Z = eT(ex, c);
                return (0, Y.createElement)(eC, {
                    scope: c,
                    forceMount: x
                }, (0, Y.createElement)(el.z, {
                    present: x || Z.open
                }, (0, Y.createElement)(eo.h, {
                    asChild: !0,
                    container: U
                }, N)))
            };
            var eO = x(57437);
            let eP = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzM1ODlfODY0OSkiPgo8cmVjdCB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHJ4PSI4IiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzU4OV84NjQ5KSIvPgo8cmVjdCB4PSItMSIgeT0iLTEiIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgcng9IjkuOCIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM1ODlfODY0OSkiLz4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAxXzM1ODlfODY0OSkiPgo8cGF0aCBkPSJNMjQgMTQuMjVDMTguNjE3MiAxNC4yNSAxNC4yNSAxOC42MTcyIDE0LjI1IDI0QzE0LjI1IDI5LjM4MjggMTguNjE3MiAzMy43NSAyNCAzMy43NUMyNC44OTg4IDMzLjc1IDI1LjYyNSAzNC40NzYyIDI1LjYyNSAzNS4zNzVDMjUuNjI1IDM2LjI3MzggMjQuODk4OCAzNyAyNCAzN0MxNi44MTk1IDM3IDExIDMxLjE4MDUgMTEgMjRDMTEgMTYuODE5NSAxNi44MTk1IDExIDI0IDExQzMxLjE4MDUgMTEgMzcgMTYuODE5NSAzNyAyNFYyNS42MjVDMzcgMjguMzE2NCAzNC44MTY0IDMwLjUgMzIuMTI1IDMwLjVDMzAuNjM3MSAzMC41IDI5LjMwMTYgMjkuODI5NyAyOC40MDc4IDI4Ljc3ODVDMjcuMjUgMjkuODQ0OSAyNS43MDEyIDMwLjUgMjQgMzAuNUMyMC40MDk4IDMwLjUgMTcuNSAyNy41OTAyIDE3LjUgMjRDMTcuNSAyMC40MDk4IDIwLjQwOTggMTcuNSAyNCAxNy41QzI1LjQxNjggMTcuNSAyNi43MjcgMTcuOTUyIDI3Ljc5MzQgMTguNzIzOEMyOC4wODI4IDE4LjQ2OTkgMjguNDU4NiAxOC4zMTI1IDI4Ljg3NSAxOC4zMTI1QzI5Ljc3MzggMTguMzEyNSAzMC41IDE5LjAzODcgMzAuNSAxOS45Mzc1VjI1LjYyNUMzMC41IDI2LjUyMzggMzEuMjI2MiAyNy4yNSAzMi4xMjUgMjcuMjVDMzMuMDIzOCAyNy4yNSAzMy43NSAyNi41MjM4IDMzLjc1IDI1LjYyNVYyNEMzMy43NSAxOC42MTcyIDI5LjM4MjggMTQuMjUgMjQgMTQuMjVaTTI3LjI1IDI0QzI3LjI1IDIzLjEzOCAyNi45MDc2IDIyLjMxMTQgMjYuMjk4MSAyMS43MDE5QzI1LjY4ODYgMjEuMDkyNCAyNC44NjIgMjAuNzUgMjQgMjAuNzVDMjMuMTM4IDIwLjc1IDIyLjMxMTQgMjEuMDkyNCAyMS43MDE5IDIxLjcwMTlDMjEuMDkyNCAyMi4zMTE0IDIwLjc1IDIzLjEzOCAyMC43NSAyNEMyMC43NSAyNC44NjIgMjEuMDkyNCAyNS42ODg2IDIxLjcwMTkgMjYuMjk4MUMyMi4zMTE0IDI2LjkwNzYgMjMuMTM4IDI3LjI1IDI0IDI3LjI1QzI0Ljg2MiAyNy4yNSAyNS42ODg2IDI2LjkwNzYgMjYuMjk4MSAyNi4yOTgxQzI2LjkwNzYgMjUuNjg4NiAyNy4yNSAyNC44NjIgMjcuMjUgMjRaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8zNTg5Xzg2NDkiIHgxPSIyNS41IiB5MT0iLTYuMjk1NzJlLTA2IiB4Mj0iMzAuMjAxNiIgeTI9IjQ3LjUzNSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjODM1OEJBIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzdCMUNGNyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXJfMzU4OV84NjQ5IiB4MT0iMjUuNTYyNSIgeTE9Ii0xLjAwMDAxIiB4Mj0iMzAuNDYiIHkyPSI0OC41MTU2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM4MzU4QkEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjN0IxQ0Y3Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMzU4OV84NjQ5Ij4KPHJlY3Qgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4IiByeD0iOCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPGNsaXBQYXRoIGlkPSJjbGlwMV8zNTg5Xzg2NDkiPgo8cmVjdCB3aWR0aD0iMjYiIGhlaWdodD0iMjYiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMSAxMSkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K",
                ez = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzM1ODlfODYwMikiPgo8cmVjdCB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHJ4PSI4IiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzU4OV84NjAyKSIvPgo8cmVjdCB4PSItMSIgeT0iLTEiIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgcng9IjkuOCIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM1ODlfODYwMikiLz4KPHBhdGggZD0iTTE4Ljg2MjIgMjYuODY0NkwxOS41MTk0IDI3LjUxODlDMTkuNTE5NCAyNy41MTg5IDIxLjA4MzcgMjkuMDczMSAyNS4zNTIxIDI0LjgyOTNDMjkuNjIwNSAyMC41ODU1IDI4LjA1NjEgMTkuMDMxMyAyOC4wNTYxIDE5LjAzMTNMMjcuNjQzIDE4LjYxODFDMjYuNjIxOCAxNy42MDQxIDI2LjUyNSAxNS45NzQ4IDI3LjQxNjIgMTQuNzg0NkwyOS4yMzYyIDEyLjM1MzVDMzAuMzM5OCAxMC44ODAyIDMyLjQ3MDQgMTAuNjg1MiAzMy43MzQzIDExLjk0MTlMMzYuMDAyMSAxNC4xOTUyQzM2LjYyNzUgMTQuODE5MiAzNy4wNDY0IDE1LjYyNTIgMzYuOTk1OSAxNi41MjA4QzM2Ljg2NTkgMTguODEzMSAzNS44Mjg4IDIzLjc0MzEgMzAuMDQ1MSAyOS40OTQ5QzIzLjkxMDUgMzUuNTkzNCAxOC4xNTQ0IDM1LjgzNjEgMTUuODAxNCAzNS42MTY1QzE1LjA1NiAzNS41NDcyIDE0LjQwODkgMzUuMTY4NyAxMy44ODc0IDM0LjY0ODdMMTEuODM2MyAzMi42MDkyQzEwLjQ0OTYgMzEuMjMyNiAxMC44Mzk2IDI4Ljg3MDkgMTIuNjEzNCAyNy45MDc0TDE1LjM3MjMgMjYuNDA2N0MxNi41MzY2IDI1Ljc3NCAxNy45NTIxIDI1Ljk2MDMgMTguODYyMiAyNi44NjQ2WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzM1ODlfODYwMiIgeDE9IjI1LjUiIHkxPSItNi4yOTU3MmUtMDYiIHgyPSIzMC4yMDE2IiB5Mj0iNDcuNTM1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM4MzU4QkEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjN0IxQ0Y3Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8zNTg5Xzg2MDIiIHgxPSIyNS41NjI1IiB5MT0iLTEuMDAwMDEiIHgyPSIzMC40NiIgeTI9IjQ4LjUxNTYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzgzNThCQSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM3QjFDRjciLz4KPC9saW5lYXJHcmFkaWVudD4KPGNsaXBQYXRoIGlkPSJjbGlwMF8zNTg5Xzg2MDIiPgo8cmVjdCB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHJ4PSI4IiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
                eR = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzM2ODVfNjcwMikiPgo8cmVjdCB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHJ4PSI4IiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzY4NV82NzAyKSIvPgo8cmVjdCB4PSItMSIgeT0iLTEiIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgcng9IjkuOCIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM2ODVfNjcwMikiLz4KPHBhdGggZD0iTTE3IDExQzEzLjY4NzUgMTEgMTEgMTMuNjg3NSAxMSAxN0MxMSAyMC4zMTI1IDEzLjY4NzUgMjMgMTcgMjNDMTcuNTUzMSAyMyAxOCAyMy40NDY5IDE4IDI0QzE4IDI0LjU1MzEgMTcuNTUzMSAyNSAxNyAyNUMxMi41ODEzIDI1IDkgMjEuNDE4NyA5IDE3QzkgMTIuNTgxMyAxMi41ODEzIDkgMTcgOUMyMS40MTg3IDkgMjUgMTIuNTgxMyAyNSAxN1YxOEMyNSAxOS42NTYyIDIzLjY1NjIgMjEgMjIgMjFDMjEuMDg0NCAyMSAyMC4yNjI1IDIwLjU4NzUgMTkuNzEyNSAxOS45NDA2QzE5IDIwLjU5NjkgMTguMDQ2OSAyMSAxNyAyMUMxNC43OTA2IDIxIDEzIDE5LjIwOTQgMTMgMTdDMTMgMTQuNzkwNiAxNC43OTA2IDEzIDE3IDEzQzE3Ljg3MTkgMTMgMTguNjc4MSAxMy4yNzgxIDE5LjMzNDQgMTMuNzUzMUMxOS41MTI1IDEzLjU5NjkgMTkuNzQzOCAxMy41IDIwIDEzLjVDMjAuNTUzMSAxMy41IDIxIDEzLjk0NjkgMjEgMTQuNVYxOEMyMSAxOC41NTMxIDIxLjQ0NjkgMTkgMjIgMTlDMjIuNTUzMSAxOSAyMyAxOC41NTMxIDIzIDE4VjE3QzIzIDEzLjY4NzUgMjAuMzEyNSAxMSAxNyAxMVpNMTkgMTdDMTkgMTYuNDY5NiAxOC43ODkzIDE1Ljk2MDkgMTguNDE0MiAxNS41ODU4QzE4LjAzOTEgMTUuMjEwNyAxNy41MzA0IDE1IDE3IDE1QzE2LjQ2OTYgMTUgMTUuOTYwOSAxNS4yMTA3IDE1LjU4NTggMTUuNTg1OEMxNS4yMTA3IDE1Ljk2MDkgMTUgMTYuNDY5NiAxNSAxN0MxNSAxNy41MzA0IDE1LjIxMDcgMTguMDM5MSAxNS41ODU4IDE4LjQxNDJDMTUuOTYwOSAxOC43ODkzIDE2LjQ2OTYgMTkgMTcgMTlDMTcuNTMwNCAxOSAxOC4wMzkxIDE4Ljc4OTMgMTguNDE0MiAxOC40MTQyQzE4Ljc4OTMgMTguMDM5MSAxOSAxNy41MzA0IDE5IDE3WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTI3LjgzODQgMzMuMjY0NEwyOC4yNDI5IDMzLjY5MDdDMjguMjQyOSAzMy42OTA3IDI5LjIwNTUgMzQuNzAzNCAzMS44MzIyIDMxLjkzODNDMzQuNDU4OCAyOS4xNzMxIDMzLjQ5NjIgMjguMTYwNCAzMy40OTYyIDI4LjE2MDRMMzMuMjQxOSAyNy44OTEyQzMyLjYxMzUgMjcuMjMwNSAzMi41NTM5IDI2LjE2ODkgMzMuMTAyNCAyNS4zOTM0TDM0LjIyMjQgMjMuODA5NEMzNC45MDE1IDIyLjg0OTQgMzYuMjEyNiAyMi43MjIzIDM2Ljk5MDQgMjMuNTQxMkwzOC4zODU5IDI1LjAwOTRDMzguNzcwOCAyNS40MTYgMzkuMDI4NiAyNS45NDExIDM4Ljk5NzUgMjYuNTI0N0MzOC45MTc1IDI4LjAxODMgMzguMjc5MiAzMS4yMzA1IDM0LjcyMDIgMzQuOTc4M0MzMC45NDUxIDM4Ljk1MTkgMjcuNDAyOSAzOS4xMSAyNS45NTQ5IDM4Ljk2NjlDMjUuNDk2MiAzOC45MjE4IDI1LjA5OCAzOC42NzUyIDI0Ljc3NzEgMzguMzM2M0wyMy41MTQ5IDM3LjAwNzRDMjIuNjYxNiAzNi4xMTA1IDIyLjkwMTYgMzQuNTcxNyAyMy45OTMxIDMzLjk0MzlMMjUuNjkwOSAzMi45NjZDMjYuNDA3MyAzMi41NTM4IDI3LjI3ODQgMzIuNjc1MiAyNy44Mzg0IDMzLjI2NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzY4NV82NzAyIiB4MT0iMjUuNSIgeTE9Ii02LjI5NTcyZS0wNiIgeDI9IjMwLjIwMTYiIHkyPSI0Ny41MzUiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzgzNThCQSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM3QjFDRjciLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM2ODVfNjcwMiIgeDE9IjI1LjU2MjUiIHkxPSItMS4wMDAwMSIgeDI9IjMwLjQ2IiB5Mj0iNDguNTE1NiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjODM1OEJBIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzdCMUNGNyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzM2ODVfNjcwMiI+CjxyZWN0IHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgcng9IjgiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
                eL = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xXzkxKSIvPgo8cGF0aCBkPSJNMzkuOTk2OSAxOEw0MC4yMzMzIDE4LjAxNTZMNDAuMzUxMyAxOC4wMzMzTDQwLjQ3MzYgMTguMDYyMkw0MC42OTU4IDE4LjEzNzhDNDAuODQ5NCAxOC4yMDA2IDQwLjk5NTQgMTguMjg0MiA0MS4xMzA1IDE4LjM4NjdMNDEuMzM4NyAxOC41Njg5TDQxLjg0OTMgMTkuMDUzM0M0NS44ODkxIDIyLjc3NjggNTAuOTk0NyAyNC43NzYyIDU2LjI0NTggMjQuNjkxMUw1Ni45MzA3IDI0LjY2ODlDNTcuMzc4MyAyNC42NDYyIDU3LjgyIDI0Ljc5MDkgNTguMTg0OSAyNS4wNzk4QzU4LjU0OTggMjUuMzY4NyA1OC44MTY3IDI1Ljc4NSA1OC45NDMxIDI2LjI2MjJDNTkuOTI3MSAyOS45NzY5IDYwLjIyODMgMzMuODczMSA1OS44Mjg3IDM3LjcxOTRDNTkuNDI4OSA0MS41NjU4IDU4LjMzNjcgNDUuMjgzNiA1Ni42MTY1IDQ4LjY1MjNDNTQuODk2NSA1Mi4wMjA3IDUyLjU4MzYgNTQuOTcxNCA0OS44MTU2IDU3LjMyODVDNDcuMDQ3NiA1OS42ODU2IDQzLjg4MDkgNjEuNDAxMiA0MC41MDM2IDYyLjM3MzRDNDAuMTc0IDYyLjQ2ODMgMzkuODI4IDYyLjQ2ODMgMzkuNDk4MiA2Mi4zNzM0QzM2LjEyMDkgNjEuNDAxNCAzMi45NTM4IDU5LjY4NiAzMC4xODU2IDU3LjMyODlDMjcuNDE3NiA1NC45NzE4IDI1LjEwNDUgNTIuMDIxNCAyMy4zODQyIDQ4LjY1MjlDMjEuNjYzOCA0NS4yODQzIDIwLjU3MTMgNDEuNTY2MiAyMC4xNzE1IDM3LjcxOThDMTkuNzcxNyAzMy44NzM0IDIwLjA3MjcgMjkuOTc2OSAyMS4wNTY3IDI2LjI2MjJDMjEuMTgzMSAyNS43ODUgMjEuNDUwMSAyNS4zNjg3IDIxLjgxNSAyNS4wNzk4QzIyLjE3OTkgMjQuNzkwOSAyMi42MjE1IDI0LjY0NjIgMjMuMDY5MyAyNC42Njg5QzI4LjU1MTMgMjQuOTQ3IDMzLjkyOTMgMjIuOTQ0NCAzOC4xNTA3IDE5LjA1MzNMMzguNjc3MyAxOC41NTMzTDM4Ljg2OTYgMTguMzg2N0MzOS4wMDQ3IDE4LjI4NDIgMzkuMTUwNSAxOC4yMDA2IDM5LjMwNCAxOC4xMzc4TDM5LjUyODIgMTguMDYyMkMzOS42MDY5IDE4LjA0MTIgMzkuNjg2NSAxOC4wMjU2IDM5Ljc2NjcgMTguMDE1NkwzOS45OTY5IDE4Wk00MC4wMDA5IDMzLjU1NTZDMzguOTkwNSAzMy41NTUxIDM4LjAxNzMgMzMuOTc4NyAzNy4yNzY1IDM0Ljc0MTFDMzYuNTM1NiAzNS41MDM2IDM2LjA4MTYgMzYuNTQ4NSAzNi4wMDU4IDM3LjY2NjdMMzUuOTk1OCAzOEwzNi4wMDU4IDM4LjMzMzRDMzYuMDU1MSAzOS4wNTQ3IDM2LjI2MjUgMzkuNzUxOCAzNi42MDk4IDQwLjM2NEMzNi45NTY5IDQwLjk3NjIgMzcuNDMzNiA0MS40ODUxIDM3Ljk5ODUgNDEuODQ2N1Y0NS43Nzc4TDM4LjAxMjUgNDYuMDM3OEMzOC4wNzI3IDQ2LjYwMDMgMzguMzI0MiA0Ny4xMTU4IDM4LjcxNTYgNDcuNDc5NEMzOS4xMDcxIDQ3Ljg0MjkgMzkuNjA4NyA0OC4wMjY5IDQwLjExODIgNDcuOTkzOEM0MC42Mjc4IDQ3Ljk2MDUgNDEuMTA2NyA0Ny43MTI3IDQxLjQ1NzEgNDcuMzAwOUM0MS44MDc2IDQ2Ljg4ODkgNDIuMDAyOSA0Ni4zNDQzIDQyLjAwMzYgNDUuNzc3OEw0Mi4wMDU2IDQxLjg0ODlDNDIuNzY5MSA0MS4zNTk2IDQzLjM2NiA0MC42MDQyIDQzLjcwMzQgMzkuNzAwMkM0NC4wNDA3IDM4Ljc5NiA0NC4wOTk2IDM3Ljc5MzggNDMuODcxMSAzNi44NDg3QzQzLjY0MjcgMzUuOTAzNiA0My4xMzk2IDM1LjA2ODUgNDIuNDM5OCAzNC40NzMxQzQxLjc0IDMzLjg3NzYgNDAuODgyNyAzMy41NTUxIDQwLjAwMDkgMzMuNTU1NloiIGZpbGw9InVybCgjcGFpbnQxX2xpbmVhcl8xXzkxKSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzFfOTEiIHgxPSI0MCIgeTE9IjAiIHgyPSI0MCIgeTI9IjgwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM4MzU2QkQiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjN0MyMEY0Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQxX2xpbmVhcl8xXzkxIiB4MT0iNDAiIHkxPSIxOCIgeDI9IjQwIiB5Mj0iNjIuNDQ0NSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSJ3aGl0ZSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNFMUQ4RkIiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
                ToolTip = l => (0, eO.jsx)($a093c7e1ec25a057$export$2881499e37b75b9a, {
                    delayDuration: 200,
                    children: (0, eO.jsxs)($a093c7e1ec25a057$export$be92b6f5f03c0fe9, {
                        children: [(0, eO.jsx)(eI, {
                            asChild: !0,
                            children: l.children
                        }), (0, eO.jsx)($a093c7e1ec25a057$export$602eac185826482c, {
                            children: (0, eO.jsxs)(eU, {
                                sideOffset: l.sideOffset || 6,
                                align: l.align,
                                side: l.side,
                                children: [l.tip, (0, eO.jsx)(eF, {})]
                            })
                        })]
                    })
                }),
                eB = U.F4 `
from {
  opacity: 0;
  transform: translateY(2px);
}
to {
  opacity: 1;
  transform: translateY(0);
}
`,
                eU = (0, Z.Z)(eS)
            `
  background: ${l=>l.theme.colors.tooltipBg};
  color: ${l=>l.theme.colors.tooltipText};
  border-radius: ${N.d.sm};
  line-height: 1;
  padding: ${N.s.sm} ${N.s.md};
  font-size: ${N.f.sm};
  box-shadow: ${N.p.sm};
  user-select: none;
  will-change: transform, opacity;
  animation: ${eB} 200ms cubic-bezier(0.16, 1, 0.3, 1);
  z-index: 999999999999999;
  max-width: 300px;
  line-height: 1.5;
`, eF = (0, Z.Z)(ej)
            `
  fill: ${l=>l.theme.colors.tooltipBg};
`
        },
        67327: function(l, c, x) {
            "use strict";
            x.d(c, {
                A: function() {
                    return eX
                },
                B: function() {
                    return ev
                },
                C: function() {
                    return Container
                },
                D: function() {
                    return Img
                },
                E: function() {
                    return eD
                },
                F: function() {
                    return ej
                },
                G: function() {
                    return eZ
                },
                H: function() {
                    return eR
                },
                I: function() {
                    return ew
                },
                J: function() {
                    return TOS
                },
                K: function() {
                    return WalletSelector
                },
                L: function() {
                    return eE
                },
                M: function() {
                    return ModalHeader
                },
                O: function() {
                    return WalletUIStatesProvider
                },
                P: function() {
                    return isAndroid
                },
                Q: function() {
                    return isIOS
                },
                R: function() {
                    return e0
                },
                S: function() {
                    return Spacer
                },
                T: function() {
                    return eG
                },
                U: function() {
                    return eT
                },
                V: function() {
                    return ex
                },
                W: function() {
                    return WalletEntryButton
                },
                X: function() {
                    return WalletSelection
                },
                a: function() {
                    return eM
                },
                b: function() {
                    return eA
                },
                c: function() {
                    return Spinner
                },
                d: function() {
                    return ef
                },
                e: function() {
                    return isMobile
                },
                f: function() {
                    return eh
                },
                g: function() {
                    return eI
                },
                h: function() {
                    return eJ
                },
                i: function() {
                    return em
                },
                j: function() {
                    return eW
                },
                m: function() {
                    return useSetIsWalletModalOpen
                },
                n: function() {
                    return eS
                },
                o: function() {
                    return eg
                },
                p: function() {
                    return eb
                },
                q: function() {
                    return ek
                },
                r: function() {
                    return eO
                },
                s: function() {
                    return ey
                },
                t: function() {
                    return eP
                },
                u: function() {
                    return useIsWalletModalOpen
                },
                v: function() {
                    return ez
                },
                w: function() {
                    return eL
                },
                x: function() {
                    return eB
                },
                y: function() {
                    return ep
                },
                z: function() {
                    return ed
                }
            });
            var N = x(99538),
                U = x(36530),
                Z = x(8801),
                $ = x(57437),
                Y = x(2265),
                q = x(41282),
                J = x(69394),
                X = x(23743),
                en = x(69954);
            let er = {
                    mauve9: "hsl(252, 4.0%, 45.2%)",
                    mauve10: "hsl(247, 3.4%, 50.7%)",
                    mauve12: "hsl(256, 6.0%, 93.2%)"
                },
                ea = {
                    green8: "hsl(151, 40.2%, 54.1%)",
                    green9: "hsl(151, 55.0%, 41.5%)"
                },
                eo = {
                    mauve1: "hsl(300, 20.0%, 99.0%)",
                    mauve3: "hsl(294, 5.5%, 95.3%)",
                    mauve5: "hsl(283, 4.4%, 91.3%)",
                    mauve6: "hsl(278, 4.1%, 89.1%)",
                    mauve12: "hsl(260, 25.0%, 11.0%)"
                },
                el = {
                    tomato9: "hsl(10, 78.0%, 54.0%)"
                },
                ec = {
                    base1: "hsl(230deg 11.63% 8.43%)",
                    base2: "hsl(230deg 11.63% 12%)",
                    base3: "hsl(230deg 11.63% 15%)",
                    base4: "hsl(230deg 11.63% 17%)",
                    primaryText: er.mauve12,
                    secondaryText: er.mauve10,
                    danger: el.tomato9,
                    success: ea.green8,
                    overlay: "rgba(0, 0, 0, 0.7)",
                    accentText: "#3385FF",
                    accentBg: "hsl(216 100% 50%)",
                    textOnAccent: er.mauve12
                },
                eu = {
                    base1: eo.mauve1,
                    base2: eo.mauve3,
                    base3: eo.mauve5,
                    base4: eo.mauve6,
                    primaryText: eo.mauve12,
                    secondaryText: er.mauve9,
                    accentText: "hsl(216 100% 45%)",
                    success: ea.green9,
                    danger: el.tomato9,
                    overlay: "rgba(0, 0, 0, 0.7)",
                    accentBg: "hsl(216 100% 50%)",
                    textOnAccent: eo.mauve1
                };

            function createThemeObj(l) {
                return {
                    type: "dark",
                    colors: {
                        primaryText: l.primaryText,
                        secondaryText: l.secondaryText,
                        accentText: l.accentText,
                        danger: l.danger,
                        success: l.success,
                        modalOverlayBg: l.overlay,
                        accentButtonBg: l.accentBg,
                        accentButtonText: l.textOnAccent,
                        primaryButtonBg: l.primaryText,
                        primaryButtonText: l.base1,
                        secondaryButtonBg: l.base3,
                        secondaryButtonText: l.primaryText,
                        secondaryButtonHoverBg: l.base4,
                        modalBg: l.base1,
                        dropdownBg: l.base1,
                        tooltipBg: l.primaryText,
                        tooltipText: l.base1,
                        inputAutofillBg: l.base2,
                        scrollbarBg: l.base2,
                        walletSelectorButtonHoverBg: l.base2,
                        separatorLine: l.base3,
                        secondaryIconColor: l.secondaryText,
                        secondaryIconHoverBg: l.base3,
                        secondaryIconHoverColor: l.primaryText,
                        borderColor: l.base3,
                        skeletonBg: l.base3,
                        selectedTextColor: l.base1,
                        selectedTextBg: l.primaryText,
                        connectedButtonBg: l.base1,
                        connectedButtonBgHover: l.base2
                    },
                    fontFamily: "inherit"
                }
            }
            let ed = createThemeObj(ec),
                ep = createThemeObj(eu),
                eh = {
                    xs: "12px",
                    sm: "14px",
                    md: "16px",
                    lg: "20px",
                    xl: "24px"
                },
                ey = {
                    xxs: "6px",
                    xs: "8px",
                    sm: "12px",
                    md: "16px",
                    lg: "24px",
                    xl: "32px",
                    xxl: "48px"
                },
                ef = {
                    sm: "6px",
                    md: "8px",
                    lg: "12px",
                    xl: "20px",
                    xxl: "32px"
                },
                em = {
                    xs: "12",
                    sm: "16",
                    md: "24",
                    lg: "32",
                    xl: "48",
                    xxl: "64"
                },
                eg = {
                    mobile: "@media (max-width: 640px)"
                },
                eb = {
                    sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
                    md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
                    lg: "0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
                    xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)"
                },
                Spacer = l => {
                    let {
                        y: c
                    } = l;
                    return (0, $.jsx)("div", {
                        style: {
                            height: ey[c]
                        }
                    })
                },
                ev = Z.Z.button `
  all: unset;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${ef.md};
  padding: ${eh.sm} ${eh.sm};
  font-size: ${eh.md};
  font-weight: 500;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  line-height: 1;
  flex-shrink: 0;
  transition: border 200ms ease;

  ${l=>l.fullWidth&&"width: 100%;"};

  background: ${l=>{switch(l.variant){case"primary":return l.theme.colors.primaryButtonBg;case"accent":return l.theme.colors.accentButtonBg;case"secondary":return l.theme.colors.secondaryButtonBg;default:return"none"}}};

  color: ${l=>{switch(l.variant){case"primary":default:return l.theme.colors.primaryButtonText;case"accent":return l.theme.colors.accentButtonText;case"secondary":case"outline":return l.theme.colors.secondaryButtonText;case"link":return l.theme.colors.accentText}}};

  ${l=>{if("outline"===l.variant)return`
      border: 1.5px solid ${l.theme.colors.borderColor};
      &:hover {
        border-color: ${l.theme.colors.accentText};
      }
    `}}

  ${l=>{if("link"===l.variant)return`
      padding: 0;
      &:hover {
        color: ${l.theme.colors.primaryText};
      }`}}

  /* pressed effect */
  &:active {
    transform: translateY(1px);
  }

  &[disabled] {
    cursor: not-allowed;
  }
`,
                ew = Z.Z.button `
  all: unset;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: ${ef.sm};
  -webkit-tap-highlight-color: transparent;
  color: ${l=>l.theme.colors.secondaryIconColor};
  padding: 2px;
  transition:
    background 0.2s ease,
    color 0.2s ease;

  &:hover {
    background: ${l=>l.theme.colors.secondaryIconHoverBg};
    color: ${l=>l.theme.colors.secondaryIconHoverColor};
  }
`,
                eT = Z.Z.button `
  all: unset;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: ${ef.sm};
  padding: ${ey.sm};
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  color: ${l=>l.theme.colors.secondaryText};
  &:hover {
    color: ${l=>l.theme.colors.primaryText};
  }
  &[disabled] {
    cursor: not-allowed;
  }
`,
                eM = Z.Z.h2 `
  margin: 0;
  font-weight: 600;
  font-size: ${eh.lg};
  color: ${l=>l.theme.colors.primaryText};
  line-height: 1.3;
  text-align: left;
  ${eg.mobile} {
    text-align: ${l=>l.centerOnMobile?"center":"left"};
  }
`,
                eI = Z.Z.p `
  all: unset;
  display: block;
  font-size: ${l=>l.sm?eh.sm:eh.md};
  color: ${l=>l.theme.colors.secondaryText};
  line-height: 1.5;
  ${eg.mobile} {
    text-align: ${l=>l.centerOnMobile?"center":"left"};
  }
`,
                BackButton = l => (0, $.jsx)(ew, {
                    onClick: l.onClick,
                    style: {
                        transform: "translateX(-25%)",
                        ...l.style
                    },
                    type: "button",
                    children: (0, $.jsx)(J.wyc, {
                        style: {
                            width: em.md,
                            height: em.md
                        }
                    })
                }),
                ex = Z.Z.a `
  all: unset;
  cursor: pointer;
  color: ${l=>l.theme.colors.accentText};
  font-size: ${l=>l.md?eh.md:eh.sm};
  text-decoration: none;
  display: block;
  line-height: 1.5;
  ${eg.mobile} {
    text-align: center;
  }
  &:hover {
    color: ${l=>l.theme.colors.primaryText};
    text-decoration: none;
  }
`,
                Img = l => {
                    let c = (0, q.y$C)();
                    return (0, $.jsx)("img", {
                        width: l.width,
                        height: l.height,
                        src: (() => {
                            try {
                                return c ? c.resolveScheme(l.src) : l.src.replace("ipfs://", "https://ipfs.io/ipfs/")
                            } catch {
                                return l.src
                            }
                        })(),
                        alt: l.alt || "",
                        loading: l.loading,
                        decoding: "async",
                        style: {
                            height: l.height ? l.height + "px" : void 0,
                            width: l.width ? l.width + "px" : void 0,
                            userSelect: "none",
                            ...l.style
                        },
                        draggable: !1,
                        className: l.className
                    })
                },
                eC = N.F4 `
  from {
    opacity: 0;
    transform: translateY(20%) scale(0.8) ;
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`,
                e_ = N.F4 `
  from {
    opacity: 0;
    transform: translateY(-20%) scale(0.8) ;
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`,
                eD = N.F4 `
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`,
                eS = Z.Z.div `
  border-top: 1px solid ${l=>l.theme.colors.separatorLine};
  display: flex;
  flex-direction: column;
  gap: ${ey.lg};
  padding: ${ey.lg};
`,
                ek = `
scrollbar-width: none;
&::-webkit-scrollbar {
  width: 0px;
  display: none;
}
`;

            function ModalHeader(l) {
                let {
                    onBack: c,
                    title: x,
                    imgSrc: N
                } = l;
                return (0, $.jsxs)("div", {
                    style: {
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        position: "relative"
                    },
                    children: [c && (0, $.jsx)(BackButton, {
                        onClick: c,
                        style: {
                            position: "absolute",
                            left: 0,
                            top: 0
                        }
                    }), (0, $.jsxs)(Container, {
                        flex: "row",
                        gap: "xs",
                        center: "both",
                        children: [N && (0, $.jsx)(Img, {
                            src: N,
                            width: em.md,
                            height: em.md
                        }), "string" == typeof x ? (0, $.jsx)(eM, {
                            children: x
                        }) : x]
                    })]
                })
            }
            let eE = Z.Z.div `
  height: 1px;
  background: ${l=>l.theme.colors.separatorLine};
`;

            function Container(l) {
                let c = {};
                return l.relative && (c.position = "relative"), l.fullHeight && (c.height = "100%"), l.expand && (c.flex = "1 1 0%"), l.flex && (c.display = "flex", c.flexDirection = l.flex, "row" === l.flex && (c.flexWrap = "wrap"), l.gap && (c.gap = ey[l.gap]), l.center && ("both" === l.center && (c.justifyContent = "center", c.alignItems = "center"), ("x" === l.center && "row" === l.flex || "y" === l.center && "column" === l.flex) && (c.justifyContent = "center"), ("x" === l.center && "column" === l.flex || "y" === l.center && "row" === l.flex) && (c.alignItems = "center"))), l.p && (c.padding = ey[l.p]), l.px && (c.paddingLeft = ey[l.px], c.paddingRight = ey[l.px]), l.debug && (c.outline = "1px solid red", c.outlineOffset = "-1px"), (0, $.jsx)(eN, {
                    "data-scrolly": l.scrollY,
                    "data-animate": l.animate,
                    color: l.color,
                    style: { ...c,
                        ...l.style
                    },
                    children: l.children
                })
            }
            let eN = Z.Z.div `
  color: ${l=>l.color?l.theme.colors[l.color]:"inherit"};

  &[data-animate="fadein"] {
    opacity: 0;
    animation: ${eD} 350ms ease forwards;
  }

  &[data-animate="floatup"] {
    opacity: 0;
    animation: ${eC} 350ms ease forwards;
  }

  &[data-animate="floatdown"] {
    opacity: 0;
    animation: ${e_} 350ms ease forwards;
  }

  &[data-scrolly="true"] {
    overflow-y: auto;
    ${ek}
  }
`;

            function isAndroid() {
                let l = detectOS();
                return !!l && l.toLowerCase().includes("android")
            }

            function isIOS() {
                let l = detectOS();
                return !!l && (l.toLowerCase().includes("ios") || l.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1)
            }

            function detectOS() {
                let l = (0, en.qY)(void 0);
                return l ? .os ? l.os : void 0
            }

            function isMobile() {
                let l = detectOS();
                return !!l && (isAndroid() || isIOS())
            }
            let eA = Z.Z.span `
  font-size: ${l=>eh[l.size||"md"]};
  color: ${l=>l.theme.colors[l.color||"secondaryText"]};
  margin: 0;
  display: ${l=>l.inline?"inline":"block"};
  font-weight: ${l=>l.weight||500};
  line-height: ${l=>l.multiline?1.5:1};
  ${l=>l.center?"text-align: center;":""};
  text-wrap: ${l=>l.balance?"balance":"inherit"};
`,
                ej = Z.Z.a `
  all: unset;
  cursor: pointer;
  color: ${l=>l.theme.colors[l.color||"accentText"]};
  font-size: ${l=>eh[l.size||"md"]};
  text-decoration: none;
  text-align: ${l=>l.center?"center":"left"};
  display: ${l=>l.inline?"inline":"block"};
  font-weight: ${l=>l.weight||500};
  line-height: 1;
  transition: color 0.2s ease;

  &:hover {
    color: ${l=>l.theme.colors[l.hoverColor||"primaryText"]};
    text-decoration: none;
  }
`,
                eO = {
                    main: "main",
                    getStarted: "getStarted"
                },
                eP = "360px",
                ez = "730px",
                eR = "Connect",
                eL = "550px",
                eB = "600px",
                eU = (0, Y.createContext)(!1),
                eF = (0, Y.createContext)(void 0),
                eW = (0, Y.createContext)({
                    title: "",
                    theme: "dark",
                    data: void 0,
                    modalSize: "wide"
                }),
                eZ = (0, Y.createContext)(() => {}),
                WalletUIStatesProvider = l => {
                    let [c, x] = (0, Y.useState)(!1), N = isMobile(), [U, Z] = (0, Y.useState)({
                        title: l.title || eR,
                        theme: l.theme || "dark",
                        data: void 0,
                        modalSize: (N ? "compact" : l.modalSize) || "wide",
                        termsOfServiceUrl: l.termsOfServiceUrl,
                        privacyPolicyUrl: l.privacyPolicyUrl,
                        welcomeScreen: l.welcomeScreen,
                        titleIconUrl: l.titleIconUrl
                    });
                    return (0, $.jsx)(eU.Provider, {
                        value: c,
                        children: (0, $.jsx)(eF.Provider, {
                            value: x,
                            children: (0, $.jsx)(eW.Provider, {
                                value: U,
                                children: (0, $.jsx)(eZ.Provider, {
                                    value: Z,
                                    children: l.children
                                })
                            })
                        })
                    })
                },
                useIsWalletModalOpen = () => (0, Y.useContext)(eU),
                useSetIsWalletModalOpen = () => {
                    let l = (0, Y.useContext)(eF);
                    if (void 0 === l) throw Error("useSetWalletModalOpen must be used within a ThirdwebProvider");
                    return l
                },
                Spinner = l => {
                    let c = (0, U.u)();
                    return (0, $.jsx)(e$, {
                        style: {
                            width: em[l.size],
                            height: em[l.size]
                        },
                        viewBox: "0 0 50 50",
                        children: (0, $.jsx)(eY, {
                            cx: "25",
                            cy: "25",
                            r: "20",
                            fill: "none",
                            stroke: c.colors[l.color],
                            strokeWidth: "4"
                        })
                    })
                },
                eQ = N.F4 `
 0% {
    stroke-dasharray: 1, 150;
    stroke-dashoffset: 0;
  }
  50% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -35;
  }
  100% {
    stroke-dasharray: 90, 150;
    stroke-dashoffset: -124;
  }
`,
                eH = N.F4 `
100% {
    transform: rotate(360deg);
  }
`,
                e$ = Z.Z.svg `
  animation: ${eH} 2s linear infinite;
  width: 1em;
  height: 1em;
`,
                eY = Z.Z.circle `
  stroke-linecap: round;
  animation: ${eQ} 1.5s ease-in-out infinite;
`,
                TWIcon = l => (0, $.jsxs)("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: l.size,
                    height: l.size,
                    viewBox: "0 0 27 16",
                    fill: "none",
                    children: [(0, $.jsx)("path", {
                        d: "M13.6891 0C13.8482 0.0317795 13.9983 0.0957213 14.1292 0.1875C14.2768 0.297724 14.39 0.444328 14.4563 0.611413C14.8718 1.60272 15.2885 2.59348 15.7064 3.5837L17.0986 6.89022C17.3418 7.46902 17.5832 8.0462 17.8298 8.62337C17.8823 8.74121 17.9094 8.86791 17.9094 8.99592C17.9094 9.12393 17.8823 9.25064 17.8298 9.36848C17.1243 11.0446 16.4182 12.7217 15.7115 14.4C15.654 14.5572 15.5516 14.696 15.4157 14.8009C15.2799 14.9057 15.1161 14.9724 14.9426 14.9935C14.7283 15.0315 14.5068 14.9982 14.3153 14.899C14.1238 14.7998 13.9741 14.6409 13.8912 14.4489C13.4939 13.5196 13.1052 12.587 12.713 11.6543C12.0463 10.075 11.3813 8.49456 10.718 6.91304C10.1255 5.50543 9.5336 4.09891 8.94223 2.69348C8.7453 2.22717 8.55522 1.75761 8.34973 1.29293C8.29321 1.16705 8.26644 1.03087 8.27132 0.894047C8.27619 0.757221 8.31259 0.623087 8.37794 0.501137C8.44329 0.379187 8.53599 0.272402 8.64948 0.188339C8.76297 0.104275 8.89448 0.0449885 9.03471 0.0146733C9.05183 0.0146733 9.06724 0.0048913 9.08437 0H13.6891Z",
                        fill: "currentColor"
                    }), (0, $.jsx)("path", {
                        d: "M5.42129 0C5.47438 0.0146739 5.52575 0.0260873 5.57712 0.0423917C5.71022 0.0819151 5.83236 0.14928 5.93458 0.239555C6.0368 0.329829 6.11653 0.440727 6.16791 0.56413C6.62457 1.63913 7.07779 2.71413 7.52759 3.78913C7.97739 4.86413 8.43404 5.95109 8.89755 7.05L9.57053 8.64456C9.62093 8.75806 9.6469 8.88004 9.6469 9.00326C9.6469 9.12648 9.62093 9.24846 9.57053 9.36196C9.32052 9.9587 9.06936 10.5565 8.81706 11.1554L7.43512 14.431C7.36255 14.6012 7.23853 14.7471 7.07879 14.8501C6.91904 14.9532 6.73075 15.0087 6.5378 15.0098C6.33426 15.0125 6.13478 14.9554 5.96654 14.8463C5.7983 14.7372 5.6695 14.5814 5.59767 14.4C5.16956 13.3712 4.74145 12.344 4.30307 11.3168L2.54781 7.14946L0.763448 2.91033C0.539118 2.37554 0.314789 1.83913 0.0784718 1.30435C-0.0212674 1.08161 -0.026107 0.830668 0.0649731 0.604591C0.156053 0.378515 0.335913 0.195028 0.566519 0.0929347C0.650596 0.0604572 0.73701 0.0337587 0.825096 0.0130438L5.42129 0Z",
                        fill: "currentColor"
                    }), (0, $.jsx)("path", {
                        d: "M26.0098 9.14348C25.8865 9.54782 25.7067 9.92935 25.5355 10.3239C25.0708 11.4315 24.6033 12.5397 24.133 13.6484C24.0251 13.9109 23.9155 14.1554 23.811 14.4114C23.7364 14.591 23.605 14.744 23.4351 14.8495C23.2651 14.9549 23.065 15.0075 22.8623 15C22.6689 14.995 22.4813 14.9353 22.3237 14.8284C22.166 14.7216 22.0453 14.5724 21.977 14.4C21.2989 12.7848 20.6196 11.1696 19.9392 9.55435C19.3524 8.16522 18.7633 6.77283 18.172 5.37717C17.6011 4.01087 17.0303 2.64456 16.4595 1.27826C16.4042 1.15338 16.3784 1.01844 16.3839 0.882999C16.3895 0.747561 16.4262 0.614939 16.4916 0.494528C16.5569 0.374117 16.6493 0.268861 16.7621 0.186219C16.875 0.103577 17.0055 0.0455688 17.1445 0.0163041L17.201 0H21.8023L21.8451 0.0130438C22.0073 0.0455066 22.158 0.116718 22.2833 0.219974C22.4085 0.32323 22.504 0.455132 22.5609 0.60326C22.8281 1.23913 23.0964 1.87554 23.3658 2.5125C24.0679 4.18206 24.77 5.85163 25.4721 7.52119C25.657 7.96141 25.8625 8.39348 26.0132 8.84511L26.0098 9.14348Z",
                        fill: "currentColor"
                    })]
                }),
                eG = Z.Z.div `
  display: flex;
  align-items: center;
  color: ${l=>l.theme.colors.secondaryText};
  font-size: ${eh.sm};
  &::before,
  &::after {
    content: "";
    flex: 1;
    border-bottom: 1px solid ${l=>l.theme.colors.separatorLine};
  }

  span {
    margin: 0 1rem;
  }
`;

            function TOS(l) {
                let {
                    termsOfServiceUrl: c,
                    privacyPolicyUrl: x
                } = l;
                return c || x ? (0, $.jsx)(Container, {
                    flex: "row",
                    center: "x",
                    children: (0, $.jsxs)(eA, {
                        size: "xs",
                        multiline: !0,
                        balance: !0,
                        inline: !0,
                        center: !0,
                        style: {
                            maxWidth: "250px"
                        },
                        children: ["By connecting, you agree to the", " ", c && (0, $.jsxs)(ej, {
                            inline: !0,
                            size: "xs",
                            href: c,
                            target: "_blank",
                            style: {
                                whiteSpace: "nowrap"
                            },
                            children: [" ", "Terms of Service", " "]
                        }), c && x && "& ", x && (0, $.jsx)(ej, {
                            inline: !0,
                            size: "xs",
                            href: x,
                            target: "_blank",
                            children: "Privacy Policy"
                        })]
                    })
                }) : null
            }
            let WalletSelector = l => {
                    let c = (0, Y.useContext)(eW),
                        x = "compact" === c.modalSize,
                        {
                            termsOfServiceUrl: N,
                            privacyPolicyUrl: U
                        } = c,
                        [Z, J] = (0, Y.useState)(!1),
                        en = (0, q.qL0)(),
                        er = (0, q.pX8)(),
                        ea = l.walletConfigs.find(l => l.id === X.w.localWallet),
                        eo = l.walletConfigs.filter(l => l.id !== X.w.localWallet),
                        el = eo.filter(l => "socialLogin" === l.category),
                        ec = sortWalletConfigs(eo.filter(l => "socialLogin" !== l.category)),
                        eu = x && (0 === el.length || Z),
                        ed = x && el.length >= 1 && ec.length >= 2,
                        ep = x && (N || U),
                        eh = !!(!ed && ea || eu),
                        ef = ea && (0, $.jsx)(ev, {
                            fullWidth: !0,
                            variant: x ? "outline" : "link",
                            style: x ? void 0 : {
                                textAlign: "left",
                                justifyContent: "flex-start"
                            },
                            onClick: () => {
                                l.selectWallet(ea)
                            },
                            "data-test": "continue-as-guest-button",
                            children: "Continue as Guest"
                        }),
                        eg = (0, Y.useRef)(!1);
                    (0, Y.useEffect)(() => {
                        setTimeout(() => {
                            eg.current = !0
                        }, 1e3)
                    }, []);
                    let eb = (0, $.jsxs)(Container, {
                            gap: "xxs",
                            center: "y",
                            flex: "row",
                            children: [void 0 === c.titleIconUrl ? (0, $.jsx)(ej, {
                                color: "primaryText",
                                hoverColor: "accentText",
                                target: "_blank",
                                href: "https://thirdweb.com/connect?utm_source=cw",
                                style: {
                                    display: "flex",
                                    alignItems: "center"
                                },
                                onClick: l => {
                                    eg.current || l.preventDefault()
                                },
                                children: (0, $.jsx)(TWIcon, {
                                    size: em.md
                                })
                            }) : "" === c.titleIconUrl ? null : (0, $.jsx)(Img, {
                                src: c.titleIconUrl,
                                width: em.md,
                                height: em.md
                            }), (0, $.jsxs)(eM, {
                                children: [" ", l.title, " "]
                            })]
                        }),
                        handleSelect = async c => {
                            "disconnected" !== er && await en(), l.selectWallet(c)
                        },
                        ew = eu && !ef && ep;
                    return (0, $.jsxs)(Container, {
                        scrollY: !0,
                        flex: "column",
                        animate: "fadein",
                        fullHeight: !0,
                        children: [(0, $.jsx)(Container, {
                            p: "lg",
                            children: Z ? (0, $.jsx)(ModalHeader, {
                                title: eb,
                                onBack: () => {
                                    J(!1)
                                }
                            }) : eb
                        }), (0, $.jsx)(Container, {
                            expand: !0,
                            scrollY: !0,
                            px: 1 === eo.length ? "lg" : "md",
                            style: {
                                paddingTop: "2px"
                            },
                            children: ed ? (0, $.jsx)($.Fragment, {
                                children: Z ? (0, $.jsx)(WalletSelection, {
                                    walletConfigs: ec,
                                    selectWallet: handleSelect
                                }) : (0, $.jsxs)(Container, {
                                    px: "xs",
                                    children: [(0, $.jsx)(WalletSelection, {
                                        walletConfigs: el,
                                        selectWallet: handleSelect
                                    }), (0, $.jsx)(eG, {
                                        children: (0, $.jsx)("span", {
                                            children: " OR "
                                        })
                                    }), (0, $.jsx)(Spacer, {
                                        y: "lg"
                                    }), (0, $.jsxs)(ev, {
                                        fullWidth: !0,
                                        variant: "outline",
                                        style: {
                                            display: "flex",
                                            justifyContent: "center",
                                            gap: ey.sm,
                                            padding: ey.md
                                        },
                                        onClick: () => {
                                            J(!0)
                                        },
                                        children: [(0, $.jsx)(Container, {
                                            flex: "row",
                                            gap: "xxs",
                                            children: ec.slice(0, 2).map(l => (0, $.jsx)(Img, {
                                                width: em.sm,
                                                height: em.sm,
                                                src: l.meta.iconURL
                                            }, l.id))
                                        }), "Connect a wallet"]
                                    }), ef ? (0, $.jsxs)($.Fragment, {
                                        children: [(0, $.jsx)(Spacer, {
                                            y: "md"
                                        }), ef, (0, $.jsx)(Spacer, {
                                            y: "xl"
                                        })]
                                    }) : (0, $.jsx)(Spacer, {
                                        y: "xl"
                                    })]
                                })
                            }) : (0, $.jsx)(WalletSelection, {
                                walletConfigs: eo,
                                selectWallet: handleSelect
                            })
                        }), eh && (0, $.jsxs)(eS, {
                            children: [eu && (0, $.jsxs)(Container, {
                                flex: "row",
                                style: {
                                    justifyContent: "space-between"
                                },
                                children: [(0, $.jsx)(eA, {
                                    color: "secondaryText",
                                    size: "sm",
                                    weight: 500,
                                    children: "New to wallets?"
                                }), (0, $.jsx)(ej, {
                                    weight: 500,
                                    size: "sm",
                                    target: "_blank",
                                    href: "https://blog.thirdweb.com/web3-wallet/",
                                    children: "Get started"
                                })]
                            }), !ed && ef]
                        }), ep && !Z && (0, $.jsxs)("div", {
                            children: [ew && (0, $.jsx)(eE, {}), (0, $.jsx)(Container, {
                                p: "md",
                                style: ew ? void 0 : {
                                    paddingTop: 0
                                },
                                children: x && (0, $.jsx)(TOS, {
                                    termsOfServiceUrl: N,
                                    privacyPolicyUrl: U
                                })
                            })]
                        })]
                    })
                },
                WalletSelection = l => {
                    let c = (0, Y.useContext)(eW),
                        x = (0, Y.useContext)(eZ),
                        N = sortWalletConfigs(l.walletConfigs);
                    return (0, $.jsx)(eV, {
                        children: N.map(N => (0, $.jsx)("li", {
                            "data-full-width": !!N.selectUI,
                            children: N.selectUI ? (0, $.jsx)(N.selectUI, {
                                modalSize: c.modalSize,
                                theme: "string" == typeof c.theme ? c.theme : c.theme.type,
                                supportedWallets: l.walletConfigs,
                                onSelect: c => {
                                    l.selectWallet(N), x(l => ({ ...l,
                                        data: c
                                    }))
                                },
                                walletConfig: N
                            }) : (0, $.jsx)(WalletEntryButton, {
                                walletConfig: N,
                                selectWallet: () => {
                                    l.selectWallet(N)
                                }
                            })
                        }, N.id))
                    })
                };

            function WalletEntryButton(l) {
                let {
                    walletConfig: c,
                    selectWallet: x
                } = l, N = c.recommended;
                return (0, $.jsxs)(eK, {
                    type: "button",
                    onClick: () => {
                        x()
                    },
                    children: [(0, $.jsx)(Img, {
                        src: c.meta.iconURL,
                        width: em.xl,
                        height: em.xl,
                        loading: "eager"
                    }), (0, $.jsxs)(Container, {
                        flex: "column",
                        gap: "xxs",
                        expand: !0,
                        children: [(0, $.jsx)(eA, {
                            color: "primaryText",
                            weight: 600,
                            children: c.meta.name
                        }), N && (0, $.jsx)(eA, {
                            size: "sm",
                            children: "Recommended"
                        }), !N && c.isInstalled && c.isInstalled() && (0, $.jsx)(eA, {
                            size: "sm",
                            children: "Installed"
                        })]
                    })]
                })
            }
            let eV = Z.Z.ul `
  all: unset;
  list-style-type: none;
  display: flex;
  flex-direction: column;
  gap: 2px;
  box-sizing: border-box;
  overflow-y: auto;
  flex: 1;
  ${ek}

  /* to show the box-shadow of inputs that overflows  */
  padding: 2px;
  margin: -2px;
  padding-bottom: 0;
  margin-bottom: 0;
  padding-bottom: ${ey.xl};
`,
                eK = Z.Z.button `
  all: unset;
  display: flex;
  align-items: center;
  gap: ${ey.sm};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  color: ${l=>l.theme.colors.secondaryText};
  position: relative;
  border-radius: ${ef.md};
  padding: ${ey.xs} ${ey.xs};

  &:hover {
    background-color: ${l=>l.theme.colors.walletSelectorButtonHoverBg};
  }

  transition:
    background-color 200ms ease,
    transform 200ms ease;

  &:hover {
    transform: scale(1.01);
  }
`;

            function sortWalletConfigs(l) {
                return l.sort((l, c) => {
                    let x = !!l.isInstalled && l.isInstalled(),
                        N = !!c.isInstalled && c.isInstalled();
                    return x && !N ? -1 : !x && N ? 1 : 0
                }).sort((l, c) => l.recommended && !c.recommended ? -1 : !l.recommended && c.recommended ? 1 : 0).sort((l, c) => l.selectUI && !c.selectUI ? -1 : !l.selectUI && c.selectUI ? 1 : 0)
            }
            let eJ = Z.Z.label `
  font-size: ${eh.sm};
  color: ${l=>l.theme.colors[l.color||"primaryText"]};
  display: block;
`,
                eX = Z.Z.input `
  font-size: ${eh.md};
  display: block;
  padding: ${l=>l.sm?ey.sm:eh.sm};
  box-sizing: border-box;
  width: 100%;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${l=>l.theme.colors.primaryText};
  -webkit-appearance: none;
  appearance: none;
  background: transparent;

  &::placeholder {
    color: ${l=>l.theme.colors.secondaryText};
  }

  box-shadow: 0 0 0 1.5px
    ${l=>"outline"===l.variant?l.theme.colors.borderColor:"transparent"};

  /* when browser auto-fills the input  */
  &:-webkit-autofill {
    -webkit-text-fill-color: ${l=>l.theme.colors.primaryText};
    -webkit-box-shadow: 0 0 0px 1000px ${l=>l.theme.colors.inputAutofillBg}
      inset !important;
    box-shadow: 0 0 0px 1000px ${l=>l.theme.colors.inputAutofillBg} inset !important;
    transition: background-color 5000s ease-in-out 0s;
  }

  &:-webkit-autofill:focus {
    -webkit-box-shadow:
      0 0 0px 1000px ${l=>l.theme.colors.inputAutofillBg} inset,
      0 0 0 2px ${l=>l.theme.colors.accentText} !important;
    box-shadow:
      0 0 0px 1000px ${l=>l.theme.colors.inputAutofillBg} inset,
      0 0 0 2px ${l=>l.theme.colors.accentText} !important;
  }

  &:focus {
    box-shadow: 0 0 0 2px ${l=>l.theme.colors.accentText};
  }

  /* show overflow ellipsis for long text - but not if it's a type="password"  */
  &:not([type="password"]) {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  &[data-error="true"] {
    box-shadow: 0 0 0 2px ${l=>l.theme.colors.danger} !important;
  }

  &[disabled] {
    cursor: not-allowed;
  }

  &[type="number"]::-webkit-outer-spin-button,
  &[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  &[type="number"] {
    appearance: none;
    -moz-appearance: textfield;
  }
`,
                e0 = Z.Z.div `
  display: flex;
  border-radius: ${ef.sm};
  box-shadow: 0 0 0px 1.5px ${l=>l.theme.colors.borderColor};

  /* show focus ring on container instead of input  */
  &:focus-within {
    box-shadow: 0 0 0px 2px ${l=>l.theme.colors.accentText};
  }

  input:focus {
    box-shadow: none;
  }

  /* show error ring on container instead of input  */
  &[data-error="true"] {
    box-shadow: 0 0 0px 2px ${l=>l.theme.colors.danger};
  }
`
        },
        54844: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                B: function() {
                    return eL
                },
                C: function() {
                    return ConnectingScreen
                },
                F: function() {
                    return FormFieldWithIconButton
                },
                G: function() {
                    return GetStartedScreen
                },
                H: function() {
                    return HeadlessConnectUI
                },
                Q: function() {
                    return QRCode
                },
                R: function() {
                    return e$
                },
                T: function() {
                    return eZ
                },
                W: function() {
                    return WalletLogoSpinner
                },
                a: function() {
                    return walletConnect
                },
                b: function() {
                    return FormField
                },
                c: function() {
                    return coinbaseWallet
                },
                d: function() {
                    return eY
                },
                e: function() {
                    return eB
                },
                f: function() {
                    return eU
                },
                g: function() {
                    return eF
                },
                m: function() {
                    return metamaskWallet
                },
                o: function() {
                    return openWindow
                },
                p: function() {
                    return phantomWallet
                },
                r: function() {
                    return rainbowWallet
                },
                t: function() {
                    return trustWallet
                },
                w: function() {
                    return wait
                },
                z: function() {
                    return zerionWallet
                }
            });
            var N = x(53061),
                U = x(64140),
                Z = x(23743),
                $ = x(33883),
                Y = x(67133);
            x(11953), x(9409), window.Buffer = Y.Buffer;
            let CoinbaseWallet = class CoinbaseWallet extends $.a {
                get walletName() {
                    return "Coinbase Wallet"
                }
                constructor(l) {
                    super(CoinbaseWallet.id, l), this.headlessMode = l ? .headlessMode || !1, this.theme = l ? .theme || !1 === this.dappMetadata.isDarkMode ? "light" : "dark"
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            CoinbaseWalletConnector: l
                        } = await x.e(1323).then(x.bind(x, 21323)), c = new l({
                            chains: this.chains,
                            options: {
                                appName: this.dappMetadata.name,
                                reloadOnDisconnect: !1,
                                darkMode: "dark" === this.theme,
                                headlessMode: this.headlessMode
                            }
                        });
                        c.on("connect", () => {}), this.coinbaseConnector = c, this.connector = new U.W(c)
                    }
                    return this.connector
                }
                async getQrUrl() {
                    if (await this.getConnector(), !this.coinbaseConnector) throw Error("Coinbase connector not initialized");
                    return this.coinbaseConnector.getQrUrl()
                }
            };
            (0, N._)(CoinbaseWallet, "meta", {
                iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
                name: "Coinbase Wallet",
                urls: {
                    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
                    android: "https://play.google.com/store/apps/details?id=org.toshi",
                    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
                }
            }), (0, N._)(CoinbaseWallet, "id", Z.w.coinbase);
            var q = x(23780),
                J = x(88672),
                X = x(19679),
                en = x(92060),
                er = x(75460),
                ea = x(86684),
                eo = new WeakMap,
                el = new WeakMap,
                ec = new WeakMap,
                eu = new WeakMap,
                ed = new WeakMap,
                ep = new WeakMap,
                eh = new WeakMap,
                ey = new WeakMap,
                ef = new WeakSet,
                em = new WeakSet;
            let WalletConnect = class WalletConnect extends $.a {
                get walletName() {
                    return "WalletConnect"
                }
                constructor(l) {
                    super(l ? .walletId || WalletConnect.id, l), (0, en._)(this, em), (0, en._)(this, ef), (0, er._)(this, eo, {
                        writable: !0,
                        value: void 0
                    }), (0, er._)(this, el, {
                        writable: !0,
                        value: void 0
                    }), (0, er._)(this, ec, {
                        writable: !0,
                        value: l => {
                            if (l) throw l
                        }
                    }), (0, er._)(this, eu, {
                        writable: !0,
                        value: l => {
                            if ((0, er.a)(this, el, l.provider), !(0, er.b)(this, el)) throw Error("WalletConnect provider not found after connecting.")
                        }
                    }), (0, er._)(this, ed, {
                        writable: !0,
                        value: () => {
                            (0, en.a)(this, em, _removeListeners2).call(this)
                        }
                    }), (0, er._)(this, ep, {
                        writable: !0,
                        value: async l => {
                            l.chain || l.account
                        }
                    }), (0, er._)(this, eh, {
                        writable: !0,
                        value: l => {
                            "display_uri" === l.type && this.emit("display_uri", l.data)
                        }
                    }), (0, er._)(this, ey, {
                        writable: !0,
                        value: () => {
                            this.emit("wc_session_request_sent")
                        }
                    }), this.projectId = l ? .projectId || ea.T, this.qrcode = l ? .qrcode !== !1
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            WalletConnectConnector: l
                        } = await x.e(8759).then(x.bind(x, 48759));
                        (0, er.a)(this, eo, new l({
                            chains: this.chains,
                            options: {
                                qrcode: this.qrcode,
                                projectId: this.projectId,
                                dappMetadata: this.dappMetadata,
                                storage: this.walletStorage,
                                qrModalOptions: this.options ? .qrModalOptions
                            }
                        })), this.connector = new U.W((0, er.b)(this, eo)), (0, er.a)(this, el, await (0, er.b)(this, eo).getProvider()), (0, en.a)(this, ef, _setupListeners2).call(this)
                    }
                    return this.connector
                }
                async connectWithQrCode(l) {
                    await this.getConnector();
                    let c = (0, er.b)(this, eo);
                    if (!c) throw Error("WalletConnect connector not found");
                    let x = await c.getProvider();
                    x.on("display_uri", c => {
                        l.onQrCodeUri(c)
                    }), this.connect({
                        chainId: l.chainId
                    }).then(l.onConnected)
                }
            };

            function _setupListeners2() {
                (0, er.b)(this, eo) && ((0, en.a)(this, em, _removeListeners2).call(this), (0, er.b)(this, eo).on("connect", (0, er.b)(this, eu)), (0, er.b)(this, eo).on("disconnect", (0, er.b)(this, ed)), (0, er.b)(this, eo).on("change", (0, er.b)(this, ep)), (0, er.b)(this, eo).on("message", (0, er.b)(this, eh)), er.b(this, el) ? .signer.client.on("session_request_sent", er.b(this, ey)))
            }

            function _removeListeners2() {
                (0, er.b)(this, eo) && ((0, er.b)(this, eo).removeListener("connect", (0, er.b)(this, eu)), (0, er.b)(this, eo).removeListener("disconnect", (0, er.b)(this, ed)), (0, er.b)(this, eo).removeListener("change", (0, er.b)(this, ep)), (0, er.b)(this, eo).removeListener("message", (0, er.b)(this, eh)), er.b(this, el) ? .signer.client.removeListener("session_request_sent", er.b(this, ey)))
            }(0, N._)(WalletConnect, "id", Z.w.walletConnect), (0, N._)(WalletConnect, "meta", {
                name: "WalletConnect",
                iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
            });
            let TrustWallet = class TrustWallet extends $.a {
                get walletName() {
                    return "Trust Wallet"
                }
                constructor(l) {
                    super(TrustWallet.id, l), (0, q.a)(globalThis.window) ? this.isInjected = !!globalThis.window.ethereum ? .isTrust : this.isInjected = !1
                }
                async getConnector() {
                    if (!this.connector) {
                        if (this.isInjected) {
                            let {
                                TrustConnector: l
                            } = await x.e(5056).then(x.bind(x, 85056)), c = new l({
                                chains: this.chains,
                                connectorStorage: this.walletStorage,
                                options: {
                                    shimDisconnect: !0
                                }
                            });
                            this.trustConnector = c, this.connector = new U.W(c)
                        } else {
                            let {
                                WalletConnectConnector: l
                            } = await x.e(8759).then(x.bind(x, 48759)), c = new l({
                                chains: this.chains,
                                options: {
                                    projectId: this.options ? .projectId || ea.T,
                                    storage: this.walletStorage,
                                    qrcode: this.options ? .qrcode,
                                    dappMetadata: this.dappMetadata,
                                    qrModalOptions: this.options ? .qrModalOptions
                                }
                            });
                            c.getProvider().then(l => {
                                l.signer.client.on("session_request_sent", () => {
                                    this.emit("wc_session_request_sent")
                                })
                            }), this.walletConnectConnector = c, this.connector = new U.W(c)
                        }
                    }
                    return this.connector
                }
                async connectWithQrCode(l) {
                    await this.getConnector();
                    let c = this.walletConnectConnector;
                    if (!c) throw Error("WalletConnect connector not found");
                    let x = await c.getProvider();
                    x.on("display_uri", c => {
                        l.onQrCodeUri(c)
                    }), this.connect({
                        chainId: l.chainId
                    }).then(l.onConnected)
                }
            };
            (0, N._)(TrustWallet, "meta", {
                name: "Trust Wallet",
                iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
                urls: {
                    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
                    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
                    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
                }
            }), (0, N._)(TrustWallet, "id", Z.w.trust);
            let ZerionWallet = class ZerionWallet extends $.a {
                get walletName() {
                    return "Zerion Wallet"
                }
                constructor(l) {
                    super(ZerionWallet.id, l), (0, q.a)(globalThis.window) ? this.isInjected = !!globalThis.window.ethereum ? .isZerion : this.isInjected = !1
                }
                async getConnector() {
                    if (!this.connector) {
                        if (this.isInjected) {
                            let {
                                ZerionConnector: l
                            } = await x.e(7846).then(x.bind(x, 47846)), c = new l({
                                chains: this.chains,
                                connectorStorage: this.walletStorage,
                                options: {
                                    shimDisconnect: !0
                                }
                            });
                            this.zerionConnector = c, this.connector = new U.W(c)
                        } else {
                            let {
                                WalletConnectConnector: l
                            } = await x.e(8759).then(x.bind(x, 48759)), c = new l({
                                chains: this.chains,
                                options: {
                                    projectId: this.options ? .projectId || ea.T,
                                    storage: this.walletStorage,
                                    qrcode: this.options ? .qrcode,
                                    dappMetadata: this.dappMetadata,
                                    qrModalOptions: this.options ? .qrModalOptions
                                }
                            });
                            c.getProvider().then(l => {
                                l.signer.client.on("session_request_sent", () => {
                                    this.emit("wc_session_request_sent")
                                })
                            }), this.walletConnectConnector = c, this.connector = new U.W(c)
                        }
                    }
                    return this.connector
                }
                async connectWithQrCode(l) {
                    await this.getConnector();
                    let c = this.walletConnectConnector;
                    if (!c) throw Error("WalletConnect connector not found");
                    let x = await c.getProvider();
                    x.on("display_uri", c => {
                        l.onQrCodeUri(c)
                    }), this.connect({
                        chainId: l.chainId
                    }).then(l.onConnected)
                }
            };
            (0, N._)(ZerionWallet, "id", "zerion"), (0, N._)(ZerionWallet, "meta", {
                name: "Zerion Wallet",
                iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
                urls: {
                    chrome: "https://zerion.io/extension",
                    android: "https://link.zerion.io/901o6IN0jqb",
                    ios: "https://link.zerion.io/a11o6IN0jqb"
                }
            });
            var eg = x(46184);
            let RainbowWallet = class RainbowWallet extends $.a {
                get walletName() {
                    return "Rainbow Wallet"
                }
                constructor(l) {
                    super(RainbowWallet.id, l), this.isInjected = !!(0, eg.g)()
                }
                async getConnector() {
                    if (!this.connector) {
                        if (this.isInjected) {
                            let {
                                RainbowConnector: l
                            } = await x.e(466).then(x.bind(x, 50466)), c = new l({
                                chains: this.chains,
                                connectorStorage: this.walletStorage,
                                options: {
                                    shimDisconnect: !0
                                }
                            });
                            this.rainbowConnector = c, this.connector = new U.W(c)
                        } else {
                            let {
                                WalletConnectConnector: l
                            } = await x.e(8759).then(x.bind(x, 48759)), c = new l({
                                chains: this.chains,
                                options: {
                                    projectId: this.options ? .projectId || ea.T,
                                    storage: this.walletStorage,
                                    qrcode: this.options ? .qrcode,
                                    dappMetadata: this.dappMetadata,
                                    qrModalOptions: this.options ? .qrModalOptions
                                }
                            });
                            c.getProvider().then(l => {
                                l.signer.client.on("session_request_sent", () => {
                                    this.emit("wc_session_request_sent")
                                })
                            }), this.walletConnectConnector = c, this.connector = new U.W(c)
                        }
                    }
                    return this.connector
                }
                async connectWithQrCode(l) {
                    await this.getConnector();
                    let c = this.walletConnectConnector;
                    if (!c) throw Error("WalletConnect connector not found");
                    let x = await c.getProvider();
                    x.on("display_uri", c => {
                        l.onQrCodeUri(c)
                    }), this.connect({
                        chainId: l.chainId
                    }).then(l.onConnected)
                }
            };
            (0, N._)(RainbowWallet, "meta", {
                name: "Rainbow Wallet",
                iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
                urls: {
                    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
                    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
                    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
                }
            }), (0, N._)(RainbowWallet, "id", Z.w.rainbow);
            var eb = x(91318);
            let PhantomWallet = class PhantomWallet extends $.a {
                get walletName() {
                    return "Phantom"
                }
                constructor(l) {
                    super(PhantomWallet.id, l), this.isInjected = !!(0, eb.g)()
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            PhantomConnector: l
                        } = await x.e(9606).then(x.bind(x, 19606)), c = new l({
                            chains: this.chains,
                            connectorStorage: this.walletStorage,
                            options: {
                                shimDisconnect: !0
                            }
                        });
                        this.phantomConnector = c, this.connector = new U.W(c)
                    }
                    return this.connector
                }
            };
            (0, N._)(PhantomWallet, "meta", {
                name: "Phantom",
                iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
                urls: {
                    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
                }
            }), (0, N._)(PhantomWallet, "id", Z.w.phantom);
            var ev = x(41282),
                ew = x(67327),
                eT = x(2265),
                eM = x(99538),
                eI = x(8801),
                ex = x(69394),
                eC = x(57437),
                e_ = x(75298);

            function WalletLogoSpinner(l) {
                return (0, eC.jsx)(eA, {
                    "data-error": l.error,
                    children: (0, eC.jsxs)("div", {
                        "data-container": !0,
                        style: {
                            position: "relative"
                        },
                        children: [(0, eC.jsx)("div", {
                            "data-gradient": !0,
                            "data-error": l.error,
                            children: (0, eC.jsx)("div", {
                                "data-blocker": !0,
                                children: (0, eC.jsx)(ew.D, {
                                    src: l.iconUrl,
                                    width: "80",
                                    height: "80"
                                })
                            })
                        }), l.error && (0, eC.jsx)(ej, {
                            onClick: l.onRetry,
                            "aria-label": "retry",
                            children: (0, eC.jsx)(ex.BGW, {
                                width: ew.i.md,
                                height: ew.i.md
                            })
                        })]
                    })
                })
            }
            x(2390);
            let eD = eM.F4 `
  from {
    transform: translate(50%, 50%) scale(0.5) rotate(-180deg);
    opacity: 0;
  }
`,
                eS = eM.F4 `
  0% {
    transform: scale(1.5) rotate(0deg);
  }
  100% {
    transform: scale(1.5) rotate(360deg);
  }
`,
                ek = eM.F4 `
  0% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-5px);
  }
  50% {
    transform: translateX(5px);
  }
  75% {
    transform: translateX(-5px);
  }
  100% {
    transform: translateX(0);
  }
`,
                eE = eM.F4 `
  from {
    opacity: 0;
    transform: translateY(80px) scale(0.2) ;
  }
`,
                eN = eM.F4 `
  from {
    transform: translateY(5px);
  }
  to {
    transform: translateY(-5px);
  }
`,
                eA = eI.Z.div `
  display: flex;
  justify-content: center;
  animation: ${eE} 400ms cubic-bezier(0.15, 1.15, 0.6, 1);
  position: relative;
  border-radius: ${ew.d.xl};

  &[data-error="true"] [data-container] {
    animation: ${ek} 0.25s linear;
  }

  [data-gradient] {
    padding: 2px; /* width of ring */
    position: relative;
    overflow: hidden;
    border-radius: ${ew.d.xl};
  }

  [data-gradient]:not([data-error="true"]) {
    animation: ${eN} 1.2s ease infinite alternate;
  }

  [data-gradient]::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;

    background: linear-gradient(
      to right,
      transparent 60%,
      ${l=>l.theme.colors.accentText}
    );

    animation: ${eS} 1.2s linear infinite;
  }

  [data-gradient][data-error="true"]::before {
    animation: none;
    background: ${l=>l.theme.colors.danger};
    box-shadow: 0 0 10px ${l=>l.theme.colors.danger};
  }

  [data-blocker] {
    padding: ${ew.s.xs};
    background: ${l=>l.theme.colors.modalBg};
    position: relative;
    z-index: 1;
    border-radius: ${ew.d.xl};
  }
`,
                ej = (0, eI.Z)(ew.I)
            `
  animation: ${eD} 0.3s ease;
  position: absolute;
  background: ${l=>l.theme.colors.danger};
  color: ${l=>l.theme.colors.modalBg};
  box-shadow: ${ew.p.sm};
  bottom: 5px;
  right: 5px;
  transform: translate(50%, 50%);
  z-index: 100;
  padding: ${ew.s.xs};
  border-radius: 50%;
  transition: all 200ms ease;

  &:hover {
    background: ${l=>l.theme.colors.danger};
    color: ${l=>l.theme.colors.modalBg};
    transform: translate(50%, 50%) scale(1.2) rotate(35deg);
  }
`, ConnectingScreen = l => {
                let c = (0, eT.useContext)(ew.j);
                return (0, eC.jsxs)(ew.C, {
                    animate: "fadein",
                    fullHeight: !0,
                    flex: "column",
                    children: [(0, eC.jsx)(ew.C, {
                        p: "lg",
                        children: (0, eC.jsx)(ew.M, {
                            title: l.walletName,
                            onBack: l.hideBackButton ? void 0 : l.onBack
                        })
                    }), (0, eC.jsx)(ew.S, {
                        y: "lg"
                    }), (0, eC.jsxs)(ew.C, {
                        flex: "column",
                        center: "both",
                        expand: !0,
                        p: "lg",
                        relative: !0,
                        children: [(0, eC.jsx)(WalletLogoSpinner, {
                            onRetry: l.onRetry,
                            error: l.errorConnecting,
                            iconUrl: l.walletIconURL
                        }), (0, eC.jsx)(ew.S, {
                            y: "xxl"
                        }), (0, eC.jsxs)(ew.C, {
                            animate: "fadein",
                            style: {
                                animationDuration: "200ms"
                            },
                            children: [(0, eC.jsx)(ew.b, {
                                center: !0,
                                color: "primaryText",
                                size: "lg",
                                weight: 600,
                                children: l.errorConnecting ? "Connection Failed" : "Connecting"
                            }), (0, eC.jsx)(ew.S, {
                                y: "lg"
                            }), l.errorConnecting ? (0, eC.jsx)(ew.b, {
                                style: {
                                    textAlign: "center"
                                },
                                children: "click on button above to try again"
                            }) : (0, eC.jsxs)(ew.b, {
                                multiline: !0,
                                style: {
                                    textAlign: "center"
                                },
                                children: ["Login and connect your wallet", (0, eC.jsx)("br", {}), " through the ", l.walletName, " ", (0, ew.e)() ? "application" : "pop-up"]
                            })]
                        })]
                    }), (0, eC.jsx)(ew.S, {
                        y: "lg"
                    }), "compact" === c.modalSize && (0, eC.jsx)(ew.L, {}), (0, eC.jsx)(ew.C, {
                        flex: "row",
                        center: "x",
                        p: "lg",
                        children: (0, eC.jsxs)(ew.B, {
                            variant: "link",
                            onClick: l.onGetStarted,
                            style: {
                                textAlign: "center",
                                fontSize: ew.f.sm
                            },
                            children: ["Don", "'", "t have ", l.walletName, "?"]
                        })
                    })]
                })
            }, QRCode = l => {
                let c = l.size || 310;
                return (0, eC.jsxs)("div", {
                    style: {
                        position: "relative"
                    },
                    children: [l.qrCodeUri ? (0, eC.jsx)(eP, {
                        children: (0, eC.jsx)(QRCodeRenderer, {
                            uri: l.qrCodeUri,
                            size: c + 20,
                            ecl: "M",
                            clearSize: l.QRIcon ? 70 : void 0
                        })
                    }) : (0, eC.jsxs)(eR, {
                        style: {
                            width: `${c}px`,
                            height: `${c}px`
                        },
                        children: [(0, eC.jsx)("span", {
                            "data-v1": !0
                        }), (0, eC.jsx)("span", {
                            "data-v2": !0
                        }), (0, eC.jsx)("span", {
                            "data-v3": !0
                        }), (0, eC.jsx)("div", {})]
                    }), l.QRIcon && (0, eC.jsx)(eO, {
                        children: l.QRIcon
                    })]
                })
            }, eO = eI.Z.div `
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  justify-content: center;
  align-content: center;
  z-index: 1000;
`, eP = eI.Z.div `
  animation: ${ew.E} 600ms ease;
  --ck-qr-dot-color: ${l=>l.theme.colors.primaryText};
  --ck-body-background: ${l=>l.theme.colors.modalBg};
  --ck-qr-background: ${l=>l.theme.colors.modalBg};
`, generateMatrix = (l, c) => {
                let x = Array.prototype.slice.call(e_.create(l, {
                        errorCorrectionLevel: c
                    }).modules.data, 0),
                    N = Math.sqrt(x.length);
                return x.reduce((l, c, x) => (x % N == 0 ? l.push([c]) : l[l.length - 1].push(c)) && l, [])
            }, ez = eM.F4 `
  0%{ background-position: 100% 0; }
  100%{ background-position: -100% 0; }
`, eR = eI.Z.div `
  --color: ${l=>l.theme.colors.skeletonBg};
  --bg: ${l=>l.theme.colors.modalBg};

  overflow: hidden;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: ${ew.d.md};

  > div {
    z-index: 4;
    position: relative;
    width: 28%;
    height: 28%;
    border-radius: 5px;
    background: var(--bg);
    box-shadow: 0 0 0 7px var(--bg);
  }

  > span {
    z-index: 4;
    position: absolute;
    background: var(--color);
    border-radius: 12px;
    width: 13.25%;
    height: 13.25%;
    box-shadow: 0 0 0 4px var(--bg);
    &:before {
      content: "";
      position: absolute;
      inset: 9px;
      border-radius: 3px;
      box-shadow: 0 0 0 4px var(--bg);
    }
    &[data-v1] {
      top: 0;
      left: 0;
    }
    &[data-v2] {
      top: 0;
      right: 0;
    }
    &[data-v3] {
      bottom: 0;
      left: 0;
    }
  }

  &:before {
    z-index: 3;
    content: "";
    position: absolute;
    inset: 0;
    background: repeat;
    background-size: 1.888% 1.888%;
    background-image: radial-gradient(var(--color) 41%, transparent 41%);
  }

  &:after {
    z-index: 100;
    content: "";
    position: absolute;
    inset: 0;
    transform: scale(1.5) rotate(45deg);
    background-image: linear-gradient(
      90deg,
      transparent 50%,
      ${l=>l.theme.colors.skeletonBg},
      transparent
    );
    background-size: 200% 100%;
    animation: ${ez} 1000ms linear infinite both;
  }
`;

            function QRCodeRenderer(l) {
                let {
                    ecl: c = "M",
                    size: x = 200,
                    uri: N,
                    clearSize: U = 0,
                    image: Z,
                    imageBackground: $ = "transparent"
                } = l, Y = x - 20, q = (0, eT.useMemo)(() => {
                    let l = [],
                        x = generateMatrix(N, c),
                        q = Y / x.length;
                    if ([{
                            x: 0,
                            y: 0
                        }, {
                            x: 1,
                            y: 0
                        }, {
                            x: 0,
                            y: 1
                        }].forEach(c => {
                            let {
                                x: N,
                                y: U
                            } = c, Z = (x.length - 7) * q * N, $ = (x.length - 7) * q * U;
                            for (let c = 0; c < 3; c++) l.push((0, eC.jsx)("rect", {
                                fill: c % 2 != 0 ? "var(--ck-qr-background, var(--ck-body-background))" : "var(--ck-qr-dot-color)",
                                rx: -((c - 2) * 5) + (0 === c ? 2 : 3),
                                ry: -((c - 2) * 5) + (0 === c ? 2 : 3),
                                width: q * (7 - 2 * c),
                                height: q * (7 - 2 * c),
                                x: Z + q * c,
                                y: $ + q * c
                            }, `${c}-${N}-${U}`))
                        }), Z) {
                        let c = (x.length - 7) * q * 1,
                            N = (x.length - 7) * q * 1;
                        l.push((0, eC.jsxs)(eC.Fragment, {
                            children: [(0, eC.jsx)("rect", {
                                fill: $,
                                rx: 12,
                                ry: 12,
                                width: 7 * q,
                                height: 7 * q,
                                x: c + 0 * q,
                                y: N + 0 * q
                            }), (0, eC.jsx)("foreignObject", {
                                width: 7 * q,
                                height: 7 * q,
                                x: c + 0 * q,
                                y: N + 0 * q,
                                children: (0, eC.jsx)("div", {
                                    style: {
                                        borderRadius: 12,
                                        overflow: "hidden"
                                    },
                                    children: Z
                                })
                            })]
                        }))
                    }
                    let J = Math.floor((U + 25) / q),
                        X = x.length / 2 - J / 2,
                        en = x.length / 2 + J / 2 - 1;
                    return x.forEach((c, N) => {
                        c.forEach((c, U) => {
                            x[N][U] && !(N < 7 && U < 7 || N > x.length - 8 && U < 7 || N < 7 && U > x.length - 8) && (Z || !(N > X && N < en && U > X && U < en)) && l.push((0, eC.jsx)("circle", {
                                cx: N * q + q / 2,
                                cy: U * q + q / 2,
                                fill: "var(--ck-qr-dot-color)",
                                r: q / 3
                            }, `circle-${N}-${U}`))
                        })
                    }), l
                }, [c, Z, $, U, Y, N]);
                return (0, eC.jsxs)("svg", {
                    height: Y,
                    width: Y,
                    viewBox: `0 0 ${Y} ${Y}`,
                    style: {
                        width: Y,
                        height: Y
                    },
                    children: [(0, eC.jsx)("rect", {
                        fill: "transparent",
                        height: Y,
                        width: Y
                    }), q]
                })
            }

            function openWindow(l) {
                if (l.startsWith("http")) {
                    let c = document.createElement("a");
                    c.href = l, c.target = "_blank", c.rel = "noreferrer noopener", c.click()
                } else window.location.href = l
            }
            let AppleIcon = l => (0, eC.jsx)("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: l.size,
                    height: l.size,
                    viewBox: "0 0 23 28",
                    fill: "none",
                    children: (0, eC.jsx)("path", {
                        d: "M22.4181 21.6041C22.008 22.5506 21.5224 23.422 20.9599 24.223C20.1931 25.3151 19.5652 26.0711 19.0814 26.4908C18.3313 27.1799 17.5277 27.5327 16.6671 27.5528C16.0493 27.5528 15.3043 27.3772 14.437 27.021C13.5669 26.6664 12.7673 26.4908 12.0362 26.4908C11.2694 26.4908 10.447 26.6664 9.56734 27.021C8.68636 27.3772 7.97665 27.5628 7.43403 27.5812C6.60879 27.6164 5.78624 27.2534 4.96519 26.4908C4.44116 26.0343 3.78569 25.2516 3.00047 24.1428C2.15799 22.9587 1.46536 21.5857 0.92274 20.0203C0.341611 18.3295 0.050293 16.6922 0.050293 15.1071C0.050293 13.2914 0.44307 11.7253 1.2298 10.413C1.84809 9.35886 2.67065 8.52734 3.70014 7.91691C4.72963 7.30648 5.84199 6.99541 7.03991 6.97551C7.69538 6.97551 8.55493 7.17804 9.6231 7.57607C10.6882 7.97544 11.3722 8.17797 11.672 8.17797C11.8962 8.17797 12.656 7.94116 13.944 7.46904C15.162 7.0312 16.19 6.84991 17.0321 6.92133C19.3141 7.10529 21.0285 8.00387 22.1687 9.62276C20.1278 10.858 19.1182 12.5881 19.1383 14.8076C19.1567 16.5363 19.7846 17.9749 21.0185 19.1172C21.5777 19.6473 22.2022 20.0571 22.897 20.3481C22.7463 20.7846 22.5872 21.2027 22.4181 21.6041ZM17.1845 1.03178C17.1845 2.38678 16.6889 3.65194 15.7011 4.82296C14.509 6.21507 13.0672 7.0195 11.5036 6.89256C11.4837 6.73 11.4721 6.55892 11.4721 6.37913C11.4721 5.07833 12.039 3.68622 13.0457 2.54798C13.5484 1.97167 14.1876 1.49247 14.9628 1.11021C15.7363 0.733653 16.4679 0.525407 17.156 0.489746C17.1761 0.670889 17.1845 0.85206 17.1845 1.03178Z",
                        fill: "#959CA0"
                    })
                }),
                ChromeIcon = l => (0, eC.jsx)("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: l.size,
                    height: l.size,
                    viewBox: "0 0 190.5 190.5",
                    children: (0, eC.jsxs)("g", {
                        transform: "translate(90.669 -507.469)",
                        children: [(0, eC.jsx)("path", {
                            d: "M4.583 650.342c26.304 0 47.627-21.324 47.627-47.628s-21.323-47.628-47.627-47.628-47.627 21.324-47.627 47.628 21.323 47.628 47.627 47.628z",
                            fill: "#fff",
                            clipPath: "none",
                            mask: "none"
                        }), (0, eC.jsx)("path", {
                            d: "M-36.664 626.539l-41.24-71.43c-8.362 14.479-12.765 30.904-12.765 47.625s4.401 33.146 12.762 47.625 20.387 26.503 34.868 34.86 30.908 12.755 47.628 12.75l41.24-71.43v-.011c-4.177 7.244-10.188 13.26-17.428 17.443a47.62 47.62 0 0 1-47.632.007 47.62 47.62 0 0 1-17.433-17.437z",
                            fill: "#229342",
                            clipPath: "none",
                            mask: "none"
                        }), (0, eC.jsx)("path", {
                            d: "M45.826 626.536l-41.239 71.43c16.72.003 33.146-4.398 47.626-12.757s26.504-20.384 34.863-34.865a95.24 95.24 0 0 0 12.755-47.627c-.003-16.72-4.408-33.145-12.772-47.623H4.58l-.01.007a47.62 47.62 0 0 1 23.819 6.372c7.243 4.179 13.257 10.19 17.439 17.431a47.62 47.62 0 0 1-.001 47.633z",
                            fill: "#fbc116",
                            clipPath: "none",
                            mask: "none"
                        }), (0, eC.jsx)("path", {
                            d: "M4.583 640.43c20.824 0 37.705-16.881 37.705-37.706s-16.881-37.705-37.705-37.705-37.705 16.881-37.705 37.705 16.881 37.706 37.705 37.706z",
                            fill: "#1a73e8",
                            clipPath: "none",
                            mask: "none"
                        }), (0, eC.jsx)("path", {
                            d: "M4.583 555.097h82.479c-8.358-14.481-20.381-26.507-34.861-34.868a95.23 95.23 0 0 0-47.625-12.76c-16.72.001-33.145 4.404-47.623 12.767a95.23 95.23 0 0 0-34.856 34.872l41.24 71.43.011.006a47.62 47.62 0 0 1-.015-47.633c4.179-7.242 10.193-13.256 17.434-17.436s15.456-6.381 23.818-6.379z",
                            fill: "#e33b2e",
                            clipPath: "none",
                            mask: "none"
                        })]
                    })
                }),
                PlayStoreIcon = l => (0, eC.jsxs)("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: l.size,
                    height: l.size,
                    viewBox: "0 0 23 26",
                    fill: "none",
                    children: [(0, eC.jsx)("path", {
                        d: "M10.5832 12.0978L0.0976562 23.2275C0.0980507 23.2298 0.0988382 23.2317 0.0992076 23.2341C0.420793 24.4427 1.52467 25.3326 2.83473 25.3326C3.35844 25.3326 3.85012 25.191 4.27179 24.9424L4.30528 24.9228L16.1087 18.1117L10.5838 12.0977",
                        fill: "#EB3131"
                    }), (0, eC.jsx)("path", {
                        d: "M21.1922 10.2046L21.1821 10.1977L16.0862 7.2435L10.345 12.3523L16.1061 18.1127L21.1752 15.1879C22.0639 14.7081 22.6672 13.7712 22.6672 12.6908C22.6672 11.6182 22.072 10.6859 21.1922 10.2046Z",
                        fill: "#F6B60B"
                    }), (0, eC.jsx)("path", {
                        d: "M0.0961678 2.10416C0.0331317 2.33661 0 2.58009 0 2.83292V22.5002C0 22.7526 0.0327407 22.9969 0.0965672 23.2285L10.9441 12.3832L0.0965672 2.10444",
                        fill: "#5778C5"
                    }), (0, eC.jsx)("path", {
                        d: "M10.6603 12.6667L16.088 7.24061L4.29785 0.404818C3.8693 0.148138 3.36912 0 2.83391 0C1.52384 0 0.418474 0.891502 0.0968301 2.10147C0.0964356 2.10265 0.0964355 2.10347 0.0964355 2.1045L10.6603 12.6669",
                        fill: "#3BAD49"
                    })]
                }),
                GetStartedScreen = l => {
                    let {
                        walletName: c,
                        walletIconURL: x,
                        appleStoreLink: N,
                        googlePlayStoreLink: U,
                        chromeExtensionLink: Z,
                        header: $,
                        footer: Y,
                        onBack: q
                    } = l, [J, X] = (0, eT.useState)("base"), en = "compact" === (0, eT.useContext)(ew.j).modalSize, er = q ? () => {
                        "base" === J ? q() : X("base")
                    } : void 0;
                    return (0, eC.jsxs)(ew.C, {
                        fullHeight: !0,
                        flex: "column",
                        animate: "fadein",
                        children: [(0, eC.jsxs)(ew.C, {
                            expand: !0,
                            flex: "column",
                            p: "lg",
                            children: ["android-scan" === J && U && (0, eC.jsx)(InstallScanScreen, {
                                platformIcon: (0, eC.jsx)(PlayStoreIcon, {
                                    size: ew.i.md
                                }),
                                url: U,
                                platform: "Google Play",
                                walletName: c,
                                walletIconURL: x,
                                onBack: er
                            }), "ios-scan" === J && N && (0, eC.jsx)(InstallScanScreen, {
                                platformIcon: (0, eC.jsx)(AppleIcon, {
                                    size: ew.i.md
                                }),
                                url: N,
                                platform: "App Store",
                                walletName: c,
                                walletIconURL: x,
                                onBack: er
                            }), "base" === J && (0, eC.jsxs)(ew.C, {
                                expand: !0,
                                flex: "column",
                                children: [$ || (0, eC.jsx)(ew.M, {
                                    onBack: er,
                                    title: c
                                }), (0, eC.jsx)(ew.S, {
                                    y: "xl"
                                }), (0, eC.jsx)(ew.C, {
                                    expand: !0,
                                    animate: "fadein",
                                    flex: "column",
                                    center: "y",
                                    style: {
                                        minHeight: "250px"
                                    },
                                    children: (0, eC.jsxs)(ew.C, {
                                        flex: "column",
                                        gap: "xs",
                                        children: [Z && (0, eC.jsxs)(eL, {
                                            onClick: () => {
                                                openWindow(Z)
                                            },
                                            children: [(0, eC.jsx)(ChromeIcon, {
                                                size: ew.i.lg
                                            }), (0, eC.jsx)("span", {
                                                children: "Download Chrome Extension"
                                            })]
                                        }), U && (0, eC.jsxs)(eL, {
                                            as: "button",
                                            onClick: () => {
                                                (0, ew.e)() ? openWindow(U): X("android-scan")
                                            },
                                            children: [(0, eC.jsx)(PlayStoreIcon, {
                                                size: ew.i.lg
                                            }), (0, eC.jsx)("span", {
                                                children: "Download on Google Play"
                                            })]
                                        }), N && (0, eC.jsxs)(eL, {
                                            as: "button",
                                            onClick: () => {
                                                (0, ew.e)() ? openWindow(N): X("ios-scan")
                                            },
                                            children: [(0, eC.jsx)(AppleIcon, {
                                                size: ew.i.lg
                                            }), (0, eC.jsx)("span", {
                                                children: "Download on App Store"
                                            })]
                                        })]
                                    })
                                })]
                            }), !("android-scan" === J || "ios-scan" === J) && Y]
                        }), "base" === J && (0, eC.jsxs)(eC.Fragment, {
                            children: [en && (0, eC.jsx)(ew.S, {
                                y: "xs"
                            }), (0, eC.jsx)(ew.n, {
                                style: en ? void 0 : {
                                    borderTop: "none"
                                },
                                children: (0, eC.jsxs)(ew.b, {
                                    size: "sm",
                                    center: !0,
                                    children: ["Get started with ", c]
                                })
                            })]
                        })]
                    })
                },
                InstallScanScreen = l => (0, eC.jsxs)(ew.C, {
                    animate: "fadein",
                    expand: !0,
                    children: [(0, eC.jsx)(ew.M, {
                        title: l.walletName,
                        onBack: l.onBack
                    }), (0, eC.jsx)(ew.S, {
                        y: "xl"
                    }), (0, eC.jsxs)(ew.C, {
                        flex: "column",
                        expand: !0,
                        center: "both",
                        style: {
                            textAlign: "center"
                        },
                        children: [(0, eC.jsx)(QRCode, {
                            qrCodeUri: l.url,
                            QRIcon: (0, eC.jsx)(ew.D, {
                                src: l.walletIconURL,
                                width: ew.i.xxl,
                                height: ew.i.xxl
                            })
                        }), (0, eC.jsx)(ew.S, {
                            y: "xl"
                        }), (0, eC.jsxs)(ew.b, {
                            multiline: !0,
                            center: !0,
                            children: ["Scan with your phone to download ", (0, eC.jsx)("br", {}), " ", l.walletName, " from", " ", l.platform]
                        }), (0, eC.jsx)(ew.S, {
                            y: "xs"
                        })]
                    })]
                }),
                eL = eI.Z.button `
  all: unset;
  text-decoration: none;
  padding: ${ew.s.sm} ${ew.s.md};
  border-radius: ${ew.d.sm};
  display: flex;
  align-items: center;
  gap: ${ew.s.md};
  cursor: pointer;
  box-sizing: border-box;
  width: 100%;
  font-weight: 500;
  color: ${l=>l.theme.colors.secondaryButtonText};
  background: ${l=>l.theme.colors.secondaryButtonBg};
  transition: 100ms ease;
  &:hover {
    background: ${l=>l.theme.colors.secondaryButtonHoverBg};
    text-decoration: none;
    color: ${l=>l.theme.colors.primaryText};
  }
`,
                ScanScreen = l => {
                    let c = (0, eT.useContext)(ew.j),
                        x = l.walletName.toLowerCase().includes("wallet") ? l.walletName : `${l.walletName} wallet`;
                    return (0, eC.jsxs)(ew.C, {
                        fullHeight: !0,
                        flex: "column",
                        animate: "fadein",
                        children: [(0, eC.jsx)(ew.C, {
                            p: "lg",
                            children: (0, eC.jsx)(ew.M, {
                                onBack: l.onBack,
                                title: l.walletName
                            })
                        }), "compact" === c.modalSize && (0, eC.jsx)(ew.S, {
                            y: "xs"
                        }), (0, eC.jsx)(ew.C, {
                            expand: !0,
                            flex: "column",
                            px: "lg",
                            center: "both",
                            children: (0, eC.jsxs)("div", {
                                style: {
                                    textAlign: "center"
                                },
                                children: [(0, eC.jsx)(QRCode, {
                                    qrCodeUri: l.qrCodeUri,
                                    size: 310,
                                    QRIcon: (0, eC.jsx)(ew.D, {
                                        width: ew.i.xxl,
                                        height: ew.i.xxl,
                                        src: l.walletIconURL
                                    })
                                }), (0, eC.jsx)(ew.S, {
                                    y: "lg"
                                }), (0, eC.jsxs)(ew.b, {
                                    center: !0,
                                    multiline: !0,
                                    children: ["Scan this with ", x, " ", (0, eC.jsx)("br", {}), " or camera app to connect"]
                                }), (0, eC.jsx)(ew.S, {
                                    y: "lg"
                                })]
                            })
                        }), (0, eC.jsx)(ew.n, {
                            style: {
                                border: "compact" === c.modalSize ? void 0 : "none"
                            },
                            children: (0, eC.jsxs)(ew.B, {
                                variant: "link",
                                onClick: l.onGetStarted,
                                style: {
                                    fontSize: ew.f.sm,
                                    textAlign: "center"
                                },
                                children: ["Don't", " have ", x, "?"]
                            })
                        })]
                    })
                },
                CoinbaseScan = l => {
                    let {
                        walletConfig: c,
                        onConnected: x,
                        onGetStarted: N,
                        onBack: U,
                        hideBackButton: Z
                    } = l, $ = (0, ev.xUo)(), [Y, q] = (0, eT.useState)(void 0), {
                        setConnectedWallet: J,
                        chainToConnect: X,
                        setConnectionStatus: en
                    } = (0, ev.tNP)(), er = (0, eT.useRef)(!1);
                    return (0, eT.useEffect)(() => {
                        er.current || (er.current = !0, (async () => {
                            let l = $(c),
                                N = await l.getQrUrl();
                            q(N || void 0), en("connecting");
                            try {
                                await l.connect({
                                    chainId: X ? .chainId
                                }), J(l), x()
                            } catch {
                                en("disconnected")
                            }
                        })())
                    }, [$, x, c, X ? .chainId, J, en]), (0, eC.jsx)(ScanScreen, {
                        onBack: U,
                        onGetStarted: N,
                        qrCodeUri: Y,
                        walletName: c.meta.name,
                        walletIconURL: c.meta.iconURL,
                        hideBackButton: Z
                    })
                },
                wait = l => new Promise(c => setTimeout(c, l)),
                CoinbaseConnectUI = l => {
                    let {
                        walletConfig: c,
                        close: x,
                        goBack: N,
                        supportedWallets: U
                    } = l, Z = (0, ev.$4A)(), {
                        meta: $
                    } = c, [Y, q] = (0, eT.useState)("loading"), [J, X] = (0, eT.useState)(!1), en = 1 === U.length, er = (0, eT.useCallback)(async () => {
                        try {
                            X(!1), ea.current = !0, await wait(1e3), q("connecting"), await Z(c), x()
                        } catch (l) {
                            X(!0), console.error(l)
                        }
                    }, [x, Z, c]), ea = (0, eT.useRef)(!1);
                    return ((0, eT.useEffect)(() => {
                        if ("loading" !== Y || ea.current) return;
                        let l = !!c.isInstalled && c.isInstalled();
                        (async () => {
                            l ? er() : (0, ew.e)() ? Z(c) : q("scanning")
                        })()
                    }, [Y, c, Z, er]), "connecting" === Y || "loading" === Y) ? (0, eC.jsx)(ConnectingScreen, {
                        errorConnecting: J,
                        onGetStarted: () => q("get-started"),
                        onRetry: er,
                        hideBackButton: en,
                        onBack: N,
                        walletName: $.name,
                        walletIconURL: $.iconURL
                    }) : "get-started" === Y ? (0, eC.jsx)(GetStartedScreen, {
                        walletIconURL: $.iconURL,
                        walletName: $.name,
                        chromeExtensionLink: $.urls ? .chrome,
                        googlePlayStoreLink: $.urls ? .android,
                        appleStoreLink: $.urls ? .ios,
                        onBack: () => {
                            N()
                        }
                    }) : "scanning" === Y ? (0, eC.jsx)(CoinbaseScan, {
                        onBack: N,
                        onConnected: x,
                        onGetStarted: () => q("get-started"),
                        walletConfig: c,
                        hideBackButton: en
                    }) : null
                },
                coinbaseWallet = l => {
                    let c = l ? .qrmodal || "custom";
                    return {
                        id: CoinbaseWallet.id,
                        recommended: l ? .recommended,
                        meta: {
                            name: "Coinbase Wallet",
                            iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQ4IiBoZWlnaHQ9IjQ4IiByeD0iOCIgZmlsbD0iIzA1NTVGRiIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMzMwM184NjM0KSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMzMxMiA0SDM1LjY2NzJDNDAuMjcwNCA0IDQ0IDguMDEyOCA0NCAxMi45NjMyVjM1LjAzNjhDNDQgMzkuOTg3MiA0MC4yNzA0IDQ0IDM1LjY2ODggNDRIMTIuMzMxMkM3LjcyOTYgNDQgNCAzOS45ODcyIDQgMzUuMDM2OFYxMi45NjMyQzQgOC4wMTI4IDcuNzI5NiA0IDEyLjMzMTIgNFoiIGZpbGw9IiMwMDUyRkYiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yNC4wMDAzIDkuNzkzNDZDMzEuODQ2NyA5Ljc5MzQ2IDM4LjIwNjcgMTYuMTUzNSAzOC4yMDY3IDIzLjk5OTlDMzguMjA2NyAzMS44NDYzIDMxLjg0NjcgMzguMjA2MyAyNC4wMDAzIDM4LjIwNjNDMTYuMTUzOSAzOC4yMDYzIDkuNzkzOTUgMzEuODQ2MyA5Ljc5Mzk1IDIzLjk5OTlDOS43OTM5NSAxNi4xNTM1IDE2LjE1MzkgOS43OTM0NiAyNC4wMDAzIDkuNzkzNDZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIwLjUwMDYgMTkuNDU5SDI3LjQ5NzRDMjguMDczNCAxOS40NTkgMjguNTM5IDE5Ljk2MTQgMjguNTM5IDIwLjU3OVYyNy40MTlDMjguNTM5IDI4LjAzODIgMjguMDcxOCAyOC41MzkgMjcuNDk3NCAyOC41MzlIMjAuNTAwNkMxOS45MjQ2IDI4LjUzOSAxOS40NTkgMjguMDM2NiAxOS40NTkgMjcuNDE5VjIwLjU3OUMxOS40NTkgMTkuOTYxNCAxOS45MjYyIDE5LjQ1OSAyMC41MDA2IDE5LjQ1OVoiIGZpbGw9IiMwMDUyRkYiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8zMzAzXzg2MzQiPgo8cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0IDQpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
                            urls: {
                                chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
                                android: "https://play.google.com/store/apps/details?id=org.toshi",
                                ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
                            }
                        },
                        create: l => new CoinbaseWallet({ ...l,
                            headlessMode: "custom" === c
                        }),
                        connectUI: "custom" === c ? CoinbaseConnectUI : CoinbaseNativeModalConnectUI,
                        isInstalled: () => !! function() {
                            function getReady(l) {
                                let c = !!l ? .isCoinbaseWallet;
                                if (c || l && "overrideIsMetaMask" in l && "providerMap" in l && l.providerMap instanceof Map && l.providerMap.has("CoinbaseWallet")) return l
                            }
                            if ((0, q.a)(globalThis.window)) return globalThis.window.ethereum ? .providers ? globalThis.window.ethereum.providers.find(getReady) : getReady(globalThis.window.ethereum)
                        }()
                    }
                },
                CoinbaseNativeModalConnectUI = l => {
                    let {
                        close: c,
                        walletConfig: x,
                        open: N,
                        supportedWallets: U,
                        theme: Z
                    } = l, $ = (0, ev.xUo)(), Y = (0, ev.tZ_)(), q = (0, ev.c4c)(), J = (0, eT.useRef)(!1), X = 1 === U.length;
                    return (0, eT.useEffect)(() => {
                        J.current || (J.current = !0, (async () => {
                            c();
                            let l = $(x);
                            l.theme = Z, Y("connecting");
                            try {
                                await l.connect(), q(l)
                            } catch (l) {
                                Y("disconnected"), X || N(), console.error(l)
                            }
                        })())
                    }, [x, c, N, X, $, Z, Y, q]), null
                };
            var eB = Object.freeze({
                __proto__: null,
                coinbaseWallet: coinbaseWallet,
                CoinbaseNativeModalConnectUI: CoinbaseNativeModalConnectUI
            });
            let MetamaskScan = l => {
                    let {
                        onBack: c,
                        onConnected: x,
                        onGetStarted: N,
                        walletConfig: U,
                        hideBackButton: Z
                    } = l, $ = (0, ev.xUo)(), [Y, q] = (0, eT.useState)(), {
                        setConnectedWallet: J,
                        chainToConnect: X,
                        setConnectionStatus: en
                    } = (0, ev.tNP)(), er = (0, eT.useRef)(!1);
                    return (0, eT.useEffect)(() => {
                        if (er.current) return;
                        er.current = !0;
                        let l = $(U);
                        en("connecting"), l.connectWithQrCode({
                            chainId: X ? .chainId,
                            onQrCodeUri(l) {
                                q(l)
                            },
                            onConnected() {
                                J(l), x()
                            }
                        })
                    }, [$, J, X, x, U, en]), (0, eC.jsx)(ScanScreen, {
                        onBack: c,
                        onGetStarted: N,
                        qrCodeUri: Y,
                        walletName: U.meta.name,
                        walletIconURL: U.meta.iconURL,
                        hideBackButton: Z
                    })
                },
                MetamaskConnectUI = l => {
                    let [c, x] = (0, eT.useState)("connecting"), {
                        walletConfig: N,
                        close: U
                    } = l, Z = (0, ev.$4A)(), [$, Y] = (0, eT.useState)(!1), q = 1 === l.supportedWallets.length, J = (0, eT.useCallback)(async () => {
                        try {
                            X.current = !0, Y(!1), x("connecting"), await wait(1e3), await Z(N), U()
                        } catch (l) {
                            Y(!0), console.error(l)
                        }
                    }, [U, Z, N]), X = (0, eT.useRef)(!1);
                    return ((0, eT.useEffect)(() => {
                        if (X.current) return;
                        let l = !!N.isInstalled && N.isInstalled();
                        (async () => {
                            l ? J() : (0, ew.e)() ? window.open(`https://metamask.app.link/dapp/${window.location.toString()}`) : x("scanning")
                        })()
                    }, [J, N]), "connecting" === c) ? (0, eC.jsx)(ConnectingScreen, {
                        errorConnecting: $,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        onRetry: J,
                        hideBackButton: q,
                        onBack: l.goBack,
                        walletName: N.meta.name,
                        walletIconURL: N.meta.iconURL
                    }) : "get-started" === c ? (0, eC.jsx)(GetStartedScreen, {
                        walletIconURL: N.meta.iconURL,
                        walletName: N.meta.name,
                        chromeExtensionLink: N.meta.urls ? .chrome,
                        googlePlayStoreLink: N.meta.urls ? .android,
                        appleStoreLink: N.meta.urls ? .ios,
                        onBack: l.goBack
                    }) : "scanning" === c ? (0, eC.jsx)(MetamaskScan, {
                        onBack: l.goBack,
                        onConnected: U,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        hideBackButton: q,
                        walletConfig: N
                    }) : null
                },
                metamaskWallet = l => ({
                    id: J.t.id,
                    recommended: l ? .recommended,
                    meta: { ...J.t.meta,
                        iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IiNGRkU2Q0UiLz4KPHBhdGggZD0iTTY0Ljk3MTIgMTQuMTc5TDQzLjI5MDMgMzAuMjgxN0w0Ny4yOTk2IDIwLjc4MTRMNjQuOTcxMiAxNC4xNzlaIiBmaWxsPSIjRTI3NjFCIiBzdHJva2U9IiNFMjc2MUIiIHN0cm9rZS13aWR0aD0iMC4xMjQ1MTQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTQuOTE5OCAxNC4xNzlMMzYuNDI2NCAzMC40MzQzTDMyLjYxMzIgMjAuNzgxNEwxNC45MTk4IDE0LjE3OVpNNTcuMTcwNCA1MS41MDUxTDUxLjM5NjEgNjAuMzUxOEw2My43NTEgNjMuNzUxTDY3LjMwMjcgNTEuNzAxMkw1Ny4xNzA0IDUxLjUwNTFaTTEyLjYzMTkgNTEuNzAxMkwxNi4xNjE5IDYzLjc1MUwyOC41MTY3IDYwLjM1MThMMjIuNzQyNCA1MS41MDUxTDEyLjYzMTkgNTEuNzAxMloiIGZpbGw9IiNFNDc2MUIiIHN0cm9rZT0iI0U0NzYxQiIgc3Ryb2tlLXdpZHRoPSIwLjEyNDUxNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0yNy44MTk0IDM2LjU1NzJMMjQuMzc2NiA0MS43NjVMMzYuNjQ0NCA0Mi4zMDk3TDM2LjIwODYgMjkuMTI2OEwyNy44MTk0IDM2LjU1NzJaTTUyLjA3MTYgMzYuNTU3Mkw0My41NzM1IDI4Ljk3NDNMNDMuMjkwMyA0Mi4zMDk3TDU1LjUzNjIgNDEuNzY1TDUyLjA3MTYgMzYuNTU3MlpNMjguNTE2NyA2MC4zNTE3TDM1Ljg4MTcgNTYuNzU2NEwyOS41MTkxIDUxLjc4ODNMMjguNTE2NyA2MC4zNTE3Wk00NC4wMDkzIDU2Ljc1NjRMNTEuMzk2MSA2MC4zNTE3TDUwLjM3MiA1MS43ODgzTDQ0LjAwOTMgNTYuNzU2NFoiIGZpbGw9IiNFNDc2MUIiIHN0cm9rZT0iI0U0NzYxQiIgc3Ryb2tlLXdpZHRoPSIwLjEyNDUxNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik01MS4zOTYxIDYwLjM1MTdMNDQuMDA5MyA1Ni43NTY0TDQ0LjU5NzcgNjEuNTcyTDQ0LjUzMjMgNjMuNTk4NEw1MS4zOTYxIDYwLjM1MTdaTTI4LjUxNjcgNjAuMzUxN0wzNS4zODA1IDYzLjU5ODRMMzUuMzM3IDYxLjU3MkwzNS44ODE3IDU2Ljc1NjRMMjguNTE2NyA2MC4zNTE3WiIgZmlsbD0iI0Q3QzFCMyIgc3Ryb2tlPSIjRDdDMUIzIiBzdHJva2Utd2lkdGg9IjAuMTI0NTE0IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTM1LjQ4OTUgNDguNjA3TDI5LjM0NDcgNDYuNzk4NEwzMy42ODA5IDQ0LjgxNTZMMzUuNDg5NSA0OC42MDdaTTQ0LjQwMTUgNDguNjA3TDQ2LjIxMDEgNDQuODE1Nkw1MC41NjgxIDQ2Ljc5ODRMNDQuNDAxNSA0OC42MDdaIiBmaWxsPSIjMjMzNDQ3IiBzdHJva2U9IiMyMzM0NDciIHN0cm9rZS13aWR0aD0iMC4xMjQ1MTQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjguNTE2NyA2MC4zNTE3TDI5LjU2MjYgNTEuNTA1TDIyLjc0MjQgNTEuNzAxMUwyOC41MTY3IDYwLjM1MTdaTTUwLjM1MDIgNTEuNTA1TDUxLjM5NjEgNjAuMzUxN0w1Ny4xNzA0IDUxLjcwMTFMNTAuMzUwMiA1MS41MDVaTTU1LjUzNjIgNDEuNzY1TDQzLjI5MDMgNDIuMzA5N0w0NC40MjMzIDQ4LjYwN0w0Ni4yMzE5IDQ0LjgxNTVMNTAuNTg5OSA0Ni43OTg0TDU1LjUzNjIgNDEuNzY1Wk0yOS4zNDQ3IDQ2Ljc5ODRMMzMuNzAyNyA0NC44MTU1TDM1LjQ4OTUgNDguNjA3TDM2LjY0NDMgNDIuMzA5N0wyNC4zNzY2IDQxLjc2NUwyOS4zNDQ3IDQ2Ljc5ODRaIiBmaWxsPSIjQ0Q2MTE2IiBzdHJva2U9IiNDRDYxMTYiIHN0cm9rZS13aWR0aD0iMC4xMjQ1MTQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjQuMzc2NiA0MS43NjVMMjkuNTE5MSA1MS43ODgzTDI5LjM0NDcgNDYuNzk4NEwyNC4zNzY2IDQxLjc2NVpNNTAuNTg5OSA0Ni43OTg0TDUwLjM3MiA1MS43ODgzTDU1LjUzNjIgNDEuNzY1TDUwLjU4OTkgNDYuNzk4NFpNMzYuNjQ0NCA0Mi4zMDk3TDM1LjQ4OTUgNDguNjA3TDM2LjkyNzYgNTYuMDM3M0wzNy4yNTQ1IDQ2LjI1MzdMMzYuNjQ0NCA0Mi4zMDk3Wk00My4yOTAzIDQyLjMwOTdMNDIuNzAxOSA0Ni4yMzE5TDQyLjk2MzQgNTYuMDM3M0w0NC40MjMzIDQ4LjYwN0w0My4yOTAzIDQyLjMwOTdaIiBmaWxsPSIjRTQ3NTFGIiBzdHJva2U9IiNFNDc1MUYiIHN0cm9rZS13aWR0aD0iMC4xMjQ1MTQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNNDQuNDIzMyA0OC42MDdMNDIuOTYzNCA1Ni4wMzc0TDQ0LjAwOTMgNTYuNzU2NEw1MC4zNzIgNTEuNzg4M0w1MC41ODk5IDQ2Ljc5ODVMNDQuNDIzMyA0OC42MDdaTTI5LjM0NDcgNDYuNzk4NUwyOS41MTkgNTEuNzg4M0wzNS44ODE3IDU2Ljc1NjRMMzYuOTI3NiA1Ni4wMzc0TDM1LjQ4OTUgNDguNjA3TDI5LjM0NDcgNDYuNzk4NVoiIGZpbGw9IiNGNjg1MUIiIHN0cm9rZT0iI0Y2ODUxQiIgc3Ryb2tlLXdpZHRoPSIwLjEyNDUxNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik00NC41MzIzIDYzLjU5ODRMNDQuNTk3NyA2MS41NzJMNDQuMDUyOSA2MS4wOTI2SDM1LjgzODFMMzUuMzM3IDYxLjU3MkwzNS4zODA1IDYzLjU5ODRMMjguNTE2NyA2MC4zNTE3TDMwLjkxMzYgNjIuMzEyOEwzNS43NzI4IDY1LjY5MDNINDQuMTE4M0w0OC45OTkyIDYyLjMxMjhMNTEuMzk2MSA2MC4zNTE3TDQ0LjUzMjMgNjMuNTk4NFoiIGZpbGw9IiNDMEFEOUUiIHN0cm9rZT0iI0MwQUQ5RSIgc3Ryb2tlLXdpZHRoPSIwLjEyNDUxNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik00NC4wMDkzIDU2Ljc1NjRMNDIuOTYzNCA1Ni4wMzc0SDM2LjkyNzZMMzUuODgxNyA1Ni43NTY0TDM1LjMzNyA2MS41NzJMMzUuODM4MSA2MS4wOTI2SDQ0LjA1MjlMNDQuNTk3NyA2MS41NzJMNDQuMDA5MyA1Ni43NTY0WiIgZmlsbD0iIzE2MTYxNiIgc3Ryb2tlPSIjMTYxNjE2IiBzdHJva2Utd2lkdGg9IjAuMTI0NTE0IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPHBhdGggZD0iTTY1Ljg4NjQgMzEuMzI3N0w2Ny43Mzg1IDIyLjQzNzRMNjQuOTcxMiAxNC4xNzlMNDQuMDA5MyAyOS43MzdMNTIuMDcxNiAzNi41NTcyTDYzLjQ2NzcgMzkuODkxMUw2NS45OTUzIDM2Ljk0OTRMNjQuOTA1OCAzNi4xNjVMNjYuNjQ5IDM0LjU3NDNMNjUuMjk4MSAzMy41Mjg0TDY3LjA0MTIgMzIuMTk5Mkw2NS44ODY0IDMxLjMyNzdaTTEyLjE3NDMgMjIuNDM3NEwxNC4wMjY1IDMxLjMyNzdMMTIuODQ5OCAzMi4xOTkyTDE0LjU5MyAzMy41Mjg0TDEzLjI2MzggMzQuNTc0M0wxNS4wMDcgMzYuMTY1TDEzLjkxNzUgMzYuOTQ5NEwxNi40MjMzIDM5Ljg5MTFMMjcuODE5NSAzNi41NTcyTDM1Ljg4MTcgMjkuNzM3TDE0LjkxOTggMTQuMTc5TDEyLjE3NDMgMjIuNDM3NFoiIGZpbGw9IiM3NjNEMTYiIHN0cm9rZT0iIzc2M0QxNiIgc3Ryb2tlLXdpZHRoPSIwLjEyNDUxNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik02My40Njc3IDM5Ljg5MUw1Mi4wNzE2IDM2LjU1NzJMNTUuNTM2MiA0MS43NjVMNTAuMzcyIDUxLjc4ODNMNTcuMTcwNCA1MS43MDEySDY3LjMwMjdMNjMuNDY3NyAzOS44OTFaTTI3LjgxOTQgMzYuNTU3MkwxNi40MjMzIDM5Ljg5MUwxMi42MzE5IDUxLjcwMTJIMjIuNzQyNEwyOS41MTkxIDUxLjc4ODNMMjQuMzc2NiA0MS43NjVMMjcuODE5NCAzNi41NTcyWk00My4yOTAzIDQyLjMwOTdMNDQuMDA5MyAyOS43MzdMNDcuMzIxNCAyMC43ODEzSDMyLjYxMzJMMzUuODgxNyAyOS43MzdMMzYuNjQ0MyA0Mi4zMDk3TDM2LjkwNTggNDYuMjc1NUwzNi45Mjc2IDU2LjAzNzNINDIuOTYzNEw0My4wMDcgNDYuMjc1NUw0My4yOTAzIDQyLjMwOTdaIiBmaWxsPSIjRjY4NTFCIiBzdHJva2U9IiNGNjg1MUIiIHN0cm9rZS13aWR0aD0iMC4xMjQ1MTQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4K"
                    },
                    create: c => {
                        let x = new J.t({ ...c,
                            projectId: l ? .projectId,
                            qrcode: !1
                        });
                        return x
                    },
                    connectUI: MetamaskConnectUI,
                    isInstalled: () => !!(0, X.g)()
                });
            var eU = Object.freeze({
                __proto__: null,
                metamaskWallet: metamaskWallet
            });
            let WalletConnectScan = l => {
                let {
                    onBack: c,
                    onConnected: x,
                    walletConfig: N
                } = l, U = (0, ev.xUo)(), [Z, $] = (0, eT.useState)(), {
                    setConnectedWallet: Y,
                    chainToConnect: q,
                    setConnectionStatus: J
                } = (0, ev.tNP)(), X = (0, eT.useRef)(!1);
                return (0, eT.useEffect)(() => {
                    if (X.current) return;
                    X.current = !0;
                    let l = U(N);
                    J("connecting"), l.connectWithQrCode({
                        chainId: q ? .chainId,
                        onQrCodeUri(l) {
                            $(l)
                        },
                        onConnected() {
                            Y(l), x()
                        }
                    })
                }, [U, Y, q, x, N, J]), (0, eC.jsxs)(ew.C, {
                    fullHeight: !0,
                    animate: "fadein",
                    flex: "column",
                    style: {
                        minHeight: "450px"
                    },
                    children: [(0, eC.jsx)(ew.C, {
                        p: "lg",
                        children: (0, eC.jsx)(ew.M, {
                            onBack: c,
                            title: "WalletConnect"
                        })
                    }), (0, eC.jsx)(ew.S, {
                        y: "md"
                    }), (0, eC.jsx)(ew.C, {
                        flex: "column",
                        center: "x",
                        px: "lg",
                        expand: !0,
                        children: (0, eC.jsx)(QRCode, {
                            size: 310,
                            qrCodeUri: Z,
                            QRIcon: (0, eC.jsx)(ew.D, {
                                width: ew.i.xxl,
                                height: ew.i.xxl,
                                src: N.meta.iconURL
                            })
                        })
                    }), (0, eC.jsx)(ew.S, {
                        y: "sm"
                    }), (0, eC.jsx)(ew.C, {
                        p: "lg",
                        children: (0, eC.jsxs)(ew.b, {
                            multiline: !0,
                            center: !0,
                            children: ["Scan this with your wallet ", (0, eC.jsx)("br", {}), "or camera app to connect", " "]
                        })
                    })]
                })
            };
            (0, eI.Z)(ex.nQG)
            `
  color: ${l=>l.theme.colors.success};
`;
            let HeadlessConnectUI = l => {
                    let {
                        close: c,
                        walletConfig: x,
                        open: N,
                        supportedWallets: U
                    } = l, Z = (0, ev.$4A)(), $ = (0, eT.useRef)(!1), Y = 1 === U.length;
                    return (0, eT.useEffect)(() => {
                        $.current || ($.current = !0, (async () => {
                            c();
                            try {
                                await Z(x)
                            } catch (l) {
                                Y || N(), console.error(l)
                            }
                        })())
                    }, [x, Z, c, N, Y]), (0, eC.jsx)(ew.C, {
                        flex: "row",
                        center: "both",
                        style: {
                            minHeight: "250px"
                        },
                        children: (0, eC.jsx)(ew.c, {
                            size: "md",
                            color: "accentText"
                        })
                    })
                },
                walletConnect = l => {
                    let c = l ? .projectId || "145769e410f16970a79ff77b2d89a1e0";
                    return {
                        recommended: l ? .recommended,
                        id: WalletConnect.id,
                        meta: { ...WalletConnect.meta,
                            iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IiMxQzdERkMiLz4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9InVybCgjcGFpbnQwX3JhZGlhbF8xXzQ2KSIvPgo8cGF0aCBkPSJNMjYuNDIyNyAzMS40NzMxQzMzLjkxNzEgMjQuMTc1NiA0Ni4wODI5IDI0LjE3NTYgNTMuNTc3MyAzMS40NzMxTDU0LjQ3OTYgMzIuMzU4QzU0Ljg1OCAzMi43MjA3IDU0Ljg1OCAzMy4zMTU1IDU0LjQ3OTYgMzMuNjc4Mkw1MS4zOTQ1IDM2LjY4MTNDNTEuMjA1MyAzNi44Njk5IDUwLjg5OTcgMzYuODY5OSA1MC43MTA1IDM2LjY4MTNMNDkuNDczNiAzNS40NzcyQzQ0LjIzNDcgMzAuMzg1IDM1Ljc2NTMgMzAuMzg1IDMwLjUyNjQgMzUuNDc3MkwyOS4yMDIxIDM2Ljc2ODRDMjkuMDEzIDM2Ljk1NyAyOC43MDc0IDM2Ljk1NyAyOC41MTgyIDM2Ljc2ODRMMjUuNDMzMSAzMy43NjUzQzI1LjA1NDcgMzMuNDAyNiAyNS4wNTQ3IDMyLjgwNzggMjUuNDMzMSAzMi40NDUxTDI2LjQyMjcgMzEuNDczMVpNNTkuOTY1OCAzNy42ODI0TDYyLjcxNjIgNDAuMzUxOEM2My4wOTQ2IDQwLjcxNDUgNjMuMDk0NiA0MS4zMDkzIDYyLjcxNjIgNDEuNjcyTDUwLjMzMjIgNTMuNzI4QzQ5Ljk1MzggNTQuMDkwNyA0OS4zNDI2IDU0LjA5MDcgNDguOTc4OCA1My43MjhMNDAuMTg5MiA0NS4xNjg0QzQwLjEwMTkgNDUuMDgxMyAzOS45NDE4IDQ1LjA4MTMgMzkuODU0NSA0NS4xNjg0TDMxLjA2NDkgNTMuNzI4QzMwLjY4NjUgNTQuMDkwNyAzMC4wNzUzIDU0LjA5MDcgMjkuNzExNSA1My43MjhMMTcuMjgzOCA0MS42NzJDMTYuOTA1NCA0MS4zMDkzIDE2LjkwNTQgNDAuNzE0NSAxNy4yODM4IDQwLjM1MThMMjAuMDM0MiAzNy42ODI0QzIwLjQxMjUgMzcuMzE5NyAyMS4wMjM3IDM3LjMxOTcgMjEuMzg3NSAzNy42ODI0TDMwLjE3NzIgNDYuMjQyQzMwLjI2NDUgNDYuMzI5IDMwLjQyNDUgNDYuMzI5IDMwLjUxMTkgNDYuMjQyTDM5LjMwMTUgMzcuNjgyNEMzOS42Nzk5IDM3LjMxOTcgNDAuMjkxIDM3LjMxOTcgNDAuNjU0OSAzNy42ODI0TDQ5LjQ0NDUgNDYuMjQyQzQ5LjUzMTggNDYuMzI5IDQ5LjY5MTkgNDYuMzI5IDQ5Ljc3OTIgNDYuMjQyTDU4LjU2ODggMzcuNjgyNEM1OC45NzYzIDM3LjMxOTcgNTkuNTg3NSAzNy4zMTk3IDU5Ljk2NTggMzcuNjgyNFoiIGZpbGw9IndoaXRlIi8+CjxkZWZzPgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50MF9yYWRpYWxfMV80NiIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDI0Nzk1NSA0MC4wMDEyKSBzY2FsZSg4MCkiPgo8c3RvcCBzdG9wLWNvbG9yPSIjNUQ5REY2Ii8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwNkZGRiIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo="
                        },
                        create: x => new WalletConnect({ ...x,
                            qrcode: !!(0, ew.e)(),
                            projectId: c,
                            qrModalOptions: l ? .qrModalOptions
                        }),
                        connectUI: l => (0, ew.e)() ? (0, eC.jsx)(HeadlessConnectUI, { ...l
                        }) : (0, eC.jsx)(WalletConnectScan, {
                            onBack: l.goBack,
                            onConnected: l.close,
                            walletConfig: l.walletConfig,
                            hideBackButton: l.supportedWallets.length > 1,
                            modalSize: l.modalSize
                        })
                    }
                };
            var eF = Object.freeze({
                __proto__: null,
                walletConnect: walletConnect
            });
            let TrustScan = l => {
                    let {
                        onBack: c,
                        onConnected: x,
                        onGetStarted: N,
                        walletConfig: U,
                        hideBackButton: Z
                    } = l, $ = (0, ev.xUo)(), [Y, q] = (0, eT.useState)(), {
                        setConnectedWallet: J,
                        chainToConnect: X,
                        setConnectionStatus: en
                    } = (0, ev.tNP)(), er = (0, eT.useRef)(!1);
                    return (0, eT.useEffect)(() => {
                        if (er.current) return;
                        er.current = !0;
                        let l = $(U);
                        en("connecting"), l.connectWithQrCode({
                            chainId: X ? .chainId,
                            onQrCodeUri(l) {
                                q(l)
                            },
                            onConnected() {
                                J(l), x()
                            }
                        })
                    }, [$, J, X, x, U, en]), (0, eC.jsx)(ScanScreen, {
                        onBack: c,
                        onGetStarted: N,
                        qrCodeUri: Y,
                        walletName: U.meta.name,
                        walletIconURL: U.meta.iconURL,
                        hideBackButton: Z
                    })
                },
                WCOpenURI = l => {
                    let {
                        onBack: c,
                        onConnected: x,
                        walletConfig: N,
                        appUriPrefix: U,
                        onRetry: Z,
                        errorConnecting: $,
                        hideBackButton: Y,
                        onGetStarted: q
                    } = l, J = (0, ev.xUo)(), {
                        setConnectedWallet: X,
                        chainToConnect: en,
                        setConnectionStatus: er
                    } = (0, ev.tNP)(), ea = (0, eT.useRef)(!1);
                    return (0, eT.useEffect)(() => {
                        if (ea.current) return;
                        ea.current = !0;
                        let l = J(N);
                        er("connecting"), l.connectWithQrCode({
                            chainId: en ? .chainId,
                            onQrCodeUri(l) {
                                (0, ew.P)() ? openWindow(`${U.android}wc?uri=${encodeURIComponent(l)}`): (0, ew.Q)() ? openWindow(`${U.ios}wc?uri=${encodeURIComponent(l)}`) : openWindow(`${U.other}wc?uri=${encodeURIComponent(l)}`)
                            },
                            onConnected() {
                                X(l), x()
                            }
                        })
                    }, [J, X, en, x, N, er, U]), (0, eC.jsx)(ConnectingScreen, {
                        hideBackButton: Y,
                        onBack: c,
                        walletName: N.meta.name,
                        walletIconURL: N.meta.iconURL,
                        errorConnecting: $,
                        onRetry: Z,
                        onGetStarted: q
                    })
                },
                eW = {
                    ios: "trust://",
                    android: "https://link.trustwallet.com/",
                    other: "https://link.trustwallet.com/"
                },
                TrustConnectUI = l => {
                    let [c, x] = (0, eT.useState)("connecting"), {
                        walletConfig: N,
                        close: U
                    } = l, Z = (0, ev.$4A)(), $ = 1 === l.supportedWallets.length, [Y, q] = (0, eT.useState)(!1), J = (0, eT.useCallback)(async () => {
                        try {
                            q(!1), X.current = !0, x("connecting"), await Z(N), U()
                        } catch (l) {
                            q(!0), console.error(l)
                        }
                    }, [U, Z, N]), X = (0, eT.useRef)(!1);
                    (0, eT.useEffect)(() => {
                        if (X.current) return;
                        let l = !!N.isInstalled && N.isInstalled();
                        (async () => {
                            l ? J() : (0, ew.e)() ? x("open-wc-uri") : x("scanning")
                        })()
                    }, [J, N]);
                    let handleGetStarted = () => {
                        x("get-started")
                    };
                    return "connecting" === c ? (0, eC.jsx)(ConnectingScreen, {
                        onRetry: J,
                        errorConnecting: Y,
                        onGetStarted: handleGetStarted,
                        hideBackButton: $,
                        onBack: l.goBack,
                        walletName: N.meta.name,
                        walletIconURL: N.meta.iconURL
                    }) : "open-wc-uri" === c ? (0, eC.jsx)(WCOpenURI, {
                        onRetry: () => {},
                        errorConnecting: Y,
                        onGetStarted: handleGetStarted,
                        hideBackButton: $,
                        onBack: l.goBack,
                        onConnected: U,
                        walletConfig: N,
                        appUriPrefix: eW
                    }) : "get-started" === c ? (0, eC.jsx)(GetStartedScreen, {
                        walletIconURL: N.meta.iconURL,
                        walletName: N.meta.name,
                        chromeExtensionLink: N.meta.urls ? .chrome,
                        googlePlayStoreLink: N.meta.urls ? .android,
                        appleStoreLink: N.meta.urls ? .ios,
                        onBack: l.goBack
                    }) : "scanning" === c ? (0, eC.jsx)(TrustScan, {
                        hideBackButton: $,
                        onBack: l.goBack,
                        onConnected: U,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        walletConfig: N
                    }) : null
                };

            function handelWCSessionRequest(l, c) {
                (0, ew.e)() && l.on("wc_session_request_sent", () => {
                    (0, ew.P)() ? openWindow(c.android): (0, ew.Q)() ? openWindow(c.ios) : openWindow(c.other)
                })
            }
            let trustWallet = l => ({
                id: TrustWallet.id,
                recommended: l ? .recommended,
                meta: { ...TrustWallet.meta,
                    iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik00MC41MzAzIDE3LjE0MjVDNDguMjQ3NyAyMy42ODU3IDU3LjE1NiAyMy4zNTE4IDU5LjcwMDMgMjMuMzcwN0M1OC44Njk4IDYwLjI1MTMgNTQuNjgzNSA1Mi45MDU4IDQwLjE4ODcgNjMuMTQxMkMyNS44NDc0IDUyLjY5MTYgMjEuNTc5IDU5Ljk3NDQgMjEuMjk2NCAyMy4wODU1QzIzLjgxNDIgMjMuMTA0MiAzMi43MTY1IDIzLjU3MDQgNDAuNTMwMyAxNy4xNDI1WiIgc3Ryb2tlPSIjMzM3NUJCIiBzdHJva2Utd2lkdGg9IjciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo="
                },
                create: c => {
                    let x = new TrustWallet({ ...c,
                        projectId: l ? .projectId,
                        qrcode: !1
                    });
                    return handelWCSessionRequest(x, eW), x
                },
                connectUI: TrustConnectUI,
                isInstalled: () => !!(0, q.a)(globalThis.window) && !!globalThis.window.ethereum.isTrust
            });
            var eZ = Object.freeze({
                __proto__: null,
                trustWallet: trustWallet
            });
            let ZerionScan = l => {
                    let {
                        onBack: c,
                        onConnected: x,
                        onGetStarted: N,
                        walletConfig: U,
                        hideBackButton: Z
                    } = l, $ = (0, ev.xUo)(), [Y, q] = (0, eT.useState)(), {
                        setConnectedWallet: J,
                        chainToConnect: X,
                        setConnectionStatus: en
                    } = (0, ev.tNP)(), er = (0, eT.useRef)(!1);
                    return (0, eT.useEffect)(() => {
                        if (er.current) return;
                        er.current = !0;
                        let l = $(U);
                        en("connecting"), l.connectWithQrCode({
                            chainId: X ? .chainId,
                            onQrCodeUri(l) {
                                q(l)
                            },
                            onConnected() {
                                J(l), x()
                            }
                        })
                    }, [$, J, X, x, U, en]), (0, eC.jsx)(ScanScreen, {
                        hideBackButton: Z,
                        onBack: c,
                        onGetStarted: N,
                        qrCodeUri: Y,
                        walletName: U.meta.name,
                        walletIconURL: U.meta.iconURL
                    })
                },
                ZerionConnectUI = l => {
                    let [c, x] = (0, eT.useState)("connecting"), {
                        walletConfig: N,
                        close: U
                    } = l, Z = (0, ev.$4A)(), $ = 1 === l.supportedWallets.length, [Y, q] = (0, eT.useState)(!1), J = (0, eT.useCallback)(async () => {
                        try {
                            q(!1), X.current = !0, x("connecting"), await Z(N), U()
                        } catch (l) {
                            q(!0)
                        }
                    }, [U, Z, N]), X = (0, eT.useRef)(!1);
                    return ((0, eT.useEffect)(() => {
                        if (X.current) return;
                        let l = !!N.isInstalled && N.isInstalled();
                        (async () => {
                            l ? J() : (0, ew.e)() ? x("open-wc-uri") : x("scanning")
                        })()
                    }, [J, N]), "connecting" === c) ? (0, eC.jsx)(ConnectingScreen, {
                        hideBackButton: $,
                        onGetStarted: () => x("get-started"),
                        onRetry: J,
                        onBack: l.goBack,
                        walletName: N.meta.name,
                        walletIconURL: N.meta.iconURL,
                        errorConnecting: Y
                    }) : "open-wc-uri" === c ? (0, eC.jsx)(WCOpenURI, {
                        onRetry: () => {},
                        onGetStarted: () => x("get-started"),
                        errorConnecting: Y,
                        hideBackButton: $,
                        onBack: l.goBack,
                        onConnected: U,
                        walletConfig: N,
                        appUriPrefix: {
                            ios: "zerion://",
                            android: "https://link.zerion.io/pt3gdRP0njb/",
                            other: "https://link.zerion.io/pt3gdRP0njb/"
                        }
                    }) : "get-started" === c ? (0, eC.jsx)(GetStartedScreen, {
                        walletIconURL: N.meta.iconURL,
                        walletName: N.meta.name,
                        chromeExtensionLink: N.meta.urls ? .chrome,
                        googlePlayStoreLink: N.meta.urls ? .android,
                        appleStoreLink: N.meta.urls ? .ios,
                        onBack: l.goBack
                    }) : "scanning" === c ? (0, eC.jsx)(ZerionScan, {
                        hideBackButton: $,
                        onBack: l.goBack,
                        onConnected: U,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        walletConfig: N
                    }) : null
                },
                eQ = {
                    ios: "zerion://",
                    android: "https://link.zerion.io/pt3gdRP0njb/",
                    other: "https://link.zerion.io/pt3gdRP0njb/"
                },
                zerionWallet = l => ({
                    id: ZerionWallet.id,
                    recommended: l ? .recommended,
                    meta: { ...ZerionWallet.meta,
                        iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IiMyMzYxRUMiLz4KPHBhdGggZD0iTTE3LjM3OSAyMEMxNi4wMDggMjAgMTUuNDc5OCAyMS42OTUyIDE2LjYzMDEgMjIuNDAzNEw0NS40MDk0IDM5Ljc1NjJDNDYuMTI2OCA0MC4xOTc4IDQ3LjA4MzUgNDAuMDIzNCA0Ny41Nzc0IDM5LjM2MDhMNjAuMjMwOSAyMi43NDlDNjEuMDkxMiAyMS41OTUgNjAuMjIyIDIwIDU4LjczMjkgMjBIMTcuMzc5WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTYyLjYxMTcgNjAuMDAwMUM2My45ODI3IDYwLjAwMDEgNjQuNTI0NSA1OC4yOTU1IDYzLjM3NDMgNTcuNTg3NUwzNC41ODY4IDQwLjIzNjlDMzMuODY5NCAzOS43OTUzIDMyLjkzNTkgMzkuOTkxOSAzMi40NDIxIDQwLjY1NDNMMTkuNzY0IDU3LjI2MjlDMTguOTAzOSA1OC40MTY3IDE5LjgwMDMgNjAuMDAwMSAyMS4yODkyIDYwLjAwMDFINjIuNjExN1oiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo="
                    },
                    create: c => {
                        let x = new ZerionWallet({ ...c,
                            projectId: l ? .projectId,
                            qrcode: !1
                        });
                        return handelWCSessionRequest(x, eQ), x
                    },
                    connectUI: ZerionConnectUI,
                    isInstalled: () => !!(0, q.a)(globalThis.window) && !!globalThis.window.ethereum.isZerion
                }),
                RainbowScan = l => {
                    let {
                        onBack: c,
                        onConnected: x,
                        onGetStarted: N,
                        walletConfig: U,
                        hideBackButton: Z
                    } = l, $ = (0, ev.xUo)(), [Y, q] = (0, eT.useState)(), {
                        setConnectedWallet: J,
                        chainToConnect: X,
                        setConnectionStatus: en
                    } = (0, ev.tNP)(), er = (0, eT.useRef)(!1);
                    return (0, eT.useEffect)(() => {
                        if (er.current) return;
                        er.current = !0;
                        let l = $(U);
                        en("connecting"), l.connectWithQrCode({
                            chainId: X ? .chainId,
                            onQrCodeUri(l) {
                                q(l)
                            },
                            onConnected() {
                                J(l), x()
                            }
                        })
                    }, [$, J, X, x, U, en]), (0, eC.jsx)(ScanScreen, {
                        onBack: c,
                        onGetStarted: N,
                        qrCodeUri: Y,
                        walletName: U.meta.name,
                        walletIconURL: U.meta.iconURL,
                        hideBackButton: Z
                    })
                },
                RainbowConnectUI = l => {
                    let [c, x] = (0, eT.useState)("connecting"), {
                        walletConfig: N,
                        close: U
                    } = l, Z = (0, ev.$4A)(), [$, Y] = (0, eT.useState)(!1), q = 1 === l.supportedWallets.length, J = (0, eT.useCallback)(async () => {
                        try {
                            Y(!1), X.current = !0, x("connecting"), await wait(1e3), await Z(N), U()
                        } catch (l) {
                            Y(!0), console.error(l)
                        }
                    }, [U, Z, N]), X = (0, eT.useRef)(!1);
                    return ((0, eT.useEffect)(() => {
                        if (X.current) return;
                        let l = !!N.isInstalled && N.isInstalled();
                        (async () => {
                            l ? J() : (0, ew.e)() ? x("open-wc-uri") : x("scanning")
                        })()
                    }, [J, N]), "connecting" === c) ? (0, eC.jsx)(ConnectingScreen, {
                        errorConnecting: $,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        onRetry: J,
                        hideBackButton: q,
                        onBack: l.goBack,
                        walletName: N.meta.name,
                        walletIconURL: N.meta.iconURL
                    }) : "open-wc-uri" === c ? (0, eC.jsx)(WCOpenURI, {
                        onRetry: () => {},
                        errorConnecting: $,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        hideBackButton: q,
                        onBack: l.goBack,
                        onConnected: U,
                        walletConfig: N,
                        appUriPrefix: {
                            ios: "rainbow://",
                            android: "https://rnbwapp.com/",
                            other: "https://rnbwapp.com/"
                        }
                    }) : "get-started" === c ? (0, eC.jsx)(GetStartedScreen, {
                        walletIconURL: N.meta.iconURL,
                        walletName: N.meta.name,
                        chromeExtensionLink: N.meta.urls ? .chrome,
                        googlePlayStoreLink: N.meta.urls ? .android,
                        appleStoreLink: N.meta.urls ? .ios,
                        onBack: l.goBack
                    }) : "scanning" === c ? (0, eC.jsx)(RainbowScan, {
                        onBack: l.goBack,
                        onConnected: U,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        hideBackButton: q,
                        walletConfig: N
                    }) : null
                },
                eH = {
                    ios: "rainbow://",
                    android: "https://rnbwapp.com/",
                    other: "https://rnbwapp.com/"
                },
                rainbowWallet = l => ({
                    id: RainbowWallet.id,
                    recommended: l ? .recommended,
                    meta: { ...RainbowWallet.meta,
                        name: "Rainbow",
                        iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzVfMTQ5KSI+CjxwYXRoIGQ9Ik04MCAwSDBWODBIODBWMFoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl81XzE0OSkiLz4KPHBhdGggZD0iTTEzLjMzMzMgMjUuMzMzNEgxNy4zMzMzQzM3Ljk1MTkgMjUuMzMzNCA1NC42NjY2IDQyLjA0ODEgNTQuNjY2NiA2Mi42NjY3VjY2LjY2NjdINjIuNjY2NkM2NC44NzU4IDY2LjY2NjcgNjYuNjY2NiA2NC44NzU4IDY2LjY2NjYgNjIuNjY2N0M2Ni42NjY2IDM1LjQyMDYgNDQuNTc5NCAxMy4zMzM0IDE3LjMzMzMgMTMuMzMzNEMxNS4xMjQyIDEzLjMzMzQgMTMuMzMzMyAxNS4xMjQyIDEzLjMzMzMgMTcuMzMzNFYyNS4zMzM0WiIgZmlsbD0idXJsKCNwYWludDFfcmFkaWFsXzVfMTQ5KSIvPgo8cGF0aCBkPSJNNTYgNjIuNjY2Nkg2Ni42NjY3QzY2LjY2NjcgNjQuODc1OCA2NC44NzU4IDY2LjY2NjYgNjIuNjY2NyA2Ni42NjY2SDU2VjYyLjY2NjZaIiBmaWxsPSJ1cmwoI3BhaW50Ml9saW5lYXJfNV8xNDkpIi8+CjxwYXRoIGQ9Ik0xNy4zMzMzIDEzLjMzMzRWMjRIMTMuMzMzM1YxNy4zMzM0QzEzLjMzMzMgMTUuMTI0MiAxNS4xMjQyIDEzLjMzMzQgMTcuMzMzMyAxMy4zMzM0WiIgZmlsbD0idXJsKCNwYWludDNfbGluZWFyXzVfMTQ5KSIvPgo8cGF0aCBkPSJNMTMuMzMzMyAyNEgxNy4zMzMzQzM4LjY4ODMgMjQgNTYgNDEuMzExNyA1NiA2Mi42NjY3VjY2LjY2NjdINDRWNjIuNjY2N0M0NCA0Ny45MzkxIDMyLjA2MDkgMzYgMTcuMzMzMyAzNkgxMy4zMzMzVjI0WiIgZmlsbD0idXJsKCNwYWludDRfcmFkaWFsXzVfMTQ5KSIvPgo8cGF0aCBkPSJNNDUuMzMzMyA2Mi42NjY2SDU2VjY2LjY2NjZINDUuMzMzM1Y2Mi42NjY2WiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzVfMTQ5KSIvPgo8cGF0aCBkPSJNMTMuMzMzMyAzNC42NjY3VjI0SDE3LjMzMzNWMzQuNjY2N0gxMy4zMzMzWiIgZmlsbD0idXJsKCNwYWludDZfbGluZWFyXzVfMTQ5KSIvPgo8cGF0aCBkPSJNMTMuMzMzMyA0MS4zMzMzQzEzLjMzMzMgNDMuNTQyNCAxNS4xMjQyIDQ1LjMzMzMgMTcuMzMzMyA0NS4zMzMzQzI2LjkwNjIgNDUuMzMzMyAzNC42NjY2IDUzLjA5MzcgMzQuNjY2NiA2Mi42NjY2QzM0LjY2NjYgNjQuODc1OCAzNi40NTc1IDY2LjY2NjYgMzguNjY2NiA2Ni42NjY2SDQ1LjMzMzNWNjIuNjY2NkM0NS4zMzMzIDQ3LjIwMjYgMzIuNzk3MyAzNC42NjY2IDE3LjMzMzMgMzQuNjY2NkgxMy4zMzMzVjQxLjMzMzNaIiBmaWxsPSJ1cmwoI3BhaW50N19yYWRpYWxfNV8xNDkpIi8+CjxwYXRoIGQ9Ik0zNC42NjY3IDYyLjY2NjZINDUuMzMzNFY2Ni42NjY2SDM4LjY2NjdDMzYuNDU3NiA2Ni42NjY2IDM0LjY2NjcgNjQuODc1OCAzNC42NjY3IDYyLjY2NjZaIiBmaWxsPSJ1cmwoI3BhaW50OF9yYWRpYWxfNV8xNDkpIi8+CjxwYXRoIGQ9Ik0xNy4zMzMzIDQ1LjMzMzNDMTUuMTI0MiA0NS4zMzMzIDEzLjMzMzMgNDMuNTQyNCAxMy4zMzMzIDQxLjMzMzNWMzQuNjY2NkgxNy4zMzMzVjQ1LjMzMzNaIiBmaWxsPSJ1cmwoI3BhaW50OV9yYWRpYWxfNV8xNDkpIi8+CjwvZz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl81XzE0OSIgeDE9IjQwIiB5MT0iMCIgeDI9IjQwIiB5Mj0iODAiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzE3NDI5OSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMDFFNTkiLz4KPC9saW5lYXJHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDFfcmFkaWFsXzVfMTQ5IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDE3LjMzMzMgNjIuNjY2Nykgcm90YXRlKC05MCkgc2NhbGUoNDkuMzMzMykiPgo8c3RvcCBvZmZzZXQ9IjAuNzcwMjc3IiBzdG9wLWNvbG9yPSIjRkY0MDAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzg3NTRDOSIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Ml9saW5lYXJfNV8xNDkiIHgxPSI1NS4zMzMzIiB5MT0iNjQuNjY2NiIgeDI9IjY2LjY2NjciIHkyPSI2NC42NjY2IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQzX2xpbmVhcl81XzE0OSIgeDE9IjE1LjMzMzMiIHkxPSIxMy4zMzM0IiB4Mj0iMTUuMzMzMyIgeTI9IjI0LjY2NjciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzg3NTRDOSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDRfcmFkaWFsXzVfMTQ5IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDE3LjMzMzMgNjIuNjY2Nykgcm90YXRlKC05MCkgc2NhbGUoMzguNjY2NykiPgo8c3RvcCBvZmZzZXQ9IjAuNzIzOTI5IiBzdG9wLWNvbG9yPSIjRkZGNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTkwMSIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NV9saW5lYXJfNV8xNDkiIHgxPSI0NS4zMzMzIiB5MT0iNjQuNjY2NiIgeDI9IjU2IiB5Mj0iNjQuNjY2NiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZGNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTkwMSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfNV8xNDkiIHgxPSIxNS4zMzMzIiB5MT0iMzQuNjY2NyIgeDI9IjE1LjMzMzMiIHkyPSIyNCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZGNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTkwMSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50N19yYWRpYWxfNV8xNDkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcuMzMzMyA2Mi42NjY2KSByb3RhdGUoLTkwKSBzY2FsZSgyOCkiPgo8c3RvcCBvZmZzZXQ9IjAuNTk1MTMiIHN0b3AtY29sb3I9IiMwMEFBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDFEQTQwIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ4X3JhZGlhbF81XzE0OSIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgzNCA2NC42NjY2KSBzY2FsZSgxMS4zMzMzIDMwLjIyMjIpIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzAwQUFGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMURBNDAiLz4KPC9yYWRpYWxHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDlfcmFkaWFsXzVfMTQ5IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDE1LjMzMzMgNDYpIHJvdGF0ZSgtOTApIHNjYWxlKDExLjMzMzMgMjE0LjkxMykiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzVfMTQ5Ij4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="
                    },
                    create: c => {
                        let x = new RainbowWallet({ ...c,
                            projectId: l ? .projectId,
                            qrcode: !1
                        });
                        return handelWCSessionRequest(x, eH), x
                    },
                    connectUI: RainbowConnectUI,
                    isInstalled: () => !!(0, eg.g)()
                });
            var e$ = Object.freeze({
                __proto__: null,
                rainbowWallet: rainbowWallet
            });
            let PhantomConnectUI = l => {
                    let [c, x] = (0, eT.useState)("connecting"), {
                        walletConfig: N,
                        close: U
                    } = l, [Z, $] = (0, eT.useState)(!1), Y = (0, ev.$4A)(), q = 1 === l.supportedWallets.length, {
                        goBack: J
                    } = l, X = (0, eT.useCallback)(async () => {
                        try {
                            en.current = !0, x("connecting"), $(!1), await wait(1e3), await Y(N), U()
                        } catch (l) {
                            $(!0), console.error(l)
                        }
                    }, [N, U, Y]), en = (0, eT.useRef)(!1);
                    return ((0, eT.useEffect)(() => {
                        if (en.current) return;
                        let l = !!N.isInstalled && N.isInstalled();
                        (async () => {
                            l ? X() : x("get-started")
                        })()
                    }, [N, U, Y, J, X]), "connecting" === c) ? (0, eC.jsx)(ConnectingScreen, {
                        hideBackButton: q,
                        onBack: l.goBack,
                        walletName: N.meta.name,
                        walletIconURL: N.meta.iconURL,
                        onGetStarted: () => {
                            x("get-started")
                        },
                        onRetry: () => {
                            X()
                        },
                        errorConnecting: Z
                    }) : "get-started" === c ? (0, eC.jsx)(GetStartedScreen, {
                        walletIconURL: N.meta.iconURL,
                        walletName: N.meta.name,
                        chromeExtensionLink: N.meta.urls ? .chrome,
                        googlePlayStoreLink: N.meta.urls ? .android,
                        appleStoreLink: N.meta.urls ? .ios,
                        onBack: () => {
                            l.goBack()
                        }
                    }) : null
                },
                phantomWallet = l => ({
                    recommended: l ? .recommended,
                    id: PhantomWallet.id,
                    meta: { ...PhantomWallet.meta,
                        iconURL: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo="
                    },
                    create: l => new PhantomWallet(l),
                    connectUI: PhantomConnectUI,
                    isInstalled: () => !!(0, eb.g)()
                }),
                eY = [metamaskWallet(), coinbaseWallet(), walletConnect(), trustWallet(), rainbowWallet(), zerionWallet(), phantomWallet()],
                FormFieldWithIconButton = l => (0, eC.jsxs)("div", {
                    children: [(0, eC.jsx)(ew.h, {
                        htmlFor: l.id,
                        children: l.label
                    }), (0, eC.jsx)(ew.S, {
                        y: "sm"
                    }), (0, eC.jsxs)(ew.R, {
                        "data-error": !!l.error,
                        children: [(0, eC.jsx)(ew.A, {
                            sm: !0,
                            variant: "transparent",
                            required: l.required,
                            name: l.name,
                            autoComplete: l.autocomplete,
                            id: l.id,
                            onChange: c => l.onChange(c.target.value),
                            value: l.value,
                            type: l.noSave ? "text" : l.type,
                            style: "password" === l.type && l.noSave ? {
                                WebkitTextSecurity: "disc"
                            } : void 0,
                            "data-test": l.dataTest,
                            placeholder: l.placeholder
                        }), (0, eC.jsx)(ew.U, {
                            type: "button",
                            onClick: l.right.onClick,
                            children: l.right.icon
                        })]
                    }), l.error && (0, eC.jsxs)(eC.Fragment, {
                        children: [(0, eC.jsx)(ew.S, {
                            y: "sm"
                        }), (0, eC.jsx)(ew.b, {
                            color: "danger",
                            size: "sm",
                            children: l.error
                        })]
                    })]
                }),
                FormField = l => (0, eC.jsxs)("div", {
                    children: [(0, eC.jsx)(ew.h, {
                        htmlFor: l.id,
                        children: l.label
                    }), (0, eC.jsx)(ew.S, {
                        y: "sm"
                    }), (0, eC.jsx)(ew.A, {
                        variant: "outline",
                        required: l.required,
                        name: l.name,
                        autoComplete: l.autocomplete,
                        id: l.id,
                        onChange: c => l.onChange(c.target.value),
                        value: l.value,
                        type: l.type,
                        "data-error": !!l.errorMessage,
                        placeholder: l.placeholder,
                        disabled: l.disabled
                    }), l.errorMessage && (0, eC.jsxs)(eC.Fragment, {
                        children: [(0, eC.jsx)(ew.S, {
                            y: "xs"
                        }), (0, eC.jsx)(ew.b, {
                            color: "danger",
                            size: "sm",
                            children: l.errorMessage
                        })]
                    })]
                })
        },
        33055: function(l, c, x) {
            "use strict";
            x.d(c, {
                frameWallet: function() {
                    return frameWallet
                }
            });
            var N = x(53061),
                U = x(23743),
                Z = x(64140),
                $ = x(33883);
            x(11953), x(9409);
            let FrameWallet = class FrameWallet extends $.a {
                get walletName() {
                    return "Frame Wallet"
                }
                constructor(l) {
                    super(FrameWallet.id, l)
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            FrameConnector: l
                        } = await x.e(7949).then(x.bind(x, 17949));
                        this.connector = new Z.W(new l({
                            chains: this.chains,
                            connectorStorage: this.walletStorage,
                            options: {
                                shimDisconnect: !0
                            }
                        }))
                    }
                    return this.connector
                }
            };
            (0, N._)(FrameWallet, "id", U.w.frame);
            var Y = x(23780),
                q = x(41282),
                J = x(54844),
                X = x(67327),
                en = x(2265),
                er = x(57437);
            x(8801), x(75298), x(2390);
            let FrameFailedConnect = l => (0, er.jsxs)(X.C, {
                    p: "lg",
                    children: [(0, er.jsx)(X.M, {
                        onBack: () => l.onBack(),
                        title: "Frame"
                    }), (0, er.jsx)(X.S, {
                        y: "xl"
                    }), (0, er.jsxs)(er.Fragment, {
                        children: [(0, er.jsx)(X.a, {
                            children: "Failed to connect to Frame "
                        }), (0, er.jsx)(X.S, {
                            y: "sm"
                        }), (0, er.jsx)(X.g, {
                            sm: !0,
                            children: "Make sure the desktop app is installed and running. You can download Frame from the link below. Make sure to refresh this page once Frame is running."
                        })]
                    }), (0, er.jsx)(X.S, {
                        y: "lg"
                    }), (0, er.jsxs)(J.B, {
                        onClick: () => {
                            (0, J.o)("https://frame.sh")
                        },
                        children: [(0, er.jsx)(X.D, {
                            width: X.i.lg,
                            height: X.i.lg,
                            src: l.walletIconURL
                        }), (0, er.jsx)("span", {
                            children: "Download Frame"
                        })]
                    }), (0, er.jsx)(X.S, {
                        y: "lg"
                    }), (0, er.jsx)(X.V, {
                        target: "_blank",
                        href: l.supportLink,
                        children: "Still having troubles connecting?"
                    })]
                }),
                FrameConnectUI = l => {
                    let [c, x] = (0, en.useState)("connecting"), N = (0, q.$4A)(), U = (0, en.useRef)(!1), {
                        walletConfig: Z,
                        close: $,
                        goBack: Y
                    } = l, ea = 1 === l.supportedWallets.length;
                    return ((0, en.useEffect)(() => {
                        U.current || (async () => {
                            if ((0, X.e)())(0, X.e)() && (0, J.o)("https://frame.sh");
                            else try {
                                U.current = !0, x("connecting"), await N(Z), $()
                            } catch (l) {
                                x("connect-failed")
                            }
                        })()
                    }, [Z, $, N, Y]), "connecting" === c) ? (0, er.jsx)(J.C, {
                        errorConnecting: !1,
                        onRetry: () => {},
                        onGetStarted: () => {
                            x("get-started")
                        },
                        hideBackButton: ea,
                        onBack: Y,
                        walletName: Z.meta.name,
                        walletIconURL: Z.meta.iconURL
                    }) : "connect-failed" === c ? (0, er.jsx)(FrameFailedConnect, {
                        onBack: Y,
                        walletIconURL: Z.meta.iconURL,
                        supportLink: "https://docs.frame.sh"
                    }) : "get-started" === c ? (0, er.jsx)(J.G, {
                        walletIconURL: Z.meta.iconURL,
                        walletName: Z.meta.name,
                        chromeExtensionLink: Z.meta.urls ? .chrome,
                        googlePlayStoreLink: Z.meta.urls ? .android,
                        appleStoreLink: Z.meta.urls ? .ios,
                        onBack: l.goBack
                    }) : null
                },
                frameWallet = l => ({
                    id: FrameWallet.id,
                    recommended: l ? .recommended,
                    meta: {
                        name: "Frame",
                        iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMjEuNDE3NEMwIDEzLjkyMDYgMCAxMC4xNzIyIDEuNDUzNiA3LjMwODc4QzIuNzMyMjQgNC43OTAwOCA0Ljc3MjQ3IDIuNzQyMzIgNy4yODE5MSAxLjQ1ODk3QzEwLjEzNDggMCAxMy44Njk0IDAgMjEuMzM4NyAwSDU4LjY2MTNDNjYuMTMwNiAwIDY5Ljg2NTIgMCA3Mi43MTgxIDEuNDU4OTdDNzUuMjI3NiAyLjc0MjMyIDc3LjI2NzcgNC43OTAwOCA3OC41NDY0IDcuMzA4NzhDODAgMTAuMTcyMiA4MCAxMy45MjA2IDgwIDIxLjQxNzRWNTguNTgyNkM4MCA2Ni4wNzk0IDgwIDY5LjgyNzggNzguNTQ2NCA3Mi42OTEyQzc3LjI2NzcgNzUuMjEgNzUuMjI3NiA3Ny4yNTc2IDcyLjcxODEgNzguNTQxQzY5Ljg2NTIgODAgNjYuMTMwNiA4MCA1OC42NjEzIDgwSDIxLjMzODdDMTMuODY5NCA4MCAxMC4xMzQ4IDgwIDcuMjgxOTEgNzguNTQxQzQuNzcyNDcgNzcuMjU3NiAyLjczMjI0IDc1LjIxIDEuNDUzNiA3Mi42OTEyQzAgNjkuODI3OCAwIDY2LjA3OTQgMCA1OC41ODI2VjIxLjQxNzRaIiBmaWxsPSIjMjYyRDM0Ii8+CjxtYXNrIGlkPSJtYXNrMF8yNF83OCIgc3R5bGU9Im1hc2stdHlwZTpsdW1pbmFuY2UiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjE3IiB5PSIxNyIgd2lkdGg9IjQ3IiBoZWlnaHQ9IjQ3Ij4KPHBhdGggZD0iTTYzLjY2NjcgMTdIMTdWNjMuNjY2N0g2My42NjY3VjE3WiIgZmlsbD0id2hpdGUiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzI0Xzc4KSI+CjxwYXRoIGQ9Ik02MS4xNDE3IDQwLjA3MzhWMjIuMzcxN0M2MS4xNDE3IDIwLjgxNTIgNTkuODY0IDE5LjUzMzIgNTguMzEyNSAxOS41MzMySDQwLjYzNzVDNDAuNDU1IDE5LjUzMzIgNDAuMzAyOCAxOS40NzIyIDQwLjE1MDggMTkuMzUwMkwzOC4wMjEzIDE3LjIxMzdDMzcuODk5NyAxNy4wOTE1IDM3LjcxNyAxNyAzNy41MzQ1IDE3SDE5LjgyOTJDMTguMjc3NyAxNyAxNyAxOC4yNTEzIDE3IDE5LjgzODVWMzcuNTQwN0MxNyAzNy43MjM4IDE3LjA2MDggMzcuODc2MyAxNy4xODI1IDM4LjAyOUwxOS4zMTIgNDAuMTY1NUMxOS40MzM3IDQwLjI4NzUgMTkuNTI1IDQwLjQ3MDcgMTkuNTI1IDQwLjY1MzhWNTguMzU2QzE5LjUyNSA1OS45MTI1IDIwLjgwMjcgNjEuMTk0NSAyMi4zNTQyIDYxLjE5NDVINDAuMDU5NUM0MC4yNDIgNjEuMTk0NSA0MC4zOTQyIDYxLjI1NTUgNDAuNTQ2MyA2MS4zNzc3TDQyLjY3NTggNjMuNTE0QzQyLjc5NzUgNjMuNjM2MiA0Mi45OCA2My42OTcyIDQzLjE2MjUgNjMuNjk3Mkg2MC44Njc4QzYyLjQxOTMgNjMuNjk3MiA2My42OTcyIDYyLjQ0NTggNjMuNjk3MiA2MC44NTg3VjQzLjE1NjVDNjMuNjk3MiA0Mi45NzMzIDYzLjYzNjIgNDIuODIwOCA2My41MTQ1IDQyLjY2ODJMNjEuMzg1IDQwLjUzMTdDNjEuMjMzIDQwLjQwOTcgNjEuMTQxNyA0MC4yNTcgNjEuMTQxNyA0MC4wNzM4Wk00OS4xMjUyIDQ5LjUzNTVIMzEuNTcyQzMxLjM1OSA0OS41MzU1IDMxLjE3NjUgNDkuMzUyMyAzMS4xNzY1IDQ5LjEzODdWMzEuNTU4NUMzMS4xNzY1IDMxLjM0NDggMzEuMzU5IDMxLjE2MTggMzEuNTcyIDMxLjE2MThINDkuMTI1MkM0OS4zMzgyIDMxLjE2MTggNDkuNTIwNyAzMS4zNDQ4IDQ5LjUyMDcgMzEuNTU4NVY0OS4xMzg3QzQ5LjU1MSA0OS4zNTIzIDQ5LjM2ODUgNDkuNTM1NSA0OS4xMjUyIDQ5LjUzNTVaIiBmaWxsPSIjRDZGOUY4Ii8+CjwvZz4KPC9zdmc+Cg==",
                        urls: {
                            chrome: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf",
                            firefox: "https://addons.mozilla.org/en-US/firefox/addon/frame-extension"
                        }
                    },
                    create: l => new FrameWallet(l),
                    connectUI: FrameConnectUI,
                    isInstalled() {
                        let l = globalThis ? .window;
                        return !!(0, Y.a)(l) && (l.ethereum ? .isFrame || l.ethereum ? .providers ? .some(l => l.isFrame) || !1)
                    }
                })
        },
        76904: function(l, c, x) {
            "use strict";
            x.d(c, {
                magicLink: function() {
                    return magicLink
                }
            });
            var N = x(53061),
                U = x(64140),
                Z = x(33883),
                $ = x(23743);
            x(11953), x(9409);
            let MagicLink = class MagicLink extends Z.a {
                get walletName() {
                    return "Magic Link"
                }
                constructor(l) {
                    super(MagicLink.id, l), this.options = l
                }
                async initializeConnector() {
                    let {
                        MagicAuthConnector: l
                    } = await x.e(9507).then(x.bind(x, 29507)), c = new l({
                        chains: this.chains,
                        options: this.options
                    });
                    return this.magicConnector = c, this.connector = new U.W(c), this.connector
                }
                async getConnector() {
                    return this.connector ? this.connector : await this.initializeConnector()
                }
                getMagic() {
                    if (!this.magicConnector) throw Error("Magic connector is not initialized");
                    return this.magicConnector.getMagicSDK()
                }
                async autoConnect(l) {
                    await this.initializeConnector(), await this.magicConnector ? .initializeMagicSDK(l);
                    let c = this.getMagic(); {
                        let l = new URL(window.location.href),
                            x = l.searchParams.get("magic_credential");
                        if (x) try {
                            this.oAuthRedirectResult = await c.oauth.getRedirectResult()
                        } catch {}
                    }
                    let x = await c.user.isLoggedIn();
                    if (x) return super.autoConnect(l);
                    throw Error("Magic user is not logged in")
                }
                async disconnect() {
                    this.oAuthRedirectResult = void 0;
                    let l = this.getMagic();
                    return await l.user.logout(), super.disconnect()
                }
                async connect(l) {
                    if ("email" in l && !1 === this.options.emailLogin) throw Error("Email login is disabled");
                    if ("phoneNumber" in l && !1 === this.options.smsLogin) throw Error("SMS login is disabled");
                    return super.connect(l)
                }
            };
            (0, N._)(MagicLink, "meta", {
                iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
                name: "Magic Link"
            }), (0, N._)(MagicLink, "id", $.w.magicLink);
            var Y = x(41282),
                q = x(2265),
                J = x(67327),
                X = x(80464),
                en = x(78698),
                er = x(8801),
                ea = x(57437);

            function magicLink(l) {
                let c = !1 !== l.emailLogin,
                    x = !1 !== l.smsLogin,
                    N = l.oauthOptions ? .providers,
                    U = l.type || "auth",
                    Z = en.a,
                    $ = "Email or phone";
                return c && !x && (Z = en.e, $ = "Email"), !c && x && (Z = en.p, $ = "Phone number"), c || x || ($ = "Social login"), {
                    category: "socialLogin",
                    id: MagicLink.id,
                    recommended: l ? .recommended,
                    meta: { ...MagicLink.meta,
                        name: $,
                        iconURL: Z
                    },
                    create: c => new MagicLink({ ...c,
                        ...l
                    }),
                    connectUI: l => "wide" === l.modalSize ? (0, ea.jsx)(MagicConnectionUIWide, { ...l,
                        type: U,
                        emailLogin: c,
                        smsLogin: x,
                        oauthProviders: N
                    }) : (0, ea.jsx)(MagicConnectionUICompact, { ...l,
                        type: U
                    }),
                    selectUI: "connect" === l.type ? void 0 : l => "wide" === l.modalSize ? (0, ea.jsx)(J.W, {
                        walletConfig: l.walletConfig,
                        selectWallet: () => l.onSelect(void 0)
                    }) : (0, ea.jsx)(MagicUI, { ...l,
                        emailLogin: c,
                        smsLogin: x,
                        oauthProviders: N,
                        showOrSeparator: l.supportedWallets.length > 1
                    }),
                    isInstalled: () => !1
                }
            }
            let MagicUI = l => {
                let c = !1 !== l.emailLogin,
                    x = !1 !== l.smsLogin,
                    N = "Login with email or phone number",
                    U = "text",
                    Z = "email or phone number is required";
                if (c && !x ? (N = "Login with email address", Z = "email address is required", U = "email") : !c && x && (N = "Login with phone number", Z = "phone number is required", U = "tel"), !c && !x && !l.oauthProviders) throw Error('MagicLink must have either "emailLogin" or "smsLogin" or social login enabled');
                let $ = "compact" === l.modalSize ? J.i.md : J.i.lg;
                return (0, ea.jsxs)(J.C, {
                    flex: "column",
                    gap: "compact" === l.modalSize ? "lg" : "xl",
                    style: {
                        width: "100%"
                    },
                    children: [l.oauthProviders && (0, ea.jsx)(ea.Fragment, {
                        children: l.oauthProviders.length >= 3 ? (0, ea.jsx)(J.C, {
                            gap: "md",
                            flex: "row",
                            center: "x",
                            children: l.oauthProviders.map(c => (0, ea.jsx)(ec, {
                                onClick: () => {
                                    l.onSelect({
                                        provider: c
                                    })
                                },
                                children: (0, ea.jsx)(en.T, {
                                    tip: `Login with ${upperCaseFirstLetter(c)}`,
                                    sideOffset: 15,
                                    children: (0, ea.jsx)("div", {
                                        children: (0, ea.jsx)(J.D, {
                                            src: eo[c],
                                            width: J.i.lg,
                                            height: J.i.lg,
                                            alt: ""
                                        })
                                    })
                                })
                            }, c))
                        }) : (0, ea.jsx)(J.C, {
                            gap: "xs",
                            flex: "column",
                            children: l.oauthProviders.map(c => (0, ea.jsxs)(el, {
                                variant: "secondary",
                                onClick: () => {
                                    l.onSelect({
                                        provider: c
                                    })
                                },
                                children: [(0, ea.jsx)(J.D, {
                                    src: eo[c],
                                    width: $,
                                    height: $,
                                    alt: ""
                                }), (0, ea.jsxs)("span", {
                                    children: ["Login with ", upperCaseFirstLetter(c)]
                                })]
                            }, c))
                        })
                    }), (0, ea.jsx)(X.I, {
                        onSelect: l.onSelect,
                        placeholder: N,
                        name: "magic-input",
                        type: U,
                        noInput: !c && !x,
                        emptyErrorMessage: Z,
                        errorMessage: l => {
                            let N = l.includes("@"),
                                U = Number.isInteger(Number(l[l.length - 1]));
                            if (N && c) {
                                let c = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,})$/g.test(l.replace(/\+/g, ""));
                                if (!c) return "Invalid email address"
                            } else if (U && x) {
                                if (!l.startsWith("+")) return "Phone number must start with a country code"
                            } else {
                                if (c && x) return "Invalid email address or phone number";
                                if (c) return "Invalid email address";
                                if (x) return "Invalid phone number"
                            }
                        },
                        showOrSeparator: l.showOrSeparator
                    })]
                })
            };

            function useConnectMagic() {
                let l = (0, Y.$4A)(),
                    c = (0, q.useCallback)(async c => {
                        let {
                            selectionData: x,
                            walletConfig: N,
                            singleWallet: U
                        } = c;
                        if ("object" == typeof x) {
                            try {
                                (async () => {
                                    await l(N, {
                                        oauthProvider: x.provider
                                    })
                                })(), c.close()
                            } catch {
                                U || c.open()
                            }
                            return
                        }
                        let Z = !!x && x.includes("@");
                        (async () => {
                            c.close();
                            try {
                                await l(N, "connect" === c.type ? {} : Z ? {
                                    email: x
                                } : {
                                    phoneNumber: x
                                })
                            } catch (l) {
                                U || c.open(), console.error(l)
                            }
                        })()
                    }, [l]);
                return c
            }
            let MagicConnectionUICompact = l => {
                    let {
                        close: c,
                        walletConfig: x,
                        open: N,
                        selectionData: U,
                        supportedWallets: Z,
                        type: $
                    } = l, Y = (0, q.useRef)(!1), X = 1 === Z.length, en = useConnectMagic();
                    return (0, q.useEffect)(() => {
                        Y.current || (Y.current = !0, en({
                            selectionData: U,
                            singleWallet: X,
                            type: $,
                            walletConfig: x,
                            open: N,
                            close: c
                        }))
                    }, [c, en, N, U, X, $, x]), (0, ea.jsx)(J.C, {
                        flex: "row",
                        center: "both",
                        style: {
                            minHeight: "250px"
                        },
                        children: (0, ea.jsx)(J.c, {
                            size: "md",
                            color: "accentText"
                        })
                    })
                },
                MagicConnectionUIWide = l => {
                    let c = useConnectMagic();
                    return (0, ea.jsxs)(J.C, {
                        p: "lg",
                        fullHeight: !0,
                        flex: "column",
                        children: [(0, ea.jsx)(J.M, {
                            onBack: l.goBack,
                            title: "Sign in"
                        }), (0, ea.jsx)(J.C, {
                            expand: !0,
                            flex: "column",
                            center: "both",
                            p: "md",
                            children: (0, ea.jsx)(MagicUI, { ...l,
                                onSelect: x => {
                                    c({
                                        selectionData: x,
                                        close: l.close,
                                        open: l.open,
                                        singleWallet: 1 === l.supportedWallets.length,
                                        type: l.type,
                                        walletConfig: l.walletConfig
                                    })
                                },
                                showOrSeparator: !1
                            })
                        })]
                    })
                },
                eo = {
                    google: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI3MDUuNiIgaGVpZ2h0PSI3MjAiIHZpZXdCb3g9IjAgMCAxODYuNjkgMTkwLjUiIHhtbG5zOnY9Imh0dHBzOi8vdmVjdGEuaW8vbmFubyI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTE4NC41ODMgNzY1LjE3MSkiPjxwYXRoIGNsaXAtcGF0aD0ibm9uZSIgbWFzaz0ibm9uZSIgZD0iTS0xMDg5LjMzMy02ODcuMjM5djM2Ljg4OGg1MS4yNjJjLTIuMjUxIDExLjg2My05LjAwNiAyMS45MDgtMTkuMTM3IDI4LjY2MmwzMC45MTMgMjMuOTg2YzE4LjAxMS0xNi42MjUgMjguNDAyLTQxLjA0NCAyOC40MDItNzAuMDUyIDAtNi43NTQtLjYwNi0xMy4yNDktMS43MzItMTkuNDgzeiIgZmlsbD0iIzQyODVmNCIvPjxwYXRoIGNsaXAtcGF0aD0ibm9uZSIgbWFzaz0ibm9uZSIgZD0iTS0xMTQyLjcxNC02NTEuNzkxbC02Ljk3MiA1LjMzNy0yNC42NzkgMTkuMjIzaDBjMTUuNjczIDMxLjA4NiA0Ny43OTYgNTIuNTYxIDg1LjAzIDUyLjU2MSAyNS43MTcgMCA0Ny4yNzgtOC40ODYgNjMuMDM4LTIzLjAzM2wtMzAuOTEzLTIzLjk4NmMtOC40ODYgNS43MTUtMTkuMzEgOS4xNzktMzIuMTI1IDkuMTc5LTI0Ljc2NSAwLTQ1LjgwNi0xNi43MTItNTMuMzQtMzkuMjI2eiIgZmlsbD0iIzM0YTg1MyIvPjxwYXRoIGNsaXAtcGF0aD0ibm9uZSIgbWFzaz0ibm9uZSIgZD0iTS0xMTc0LjM2NS03MTIuNjFjLTYuNDk0IDEyLjgxNS0xMC4yMTcgMjcuMjc2LTEwLjIxNyA0Mi42ODlzMy43MjMgMjkuODc0IDEwLjIxNyA0Mi42ODljMCAuMDg2IDMxLjY5My0yNC41OTIgMzEuNjkzLTI0LjU5Mi0xLjkwNS01LjcxNS0zLjAzMS0xMS43NzYtMy4wMzEtMTguMDk4czEuMTI2LTEyLjM4MyAzLjAzMS0xOC4wOTh6IiBmaWxsPSIjZmJiYzA1Ii8+PHBhdGggZD0iTS0xMDg5LjMzMy03MjcuMjQ0YzE0LjAyOCAwIDI2LjQ5NyA0Ljg0OSAzNi40NTUgMTQuMjAxbDI3LjI3Ni0yNy4yNzZjLTE2LjUzOS0xNS40MTMtMzguMDEzLTI0Ljg1Mi02My43MzEtMjQuODUyLTM3LjIzNCAwLTY5LjM1OSAyMS4zODgtODUuMDMyIDUyLjU2MWwzMS42OTIgMjQuNTkyYzcuNTMzLTIyLjUxNCAyOC41NzUtMzkuMjI2IDUzLjM0LTM5LjIyNnoiIGZpbGw9IiNlYTQzMzUiIGNsaXAtcGF0aD0ibm9uZSIgbWFzaz0ibm9uZSIvPjwvZz48L3N2Zz4=",
                    facebook: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGRhdGEtbmFtZT0iRWJlbmUgMSIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgaWQ9ImZhY2Vib29rLWxvZ28tMjAxOSI+PHBhdGggZmlsbD0iIzE4NzdmMiIgZD0iTTEwMjQsNTEyQzEwMjQsMjI5LjIzMDE2LDc5NC43Njk3OCwwLDUxMiwwUzAsMjI5LjIzMDE2LDAsNTEyYzAsMjU1LjU1NCwxODcuMjMxLDQ2Ny4zNzAxMiw0MzIsNTA1Ljc3Nzc3VjY2MEgzMDJWNTEySDQzMlYzOTkuMkM0MzIsMjcwLjg3OTgyLDUwOC40Mzg1NCwyMDAsNjI1LjM4OTIyLDIwMCw2ODEuNDA3NjUsMjAwLDc0MCwyMTAsNzQwLDIxMFYzMzZINjc1LjQzNzEzQzYxMS44MzUwOCwzMzYsNTkyLDM3NS40NjY2Nyw1OTIsNDE1Ljk1NzI4VjUxMkg3MzRMNzExLjMsNjYwSDU5MnYzNTcuNzc3NzdDODM2Ljc2OSw5NzkuMzcwMTIsMTAyNCw3NjcuNTU0LDEwMjQsNTEyWiI+PC9wYXRoPjxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik03MTEuMyw2NjAsNzM0LDUxMkg1OTJWNDE1Ljk1NzI4QzU5MiwzNzUuNDY2NjcsNjExLjgzNTA4LDMzNiw2NzUuNDM3MTMsMzM2SDc0MFYyMTBzLTU4LjU5MjM1LTEwLTExNC42MTA3OC0xMEM1MDguNDM4NTQsMjAwLDQzMiwyNzAuODc5ODIsNDMyLDM5OS4yVjUxMkgzMDJWNjYwSDQzMnYzNTcuNzc3NzdhNTE3LjM5NjE5LDUxNy4zOTYxOSwwLDAsMCwxNjAsMFY2NjBaIj48L3BhdGg+PC9zdmc+",
                    twitter: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNiAxNiIgaWQ9InR3aXR0ZXIiPjxwYXRoIGZpbGw9IiMwM0E5RjQiIGQ9Ik0xNiAzLjUzOWE2LjgzOSA2LjgzOSAwIDAgMS0xLjg5LjUxOCAzLjI2MiAzLjI2MiAwIDAgMCAxLjQ0My0xLjgxMyA2LjU1NSA2LjU1NSAwIDAgMS0yLjA4Ljc5NCAzLjI4IDMuMjggMCAwIDAtNS42NzQgMi4yNDNjMCAuMjYuMDIyLjUxLjA3Ni43NDhhOS4yODQgOS4yODQgMCAwIDEtNi43NjEtMy40MzEgMy4yODUgMy4yODUgMCAwIDAgMS4wMDggNC4zODRBMy4yNCAzLjI0IDAgMCAxIC42NCA2LjU3OHYuMDM2YTMuMjk1IDMuMjk1IDAgMCAwIDIuNjI4IDMuMjIzIDMuMjc0IDMuMjc0IDAgMCAxLS44Ni4xMDggMi45IDIuOSAwIDAgMS0uNjIxLS4wNTYgMy4zMTEgMy4zMTEgMCAwIDAgMy4wNjUgMi4yODUgNi41OSA2LjU5IDAgMCAxLTQuMDY3IDEuMzk5Yy0uMjY5IDAtLjUyNy0uMDEyLS43ODUtLjA0NUE5LjIzNCA5LjIzNCAwIDAgMCA1LjAzMiAxNWM2LjAzNiAwIDkuMzM2LTUgOS4zMzYtOS4zMzQgMC0uMTQ1LS4wMDUtLjI4NS0uMDEyLS40MjRBNi41NDQgNi41NDQgMCAwIDAgMTYgMy41Mzl6Ij48L3BhdGg+PC9zdmc+",
                    github: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzEwXzIpIj4KPHBhdGggZD0iTTcuOTk5IDBDMy41ODIwMSAwIDQuNjE2NDhlLTA2IDMuNTk2IDQuNjE2NDhlLTA2IDguMDMyQy0wLjAwMTggOS43MTU1NSAwLjUyNTUxOSAxMS4zNTcxIDEuNTA3NDQgMTIuNzI0NkMyLjQ4OTM1IDE0LjA5MjIgMy44NzYyMSAxNS4xMTY2IDUuNDcyIDE1LjY1M0M1Ljg3MiAxNS43MjcgNi4wMTggMTUuNDc5IDYuMDE4IDE1LjI2NkM2LjAxOCAxNS4wNzUgNi4wMTEgMTQuNTcgNi4wMDcgMTMuOUMzLjc4MiAxNC4zODUgMy4zMTIgMTIuODIzIDMuMzEyIDEyLjgyM0MyLjk0OSAxMS44OTUgMi40MjQgMTEuNjQ4IDIuNDI0IDExLjY0OEMxLjY5NyAxMS4xNSAyLjQ3OCAxMS4xNiAyLjQ3OCAxMS4xNkMzLjI4MSAxMS4yMTcgMy43MDMgMTEuOTg4IDMuNzAzIDExLjk4OEM0LjQxNyAxMy4yMTUgNS41NzYgMTIuODYxIDYuMDMyIDEyLjY1NUM2LjEwNCAxMi4xMzYgNi4zMTEgMTEuNzgyIDYuNTQgMTEuNTgxQzQuNzY0IDExLjM3OCAyLjg5NiAxMC42ODkgMi44OTYgNy42MTJDMi44OTYgNi43MzUgMy4yMDggNi4wMTggMy43MiA1LjQ1NkMzLjYzNyA1LjI1MyAzLjM2MyA0LjQzNiAzLjc5OCAzLjMzMUMzLjc5OCAzLjMzMSA0LjQ3IDMuMTE1IDUuOTk4IDQuMTU0QzYuNjUwNzUgMy45NzU2MSA3LjMyNDMyIDMuODg0ODIgOC4wMDEwMSAzLjg4NEM4LjY3NzcyIDMuODg1MzQgOS4zNTEyNiAzLjk3NjQ3IDEwLjAwNCA0LjE1NUMxMS41MzEgMy4xMTYgMTIuMjAyIDMuMzMyIDEyLjIwMiAzLjMzMkMxMi42MzggNC40MzggMTIuMzY0IDUuMjU0IDEyLjI4MiA1LjQ1N0MxMi43OTUgNi4wMTkgMTMuMTA0IDYuNzM2IDEzLjEwNCA3LjYxM0MxMy4xMDQgMTAuNjk4IDExLjIzNCAxMS4zNzcgOS40NTIgMTEuNTc2QzkuNzM5IDExLjgyNCA5Ljk5NSAxMi4zMTQgOS45OTUgMTMuMDYzQzkuOTk1IDE0LjEzNyA5Ljk4NSAxNS4wMDMgOS45ODUgMTUuMjY2QzkuOTg1IDE1LjQ4MSAxMC4xMjkgMTUuNzMxIDEwLjUzNSAxNS42NTJDMTIuMTI5MiAxNS4xMTQzIDEzLjUxNDQgMTQuMDg5NSAxNC40OTQ5IDEyLjcyMjNDMTUuNDc1NSAxMS4zNTUxIDE2LjAwMTkgOS43MTQ0OCAxNiA4LjAzMkMxNiAzLjU5NiAxMi40MTggMCA3Ljk5OSAwWiIgZmlsbD0iIzhCOEI4QiIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwXzIiPgo8cmVjdCB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==",
                    apple: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDM4IiBoZWlnaHQ9IjI1MDAiIHZpZXdCb3g9IjAgMCA0OTYuMjU1IDYwOC43MjgiIGlkPSJhcHBsZSI+PHBhdGggZmlsbD0iIzk5OSIgZD0iTTI3My44MSA1Mi45NzNDMzEzLjgwNi4yNTcgMzY5LjQxIDAgMzY5LjQxIDBzOC4yNzEgNDkuNTYyLTMxLjQ2MyA5Ny4zMDZjLTQyLjQyNiA1MC45OC05MC42NDkgNDIuNjM4LTkwLjY0OSA0Mi42MzhzLTkuMDU1LTQwLjA5NCAyNi41MTItODYuOTcxek0yNTIuMzg1IDE3NC42NjJjMjAuNTc2IDAgNTguNzY0LTI4LjI4NCAxMDguNDcxLTI4LjI4NCA4NS41NjIgMCAxMTkuMjIyIDYwLjg4MyAxMTkuMjIyIDYwLjg4M3MtNjUuODMzIDMzLjY1OS02NS44MzMgMTE1LjMzMWMwIDkyLjEzMyA4Mi4wMSAxMjMuODg1IDgyLjAxIDEyMy44ODVzLTU3LjMyOCAxNjEuMzU3LTEzNC43NjIgMTYxLjM1N2MtMzUuNTY1IDAtNjMuMjE1LTIzLjk2Ny0xMDAuNjg4LTIzLjk2Ny0zOC4xODggMC03Ni4wODQgMjQuODYxLTEwMC43NjYgMjQuODYxQzg5LjMzIDYwOC43MyAwIDQ1NS42NjYgMCAzMzIuNjI4YzAtMTIxLjA1MiA3NS42MTItMTg0LjU1NCAxNDYuNTMzLTE4NC41NTQgNDYuMTA1IDAgODEuODgzIDI2LjU4OCAxMDUuODUyIDI2LjU4OHoiPjwvcGF0aD48L3N2Zz4=",
                    linkedin: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NCIgaGVpZ2h0PSI0MCIgaWQ9ImxpbmtlZGluIj48cGF0aCBmaWxsPSIjMDA3RUJCIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00NCA0MGgtOS43MjVWMjUuOTM4YzAtMy42OC0xLjUyLTYuMTkzLTQuODY2LTYuMTkzLTIuNTU4IDAtMy45ODEgMS42OTYtNC42NDMgMy4zMy0uMjQ5LjU4Ni0uMjEgMS40MDMtLjIxIDIuMjJWNDBoLTkuNjM0cy4xMjQtMjQuOTA5IDAtMjcuMTczaDkuNjM0djQuMjY1Yy41Ny0xLjg2NSAzLjY0OC00LjUyNiA4LjU2LTQuNTI2QzM5LjIxMSAxMi41NjYgNDQgMTYuNDc0IDQ0IDI0Ljg5MVY0MHpNNS4xOCA5LjQyOGgtLjA2M0MyLjAxMyA5LjQyOCAwIDcuMzUxIDAgNC43MTggMCAyLjAzNCAyLjA3MiAwIDUuMjM5IDBjMy4xNjQgMCA1LjExIDIuMDI5IDUuMTcxIDQuNzEgMCAyLjYzMy0yLjAwNyA0LjcxOC01LjIzIDQuNzE4em0tNC4wNyAzLjM5OWg4LjU3NlY0MEgxLjExVjEyLjgyN3oiPjwvcGF0aD48L3N2Zz4=",
                    bitbucket: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgaWQ9ImJpdGJ1Y2tldCI+PHBhdGggZmlsbD0iIzI2ODBGOCIgZD0iTTQuMjk3IDIzaDE1LjY1OWEuNzc2Ljc3NiAwIDAgMCAuNzY5LS42NTdMMjMuOTkgMS45MTZhLjc4Ljc4IDAgMCAwLS42MzUtLjg5NyAxLjEzIDEuMTMgMCAwIDAtLjEzNC0uMDA5TC43NzkgMUEuNzc1Ljc3NSAwIDAgMCAwIDEuNzc1YzAgLjA0NC4wMDUuMDkzLjAwOS4xMzdsMy4yNjUgMjAuMTk2Yy4wODIuNTA5LjUxNS44ODcgMS4wMjMuODkyek0xNS43MzYgOC4zOTFsLTEuMjExIDcuMjA1aC01TDguMTczIDguMzkxaDcuNTYzeiI+PC9wYXRoPjwvc3ZnPg==",
                    gitlab: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAwIiBoZWlnaHQ9IjIzMDUiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaW5ZTWluIG1lZXQiIHZpZXdCb3g9IjAgMCAyNTYgMjM2IiBpZD0iZ2l0bGFiIj48cGF0aCBmaWxsPSIjRTI0MzI5IiBkPSJNMTI4LjA3NSAyMzYuMDc1bDQ3LjEwNC0xNDQuOTdIODAuOTdsNDcuMTA0IDE0NC45N3oiPjwvcGF0aD48cGF0aCBmaWxsPSIjRkM2RDI2IiBkPSJNMTI4LjA3NSAyMzYuMDc0TDgwLjk3IDkxLjEwNEgxNC45NTZsMTEzLjExOSAxNDQuOTd6Ij48L3BhdGg+PHBhdGggZmlsbD0iI0ZDQTMyNiIgZD0iTTE0Ljk1NiA5MS4xMDRMLjY0MiAxMzUuMTZhOS43NTIgOS43NTIgMCAwIDAgMy41NDIgMTAuOTAzbDEyMy44OTEgOTAuMDEyLTExMy4xMi0xNDQuOTd6Ij48L3BhdGg+PHBhdGggZmlsbD0iI0UyNDMyOSIgZD0iTTE0Ljk1NiA5MS4xMDVIODAuOTdMNTIuNjAxIDMuNzljLTEuNDYtNC40OTMtNy44MTYtNC40OTItOS4yNzUgMGwtMjguMzcgODcuMzE1eiI+PC9wYXRoPjxwYXRoIGZpbGw9IiNGQzZEMjYiIGQ9Ik0xMjguMDc1IDIzNi4wNzRsNDcuMTA0LTE0NC45N2g2Ni4wMTVsLTExMy4xMiAxNDQuOTd6Ij48L3BhdGg+PHBhdGggZmlsbD0iI0ZDQTMyNiIgZD0iTTI0MS4xOTQgOTEuMTA0bDE0LjMxNCA0NC4wNTZhOS43NTIgOS43NTIgMCAwIDEtMy41NDMgMTAuOTAzbC0xMjMuODkgOTAuMDEyIDExMy4xMTktMTQ0Ljk3eiI+PC9wYXRoPjxwYXRoIGZpbGw9IiNFMjQzMjkiIGQ9Ik0yNDEuMTk0IDkxLjEwNWgtNjYuMDE1bDI4LjM3LTg3LjMxNWMxLjQ2LTQuNDkzIDcuODE2LTQuNDkyIDkuMjc1IDBsMjguMzcgODcuMzE1eiI+PC9wYXRoPjwvc3ZnPg==",
                    twitch: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgdmlld0JveD0iMCAwIDExMS43ODY2NyAxMjcuMzg2NjciCiAgIGhlaWdodD0iMTI3LjM4NjY3IgogICB3aWR0aD0iMTExLjc4NjY3IgogICB4bWw6c3BhY2U9InByZXNlcnZlIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmczMzU1IgogICBzb2RpcG9kaTpkb2NuYW1lPSJUd2l0Y2hfbG9nby5zdmciCiAgIGlua3NjYXBlOnZlcnNpb249IjEuMS4xICgzYmY1YWUwZDI1LCAyMDIxLTA5LTIwKSIKICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiCiAgIHhtbG5zOnNvZGlwb2RpPSJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZCIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZGVmcwogICBpZD0iZGVmczI5Ij4KICAgIAogICAgCiAgPC9kZWZzPjxzb2RpcG9kaTpuYW1lZHZpZXcKICAgaWQ9Im5hbWVkdmlldzI3IgogICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgIGlua3NjYXBlOnBhZ2VjaGVja2VyYm9hcmQ9IjAiCiAgIHNob3dncmlkPSJmYWxzZSIKICAgaW5rc2NhcGU6em9vbT0iNC4xOTkyMjg0IgogICBpbmtzY2FwZTpjeD0iLTUwLjYwNDUzNSIKICAgaW5rc2NhcGU6Y3k9IjE0MC4zODI5MyIKICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIyNTYwIgogICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMzg3IgogICBpbmtzY2FwZTp3aW5kb3cteD0iMTkxMiIKICAgaW5rc2NhcGU6d2luZG93LXk9Ii04IgogICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJzdmczMzU1IiAvPgogIDxnCiAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMzMzMywwLDAsLTEuMzMzMzMzMywxMDEuMzkzMzMsNjcuNTg5MzMyKSIKICAgaWQ9ImczMzY1Ij4KICAgICAgPHBhdGgKICAgaWQ9InBhdGgzMzY3IgogICBzdHlsZT0iZmlsbDojNjQ0MWE1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lIgogICBkPSJtIDAsMCAtMTMuNjUyLC0xMy42NTEgaCAtMjEuNDQ1IGwgLTExLjY5OSwtMTEuNjk3IHYgMTEuNjk3IEggLTY0LjM0NCBWIDQyLjg5MyBIIDAgWiBtIC03Mi4xNDYsNTAuNjkyIC0zLjg5OSwtMTUuNTk5IHYgLTcwLjE5IGggMTcuNTUgdiAtOS43NTEgaCA5Ljc0NiBsIDkuNzUyLDkuNzUxIGggMTUuNTk2IEwgNy43OTUsLTMuOTA1IHYgNTQuNTk3IHoiIC8+CiAgICA8L2c+PHBhdGgKICAgaWQ9InBhdGgzMzY5IgogICBzdHlsZT0iZmlsbDojNjQ0MWE1O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoxLjMzMzMzIgogICBkPSJtIDQ0LjE5NzMzMSw2Mi4zOTQyNjYgaCAxMC4zOTg2NyBWIDMxLjE5MjkzMyBoIC0xMC4zOTg2NyB6IG0gMjguNTk0NjcsMCBoIDEwLjM5ODY2IFYgMzEuMTkyOTMzIGggLTEwLjM5ODY2IHoiIC8+Cjwvc3ZnPgo=",
                    discord: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDEwMCAxMDAiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBpZD0iZGlzY29yZCI+PHBhdGggZmlsbD0iIzY2NjVkMiIgZD0iTTg1LjIyLDI0Ljk1OGMtMTEuNDU5LTguNTc1LTIyLjQzOC04LjMzNC0yMi40MzgtOC4zMzRsLTEuMTIyLDEuMjgyCgkJCQljMTMuNjIzLDQuMDg3LDE5Ljk1NCwxMC4wOTcsMTkuOTU0LDEwLjA5N2MtMTkuNDkxLTEwLjczMS00NC4zMTctMTAuNjU0LTY0LjU5LDBjMCwwLDYuNTcxLTYuMzMxLDIwLjk5Ni0xMC40MThsLTAuODAxLTAuOTYyCgkJCQljMCwwLTEwLjg5OS0wLjI0LTIyLjQzOCw4LjMzNGMwLDAtMTEuNTQsMjAuNzU1LTExLjU0LDQ2LjMxOWMwLDAsNi43MzIsMTEuNTQsMjQuNDQyLDEyLjEwMWMwLDAsMi45NjUtMy41MjYsNS4zNjktNi41NzEKCQkJCWMtMTAuMTc3LTMuMDQ1LTE0LjAyNC05LjM3Ni0xNC4wMjQtOS4zNzZjNi4zOTQsNC4wMDEsMTIuODU5LDYuNTA1LDIwLjkxNiw4LjA5NGMxMy4xMDgsMi42OTgsMjkuNDEzLTAuMDc2LDQxLjU5MS04LjA5NAoJCQkJYzAsMC00LjAwNyw2LjQ5MS0xNC41MDUsOS40NTZjMi40MDQsMi45NjUsNS4yODksNi40MTEsNS4yODksNi40MTFjMTcuNzEtMC41NjEsMjQuNDQxLTEyLjEwMSwyNC40NDEtMTIuMDIKCQkJCUM5Ni43NTksNDUuNzEzLDg1LjIyLDI0Ljk1OCw4NS4yMiwyNC45NTh6IE0zNS4wNTUsNjMuODI0Yy00LjQ4OCwwLTguMTc0LTMuOTI3LTguMTc0LTguODE1CgkJCQljMC4zMjgtMTEuNzA3LDE2LjEwMi0xMS42NzEsMTYuMzQ4LDBDNDMuMjI5LDU5Ljg5NywzOS42MjIsNjMuODI0LDM1LjA1NSw2My44MjR6IE02NC4zMDQsNjMuODI0CgkJCQljLTQuNDg4LDAtOC4xNzQtMy45MjctOC4xNzQtOC44MTVjMC4zNi0xMS42ODQsMTUuOTM3LTExLjY4OSwxNi4zNDgsMEM3Mi40NzgsNTkuODk3LDY4Ljg3Miw2My44MjQsNjQuMzA0LDYzLjgyNHoiPjwvcGF0aD48L3N2Zz4=",
                    microsoft: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciICB2aWV3Qm94PSIwIDAgNDggNDgiIHdpZHRoPSI0OHB4IiBoZWlnaHQ9IjQ4cHgiPjxwYXRoIGZpbGw9IiNmZjU3MjIiIGQ9Ik02IDZIMjJWMjJINnoiIHRyYW5zZm9ybT0icm90YXRlKC0xODAgMTQgMTQpIi8+PHBhdGggZmlsbD0iIzRjYWY1MCIgZD0iTTI2IDZINDJWMjJIMjZ6IiB0cmFuc2Zvcm09InJvdGF0ZSgtMTgwIDM0IDE0KSIvPjxwYXRoIGZpbGw9IiNmZmMxMDciIGQ9Ik0yNiAyNkg0MlY0MkgyNnoiIHRyYW5zZm9ybT0icm90YXRlKC0xODAgMzQgMzQpIi8+PHBhdGggZmlsbD0iIzAzYTlmNCIgZD0iTTYgMjZIMjJWNDJINnoiIHRyYW5zZm9ybT0icm90YXRlKC0xODAgMTQgMzQpIi8+PC9zdmc+"
                };

            function upperCaseFirstLetter(l) {
                return l.charAt(0).toUpperCase() + l.slice(1)
            }
            let el = (0, er.Z)(J.B)
            `
  display: flex;
  justify-content: flex-start;
  gap: ${J.s.md};
  font-size: ${J.f.md};
  transition: background-color 0.2s ease;
  &:hover {
    background-color: ${l=>l.theme.colors.secondaryButtonBg};
  }
  &:active {
    box-shadow: none;
  }
`, ec = (0, er.Z)(J.I)
            `
  border: 1px solid ${l=>l.theme.colors.borderColor};
  padding: ${J.s.xs};
`
        },
        8499: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                F: function() {
                    return el
                },
                G: function() {
                    return GoogleIcon
                },
                O: function() {
                    return OTPInput
                },
                a: function() {
                    return ep
                },
                o: function() {
                    return openGoogleSignInWindow
                },
                p: function() {
                    return paperWallet
                }
            });
            var N = x(53061),
                U = x(23743),
                Z = x(33883);
            x(9409), x(11953);
            let PaperWallet = class PaperWallet extends Z.a {
                get walletName() {
                    return "Paper Wallet"
                }
                constructor(l) {
                    if (super(PaperWallet.id, { ...l
                        }), l.paperClientId && "uninitialized" === l.paperClientId) {
                        this.paperClientId = "00000000-0000-0000-0000-000000000000", this.chain = l.chain;
                        return
                    }
                    if (l.advancedOptions && l.advancedOptions ? .recoveryShareManagement === "USER_MANAGED" && (l.paperClientId && !this.isClientIdLegacyPaper(l.paperClientId) || !l.paperClientId && l.clientId && !this.isClientIdLegacyPaper(l.clientId))) throw Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
                    if (!l.clientId && !l.paperClientId) throw Error("clientId or paperClientId is required");
                    if (l.paperClientId && !this.isClientIdLegacyPaper(l.paperClientId)) throw Error("paperClientId must be a legacy paper client ID");
                    if (l.clientId && this.isClientIdLegacyPaper(l.clientId)) throw Error("clientId must be a thirdweb client ID");
                    this.paperClientId = l.paperClientId ? ? l.clientId, this.chain = l.chain
                }
                isClientIdLegacyPaper(l) {
                    return l.indexOf("-") > 0 && 36 === l.length
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            PaperWalletConnector: l
                        } = await x.e(1956).then(x.bind(x, 51956));
                        this.connector = new l({
                            clientId: this.paperClientId,
                            chain: this.chain,
                            chains: this.chains,
                            advancedOptions: {
                                recoveryShareManagement: this.options ? .advancedOptions ? .recoveryShareManagement
                            },
                            styles: this.options ? .styles
                        })
                    }
                    return this.connector
                }
                getConnectParams() {
                    let l = super.getConnectParams();
                    return l ? "object" == typeof l.googleLogin ? { ...l,
                        googleLogin: !0
                    } : l : void 0
                }
                async getEmail() {
                    let l = await this.getConnector();
                    return l.getEmail()
                }
                async getPaperSDK() {
                    let l = await this.getConnector();
                    return l.getPaperSDK()
                }
            };
            (0, N._)(PaperWallet, "id", U.w.paper), (0, N._)(PaperWallet, "meta", {
                name: "Paper Wallet",
                iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
            });
            var $ = x(2265),
                Y = x(8801),
                q = x(41282),
                J = x(67327),
                X = x(57437),
                en = x(80464),
                er = x(26915),
                ea = x(78698);
            let GoogleIcon = l => (0, X.jsxs)("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                height: l.size,
                viewBox: "0 0 24 24",
                width: l.size,
                children: [(0, X.jsx)("path", {
                    d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z",
                    fill: "#4285F4"
                }), (0, X.jsx)("path", {
                    d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z",
                    fill: "#34A853"
                }), (0, X.jsx)("path", {
                    d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z",
                    fill: "#FBBC05"
                }), (0, X.jsx)("path", {
                    d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z",
                    fill: "#EA4335"
                }), (0, X.jsx)("path", {
                    d: "M1 1h22v22H1z",
                    fill: "none"
                })]
            });

            function openGoogleSignInWindow() {
                let l = window.open("", void 0, "width=350, height=500");
                return l && (l.document.title = "Sign In - Google Accounts", l.document.body.innerHTML = eo), l
            }
            let eo = `
<svg class="loader" viewBox="0 0 50 50">
  <circle
    cx="25"
    cy="25"
    r="20"
    fill="none"
    stroke="#000"
    stroke-width="4"
  />
</svg>

<style>
  body,
  html {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .loader {
    width: 15vw;
    height: 15vw;
    animation: spin 2s linear infinite;
  }

  .loader circle {
    animation: loading 1.5s linear infinite;
  }

  @keyframes loading {
    0% {
      stroke-dasharray: 1, 150;
      stroke-dashoffset: 0;
    }
    50% {
      stroke-dasharray: 90, 150;
      stroke-dashoffset: -35;
    }
    100% {
      stroke-dasharray: 90, 150;
      stroke-dashoffset: -124;
    }
  }

  @keyframes spin {
    100% {
      transform: rotate(360deg);
    }
  }
</style>
`,
                el = Y.Z.div `
  animation: ${J.E} 0.15s ease-in;
`;

            function OTPInput(l) {
                let c = l.value.split("").map(Number),
                    setOTP = c => {
                        l.setValue(c.join(""))
                    },
                    x = c.length,
                    N = (0, $.useRef)([]);
                return (0, $.useEffect)(() => {
                    N.current[x] && requestAnimationFrame(() => {
                        N.current[x] ? .focus()
                    })
                }, [x]), (0, X.jsx)(J.C, {
                    center: "x",
                    gap: "sm",
                    flex: "row",
                    children: Array(l.digits).fill(null).map((U, Z) => (0, X.jsx)(ec, {
                        "data-error": l.isInvalid,
                        ref: l => N.current[Z] = l,
                        value: void 0 === c[Z] ? "" : c[Z],
                        type: "number",
                        variant: "outline",
                        onPaste: c => {
                            let x = c.clipboardData.getData("text/plain"),
                                N = x.slice(0, l.digits).split("").filter(l => /[0-9]/.test(l)).map(Number);
                            setOTP(N), c.preventDefault()
                        },
                        onKeyDown: x => {
                            if ("Enter" === x.key && l.onEnter) {
                                l.onEnter();
                                return
                            }
                            if ("ArrowLeft" === x.key) {
                                if (0 === Z) return;
                                N.current[Z - 1] ? .focus();
                                return
                            }
                            if ("ArrowRight" === x.key) {
                                if (Z === l.digits - 1) return;
                                N.current[Z + 1] ? .focus();
                                return
                            }
                            if ("e" === x.key || "." === x.key) {
                                x.preventDefault();
                                return
                            }
                            if ("Backspace" === x.key) {
                                if (0 === Z) return;
                                let l = c.slice(0, -1);
                                setOTP(l)
                            }
                        },
                        onChange: l => {
                            let N = l.target.value;
                            if (N.length > 1) {
                                let l = N[N.length - 1];
                                l && (N = l)
                            }
                            if (!/[0-9]/.test(N) && "" !== N) {
                                l.preventDefault();
                                return
                            }
                            let U = [...c],
                                $ = Z > x - 1 ? x : Z;
                            U[$] = Number(N), setOTP(U)
                        }
                    }, Z))
                })
            }
            let ec = (0, Y.Z)(J.A)
            `
  appearance: none;
  -webkit-appearance: none;
  width: 40px;
  height: 40px;
  text-align: center;
  font-size: ${J.f.md};
  padding: ${J.s.xs};
  ${J.o.mobile} {
    width: 35px;
    height: 35px;
  }
  &[data-verify-status="invalid"] {
    color: ${l=>l.theme.colors.danger};
    border-color: ${l=>l.theme.colors.danger};
  }
`, PaperFormUI = l => {
                let c = (0, q.xUo)(),
                    x = (0, q.tZ_)(),
                    N = (0, q.c4c)(),
                    googleLogin = async () => {
                        try {
                            let U = c(l.walletConfig);
                            x("connecting");
                            let Z = openGoogleSignInWindow();
                            if (!Z) throw Error("Failed to open google login window");
                            await U.connect({
                                googleLogin: {
                                    openedWindow: Z,
                                    closeOpenedWindow: l => {
                                        l.close()
                                    }
                                }
                            }), N(U)
                        } catch (l) {
                            x("disconnected"), console.error(l)
                        }
                    };
                return (0, X.jsxs)("div", {
                    children: [l.googleLoginSupported && (0, X.jsxs)(X.Fragment, {
                        children: [(0, X.jsxs)(eu, {
                            variant: "secondary",
                            fullWidth: !0,
                            onClick: () => {
                                googleLogin(), l.onSelect({
                                    google: !0
                                })
                            },
                            children: [(0, X.jsx)(GoogleIcon, {
                                size: J.i.md
                            }), "Sign in with Google"]
                        }), (0, X.jsx)(J.S, {
                            y: "lg"
                        }), (0, X.jsx)(J.T, {
                            children: (0, X.jsx)("span", {
                                children: "OR"
                            })
                        }), (0, X.jsx)(J.S, {
                            y: "lg"
                        })]
                    }), (0, X.jsx)(en.I, {
                        onSelect: c => l.onSelect({
                            email: c
                        }),
                        placeholder: "Enter your email address",
                        name: "email",
                        type: "email",
                        errorMessage: l => {
                            let c = l.replace(/\+/g, ""),
                                x = /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,})$/g.test(c);
                            if (!x) return "Invalid email address"
                        },
                        emptyErrorMessage: "email address is required",
                        showOrSeparator: l.showOrSeparator
                    })]
                })
            }, PaperFormUIScreen = l => {
                let c = "compact" === l.modalSize;
                return (0, X.jsxs)(J.C, {
                    fullHeight: !0,
                    flex: "column",
                    p: "lg",
                    animate: "fadein",
                    style: {
                        minHeight: "250px"
                    },
                    children: [(0, X.jsx)(J.M, {
                        onBack: l.onBack,
                        title: "Sign in"
                    }), c ? (0, X.jsx)(J.S, {
                        y: "xl"
                    }) : null, (0, X.jsx)(J.C, {
                        expand: !0,
                        flex: "column",
                        center: "y",
                        p: c ? void 0 : "lg",
                        children: (0, X.jsx)(PaperFormUI, {
                            walletConfig: l.walletConfig,
                            googleLoginSupported: l.googleLoginSupported,
                            onSelect: l.onSelect,
                            showOrSeparator: !1
                        })
                    })]
                })
            }, eu = (0, Y.Z)(J.B)
            `
  display: flex;
  justify-content: center;
  gap: ${J.s.sm};
`, PaperOTPLoginUI = l => {
                let c = l.selectionData,
                    [x, N] = (0, $.useState)(""),
                    [U, Z] = (0, $.useState)(""),
                    {
                        createWalletInstance: Y,
                        setConnectedWallet: en,
                        setConnectionStatus: er
                    } = (0, q.tNP)(),
                    [ea, eo] = (0, $.useState)(null),
                    ec = "wide" === l.modalSize,
                    [eu, ep] = (0, $.useState)("idle"),
                    [eh, ey] = (0, $.useState)("sending"),
                    ef = !!("string" != typeof eh && "AWS_MANAGED" !== eh.recoveryShareManagement && eh.isNewDevice && !eh.isNewUser),
                    em = (0, $.useCallback)(async () => {
                        N(""), ep("idle"), ey("sending");
                        try {
                            let x = Y(l.walletConfig);
                            eo(x);
                            let N = await x.getPaperSDK(),
                                {
                                    isNewDevice: U,
                                    isNewUser: Z,
                                    recoveryShareManagement: $
                                } = await N.auth.sendPaperEmailLoginOtp({
                                    email: c
                                });
                            ey({
                                isNewDevice: U,
                                isNewUser: Z,
                                recoveryShareManagement: $
                            })
                        } catch (l) {
                            console.error(l), ep("idle"), ey("error")
                        }
                    }, [Y, c, l.walletConfig]),
                    handleSubmit = l => {
                        (!ef || U) && "string" != typeof eh && 6 === l.length && verifyCodes(l)
                    },
                    verifyCodes = async x => {
                        if (ep("idle"), ea) try {
                            ep("verifying"), er("connecting"), await ea.connect({
                                email: c,
                                otp: x,
                                recoveryCode: ef ? U : void 0
                            }), en(ea), ep("valid"), l.close()
                        } catch (l) {
                            ep("invalid"), console.error(l)
                        }
                    },
                    eg = (0, $.useRef)(!1);
                return (0, $.useEffect)(() => {
                    eg.current || (eg.current = !0, em())
                }, [em]), (0, X.jsxs)(J.C, {
                    fullHeight: !0,
                    flex: "column",
                    animate: "fadein",
                    children: [(0, X.jsx)(J.C, {
                        p: "lg",
                        children: (0, X.jsx)(J.M, {
                            title: "Sign in",
                            onBack: l.goBack
                        })
                    }), (0, X.jsx)(J.C, {
                        expand: !0,
                        flex: "column",
                        center: "y",
                        children: (0, X.jsxs)("form", {
                            onSubmit: l => {
                                l.preventDefault()
                            },
                            children: [(0, X.jsxs)("div", {
                                style: {
                                    textAlign: "center"
                                },
                                children: [!ec && (0, X.jsx)(J.S, {
                                    y: "lg"
                                }), (0, X.jsx)(J.b, {
                                    children: "Enter the OTP sent to"
                                }), (0, X.jsx)(J.S, {
                                    y: "sm"
                                }), (0, X.jsx)(J.b, {
                                    color: "primaryText",
                                    children: c
                                }), (0, X.jsx)(J.S, {
                                    y: "xl"
                                })]
                            }), (0, X.jsx)(OTPInput, {
                                isInvalid: "invalid" === eu,
                                digits: 6,
                                value: x,
                                setValue: l => {
                                    N(l), ep("idle"), ef || handleSubmit(l)
                                },
                                onEnter: () => {
                                    handleSubmit(x)
                                }
                            }), ef && (0, X.jsxs)(J.C, {
                                px: "lg",
                                style: {
                                    textAlign: "center"
                                },
                                children: [(0, X.jsx)(J.S, {
                                    y: "xxl"
                                }), (0, X.jsx)(J.b, {
                                    color: "primaryText",
                                    children: "New device detected"
                                }), (0, X.jsx)(J.S, {
                                    y: "sm"
                                }), (0, X.jsxs)(J.b, {
                                    size: "sm",
                                    multiline: !0,
                                    style: {
                                        maxWidth: "350px"
                                    },
                                    children: ["Enter the recovery code emailed to you ", (0, X.jsx)("br", {}), " when you first signed up"]
                                }), (0, X.jsx)(J.S, {
                                    y: "lg"
                                }), (0, X.jsx)(J.A, {
                                    sm: !0,
                                    autoComplete: "off",
                                    required: !0,
                                    "data-error": "invalid" === eu,
                                    id: "recovery-code",
                                    variant: "outline",
                                    style: {
                                        textAlign: "center"
                                    },
                                    value: U,
                                    onChange: l => Z(l.target.value),
                                    placeholder: "Enter your recovery code"
                                })]
                            }), "invalid" === eu && (0, X.jsxs)(el, {
                                children: [(0, X.jsx)(J.S, {
                                    y: "md"
                                }), (0, X.jsxs)(J.b, {
                                    size: "sm",
                                    color: "danger",
                                    center: !0,
                                    children: ["Invalid OTP ", ef ? "or recovery code" : ""]
                                })]
                            }), (0, X.jsx)(J.S, {
                                y: ef ? "xl" : "xxl"
                            }), (0, X.jsx)(J.C, {
                                px: ec ? "xxl" : "lg",
                                children: "verifying" === eu ? (0, X.jsx)(X.Fragment, {
                                    children: (0, X.jsx)(J.C, {
                                        flex: "row",
                                        center: "x",
                                        animate: "fadein",
                                        children: (0, X.jsx)(J.c, {
                                            size: "lg",
                                            color: "accentText"
                                        })
                                    })
                                }) : (0, X.jsx)(J.C, {
                                    animate: "fadein",
                                    children: (0, X.jsx)(J.B, {
                                        onClick: () => handleSubmit(x),
                                        variant: "accent",
                                        type: "submit",
                                        style: {
                                            width: "100%"
                                        },
                                        children: "Verify"
                                    })
                                }, "btn-container")
                            }), (0, X.jsx)(J.S, {
                                y: ef ? "xl" : "xxl"
                            }), !ec && (0, X.jsx)(J.L, {}), (0, X.jsxs)(J.C, {
                                p: ec ? void 0 : "lg",
                                children: ["error" === eh && (0, X.jsxs)(X.Fragment, {
                                    children: [(0, X.jsx)(J.b, {
                                        size: "sm",
                                        center: !0,
                                        color: "danger",
                                        children: "Failed to send OTP"
                                    }), (0, X.jsx)(J.S, {
                                        y: "md"
                                    })]
                                }), "sending" === eh && (0, X.jsxs)(J.C, {
                                    flex: "row",
                                    center: "both",
                                    gap: "xs",
                                    style: {
                                        textAlign: "center"
                                    },
                                    children: [(0, X.jsx)(J.b, {
                                        size: "sm",
                                        children: "Sending OTP"
                                    }), (0, X.jsx)(J.c, {
                                        size: "xs",
                                        color: "secondaryText"
                                    })]
                                }), "string" != typeof eh && (0, X.jsx)(ed, {
                                    onClick: em,
                                    type: "button",
                                    children: "Resend OTP"
                                })]
                            })]
                        })
                    })]
                })
            }, ed = Y.Z.button `
  all: unset;
  color: ${l=>l.theme.colors.accentText};
  font-size: ${J.f.sm};
  cursor: pointer;
  text-align: center;
  width: 100%;
  &:hover {
    color: ${l=>l.theme.colors.primaryText};
  }
`, PaperGoogleLogin = l => {
                let {
                    goBack: c,
                    modalSize: x
                } = l, N = (0, q.xUo)(), U = (0, q.tZ_)(), Z = (0, q.c4c)(), Y = (0, q.pX8)(), googleLogin = async () => {
                    try {
                        let c = N(l.walletConfig);
                        U("connecting");
                        let x = openGoogleSignInWindow();
                        if (!x) throw Error("Failed to open google login window");
                        await c.connect({
                            googleLogin: {
                                openedWindow: x,
                                closeOpenedWindow: l => {
                                    l.close()
                                }
                            }
                        }), Z(c), l.close()
                    } catch (l) {
                        U("disconnected"), console.error(l)
                    }
                }, en = l.close;
                return (0, $.useEffect)(() => {
                    "connected" === Y && en()
                }, [Y, en]), (0, X.jsx)(J.C, {
                    animate: "fadein",
                    flex: "column",
                    fullHeight: !0,
                    children: (0, X.jsxs)(J.C, {
                        flex: "column",
                        expand: !0,
                        p: "lg",
                        style: {
                            paddingBottom: 0
                        },
                        children: [(0, X.jsx)(J.M, {
                            title: (0, X.jsxs)(J.C, {
                                flex: "row",
                                center: "both",
                                gap: "xs",
                                children: [(0, X.jsx)(GoogleIcon, {
                                    size: J.i.md
                                }), (0, X.jsx)(J.a, {
                                    children: " Sign in "
                                })]
                            }),
                            onBack: c
                        }), "compact" === x ? (0, X.jsx)(J.S, {
                            y: "xl"
                        }) : null, (0, X.jsxs)(J.C, {
                            flex: "column",
                            center: "both",
                            expand: !0,
                            style: {
                                textAlign: "center",
                                minHeight: "250px"
                            },
                            children: ["connecting" === Y && (0, X.jsxs)(J.C, {
                                animate: "fadein",
                                children: [(0, X.jsx)(J.b, {
                                    color: "primaryText",
                                    multiline: !0,
                                    style: {
                                        maxWidth: "250px"
                                    },
                                    children: "Select your Google account in the pop-up"
                                }), (0, X.jsx)(J.S, {
                                    y: "xl"
                                }), (0, X.jsx)(J.C, {
                                    center: "x",
                                    flex: "row",
                                    children: (0, X.jsx)(J.c, {
                                        size: "lg",
                                        color: "accentText"
                                    })
                                }), (0, X.jsx)(J.S, {
                                    y: "xxl"
                                })]
                            }), "disconnected" === Y && (0, X.jsxs)(J.C, {
                                animate: "fadein",
                                children: [(0, X.jsx)(J.b, {
                                    color: "danger",
                                    children: "Failed to sign in"
                                }), (0, X.jsx)(J.S, {
                                    y: "lg"
                                }), (0, X.jsxs)(J.B, {
                                    variant: "primary",
                                    onClick: googleLogin,
                                    children: [" ", "Retry", " "]
                                }), (0, X.jsx)(J.S, {
                                    y: "xxl"
                                })]
                            })]
                        })]
                    })
                })
            }, paperWallet = l => {
                let c = "AWS_MANAGED";
                return {
                    category: "socialLogin",
                    id: PaperWallet.id,
                    recommended: l ? .recommended,
                    meta: { ...PaperWallet.meta,
                        name: "Email",
                        iconURL: ea.e
                    },
                    create: c => new PaperWallet({ ...c,
                        ...l,
                        advancedOptions: {
                            recoveryShareManagement: "AWS_MANAGED",
                            ...l ? .advancedOptions
                        }
                    }),
                    selectUI: x => (0, X.jsx)(PaperSelectionUI, { ...x,
                        recoveryShareManagement: l ? .advancedOptions ? .recoveryShareManagement || c
                    }),
                    connectUI: x => (0, X.jsx)(PaperConnectUI, { ...x,
                        recoveryShareManagement: l ? .advancedOptions ? .recoveryShareManagement || c
                    })
                }
            }, PaperSelectionUI = l => {
                let c = (0, er.u)();
                return "wide" === l.modalSize || c !== J.r.main && "compact" === l.modalSize ? (0, X.jsx)(J.W, {
                    walletConfig: l.walletConfig,
                    selectWallet: () => {
                        l.onSelect(void 0)
                    }
                }) : (0, X.jsx)("div", {
                    children: (0, X.jsx)(PaperFormUI, {
                        walletConfig: l.walletConfig,
                        googleLoginSupported: "USER_MANAGED" !== l.recoveryShareManagement,
                        showOrSeparator: l.supportedWallets.length > 1,
                        onSelect: l.onSelect
                    })
                })
            }, PaperConnectUI = l => {
                let [c, x] = (0, $.useState)(l.selectionData);
                if (c) {
                    let handleBack = () => {
                        "wide" === l.modalSize ? x(void 0) : l.goBack()
                    };
                    return "email" in c ? (0, X.jsx)(PaperOTPLoginUI, { ...l,
                        recoveryShareManagement: l.recoveryShareManagement,
                        selectionData: c.email,
                        goBack: handleBack
                    }) : (0, X.jsx)(PaperGoogleLogin, { ...l,
                        goBack: handleBack
                    })
                }
                return (0, X.jsx)(PaperFormUIScreen, {
                    walletConfig: l.walletConfig,
                    googleLoginSupported: "USER_MANAGED" !== l.recoveryShareManagement,
                    modalSize: l.modalSize,
                    onSelect: l => {
                        x(l)
                    },
                    onBack: l.goBack
                })
            };
            var ep = Object.freeze({
                __proto__: null,
                paperWallet: paperWallet
            })
        },
        41226: function(l, c, x) {
            "use strict";
            x.d(c, {
                safeWallet: function() {
                    return safeWallet
                }
            });
            var N = x(23743),
                U = x(86985),
                Z = x(53061),
                $ = x(33883);
            x(9409), x(11953);
            let SafeWallet = class SafeWallet extends $.a {
                get walletName() {
                    return "Safe Wallet"
                }
                constructor(l) {
                    super(SafeWallet.id, { ...l
                    })
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            SafeConnector: l
                        } = await Promise.all([x.e(1274), x.e(1613), x.e(7652)]).then(x.bind(x, 41613));
                        this.connector = new l
                    }
                    return this.connector
                }
                async updateChains(l) {}
                getPersonalWallet() {
                    return this.connector ? .personalWallet
                }
                autoConnect(l) {
                    return this.connect(l)
                }
            };
            (0, Z._)(SafeWallet, "meta", {
                name: "Safe",
                iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
            }), (0, Z._)(SafeWallet, "id", N.w.safe);
            var Y = x(41282),
                q = x(54844),
                J = x(2265),
                X = x(67327),
                en = x(57437),
                er = x(8801),
                ea = x(69394),
                eo = x(18994);
            x(75298), x(2390);
            let SelectpersonalWallet = l => {
                    let c = l.personalWallets.find(l => l.id === N.w.localWallet),
                        x = l.personalWallets.filter(l => l.id !== N.w.localWallet),
                        {
                            selectWallet: U
                        } = l,
                        Z = (0, J.useRef)(!1);
                    return ((0, J.useEffect)(() => {
                        !Z.current && c && 0 === x.length && (Z.current = !0, U(c))
                    }, [c, x.length, U]), c && 0 === x.length) ? (0, en.jsx)("div", {
                        style: {
                            height: "250px"
                        }
                    }) : (0, en.jsxs)(X.C, {
                        flex: "column",
                        scrollY: !0,
                        animate: "fadein",
                        children: [(0, en.jsx)(X.C, {
                            p: "lg",
                            children: (0, en.jsx)(X.M, {
                                title: l.safeWallet.meta.name,
                                onBack: l.renderBackButton ? l.onBack : void 0,
                                imgSrc: l.safeWallet.meta.iconURL
                            })
                        }), (0, en.jsx)(X.L, {}), (0, en.jsx)(X.S, {
                            y: "sm"
                        }), (0, en.jsxs)(X.C, {
                            px: "lg",
                            children: [(0, en.jsx)(X.S, {
                                y: "md"
                            }), (0, en.jsx)(X.b, {
                                size: "lg",
                                color: "primaryText",
                                weight: 500,
                                children: "Link personal wallet"
                            }), (0, en.jsx)(X.S, {
                                y: "sm"
                            }), (0, en.jsxs)(X.b, {
                                multiline: !0,
                                children: ["Connect your personal wallet to use Safe.", " ", (0, en.jsx)(X.F, {
                                    inline: !0,
                                    target: "_blank",
                                    href: "https://docs.safe.global/getting-started/readme",
                                    style: {
                                        whiteSpace: "nowrap"
                                    },
                                    children: "Learn more"
                                }), " "]
                            })]
                        }), (0, en.jsx)(X.S, {
                            y: "lg"
                        }), (0, en.jsx)(X.C, {
                            expand: !0,
                            px: "md",
                            scrollY: !0,
                            children: (0, en.jsx)(X.X, {
                                maxHeight: "300px",
                                walletConfigs: x,
                                selectWallet: l.selectWallet
                            })
                        }), c && (0, en.jsx)(X.n, {
                            children: (0, en.jsx)(X.B, {
                                variant: "outline",
                                fullWidth: !0,
                                onClick: () => {
                                    l.selectWallet(c)
                                },
                                "data-test": "continue-as-guest-button",
                                children: "Continue as guest"
                            })
                        })]
                    })
                },
                el = {
                    eth: 1,
                    matic: 137,
                    avax: 43114,
                    bnb: 56,
                    oeth: 10,
                    gor: 5,
                    "base-gor": 84531
                },
                SelectAccount = l => {
                    let c = (0, Y.Osb)(),
                        x = (0, Y.$4A)(),
                        N = (0, Y.AbE)(),
                        Z = (0, Y.xxU)(),
                        [$, er] = (0, J.useState)(""),
                        [ed, ep] = (0, J.useState)(-1),
                        [eh, ey] = (0, J.useState)(!1),
                        [ef, em] = (0, J.useState)(!1),
                        [eg, eb] = (0, J.useState)(!1),
                        ev = (0, Y.pX8)(),
                        ew = (0, Y.EnH)(),
                        eT = ew.filter(l => U.S.has(l.chainId)),
                        eM = eT.find(l => l.chainId === ed),
                        eI = eT.filter(l => l.testnet),
                        ex = eT.filter(l => !l.testnet),
                        eC = ex.length > 0 && eI.length > 0,
                        handleSubmit = async () => {
                            if (eM && c && N) {
                                ey(!1);
                                try {
                                    await x(l.safeWalletConfig, {
                                        chain: eM,
                                        personalWallet: c,
                                        safeAddress: $
                                    }), l.onConnect()
                                } catch (l) {
                                    console.error(l), ey(!0)
                                }
                            }
                        },
                        e_ = -1 !== ed && Z !== ed,
                        eD = eo.isAddress($),
                        eS = 1 === eT.length,
                        ek = (0, Y.o$C)(),
                        eE = (0, J.useContext)(X.j);
                    return (0, en.jsx)(X.C, {
                        fullHeight: !0,
                        flex: "column",
                        scrollY: !0,
                        children: (0, en.jsxs)("form", {
                            style: {
                                height: "100%",
                                display: "flex",
                                flexDirection: "column"
                            },
                            onSubmit: l => {
                                l.preventDefault(), handleSubmit()
                            },
                            children: [(0, en.jsx)(X.C, {
                                p: "lg",
                                children: (0, en.jsx)(X.M, {
                                    title: l.safeWalletConfig.meta.name,
                                    onBack: l.renderBackButton ? l.onBack : void 0,
                                    imgSrc: l.safeWalletConfig.meta.iconURL
                                })
                            }), (0, en.jsxs)(X.C, {
                                expand: !0,
                                flex: "column",
                                p: "lg",
                                scrollY: !0,
                                style: {
                                    paddingTop: 0
                                },
                                children: [(0, en.jsx)(X.S, {
                                    y: "md"
                                }), (0, en.jsx)(X.b, {
                                    color: "primaryText",
                                    size: "lg",
                                    weight: 500,
                                    children: "Enter your safe details"
                                }), (0, en.jsx)(X.S, {
                                    y: "sm"
                                }), (0, en.jsxs)(X.g, {
                                    children: ["You can find your safe address in", " ", (0, en.jsx)(X.F, {
                                        inline: !0,
                                        target: "_blank",
                                        href: "https://app.safe.global/home",
                                        style: {
                                            display: "inline",
                                            whiteSpace: "nowrap"
                                        },
                                        children: "Safe Dashboard"
                                    })]
                                }), (0, en.jsx)(X.S, {
                                    y: "xl"
                                }), (0, en.jsx)(q.b, {
                                    name: "safeAddress",
                                    id: "safeAddress",
                                    errorMessage: $ && !eD ? "Invalid Safe Address" : void 0,
                                    autocomplete: "on",
                                    onChange: l => {
                                        if (ey(!1), l.length > 4) {
                                            let c = l.split(":")[0];
                                            c && c in el ? (ep(el[c]), er(l.slice(c.length + 1))) : er(l)
                                        } else er(l)
                                    },
                                    label: "Safe Address",
                                    type: "text",
                                    value: $,
                                    required: !0,
                                    placeholder: "0x123..."
                                }), (0, en.jsx)(X.S, {
                                    y: "lg"
                                }), (0, en.jsx)(X.h, {
                                    htmlFor: "safeNetwork",
                                    children: "Safe Network"
                                }), (0, en.jsx)(X.S, {
                                    y: "sm"
                                }), (0, en.jsxs)("div", {
                                    style: {
                                        position: "relative"
                                    },
                                    children: [(0, en.jsxs)(ec, {
                                        "data-error": 0 === eT.length || eh,
                                        required: !0,
                                        name: "safeNetwork",
                                        id: "safeNetwork",
                                        value: ed,
                                        disabled: eS,
                                        placeholder: "Network your safe is deployed to",
                                        onChange: l => {
                                            ey(!1), em(!1), ep(Number(l.target.value))
                                        },
                                        children: [!eS && (0, en.jsx)("option", {
                                            value: "",
                                            hidden: !0,
                                            children: "Network your safe is deployed to"
                                        }), eC ? (0, en.jsxs)(en.Fragment, {
                                            children: [(0, en.jsx)("optgroup", {
                                                label: "Mainnets",
                                                children: ex.map(l => (0, en.jsx)("option", {
                                                    value: l.chainId,
                                                    children: l.name
                                                }, l.chainId))
                                            }), (0, en.jsx)("optgroup", {
                                                label: "Testnets",
                                                children: eI.map(l => (0, en.jsx)("option", {
                                                    value: l.chainId,
                                                    children: l.name
                                                }, l.chainId))
                                            })]
                                        }) : eT.map(l => (0, en.jsx)("option", {
                                            value: l.chainId,
                                            children: l.name
                                        }, l.chainId))]
                                    }), !eS && (0, en.jsx)(eu, {
                                        width: X.i.sm,
                                        height: X.i.sm,
                                        style: {
                                            position: "absolute",
                                            top: "50%",
                                            right: X.s.sm,
                                            transform: "translateY(-50%)",
                                            pointerEvents: "none"
                                        }
                                    })]
                                }), (0, en.jsx)(X.S, {
                                    y: "sm"
                                }), 0 === eT.length && (0, en.jsxs)(en.Fragment, {
                                    children: [(0, en.jsxs)(X.b, {
                                        color: "danger",
                                        multiline: !0,
                                        size: "xs",
                                        children: [" ", "Can not use Safe: No Safe supported chains are configured in App"]
                                    }), (0, en.jsx)(X.S, {
                                        y: "sm"
                                    })]
                                }), eh && (0, en.jsxs)(X.b, {
                                    size: "xs",
                                    multiline: !0,
                                    color: "danger",
                                    style: {
                                        display: "flex",
                                        gap: X.s.sm,
                                        alignItems: "center"
                                    },
                                    children: [(0, en.jsx)(ea.LPM, {
                                        width: X.i.sm,
                                        height: X.i.sm
                                    }), (0, en.jsxs)("span", {
                                        children: ["Could not connect to Safe. ", (0, en.jsx)("br", {}), "Make sure safe address and network are correct."]
                                    })]
                                }), ef && (0, en.jsx)(X.b, {
                                    color: "danger",
                                    size: "sm",
                                    children: (0, en.jsxs)(X.C, {
                                        flex: "row",
                                        gap: "sm",
                                        center: "y",
                                        children: [(0, en.jsx)(ea.LPM, {
                                            width: X.i.sm,
                                            height: X.i.sm
                                        }), "Failed to switch network"]
                                    })
                                })]
                            }), (0, en.jsx)(X.n, {
                                style: {
                                    borderTop: "wide" === eE.modalSize ? "none" : void 0
                                },
                                children: (0, en.jsx)("div", {
                                    children: (0, en.jsx)("div", {
                                        style: {
                                            display: "flex",
                                            justifyContent: "flex-end"
                                        },
                                        children: e_ ? (0, en.jsxs)(X.B, {
                                            type: "button",
                                            variant: "primary",
                                            style: {
                                                display: "flex",
                                                alignItems: "center",
                                                gap: X.s.sm,
                                                width: "compact" === eE.modalSize ? "100%" : void 0
                                            },
                                            onClick: async () => {
                                                if (!c) throw Error("No active wallet");
                                                ey(!1), em(!1), eb(!0);
                                                try {
                                                    await ek(ed)
                                                } catch (l) {
                                                    em(!0)
                                                } finally {
                                                    eb(!1)
                                                }
                                            },
                                            children: [" ", eg ? "Switching" : "Switch Network", eg && (0, en.jsx)(X.c, {
                                                size: "sm",
                                                color: "primaryButtonText"
                                            })]
                                        }) : (0, en.jsxs)(X.B, {
                                            variant: "accent",
                                            type: "submit",
                                            style: {
                                                display: "flex",
                                                alignItems: "center",
                                                gap: X.s.sm,
                                                width: "compact" === eE.modalSize ? "100%" : void 0
                                            },
                                            children: ["connecting" === ev ? "Connecting" : "Connect to Safe", "connecting" === ev && (0, en.jsx)(X.c, {
                                                size: "sm",
                                                color: "accentButtonText"
                                            })]
                                        })
                                    })
                                })
                            })]
                        })
                    })
                },
                ec = er.Z.select `
  width: 100%;
  padding: ${X.s.sm};
  box-sizing: border-box;
  outline: none;
  border: none;
  border-radius: 6px;
  color: ${l=>l.theme.colors.primaryText};
  background: none;
  font-size: ${X.f.md};
  box-shadow: 0 0 0 1.5px ${l=>l.theme.colors.secondaryButtonBg};
  appearance: none;

  &:focus {
    box-shadow: 0 0 0 2px ${l=>l.theme.colors.accentText};
  }

  &:invalid {
    color: ${l=>l.theme.colors.secondaryText};
  }
  &[data-error="true"] {
    box-shadow: 0 0 0 1.5px ${l=>l.theme.colors.danger};
  }

  &[disabled] {
    opacity: 1;
    cursor: not-allowed;
  }
`,
                eu = (0, er.Z)(ea.v4q)
            `
  color: ${l=>l.theme.colors.secondaryText};
`, safeWallet = l => {
                let c = l ? .personalWallets || q.d;
                return {
                    id: SafeWallet.id,
                    recommended: l ? .recommended,
                    meta: { ...SafeWallet.meta,
                        iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA4MCA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwIiBoZWlnaHQ9IjgwIiByeD0iMTIiIGZpbGw9IiMxMkZGODAiLz4KPG1hc2sgaWQ9Im1hc2swXzFfNDgiIHN0eWxlPSJtYXNrLXR5cGU6bHVtaW5hbmNlIiBtYXNrVW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4PSIxMiIgeT0iMTIiIHdpZHRoPSI1NiIgaGVpZ2h0PSI1NiI+CjxwYXRoIGQ9Ik00MCA2OEM1NS40NjQgNjggNjggNTUuNDY0IDY4IDQwQzY4IDI0LjUzNiA1NS40NjQgMTIgNDAgMTJDMjQuNTM2IDEyIDEyIDI0LjUzNiAxMiA0MEMxMiA1NS40NjQgMjQuNTM2IDY4IDQwIDY4WiIgZmlsbD0id2hpdGUiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzFfNDgpIj4KPHBhdGggZD0iTTY4LjEzNzUgNy40MjY3Nkg5LjMzNzUyVjcxLjk5NDhINjguMTM3NVY3LjQyNjc2WiIgZmlsbD0iIzEyRkY4MCIvPgo8L2c+CjxwYXRoIGQ9Ik01NS42NjgzIDQwLjAwNDZINTEuODQyOUM1MC43MDA1IDQwLjAwNDYgNDkuNzc0OCA0MC45MzA5IDQ5Ljc3NDggNDIuMDcyN1Y0Ny42MjQ2QzQ5Ljc3NDggNDguNzY3IDQ4Ljg0ODYgNDkuNjkyNyA0Ny43MDY4IDQ5LjY5MjdIMzIuNDg3NkMzMS4zNDUyIDQ5LjY5MjcgMzAuNDE5NiA1MC42MTg5IDMwLjQxOTYgNTEuNzYwN1Y1NS41ODYxQzMwLjQxOTYgNTYuNzI4NSAzMS4zNDU4IDU3LjY1NDIgMzIuNDg3NiA1Ny42NTQySDQ4LjU4NzZDNDkuNzMgNTcuNjU0MiA1MC42NDM0IDU2LjcyNzkgNTAuNjQzNCA1NS41ODYxVjUyLjUxNzNDNTAuNjQzNCA1MS4zNzQ5IDUxLjU2OTYgNTAuNTY0IDUyLjcxMTUgNTAuNTY0SDU1LjY2ODNDNTYuODEwNyA1MC41NjQgNTcuNzM2NCA0OS42Mzc4IDU3LjczNjQgNDguNDk1OVY0Mi4wNDgxQzU3LjczNjQgNDAuOTA1NyA1Ni44MTAxIDQwLjAwNDEgNTUuNjY4MyA0MC4wMDQxVjQwLjAwNDZaIiBmaWxsPSIjMTIxMzEyIi8+CjxwYXRoIGQ9Ik0zMC40MjQgMzIuMzk5N0MzMC40MjQgMzEuMjU3MyAzMS4zNTAzIDMwLjMzMTYgMzIuNDkyMSAzMC4zMzE2SDQ3LjcwMTdDNDguODQ0MSAzMC4zMzE2IDQ5Ljc2OTggMjkuNDA1NCA0OS43Njk4IDI4LjI2MzZWMjQuNDM4MkM0OS43Njk4IDIzLjI5NTggNDguODQzNiAyMi4zNzAxIDQ3LjcwMTcgMjIuMzcwMUgzMS42MTA3QzMwLjQ2ODMgMjIuMzcwMSAyOS41NDI2IDIzLjI5NjQgMjkuNTQyNiAyNC40MzgyVjI3LjM4NTVDMjkuNTQyNiAyOC41Mjc5IDI4LjYxNjQgMjkuNDUzNiAyNy40NzQ1IDI5LjQ1MzZIMjQuNTMwNkMyMy4zODgyIDI5LjQ1MzYgMjIuNDYyNSAzMC4zNzk4IDIyLjQ2MjUgMzEuNTIxNlYzNy45NzYyQzIyLjQ2MjUgMzkuMTE4NiAyMy4zOTIxIDM5Ljk5NzggMjQuNTM0NSAzOS45OTc4SDI4LjM1OTlDMjkuNTAyMyAzOS45OTc4IDMwLjQyOCAzOS4wNzE2IDMwLjQyOCAzNy45Mjk3TDMwLjQyNDYgMzIuNDAwM0wzMC40MjQgMzIuMzk5N1oiIGZpbGw9IiMxMjEzMTIiLz4KPHBhdGggZD0iTTM4LjI5MjkgMzUuOTc1SDQxLjk2NzZDNDMuMTY0OSAzNS45NzUgNDQuMTM3MSAzNi45NDcxIDQ0LjEzNzEgMzguMTQ0NFY0MS44MTkxQzQ0LjEzNzEgNDMuMDE2NCA0My4xNjQ5IDQzLjk4ODYgNDEuOTY3NiA0My45ODg2SDM4LjI5MjlDMzcuMDk1NiA0My45ODg2IDM2LjEyMzUgNDMuMDE2NCAzNi4xMjM1IDQxLjgxOTFWMzguMTQ0NEMzNi4xMjM1IDM2Ljk0NzEgMzcuMDk1NiAzNS45NzUgMzguMjkyOSAzNS45NzVaIiBmaWxsPSIjMTIxMzEyIi8+Cjwvc3ZnPgo="
                    },
                    create: l => new SafeWallet({ ...l
                    }),
                    connectUI: l => (0, en.jsx)(SafeConnectUI, { ...l,
                        personalWallets: c
                    }),
                    isInstalled: () => !1,
                    personalWallets: c
                }
            }, SafeConnectUI = l => {
                let c = (0, Y.Osb)(),
                    [x, N] = (0, J.useState)(),
                    U = (0, Y.qL0)();
                if (x) {
                    let c = {
                        close: () => {
                            N(void 0), l.close(!1)
                        },
                        goBack: () => {
                            N(void 0)
                        },
                        isOpen: l.isOpen,
                        open: l.open,
                        theme: l.theme,
                        walletConfig: x,
                        supportedWallets: l.personalWallets,
                        selectionData: l.selectionData,
                        setSelectionData: l.setSelectionData,
                        modalSize: l.modalSize
                    };
                    return x.connectUI ? (0, en.jsx)(x.connectUI, { ...c
                    }) : (0, en.jsx)(q.H, { ...c
                    })
                }
                return c ? (0, en.jsx)(SelectAccount, {
                    renderBackButton: l.supportedWallets.length > 1,
                    onBack: () => {
                        U(), l.goBack()
                    },
                    onConnect: l.close,
                    safeWalletConfig: l.walletConfig
                }) : (0, en.jsx)(SelectpersonalWallet, {
                    personalWallets: l.personalWallets,
                    onBack: l.goBack,
                    safeWallet: l.walletConfig,
                    selectWallet: N,
                    renderBackButton: l.supportedWallets.length > 1
                })
            }
        },
        93188: function(l, c, x) {
            "use strict";
            x.d(c, {
                RZ8: function() {
                    return N.C
                },
                wyl: function() {
                    return N.T
                },
                Dq5: function() {
                    return U.c
                },
                k9e: function() {
                    return U.m
                },
                u4Y: function() {
                    return U.r
                },
                SFn: function() {
                    return Z.SFn
                },
                aCi: function() {
                    return Z.aCi
                },
                cqn: function() {
                    return Z.cqn
                },
                doQ: function() {
                    return Z.doQ
                },
                GGd: function() {
                    return Z.GGd
                },
                aFJ: function() {
                    return U.a
                }
            });
            var N = x(26915),
                U = x(54844),
                Z = x(41282),
                $ = x(2265),
                Y = x(92060),
                q = x(75460),
                J = x(53061),
                X = x(33883),
                en = x(23743),
                er = x(1106),
                ea = x(33234),
                eo = x(512),
                el = x(53620),
                ec = x(70723),
                eu = x(58619),
                ed = x(91798),
                ep = x(12060),
                eh = x(31935),
                ey = x.n(eh);
            x(35077);
            var ef = x(87853);
            let G = class G {
                constructor(l) {
                    this.client = l
                }
            };
            let H = class H {
                constructor(l) {
                    this.opts = l
                }
            };
            let em = {
                    wc_authRequest: {
                        req: {
                            ttl: eu.ONE_DAY,
                            prompt: !0,
                            tag: 3e3
                        },
                        res: {
                            ttl: eu.ONE_DAY,
                            prompt: !1,
                            tag: 3001
                        }
                    }
                },
                eg = {
                    min: eu.FIVE_MINUTES,
                    max: eu.SEVEN_DAYS
                },
                eb = "authClient",
                ev = "wc@1:auth:",
                ew = `${ev}:PUB_KEY`;

            function z(l) {
                return l ? .split(":")
            }

            function W(l) {
                let c = l && z(l);
                if (c) return c.pop()
            }
            async function et(l, c, x, N, U) {
                switch (x.t) {
                    case "eip191":
                        var Z;
                        return Z = x.s, (0, ep.recoverAddress)((0, ed.r)(c), Z).toLowerCase() === l.toLowerCase();
                    case "eip1271":
                        return await rt(l, c, x.s, N, U);
                    default:
                        throw Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${x.t}`)
                }
            }
            async function rt(l, c, x, N, U) {
                try {
                    let Z = "0x1626ba7e",
                        $ = x.substring(2),
                        Y = (0, ed.r)(c).substring(2),
                        q = await ey()(`https://rpc.walletconnect.com/v1/?chainId=${N}&projectId=${U}`, {
                            method: "POST",
                            body: JSON.stringify({
                                id: Date.now() + Math.floor(1e3 * Math.random()),
                                jsonrpc: "2.0",
                                method: "eth_call",
                                params: [{
                                    to: l,
                                    data: Z + Y + "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041" + $
                                }, "latest"]
                            })
                        }),
                        {
                            result: J
                        } = await q.json();
                    return !!J && J.slice(0, Z.length).toLowerCase() === Z.toLowerCase()
                } catch (l) {
                    return console.error("isValidEip1271Signature: ", l), !1
                }
            }

            function ee(l) {
                return l.getAll().filter(l => "requester" in l)
            }

            function te(l, c) {
                return ee(l).find(l => l.id === c)
            }
            var Dt = function(l, c) {
                if (l.length >= 255) throw TypeError("Alphabet too long");
                for (var x = new Uint8Array(256), N = 0; N < x.length; N++) x[N] = 255;
                for (var U = 0; U < l.length; U++) {
                    var Z = l.charAt(U),
                        $ = Z.charCodeAt(0);
                    if (255 !== x[$]) throw TypeError(Z + " is ambiguous");
                    x[$] = U
                }
                var Y = l.length,
                    q = l.charAt(0),
                    J = Math.log(Y) / Math.log(256),
                    X = Math.log(256) / Math.log(Y);

                function p(l) {
                    if ("string" != typeof l) throw TypeError("Expected String");
                    if (0 === l.length) return new Uint8Array;
                    var c = 0;
                    if (" " !== l[0]) {
                        for (var N = 0, U = 0; l[c] === q;) N++, c++;
                        for (var Z = (l.length - c) * J + 1 >>> 0, $ = new Uint8Array(Z); l[c];) {
                            var X = x[l.charCodeAt(c)];
                            if (255 === X) return;
                            for (var en = 0, er = Z - 1;
                                (0 !== X || en < U) && -1 !== er; er--, en++) X += Y * $[er] >>> 0, $[er] = X % 256 >>> 0, X = X / 256 >>> 0;
                            if (0 !== X) throw Error("Non-zero carry");
                            U = en, c++
                        }
                        if (" " !== l[c]) {
                            for (var ea = Z - U; ea !== Z && 0 === $[ea];) ea++;
                            for (var eo = new Uint8Array(N + (Z - ea)), el = N; ea !== Z;) eo[el++] = $[ea++];
                            return eo
                        }
                    }
                }
                return {
                    encode: function(c) {
                        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                        if (0 === c.length) return "";
                        for (var x = 0, N = 0, U = 0, Z = c.length; U !== Z && 0 === c[U];) U++, x++;
                        for (var $ = (Z - U) * X + 1 >>> 0, J = new Uint8Array($); U !== Z;) {
                            for (var en = c[U], er = 0, ea = $ - 1;
                                (0 !== en || er < N) && -1 !== ea; ea--, er++) en += 256 * J[ea] >>> 0, J[ea] = en % Y >>> 0, en = en / Y >>> 0;
                            if (0 !== en) throw Error("Non-zero carry");
                            N = er, U++
                        }
                        for (var eo = $ - N; eo !== $ && 0 === J[eo];) eo++;
                        for (var el = q.repeat(x); eo < $; ++eo) el += l.charAt(J[eo]);
                        return el
                    },
                    decodeUnsafe: p,
                    decode: function(l) {
                        var x = p(l);
                        if (x) return x;
                        throw Error(`Non-${c} character`)
                    }
                }
            };
            let re = l => {
                    if (l instanceof Uint8Array && "Uint8Array" === l.constructor.name) return l;
                    if (l instanceof ArrayBuffer) return new Uint8Array(l);
                    if (ArrayBuffer.isView(l)) return new Uint8Array(l.buffer, l.byteOffset, l.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                ct = l => new TextEncoder().encode(l),
                ht = l => new TextDecoder().decode(l);
            let lt = class lt {
                constructor(l, c, x) {
                    this.name = l, this.prefix = c, this.baseEncode = x
                }
                encode(l) {
                    if (l instanceof Uint8Array) return `${this.prefix}${this.baseEncode(l)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let dt = class dt {
                constructor(l, c, x) {
                    if (this.name = l, this.prefix = c, void 0 === c.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = x
                }
                decode(l) {
                    if ("string" == typeof l) {
                        if (l.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(l)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(l.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(l) {
                    return ie(this, l)
                }
            };
            let pt = class pt {
                constructor(l) {
                    this.decoders = l
                }
                or(l) {
                    return ie(this, l)
                }
                decode(l) {
                    let c = l[0],
                        x = this.decoders[c];
                    if (x) return x.decode(l);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(l)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let ie = (l, c) => new pt({ ...l.decoders || {
                    [l.prefix]: l
                },
                ...c.decoders || {
                    [c.prefix]: c
                }
            });
            let ft = class ft {
                constructor(l, c, x, N) {
                    this.name = l, this.prefix = c, this.baseEncode = x, this.baseDecode = N, this.encoder = new lt(l, c, x), this.decoder = new dt(l, c, N)
                }
                encode(l) {
                    return this.encoder.encode(l)
                }
                decode(l) {
                    return this.decoder.decode(l)
                }
            };
            let O = ({
                    name: l,
                    prefix: c,
                    encode: x,
                    decode: N
                }) => new ft(l, c, x, N),
                T = ({
                    prefix: l,
                    name: c,
                    alphabet: x
                }) => {
                    let {
                        encode: N,
                        decode: U
                    } = Dt(x, c);
                    return O({
                        prefix: l,
                        name: c,
                        encode: N,
                        decode: l => re(U(l))
                    })
                },
                gt = (l, c, x, N) => {
                    let U = {};
                    for (let l = 0; l < c.length; ++l) U[c[l]] = l;
                    let Z = l.length;
                    for (;
                        "=" === l[Z - 1];) --Z;
                    let $ = new Uint8Array(Z * x / 8 | 0),
                        Y = 0,
                        q = 0,
                        J = 0;
                    for (let c = 0; c < Z; ++c) {
                        let Z = U[l[c]];
                        if (void 0 === Z) throw SyntaxError(`Non-${N} character`);
                        q = q << x | Z, (Y += x) >= 8 && (Y -= 8, $[J++] = 255 & q >> Y)
                    }
                    if (Y >= x || 255 & q << 8 - Y) throw SyntaxError("Unexpected end of data");
                    return $
                },
                Et = (l, c, x) => {
                    let N = "=" === c[c.length - 1],
                        U = (1 << x) - 1,
                        Z = "",
                        $ = 0,
                        Y = 0;
                    for (let N = 0; N < l.length; ++N)
                        for (Y = Y << 8 | l[N], $ += 8; $ > x;) $ -= x, Z += c[U & Y >> $];
                    if ($ && (Z += c[U & Y << x - $]), N)
                        for (; Z.length * x & 7;) Z += "=";
                    return Z
                },
                d = ({
                    name: l,
                    prefix: c,
                    bitsPerChar: x,
                    alphabet: N
                }) => O({
                    prefix: c,
                    name: l,
                    encode: l => Et(l, N, x),
                    decode: c => gt(c, N, x, l)
                }),
                eT = O({
                    prefix: "\x00",
                    name: "identity",
                    encode: l => ht(l),
                    decode: l => ct(l)
                });
            var eM = Object.freeze({
                __proto__: null,
                identity: eT
            });
            let eI = d({
                prefix: "0",
                name: "base2",
                alphabet: "01",
                bitsPerChar: 1
            });
            var ex = Object.freeze({
                __proto__: null,
                base2: eI
            });
            let eC = d({
                prefix: "7",
                name: "base8",
                alphabet: "01234567",
                bitsPerChar: 3
            });
            var e_ = Object.freeze({
                __proto__: null,
                base8: eC
            });
            let eD = T({
                prefix: "9",
                name: "base10",
                alphabet: "0123456789"
            });
            var eS = Object.freeze({
                __proto__: null,
                base10: eD
            });
            let ek = d({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                eE = d({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                });
            var eN = Object.freeze({
                __proto__: null,
                base16: ek,
                base16upper: eE
            });
            let eA = d({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                ej = d({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                eO = d({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                eP = d({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                ez = d({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                eR = d({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                eL = d({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                eB = d({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                eU = d({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                });
            var eF = Object.freeze({
                __proto__: null,
                base32: eA,
                base32upper: ej,
                base32pad: eO,
                base32padupper: eP,
                base32hex: ez,
                base32hexupper: eR,
                base32hexpad: eL,
                base32hexpadupper: eB,
                base32z: eU
            });
            let eW = T({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                eZ = T({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                });
            var eQ = Object.freeze({
                __proto__: null,
                base36: eW,
                base36upper: eZ
            });
            let eH = T({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                e$ = T({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                });
            var eY = Object.freeze({
                __proto__: null,
                base58btc: eH,
                base58flickr: e$
            });
            let eG = d({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                eV = d({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                eK = d({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                eJ = d({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                });
            var eX = Object.freeze({
                __proto__: null,
                base64: eG,
                base64pad: eV,
                base64url: eK,
                base64urlpad: eJ
            });
            let e0 = Array.from("\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                e2 = e0.reduce((l, c, x) => (l[x] = c, l), []),
                e1 = e0.reduce((l, c, x) => (l[c.codePointAt(0)] = x, l), []),
                e5 = O({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(l) {
                        return l.reduce((l, c) => l += e2[c], "")
                    },
                    decode: function(l) {
                        let c = [];
                        for (let x of l) {
                            let l = e1[x.codePointAt(0)];
                            if (void 0 === l) throw Error(`Non-base256emoji character: ${x}`);
                            c.push(l)
                        }
                        return new Uint8Array(c)
                    }
                });
            var e4 = Object.freeze({
                __proto__: null,
                base256emoji: e5
            });

            function oe(l, c, x) {
                c = c || [], x = x || 0;
                for (var N = x; l >= 2147483648;) c[x++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[x++] = 255 & l | 128, l >>>= 7;
                return c[x] = 0 | l, oe.bytes = x - N + 1, c
            }

            function j(l, c) {
                var x, N = 0,
                    c = c || 0,
                    U = 0,
                    Z = c,
                    $ = l.length;
                do {
                    if (Z >= $) throw j.bytes = 0, RangeError("Could not decode varint");
                    x = l[Z++], N += U < 28 ? (127 & x) << U : (127 & x) * Math.pow(2, U), U += 7
                } while (x >= 128);
                return j.bytes = Z - c, N
            }
            var e3 = {
                encode: oe,
                decode: j,
                encodingLength: function(l) {
                    return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let De = (l, c, x = 0) => (e3.encode(l, c, x), c),
                ce = l => e3.encodingLength(l),
                M = (l, c) => {
                    let x = c.byteLength,
                        N = ce(l),
                        U = N + ce(x),
                        Z = new Uint8Array(U + x);
                    return De(l, Z, 0), De(x, Z, N), Z.set(c, U), new yr(l, x, c, Z)
                };
            let yr = class yr {
                constructor(l, c, x, N) {
                    this.code = l, this.size = c, this.digest = x, this.bytes = N
                }
            };
            let he = ({
                name: l,
                code: c,
                encode: x
            }) => new wr(l, c, x);
            let wr = class wr {
                constructor(l, c, x) {
                    this.name = l, this.code = c, this.encode = x
                }
                digest(l) {
                    if (l instanceof Uint8Array) {
                        let c = this.encode(l);
                        return c instanceof Uint8Array ? M(this.code, c) : c.then(l => M(this.code, l))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let le = l => async c => new Uint8Array(await crypto.subtle.digest(l, c)),
                e6 = he({
                    name: "sha2-256",
                    code: 18,
                    encode: le("SHA-256")
                }),
                e8 = he({
                    name: "sha2-512",
                    code: 19,
                    encode: le("SHA-512")
                });
            var e9 = Object.freeze({
                    __proto__: null,
                    sha256: e6,
                    sha512: e8
                }),
                e7 = Object.freeze({
                    __proto__: null,
                    identity: {
                        code: 0,
                        name: "identity",
                        encode: re,
                        digest: l => M(0, re(l))
                    }
                });
            new TextEncoder, new TextDecoder;
            let tt = { ...eM,
                ...ex,
                ...e_,
                ...eS,
                ...eN,
                ...eF,
                ...eQ,
                ...eY,
                ...eX,
                ...e4
            };

            function ge(l, c, x, N) {
                return {
                    name: l,
                    prefix: c,
                    encoder: {
                        name: l,
                        prefix: c,
                        encode: x
                    },
                    decoder: {
                        decode: N
                    }
                }
            }({ ...e9,
                ...e7
            });
            let tn = ge("utf8", "u", l => "u" + new TextDecoder("utf8").decode(l), l => new TextEncoder().encode(l.substring(1))),
                tr = ge("ascii", "a", l => {
                    let c = "a";
                    for (let x = 0; x < l.length; x++) c += String.fromCharCode(l[x]);
                    return c
                }, l => {
                    l = l.substring(1);
                    let c = function(l = 0) {
                        return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? globalThis.Buffer.allocUnsafe(l) : new Uint8Array(l)
                    }(l.length);
                    for (let x = 0; x < l.length; x++) c[x] = l.charCodeAt(x);
                    return c
                }),
                ta = {
                    utf8: tn,
                    "utf-8": tn,
                    hex: tt.base16,
                    latin1: tr,
                    ascii: tr,
                    binary: tr,
                    ...tt
                };

            function K(l) {
                let c = (0, ef.vp)(function(l, c = "utf8") {
                    let x = ta[c];
                    if (!x) throw Error(`Unsupported encoding "${c}"`);
                    return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(l, "utf8") : x.decoder.decode(`${x.prefix}${l}`)
                }(l, "utf8"));
                return function(l, c = "utf8") {
                    let x = ta[c];
                    if (!x) throw Error(`Unsupported encoding "${c}"`);
                    return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(l.buffer, l.byteOffset, l.byteLength).toString("utf8") : x.encoder.encode(l).substring(1)
                }(c, "base16")
            }
            var to = Object.defineProperty,
                tl = Object.defineProperties,
                tc = Object.getOwnPropertyDescriptors,
                tu = Object.getOwnPropertySymbols,
                td = Object.prototype.hasOwnProperty,
                tp = Object.prototype.propertyIsEnumerable,
                me = (l, c, x) => c in l ? to(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                I = (l, c) => {
                    for (var x in c || (c = {})) td.call(c, x) && me(l, x, c[x]);
                    if (tu)
                        for (var x of tu(c)) tp.call(c, x) && me(l, x, c[x]);
                    return l
                },
                V = (l, c) => tl(l, tc(c));
            let Br = class Br extends G {
                constructor(l) {
                    super(l), this.initialized = !1, this.name = "authEngine", this.init = () => {
                        this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                            methods: Object.keys(em)
                        }), this.initialized = !0)
                    }, this.request = async (l, c) => {
                        if (this.isInitialized(), ! function(l) {
                                let c = (0, ec.jvJ)(l.aud),
                                    x = RegExp(`${l.domain}`).test(l.aud),
                                    N = !!l.nonce,
                                    U = !l.type || "eip4361" === l.type,
                                    Z = l.expiry;
                                if (Z && !(0, ec.ONw)(Z, eg)) {
                                    let {
                                        message: l
                                    } = (0, ec.kCb)("MISSING_OR_INVALID", `request() expiry: ${Z}. Expiry must be a number (in seconds) between ${eg.min} and ${eg.max}`);
                                    throw Error(l)
                                }
                                return !!(c && x && N && U)
                            }(l)) throw Error("Invalid request");
                        if (null != c && c.topic) return await this.requestOnKnownPairing(c.topic, l);
                        let {
                            chainId: x,
                            statement: N,
                            aud: U,
                            domain: Z,
                            nonce: $,
                            type: Y,
                            exp: q,
                            nbf: J
                        } = l, {
                            topic: X,
                            uri: en
                        } = await this.client.core.pairing.create();
                        this.client.logger.info({
                            message: "Generated new pairing",
                            pairing: {
                                topic: X,
                                uri: en
                            }
                        });
                        let er = await this.client.core.crypto.generateKeyPair(),
                            ea = (0, ec.YmJ)(er);
                        await this.client.authKeys.set(ew, {
                            responseTopic: ea,
                            publicKey: er
                        }), await this.client.pairingTopics.set(ea, {
                            topic: ea,
                            pairingTopic: X
                        }), await this.client.core.relayer.subscribe(ea), this.client.logger.info(`sending request to new pairing topic: ${X}`);
                        let eo = await this.sendRequest(X, "wc_authRequest", {
                            payloadParams: {
                                type: Y ? ? "eip4361",
                                chainId: x,
                                statement: N,
                                aud: U,
                                domain: Z,
                                version: "1",
                                nonce: $,
                                iat: new Date().toISOString(),
                                exp: q,
                                nbf: J
                            },
                            requester: {
                                publicKey: er,
                                metadata: this.client.metadata
                            }
                        }, {}, l.expiry);
                        return this.client.logger.info(`sent request to new pairing topic: ${X}`), {
                            uri: en,
                            id: eo
                        }
                    }, this.respond = async (l, c) => {
                        if (this.isInitialized(), !te(this.client.requests, l.id)) throw Error("Invalid response");
                        let x = te(this.client.requests, l.id);
                        if (!x) throw Error(`Could not find pending auth request with id ${l.id}`);
                        let N = x.requester.publicKey,
                            U = await this.client.core.crypto.generateKeyPair(),
                            Z = (0, ec.YmJ)(N),
                            $ = {
                                type: ec.rVF,
                                receiverPublicKey: N,
                                senderPublicKey: U
                            };
                        if ("error" in l) {
                            await this.sendError(x.id, Z, l, $);
                            return
                        }
                        let Y = {
                            h: {
                                t: "eip4361"
                            },
                            p: V(I({}, x.cacaoPayload), {
                                iss: c
                            }),
                            s: l.signature
                        };
                        await this.sendResult(x.id, Z, Y, $), await this.client.core.pairing.activate({
                            topic: x.pairingTopic
                        }), await this.client.requests.update(x.id, I({}, Y))
                    }, this.getPendingRequests = () => ee(this.client.requests), this.formatMessage = (l, c) => {
                        this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(l)}`);
                        let x = `${l.domain} wants you to sign in with your Ethereum account:`,
                            N = W(c),
                            U = l.statement,
                            Z = `URI: ${l.aud}`,
                            $ = `Version: ${l.version}`,
                            Y = `Chain ID: ${function(l){let c=l&&z(l);if(c)return c[3]}(c)}`,
                            q = `Nonce: ${l.nonce}`,
                            J = `Issued At: ${l.iat}`,
                            X = l.exp ? `Expiry: ${l.exp}` : void 0,
                            en = l.resources && l.resources.length > 0 ? `Resources:
${l.resources.map(l=>`- ${l}`).join(`
`)}` : void 0;
                        return [x, N, "", U, "", Z, $, Y, q, J, X, en].filter(l => null != l).join(`
`)
                    }, this.setExpiry = async (l, c) => {
                        this.client.core.pairing.pairings.keys.includes(l) && await this.client.core.pairing.updateExpiry({
                            topic: l,
                            expiry: c
                        }), this.client.core.expirer.set(l, c)
                    }, this.sendRequest = async (l, c, x, N, U) => {
                        let Z = (0, el.formatJsonRpcRequest)(c, x),
                            $ = await this.client.core.crypto.encode(l, Z, N),
                            Y = em[c].req;
                        if (U && (Y.ttl = U), this.client.core.history.set(l, Z), (0, ec.jUY)()) {
                            let l = K(JSON.stringify(Z));
                            this.client.core.verify.register({
                                attestationId: l
                            })
                        }
                        return await this.client.core.relayer.publish(l, $, V(I({}, Y), {
                            internal: {
                                throwOnFailedPublish: !0
                            }
                        })), Z.id
                    }, this.sendResult = async (l, c, x, N) => {
                        let U = (0, el.formatJsonRpcResult)(l, x),
                            Z = await this.client.core.crypto.encode(c, U, N),
                            $ = await this.client.core.history.get(c, l),
                            Y = em[$.request.method].res;
                        return await this.client.core.relayer.publish(c, Z, V(I({}, Y), {
                            internal: {
                                throwOnFailedPublish: !0
                            }
                        })), await this.client.core.history.resolve(U), U.id
                    }, this.sendError = async (l, c, x, N) => {
                        let U = (0, el.formatJsonRpcError)(l, x.error),
                            Z = await this.client.core.crypto.encode(c, U, N),
                            $ = await this.client.core.history.get(c, l),
                            Y = em[$.request.method].res;
                        return await this.client.core.relayer.publish(c, Z, Y), await this.client.core.history.resolve(U), U.id
                    }, this.requestOnKnownPairing = async (l, c) => {
                        let x = this.client.core.pairing.pairings.getAll({
                            active: !0
                        }).find(c => c.topic === l);
                        if (!x) throw Error(`Could not find pairing for provided topic ${l}`);
                        let {
                            publicKey: N
                        } = this.client.authKeys.get(ew), {
                            chainId: U,
                            statement: Z,
                            aud: $,
                            domain: Y,
                            nonce: q,
                            type: J
                        } = c, X = await this.sendRequest(x.topic, "wc_authRequest", {
                            payloadParams: {
                                type: J ? ? "eip4361",
                                chainId: U,
                                statement: Z,
                                aud: $,
                                domain: Y,
                                version: "1",
                                nonce: q,
                                iat: new Date().toISOString()
                            },
                            requester: {
                                publicKey: N,
                                metadata: this.client.metadata
                            }
                        }, {}, c.expiry);
                        return this.client.logger.info(`sent request to known pairing topic: ${x.topic}`), {
                            id: X
                        }
                    }, this.onPairingCreated = l => {
                        let c = this.getPendingRequests();
                        if (c) {
                            let x = Object.values(c).find(c => c.pairingTopic === l.topic);
                            x && this.handleAuthRequest(x)
                        }
                    }, this.onRelayEventRequest = l => {
                        let {
                            topic: c,
                            payload: x
                        } = l, N = x.method;
                        return "wc_authRequest" === N ? this.onAuthRequest(c, x) : this.client.logger.info(`Unsupported request method ${N}`)
                    }, this.onRelayEventResponse = async l => {
                        let {
                            topic: c,
                            payload: x
                        } = l, N = (await this.client.core.history.get(c, x.id)).request.method;
                        return "wc_authRequest" === N ? this.onAuthResponse(c, x) : this.client.logger.info(`Unsupported response method ${N}`)
                    }, this.onAuthRequest = async (l, c) => {
                        let {
                            requester: x,
                            payloadParams: N
                        } = c.params;
                        this.client.logger.info({
                            type: "onAuthRequest",
                            topic: l,
                            payload: c
                        });
                        let U = K(JSON.stringify(c)),
                            Z = await this.getVerifyContext(U, this.client.metadata),
                            $ = {
                                requester: x,
                                pairingTopic: l,
                                id: c.id,
                                cacaoPayload: N,
                                verifyContext: Z
                            };
                        await this.client.requests.set(c.id, $), this.handleAuthRequest($)
                    }, this.handleAuthRequest = async l => {
                        let {
                            id: c,
                            pairingTopic: x,
                            requester: N,
                            cacaoPayload: U,
                            verifyContext: Z
                        } = l;
                        try {
                            this.client.emit("auth_request", {
                                id: c,
                                topic: x,
                                params: {
                                    requester: N,
                                    cacaoPayload: U
                                },
                                verifyContext: Z
                            })
                        } catch (c) {
                            await this.sendError(l.id, l.pairingTopic, c), this.client.logger.error(c)
                        }
                    }, this.onAuthResponse = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        if (this.client.logger.info({
                                type: "onAuthResponse",
                                topic: l,
                                response: c
                            }), (0, el.isJsonRpcResult)(c)) {
                            let {
                                pairingTopic: N
                            } = this.client.pairingTopics.get(l);
                            await this.client.core.pairing.activate({
                                topic: N
                            });
                            let {
                                s: U,
                                p: Z
                            } = c.result;
                            await this.client.requests.set(x, I({
                                id: x,
                                pairingTopic: N
                            }, c.result));
                            let $ = this.formatMessage(Z, Z.iss);
                            this.client.logger.debug(`reconstructed message:
`, JSON.stringify($)), this.client.logger.debug("payload.iss:", Z.iss), this.client.logger.debug("signature:", U);
                            let Y = W(Z.iss),
                                q = function(l) {
                                    let c = l && z(l);
                                    if (c) return c[2] + ":" + c[3]
                                }(Z.iss);
                            if (!Y) throw Error("Could not derive address from `payload.iss`");
                            if (!q) throw Error("Could not derive chainId from `payload.iss`");
                            this.client.logger.debug("walletAddress extracted from `payload.iss`:", Y), await et(Y, $, U, q, this.client.projectId) ? this.client.emit("auth_response", {
                                id: x,
                                topic: l,
                                params: c
                            }) : this.client.emit("auth_response", {
                                id: x,
                                topic: l,
                                params: {
                                    message: "Invalid signature",
                                    code: -1
                                }
                            })
                        } else(0, el.isJsonRpcError)(c) && this.client.emit("auth_response", {
                            id: x,
                            topic: l,
                            params: c
                        })
                    }, this.getVerifyContext = async (l, c) => {
                        let x = {
                            verified: {
                                verifyUrl: c.verifyUrl || "",
                                validation: "UNKNOWN",
                                origin: c.url || ""
                            }
                        };
                        try {
                            let N = await this.client.core.verify.resolve({
                                attestationId: l,
                                verifyUrl: c.verifyUrl
                            });
                            N && (x.verified.origin = N.origin, x.verified.isScam = N.isScam, x.verified.validation = origin === new URL(c.url).origin ? "VALID" : "INVALID")
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                        return this.client.logger.info(`Verify context: ${JSON.stringify(x)}`), x
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ec.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                registerRelayerEvents() {
                    this.client.core.relayer.on(er.Mb.message, async l => {
                        let {
                            topic: c,
                            message: x
                        } = l, {
                            responseTopic: N,
                            publicKey: U
                        } = this.client.authKeys.keys.includes(ew) ? this.client.authKeys.get(ew) : {
                            responseTopic: void 0,
                            publicKey: void 0
                        };
                        if (N && c !== N) {
                            this.client.logger.debug("[Auth] Ignoring message from unknown topic", c);
                            return
                        }
                        let Z = await this.client.core.crypto.decode(c, x, {
                            receiverPublicKey: U
                        });
                        (0, el.isJsonRpcRequest)(Z) ? (this.client.core.history.set(c, Z), this.onRelayEventRequest({
                            topic: c,
                            payload: Z
                        })) : (0, el.isJsonRpcResponse)(Z) && (await this.client.core.history.resolve(Z), this.onRelayEventResponse({
                            topic: c,
                            payload: Z
                        }))
                    })
                }
                registerPairingEvents() {
                    this.client.core.pairing.events.on(er.I8.create, l => this.onPairingCreated(l))
                }
            };
            let S = class S extends H {
                constructor(l) {
                    super(l), this.protocol = "wc", this.version = 1, this.name = eb, this.events = new eo.EventEmitter, this.emit = (l, c) => this.events.emit(l, c), this.on = (l, c) => this.events.on(l, c), this.once = (l, c) => this.events.once(l, c), this.off = (l, c) => this.events.off(l, c), this.removeListener = (l, c) => this.events.removeListener(l, c), this.request = async (l, c) => {
                        try {
                            return await this.engine.request(l, c)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.respond = async (l, c) => {
                        try {
                            return await this.engine.respond(l, c)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getPendingRequests = () => {
                        try {
                            return this.engine.getPendingRequests()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.formatMessage = (l, c) => {
                        try {
                            return this.engine.formatMessage(l, c)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    };
                    let c = "u" > typeof l.logger && "string" != typeof l.logger ? l.logger : (0, ea.gw)((0, ea.jI)({
                        level: l.logger || "error"
                    }));
                    this.name = l ? .name || eb, this.metadata = l.metadata, this.projectId = l.projectId, this.core = l.core || new er.QY(l), this.logger = (0, ea.Ep)(c, this.name), this.authKeys = new er.yh(this.core, this.logger, "authKeys", ev, () => ew), this.pairingTopics = new er.yh(this.core, this.logger, "pairingTopics", ev), this.requests = new er.yh(this.core, this.logger, "requests", ev, l => l.id), this.engine = new Br(this)
                }
                static async init(l) {
                    let c = new S(l);
                    return await c.initialize(), c
                }
                get context() {
                    return (0, ea.Fd)(this.logger)
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({
                            authClient: this
                        })
                    } catch (l) {
                        throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(l.message), l
                    }
                }
            };
            var th, ty = x(24621),
                tf = {
                    exports: {}
                },
                tm = "object" == typeof Reflect ? Reflect : null,
                tg = tm && "function" == typeof tm.apply ? tm.apply : function(l, c, x) {
                    return Function.prototype.apply.call(l, c, x)
                };
            th = tm && "function" == typeof tm.ownKeys ? tm.ownKeys : Object.getOwnPropertySymbols ? function(l) {
                return Object.getOwnPropertyNames(l).concat(Object.getOwnPropertySymbols(l))
            } : function(l) {
                return Object.getOwnPropertyNames(l)
            };
            var tb = Number.isNaN || function(l) {
                return l != l
            };

            function o() {
                o.init.call(this)
            }
            tf.exports = o, tf.exports.once = function(l, c) {
                return new Promise(function(x, N) {
                    function i(x) {
                        l.removeListener(c, a), N(x)
                    }

                    function a() {
                        "function" == typeof l.removeListener && l.removeListener("error", i), x([].slice.call(arguments))
                    }
                    index_es_R(l, c, a, {
                        once: !0
                    }), "error" !== c && "function" == typeof l.on && index_es_R(l, "error", i, {
                        once: !0
                    })
                })
            }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
            var tv = 10;

            function g(l) {
                if ("function" != typeof l) throw TypeError('The "listener" argument must be of type Function. Received type ' + typeof l)
            }

            function _(l) {
                return void 0 === l._maxListeners ? o.defaultMaxListeners : l._maxListeners
            }

            function index_es_S(l, c, x, N) {
                var U, Z, $;
                if (g(x), void 0 === (Z = l._events) ? (Z = l._events = Object.create(null), l._eventsCount = 0) : (void 0 !== Z.newListener && (l.emit("newListener", c, x.listener ? x.listener : x), Z = l._events), $ = Z[c]), void 0 === $) $ = Z[c] = x, ++l._eventsCount;
                else if ("function" == typeof $ ? $ = Z[c] = N ? [x, $] : [$, x] : N ? $.unshift(x) : $.push(x), (U = _(l)) > 0 && $.length > U && !$.warned) {
                    $.warned = !0;
                    var Y = Error("Possible EventEmitter memory leak detected. " + $.length + " " + String(c) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    Y.name = "MaxListenersExceededWarning", Y.emitter = l, Y.type = c, Y.count = $.length, console && console.warn && console.warn(Y)
                }
                return l
            }

            function D() {
                if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 == arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }

            function C(l, c, x) {
                var N = {
                        fired: !1,
                        wrapFn: void 0,
                        target: l,
                        type: c,
                        listener: x
                    },
                    U = D.bind(N);
                return U.listener = x, N.wrapFn = U, U
            }

            function b(l, c, x) {
                var N = l._events;
                if (void 0 === N) return [];
                var U = N[c];
                return void 0 === U ? [] : "function" == typeof U ? x ? [U.listener || U] : [U] : x ? function(l) {
                    for (var c = Array(l.length), x = 0; x < c.length; ++x) c[x] = l[x].listener || l[x];
                    return c
                }(U) : index_es_O(U, U.length)
            }

            function E(l) {
                var c = this._events;
                if (void 0 !== c) {
                    var x = c[l];
                    if ("function" == typeof x) return 1;
                    if (void 0 !== x) return x.length
                }
                return 0
            }

            function index_es_O(l, c) {
                for (var x = Array(c), N = 0; N < c; ++N) x[N] = l[N];
                return x
            }

            function index_es_R(l, c, x, N) {
                if ("function" == typeof l.on) N.once ? l.once(c, x) : l.on(c, x);
                else if ("function" == typeof l.addEventListener) l.addEventListener(c, function i(U) {
                    N.once && l.removeEventListener(c, i), x(U)
                });
                else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof l)
            }
            Object.defineProperty(o, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return tv
                },
                set: function(l) {
                    if ("number" != typeof l || l < 0 || tb(l)) throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + l + ".");
                    tv = l
                }
            }), o.init = function() {
                (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }, o.prototype.setMaxListeners = function(l) {
                if ("number" != typeof l || l < 0 || tb(l)) throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + l + ".");
                return this._maxListeners = l, this
            }, o.prototype.getMaxListeners = function() {
                return _(this)
            }, o.prototype.emit = function(l) {
                for (var c = [], x = 1; x < arguments.length; x++) c.push(arguments[x]);
                var N = "error" === l,
                    U = this._events;
                if (void 0 !== U) N = N && void 0 === U.error;
                else if (!N) return !1;
                if (N) {
                    if (c.length > 0 && (Z = c[0]), Z instanceof Error) throw Z;
                    var Z, $ = Error("Unhandled error." + (Z ? " (" + Z.message + ")" : ""));
                    throw $.context = Z, $
                }
                var Y = U[l];
                if (void 0 === Y) return !1;
                if ("function" == typeof Y) tg(Y, this, c);
                else
                    for (var q = Y.length, J = index_es_O(Y, q), x = 0; x < q; ++x) tg(J[x], this, c);
                return !0
            }, o.prototype.addListener = function(l, c) {
                return index_es_S(this, l, c, !1)
            }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(l, c) {
                return index_es_S(this, l, c, !0)
            }, o.prototype.once = function(l, c) {
                return g(c), this.on(l, C(this, l, c)), this
            }, o.prototype.prependOnceListener = function(l, c) {
                return g(c), this.prependListener(l, C(this, l, c)), this
            }, o.prototype.removeListener = function(l, c) {
                var x, N, U, Z, $;
                if (g(c), void 0 === (N = this._events) || void 0 === (x = N[l])) return this;
                if (x === c || x.listener === c) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete N[l], N.removeListener && this.emit("removeListener", l, x.listener || c));
                else if ("function" != typeof x) {
                    for (U = -1, Z = x.length - 1; Z >= 0; Z--)
                        if (x[Z] === c || x[Z].listener === c) {
                            $ = x[Z].listener, U = Z;
                            break
                        }
                    if (U < 0) return this;
                    0 === U ? x.shift() : function(l, c) {
                        for (; c + 1 < l.length; c++) l[c] = l[c + 1];
                        l.pop()
                    }(x, U), 1 === x.length && (N[l] = x[0]), void 0 !== N.removeListener && this.emit("removeListener", l, $ || c)
                }
                return this
            }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(l) {
                var c, x, N;
                if (void 0 === (x = this._events)) return this;
                if (void 0 === x.removeListener) return 0 == arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== x[l] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete x[l]), this;
                if (0 == arguments.length) {
                    var U, Z = Object.keys(x);
                    for (N = 0; N < Z.length; ++N) "removeListener" !== (U = Z[N]) && this.removeAllListeners(U);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                }
                if ("function" == typeof(c = x[l])) this.removeListener(l, c);
                else if (void 0 !== c)
                    for (N = c.length - 1; N >= 0; N--) this.removeListener(l, c[N]);
                return this
            }, o.prototype.listeners = function(l) {
                return b(this, l, !0)
            }, o.prototype.rawListeners = function(l) {
                return b(this, l, !1)
            }, o.listenerCount = function(l, c) {
                return "function" == typeof l.listenerCount ? l.listenerCount(c) : E.call(l, c)
            }, o.prototype.listenerCount = E, o.prototype.eventNames = function() {
                return this._eventsCount > 0 ? th(this._events) : []
            };
            let index_es_x = class index_es_x {
                constructor(l) {
                    this.opts = l
                }
            };
            let P = class P {
                constructor(l) {
                    this.client = l
                }
            };
            var tw = Object.defineProperty,
                tT = Object.defineProperties,
                tM = Object.getOwnPropertyDescriptors,
                tI = Object.getOwnPropertySymbols,
                tx = Object.prototype.hasOwnProperty,
                tC = Object.prototype.propertyIsEnumerable,
                index_es_j = (l, c, x) => c in l ? tw(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                index_es_ee = (l, c) => {
                    for (var x in c || (c = {})) tx.call(c, x) && index_es_j(l, x, c[x]);
                    if (tI)
                        for (var x of tI(c)) tC.call(c, x) && index_es_j(l, x, c[x]);
                    return l
                },
                index_es_te = (l, c) => tT(l, tM(c));
            let index_es_se = class index_es_se extends P {
                constructor(l) {
                    super(l), this.init = async () => {
                        this.signClient = await ty.TN.init({
                            core: this.client.core,
                            metadata: this.client.metadata,
                            signConfig: this.client.signConfig
                        }), this.authClient = await S.init({
                            core: this.client.core,
                            projectId: "",
                            metadata: this.client.metadata
                        })
                    }, this.pair = async l => {
                        await this.client.core.pairing.pair(l)
                    }, this.approveSession = async l => {
                        let {
                            topic: c,
                            acknowledged: x
                        } = await this.signClient.approve(index_es_te(index_es_ee({}, l), {
                            id: l.id,
                            namespaces: l.namespaces,
                            sessionProperties: l.sessionProperties,
                            sessionConfig: l.sessionConfig
                        }));
                        return await x(), this.signClient.session.get(c)
                    }, this.rejectSession = async l => await this.signClient.reject(l), this.updateSession = async l => await this.signClient.update(l), this.extendSession = async l => await this.signClient.extend(l), this.respondSessionRequest = async l => await this.signClient.respond(l), this.disconnectSession = async l => await this.signClient.disconnect(l), this.emitSessionEvent = async l => await this.signClient.emit(l), this.getActiveSessions = () => this.signClient.session.getAll().reduce((l, c) => (l[c.topic] = c, l), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (l, c) => await this.authClient.respond(l, c), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter(l => "requester" in l), this.formatMessage = (l, c) => this.authClient.formatMessage(l, c), this.approveSessionAuthenticate = async l => await this.signClient.approveSessionAuthenticate(l), this.rejectSessionAuthenticate = async l => await this.signClient.rejectSessionAuthenticate(l), this.formatAuthMessage = l => this.signClient.formatAuthMessage(l), this.registerDeviceToken = l => this.client.core.echoClient.registerDeviceToken(l), this.on = (l, c) => (this.setEvent(l, "off"), this.setEvent(l, "on"), this.client.events.on(l, c)), this.once = (l, c) => (this.setEvent(l, "off"), this.setEvent(l, "once"), this.client.events.once(l, c)), this.off = (l, c) => (this.setEvent(l, "off"), this.client.events.off(l, c)), this.removeListener = (l, c) => (this.setEvent(l, "removeListener"), this.client.events.removeListener(l, c)), this.onSessionRequest = l => {
                        this.client.events.emit("session_request", l)
                    }, this.onSessionProposal = l => {
                        this.client.events.emit("session_proposal", l)
                    }, this.onSessionDelete = l => {
                        this.client.events.emit("session_delete", l)
                    }, this.onAuthRequest = l => {
                        this.client.events.emit("auth_request", l)
                    }, this.onProposalExpire = l => {
                        this.client.events.emit("proposal_expire", l)
                    }, this.onSessionRequestExpire = l => {
                        this.client.events.emit("session_request_expire", l)
                    }, this.onSessionRequestAuthenticate = l => {
                        this.client.events.emit("session_authenticate", l)
                    }, this.setEvent = (l, c) => {
                        switch (l) {
                            case "session_request":
                                this.signClient.events[c]("session_request", this.onSessionRequest);
                                break;
                            case "session_proposal":
                                this.signClient.events[c]("session_proposal", this.onSessionProposal);
                                break;
                            case "session_delete":
                                this.signClient.events[c]("session_delete", this.onSessionDelete);
                                break;
                            case "auth_request":
                                this.authClient[c]("auth_request", this.onAuthRequest);
                                break;
                            case "proposal_expire":
                                this.signClient.events[c]("proposal_expire", this.onProposalExpire);
                                break;
                            case "session_request_expire":
                                this.signClient.events[c]("session_request_expire", this.onSessionRequestExpire);
                                break;
                            case "session_authenticate":
                                this.signClient.events[c]("session_authenticate", this.onSessionRequestAuthenticate)
                        }
                    }, this.signClient = {}, this.authClient = {}
                }
            };
            let t_ = class extends index_es_x {
                constructor(l) {
                    super(l), this.events = new tf.exports, this.on = (l, c) => this.engine.on(l, c), this.once = (l, c) => this.engine.once(l, c), this.off = (l, c) => this.engine.off(l, c), this.removeListener = (l, c) => this.engine.removeListener(l, c), this.pair = async l => {
                        try {
                            return await this.engine.pair(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.approveSession = async l => {
                        try {
                            return await this.engine.approveSession(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.rejectSession = async l => {
                        try {
                            return await this.engine.rejectSession(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.updateSession = async l => {
                        try {
                            return await this.engine.updateSession(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.extendSession = async l => {
                        try {
                            return await this.engine.extendSession(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.respondSessionRequest = async l => {
                        try {
                            return await this.engine.respondSessionRequest(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.disconnectSession = async l => {
                        try {
                            return await this.engine.disconnectSession(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.emitSessionEvent = async l => {
                        try {
                            return await this.engine.emitSessionEvent(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getActiveSessions = () => {
                        try {
                            return this.engine.getActiveSessions()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getPendingSessionProposals = () => {
                        try {
                            return this.engine.getPendingSessionProposals()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getPendingSessionRequests = () => {
                        try {
                            return this.engine.getPendingSessionRequests()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.respondAuthRequest = async (l, c) => {
                        try {
                            return await this.engine.respondAuthRequest(l, c)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getPendingAuthRequests = () => {
                        try {
                            return this.engine.getPendingAuthRequests()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.formatMessage = (l, c) => {
                        try {
                            return this.engine.formatMessage(l, c)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.registerDeviceToken = l => {
                        try {
                            return this.engine.registerDeviceToken(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.approveSessionAuthenticate = l => {
                        try {
                            return this.engine.approveSessionAuthenticate(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.rejectSessionAuthenticate = l => {
                        try {
                            return this.engine.rejectSessionAuthenticate(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.formatAuthMessage = l => {
                        try {
                            return this.engine.formatAuthMessage(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.metadata = l.metadata, this.name = l.name || "Web3Wallet", this.signConfig = l.signConfig, this.core = l.core, this.logger = this.core.logger, this.engine = new index_es_se(this)
                }
                static async init(l) {
                    let c = new t_(l);
                    return await c.initialize(), c
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.engine.init(), this.logger.info("Web3Wallet Initialization Success")
                    } catch (l) {
                        throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(l.message), l
                    }
                }
            };
            t_.notifications = {
                decryptMessage: async l => {
                    let c = {
                        core: new er.QY({
                            storageOptions: l.storageOptions,
                            storage: l.storage
                        })
                    };
                    await c.core.crypto.init();
                    let x = c.core.crypto.decode(l.topic, l.encryptedMessage);
                    return c.core = null, x
                },
                getMetadata: async l => {
                    let c = {
                        core: new er.QY({
                            storageOptions: l.storageOptions,
                            storage: l.storage
                        }),
                        sessionStore: null
                    };
                    c.sessionStore = new ty.pG(c.core, c.core.logger), await c.sessionStore.init();
                    let x = c.sessionStore.get(l.topic),
                        N = x ? .peer.metadata;
                    return c.core = null, c.sessionStore = null, N
                }
            };
            var tD = x(57273),
                tS = x(18994),
                tk = x(58337),
                tE = x(11953),
                tN = x(86684);
            let WalletConnectHandler = class WalletConnectHandler extends tE.Z {};
            var tA = new WeakMap,
                tj = new WeakMap,
                tO = new WeakMap,
                tP = new WeakMap,
                tz = new WeakMap,
                tR = new WeakMap,
                tL = new WeakSet,
                tB = new WeakSet;
            let WalletConnectV2Handler = class WalletConnectV2Handler extends WalletConnectHandler {
                constructor(l) {
                    super(), (0, Y._)(this, tB), (0, Y._)(this, tL), (0, q._)(this, tA, {
                        writable: !0,
                        value: void 0
                    }), (0, q._)(this, tj, {
                        writable: !0,
                        value: void 0
                    }), (0, q._)(this, tO, {
                        writable: !0,
                        value: void 0
                    }), (0, q._)(this, tP, {
                        writable: !0,
                        value: void 0
                    }), (0, q._)(this, tz, {
                        writable: !0,
                        value: void 0
                    }), (0, q._)(this, tR, {
                        writable: !0,
                        value: void 0
                    }), (0, q.a)(this, tP, l ? .walletConnectWalletMetadata || {
                        name: "Thirdweb Smart Wallet",
                        description: "Thirdweb Smart Wallet",
                        url: "https://thirdweb.com",
                        icons: ["https://thirdweb.com/favicon.ico"]
                    }), (0, q.a)(this, tA, new er.QY({
                        projectId: l ? .walletConenctV2ProjectId || tN.T,
                        relayUrl: l ? .walletConnectV2RelayUrl || tN.W
                    }))
                }
                async init() {
                    (0, q.a)(this, tj, await t_.init({
                        core: (0, q.b)(this, tA),
                        metadata: (0, q.b)(this, tP)
                    }));
                    let l = (0, q.b)(this, tj).getActiveSessions(),
                        c = Object.keys(l);
                    c[0] && (0, q.a)(this, tO, l[c[0]]), (0, Y.a)(this, tL, _setupWalletConnectEventsListeners2$1).call(this)
                }
                async connectApp(l) {
                    if (!(0, q.b)(this, tj)) throw Error("Please, init the wallet before connecting an app.");
                    await (0, q.b)(this, tj).core.pairing.pair({
                        uri: l
                    })
                }
                async approveSession(l) {
                    if (!(0, q.b)(this, tj)) throw Error("Please, init the wallet before making session requests.");
                    if (!(0, q.b)(this, tz)) throw Error("Please, pass a valid proposal.");
                    let c = await l.getAddress(),
                        {
                            id: x,
                            params: N
                        } = (0, q.b)(this, tz),
                        {
                            requiredNamespaces: U,
                            relays: Z
                        } = N,
                        $ = {};
                    Object.keys(U).forEach(l => {
                        let x = [],
                            N = U[l];
                        N && (N.chains ? .map(l => {
                            x.push(`${l}:${c}`)
                        }), $[l] = {
                            accounts: x,
                            methods: N.methods,
                            events: N.events
                        })
                    }), (0, q.a)(this, tO, await (0, q.b)(this, tj).approveSession({
                        id: x,
                        relayProtocol: Z[0] ? .protocol,
                        namespaces: $
                    })), this.emit("session_approved")
                }
                async rejectSession() {
                    if (!(0, q.b)(this, tj)) throw Error("Please, init the wallet before making session requests.");
                    if (!(0, q.b)(this, tz)) throw Error("Please, pass a valid proposal.");
                    let {
                        id: l
                    } = (0, q.b)(this, tz);
                    await (0, q.b)(this, tj).rejectSession({
                        id: l,
                        reason: {
                            message: "User rejected methods.",
                            code: 5002
                        }
                    })
                }
                async approveEIP155Request(l) {
                    let c;
                    if (!(0, q.b)(this, tR)) return;
                    let {
                        topic: x,
                        params: N,
                        id: U
                    } = (0, q.b)(this, tR), {
                        request: Z
                    } = N;
                    switch (Z.method) {
                        case tN.E.PERSONAL_SIGN:
                        case tN.E.ETH_SIGN:
                            let $ = (0, Y.a)(this, tB, _getSignParamsMessage2).call(this, Z.params),
                                J = await l.signMessage($ || "");
                            c = (0, el.formatJsonRpcResult)(U, J);
                            break;
                        case tN.E.ETH_SEND_TRANSACTION:
                            let X = await l.getSigner(),
                                en = Z.params[0],
                                er = await X.sendTransaction(en),
                                {
                                    transactionHash: ea
                                } = await er.wait();
                            c = (0, el.formatJsonRpcResult)(U, ea);
                            break;
                        case tN.E.ETH_SIGN_TRANSACTION:
                            let eo = await l.getSigner(),
                                ec = Z.params[0],
                                eu = await eo.signTransaction(ec);
                            c = (0, el.formatJsonRpcResult)(U, eu);
                        default:
                            return q.b(this, tj) ? .respondSessionRequest({
                                topic: x,
                                response: {
                                    id: U,
                                    jsonrpc: "2.0",
                                    error: {
                                        message: "Invalid event.",
                                        code: 1002
                                    }
                                }
                            })
                    }
                    return q.b(this, tj) ? .respondSessionRequest({
                        topic: x,
                        response: c
                    })
                }
                async rejectEIP155Request() {
                    if (!(0, q.b)(this, tR)) return;
                    let {
                        topic: l,
                        id: c
                    } = (0, q.b)(this, tR);
                    return q.b(this, tj) ? .respondSessionRequest({
                        topic: l,
                        response: {
                            id: c,
                            jsonrpc: "2.0",
                            error: {
                                message: "User rejected methods.",
                                code: 5002
                            }
                        }
                    })
                }
                getActiveSessions() {
                    if (!(0, q.b)(this, tj)) throw Error("Please, init the wallet before getting sessions.");
                    let l = (0, q.b)(this, tj).getActiveSessions(),
                        c = Object.keys(l);
                    if (!l || 0 === c.length) return [];
                    let x = [];
                    for (let N of c) {
                        let c = l[N];
                        if (c) {
                            let l = c.topic,
                                N = c.peer.metadata;
                            x.push({
                                topic: l,
                                peer: {
                                    metadata: N
                                }
                            })
                        }
                    }
                    return x
                }
                disconnectSession() {
                    if (!(0, q.b)(this, tj)) throw Error("Please, init the wallet before disconnecting sessions.");
                    if (!(0, q.b)(this, tO)) return Promise.resolve();
                    let l = {
                        topic: (0, q.b)(this, tO).topic,
                        reason: {
                            message: "User disconnected.",
                            code: 6e3
                        }
                    };
                    return q.b(this, tj) ? .disconnectSession(l)
                }
            };

            function _setupWalletConnectEventsListeners2$1() {
                if (!(0, q.b)(this, tj)) throw Error("Please, init the wallet before making session requests.");
                (0, q.b)(this, tj).on("session_proposal", l => {
                    (0, q.a)(this, tz, l), this.emit("session_proposal", {
                        proposer: {
                            metadata: l.params.proposer.metadata
                        }
                    })
                }), (0, q.b)(this, tj).on("session_delete", l => {
                    (0, q.a)(this, tO, void 0), (0, q.a)(this, tz, void 0), this.emit("session_delete", {
                        topic: l.topic
                    })
                }), (0, q.b)(this, tj).on("session_request", async l => {
                    if (!(0, q.b)(this, tO)) return;
                    let {
                        params: c
                    } = l, {
                        request: x
                    } = c, {
                        params: N
                    } = x;
                    switch (x.method) {
                        case tN.E.ETH_SIGN:
                        case tN.E.PERSONAL_SIGN:
                            (0, q.a)(this, tR, l);
                            let U = N[0],
                                Z = new TextDecoder().decode(tD.arrayify(U)),
                                $ = [...N];
                            $[0] = Z, this.emit("session_request", {
                                topic: (0, q.b)(this, tO).topic,
                                params: $,
                                peer: {
                                    metadata: (0, q.b)(this, tO).peer.metadata
                                },
                                method: x.method
                            });
                            return;
                        case tN.E.ETH_SEND_TRANSACTION:
                        case tN.E.ETH_SIGN_TRANSACTION:
                            (0, q.a)(this, tR, l), this.emit("session_request", {
                                topic: (0, q.b)(this, tO).topic,
                                params: l.params.request.params,
                                peer: {
                                    metadata: (0, q.b)(this, tO).peer.metadata
                                },
                                method: x.method
                            });
                            return;
                        default:
                            throw Error(`WCV2.Method not supported: ${x.method}`)
                    }
                })
            }

            function _getSignParamsMessage2(l) {
                let c = l.filter(l => !tS.isAddress(l))[0] || "";
                return tD.isHexString(c) ? tk.ZN(c) : c
            }
            let NoOpWalletConnectHandler = class NoOpWalletConnectHandler extends WalletConnectHandler {
                init() {
                    return Promise.resolve()
                }
                connectApp(l) {
                    return Promise.resolve()
                }
                approveSession(l) {
                    return Promise.resolve()
                }
                rejectSession() {
                    return Promise.resolve()
                }
                approveEIP155Request(l) {
                    return Promise.resolve()
                }
                rejectEIP155Request() {
                    return Promise.resolve()
                }
                getActiveSessions() {
                    return []
                }
                disconnectSession() {
                    return Promise.resolve()
                }
            };
            var tU = new WeakMap,
                tF = new WeakSet;
            let SmartWallet = class SmartWallet extends X.a {
                get walletName() {
                    return "Smart Wallet"
                }
                constructor(l) {
                    super(SmartWallet.id, { ...l
                    }), (0, Y._)(this, tF), (0, J._)(this, "enableConnectApp", !1), (0, q._)(this, tU, {
                        writable: !0,
                        value: void 0
                    }), this.enableConnectApp = l ? .enableConnectApp || !1, (0, q.a)(this, tU, this.enableConnectApp ? new WalletConnectV2Handler({
                        walletConnectWalletMetadata: l ? .walletConnectWalletMetadata,
                        walletConenctV2ProjectId: l ? .walletConenctV2ProjectId,
                        walletConnectV2RelayUrl: l ? .walletConnectV2RelayUrl
                    }) : new NoOpWalletConnectHandler)
                }
                async getConnector() {
                    if (!this.connector) {
                        this.enableConnectApp && (await (0, q.b)(this, tU).init(), (0, Y.a)(this, tF, _setupWalletConnectEventsListeners2).call(this));
                        let {
                            SmartWalletConnector: l
                        } = await x.e(3390).then(x.bind(x, 3390));
                        this.connector = new l(this.options)
                    }
                    return this.connector
                }
                getPersonalWallet() {
                    return this.connector ? .personalWallet
                }
                async hasPermissionToExecute(l) {
                    let c = await this.getConnector();
                    return c.hasPermissionToExecute(l)
                }
                async execute(l) {
                    let c = await this.getConnector();
                    return c.execute(l)
                }
                async executeBatch(l) {
                    let c = await this.getConnector();
                    return c.executeBatch(l)
                }
                async deploy() {
                    let l = await this.getConnector();
                    return l.deploy()
                }
                async deployIfNeeded() {
                    let l = await this.getConnector();
                    return l.deployIfNeeded()
                }
                async isDeployed() {
                    let l = await this.getConnector();
                    return l.isDeployed()
                }
                async createSessionKey(l, c) {
                    let x = await this.getConnector();
                    return x.grantPermissions(l, c)
                }
                async revokeSessionKey(l) {
                    let c = await this.getConnector();
                    return c.revokePermissions(l)
                }
                async addAdmin(l) {
                    let c = await this.getConnector();
                    return c.addAdmin(l)
                }
                async removeAdmin(l) {
                    let c = await this.getConnector();
                    return c.removeAdmin(l)
                }
                async getAllActiveSigners() {
                    let l = await this.getConnector();
                    return l.getAllActiveSigners()
                }
                async getAccountContract() {
                    let l = await this.getConnector();
                    return l.getAccountContract()
                }
                async getFactoryContract() {
                    let l = await this.getConnector();
                    return l.getFactoryContract()
                }
                autoConnect(l) {
                    return this.connect(l)
                }
                async connectApp(l) {
                    if (!this.enableConnectApp) throw Error("enableConnectApp is set to false in this wallet config");
                    q.b(this, tU) ? .connectApp(l)
                }
                async approveSession() {
                    await (0, q.b)(this, tU).approveSession(this), this.emit("message", {
                        type: "session_approved"
                    })
                }
                rejectSession() {
                    return (0, q.b)(this, tU).rejectSession()
                }
                approveRequest() {
                    return (0, q.b)(this, tU).approveEIP155Request(this)
                }
                rejectRequest() {
                    return (0, q.b)(this, tU).rejectEIP155Request()
                }
                getActiveSessions() {
                    if (!(0, q.b)(this, tU)) throw Error("Please, init the wallet before making session requests.");
                    return (0, q.b)(this, tU).getActiveSessions()
                }
                disconnectSession() {
                    return q.b(this, tU) ? .disconnectSession()
                }
                isWCReceiverEnabled() {
                    return this.enableConnectApp
                }
            };

            function _setupWalletConnectEventsListeners2() {
                if (!(0, q.b)(this, tU)) throw Error("Please, init the wallet before making session requests.");
                (0, q.b)(this, tU).on("session_proposal", l => {
                    this.emit("message", {
                        type: "session_proposal",
                        data: l
                    })
                }), (0, q.b)(this, tU).on("session_delete", () => {
                    this.emit("message", {
                        type: "session_delete"
                    })
                }), (0, q.b)(this, tU).on("switch_chain", l => {
                    let c = l.params[0].chainId;
                    this.emit("message", {
                        type: "switch_chain",
                        data: {
                            chainId: c
                        }
                    }), (0, q.b)(this, tU).disconnectSession()
                }), (0, q.b)(this, tU).on("session_request", l => {
                    this.emit("message", {
                        type: "session_request",
                        data: l
                    })
                })
            }(0, J._)(SmartWallet, "meta", {
                name: "Smart Wallet",
                iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
            }), (0, J._)(SmartWallet, "id", en.w.smartWallet);
            var tW = x(67327);
            x(78698);
            var tZ = x(8801);
            x(8499), x(80464);
            var tQ = x(57437);
            x(33055);
            var tH = x(69394);
            x(76904), x(41226), x(70388), x(2390), x(75298), (0, tZ.Z)(tW.B)
            `
  display: flex;
  justify-content: center;
  gap: ${tW.s.sm};
`, tZ.Z.button `
  all: unset;
  color: ${l=>l.theme.colors.accentText};
  font-size: ${tW.f.sm};
  cursor: pointer;
  text-align: center;
  font-weight: 500;
  width: 100%;
  &:hover {
    color: ${l=>l.theme.colors.primaryText};
  }
`, (0, tZ.Z)(tH.rG2)
            `
  color: ${l=>l.theme.colors.secondaryIconColor};
  transition:
    transform 200ms ease,
    color 200ms ease;
`, tZ.Z.div `
  border: 2px solid ${l=>l.theme.colors.borderColor};
  border-radius: ${tW.d.md};
  padding: ${tW.s.xl} ${tW.s.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${l=>l.theme.colors.accentText};
    svg {
      color: ${l=>l.theme.colors.accentText};
    }
  }

  &[data-error="true"] {
    border-color: ${l=>l.theme.colors.danger};
  }
`
        },
        70388: function(l, c, x) {
            "use strict";
            x.d(c, {
                walletConnectV1: function() {
                    return U
                }
            });
            var N = x(54844);
            x(41282), x(67327), x(8801), x(57437), x(2265), x(75298), x(2390);
            let U = N.a
        },
        44049: function(l, c, x) {
            "use strict";
            x.d(c, {
                A: function() {
                    return ec
                },
                B: function() {
                    return en
                },
                C: function() {
                    return em
                },
                D: function() {
                    return eg
                },
                F: function() {
                    return J
                },
                M: function() {
                    return X
                },
                N: function() {
                    return ef
                },
                P: function() {
                    return eo
                },
                Q: function() {
                    return eu
                },
                a: function() {
                    return ea
                },
                b: function() {
                    return ey
                },
                c: function() {
                    return eh
                }
            });
            var N = x(56662),
                U = x.n(N),
                Z = x(92598),
                $ = x(74578);
            let Y = $.z.instanceof(File),
                q = $.z.union([Y, $.z.object({
                    data: $.z.union([Y, $.z.string()]),
                    name: $.z.string()
                })]),
                J = $.z.union([q, $.z.string()]),
                X = 1e4,
                en = $.z.union([$.z.array($.z.number()), $.z.string()]),
                er = $.z.union([$.z.bigint(), $.z.custom(l => Z.O$.isBigNumber(l)), $.z.custom(l => U().isBN(l))]).transform(l => U().isBN(l) ? new(U())(l).toString() : Z.O$.from(l).toString()),
                ea = $.z.number().max(X, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                eo = $.z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
                el = $.z.union([$.z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), $.z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform(l => l.replace("#", "")), $.z.string().length(0)]),
                ec = $.z.union([$.z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), $.z.number().min(0, "Amount cannot be negative")]).transform(l => "number" == typeof l ? l.toString() : l),
                eu = $.z.union([ec, $.z.literal("unlimited")]).default("unlimited"),
                ed = $.z.object({}).catchall($.z.union([er, $.z.unknown()])),
                ep = $.z.union([$.z.array(ed), ed]).optional().nullable(),
                eh = $.z.object({
                    name: $.z.union([$.z.string(), $.z.number()]).optional().nullable(),
                    description: $.z.string().nullable().optional().nullable(),
                    image: J.nullable().optional(),
                    animation_url: J.optional().nullable()
                }),
                ey = eh.extend({
                    external_url: J.nullable().optional(),
                    background_color: el.optional().nullable(),
                    properties: ep,
                    attributes: ep
                }).catchall($.z.union([er, $.z.unknown()])),
                ef = $.z.union([ey, $.z.string()]),
                em = ey.extend({
                    id: $.z.string(),
                    uri: $.z.string(),
                    image: $.z.string().nullable().optional(),
                    external_url: $.z.string().nullable().optional(),
                    animation_url: $.z.string().nullable().optional()
                }),
                eg = 100
        },
        33693: function(l, c, x) {
            "use strict";
            x.d(c, {
                g: function() {
                    return getCachedAbiForContract
                }
            });
            var N = x(27058),
                U = (x(74578), x(44049)),
                Z = x(42840);

            function getCachedAbiForContract(l) {
                if (l in Z.Z) return Z.Z[l]
            }
            N.ab, U.A, N.a7, U.C, N.a8, U.b, N.a8, U.N
        },
        78438: function(l, c, x) {
            "use strict";
            x.d(c, {
                L: function() {
                    return e_
                },
                T: function() {
                    return ThirdwebSDK
                },
                U: function() {
                    return UserWallet
                },
                c: function() {
                    return checkClientIdOrSecretKey
                }
            });
            var N = x(27058),
                U = x(29822),
                Z = x(30707),
                $ = JSON.parse('[{"inputs":[{"internalType":"address","name":"_pluginMap","type":"address"},{"internalType":"address[]","name":"_trustedForwarders","type":"address[]"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"indexed":true,"internalType":"address","name":"pluginAddress","type":"address"}],"name":"PluginAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"indexed":true,"internalType":"address","name":"pluginAddress","type":"address"}],"name":"PluginRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"indexed":true,"internalType":"string","name":"functionSignature","type":"string"},{"indexed":true,"internalType":"address","name":"pluginAddress","type":"address"}],"name":"PluginSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"indexed":true,"internalType":"address","name":"oldPluginAddress","type":"address"},{"indexed":true,"internalType":"address","name":"newPluginAddress","type":"address"}],"name":"PluginUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"_selector","type":"bytes4"}],"name":"_getPluginForFunction","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"internalType":"string","name":"functionSignature","type":"string"},{"internalType":"address","name":"pluginAddress","type":"address"}],"internalType":"struct IPluginMap.Plugin","name":"_plugin","type":"tuple"}],"name":"addPlugin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_pluginAddress","type":"address"}],"name":"getAllFunctionsOfPlugin","outputs":[{"internalType":"bytes4[]","name":"registered","type":"bytes4[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAllPlugins","outputs":[{"components":[{"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"internalType":"string","name":"functionSignature","type":"string"},{"internalType":"address","name":"pluginAddress","type":"address"}],"internalType":"struct IPluginMap.Plugin[]","name":"registered","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"_selector","type":"bytes4"}],"name":"getPluginForFunction","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"member","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"count","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRoleWithSwitch","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"name":"isTrustedForwarder","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pluginMap","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"_selector","type":"bytes4"}],"name":"removePlugin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"bytes4","name":"functionSelector","type":"bytes4"},{"internalType":"string","name":"functionSignature","type":"string"},{"internalType":"address","name":"pluginAddress","type":"address"}],"internalType":"struct IPluginMap.Plugin","name":"_plugin","type":"tuple"}],"name":"updatePlugin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]'),
                Y = x(98291),
                q = x(77273),
                J = x(28410),
                X = x(92598),
                en = x(57273),
                er = x(55725),
                ea = x(91798),
                eo = x(12060),
                el = x(61678),
                ec = x(18994),
                eu = x(5572),
                ed = x(36339),
                ep = x(94287),
                eh = x(58337),
                ey = x(54497),
                ef = x(11953),
                em = x(22130),
                eg = x(44931),
                eb = x(74939),
                ev = x(42840),
                ew = x(9366),
                eT = x.n(ew),
                eM = x(46762),
                eI = JSON.parse('[{"inputs":[{"internalType":"address","name":"_trustedForwarder","type":"address"},{"internalType":"address","name":"_registry","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"implementation","type":"address"},{"indexed":true,"internalType":"bytes32","name":"contractType","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"version","type":"uint256"}],"name":"ImplementationAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"implementation","type":"address"},{"indexed":false,"internalType":"bool","name":"isApproved","type":"bool"}],"name":"ImplementationApproved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"implementation","type":"address"},{"indexed":false,"internalType":"address","name":"proxy","type":"address"},{"indexed":true,"internalType":"address","name":"deployer","type":"address"}],"name":"ProxyDeployed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"FACTORY_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_implementation","type":"address"}],"name":"addImplementation","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"approval","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_implementation","type":"address"},{"internalType":"bool","name":"_toApprove","type":"bool"}],"name":"approveImplementation","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"currentVersion","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_type","type":"bytes32"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"deployProxy","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_implementation","type":"address"},{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes32","name":"_salt","type":"bytes32"}],"name":"deployProxyByImplementation","outputs":[{"internalType":"address","name":"deployedProxy","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_type","type":"bytes32"},{"internalType":"bytes","name":"_data","type":"bytes"},{"internalType":"bytes32","name":"_salt","type":"bytes32"}],"name":"deployProxyDeterministic","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"deployer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_type","type":"bytes32"},{"internalType":"uint256","name":"_version","type":"uint256"}],"name":"getImplementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_type","type":"bytes32"}],"name":"getLatestImplementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"implementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"name":"isTrustedForwarder","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"registry","outputs":[{"internalType":"contract TWRegistry","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]'),
                ex = JSON.parse('[{"inputs":[{"internalType":"address","name":"_trustedForwarder","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"deployer","type":"address"},{"indexed":true,"internalType":"address","name":"deployment","type":"address"}],"name":"Added","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"deployer","type":"address"},{"indexed":true,"internalType":"address","name":"deployment","type":"address"}],"name":"Deleted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"OPERATOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"},{"internalType":"address","name":"_deployment","type":"address"}],"name":"add","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"}],"name":"count","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"}],"name":"getAll","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"name":"isTrustedForwarder","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"},{"internalType":"address","name":"_deployment","type":"address"}],"name":"remove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]');
            let eC = !1;

            function checkClientIdOrSecretKey(l, c, x) {
                !eC && (eC = !0, c || x || console.warn(l))
            }
            let e_ = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
                eD = {
                    [N.cR.Mainnet]: {
                        "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
                        "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
                        "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
                        "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
                    },
                    [N.cR.Polygon]: {
                        "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
                        "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
                        "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
                        "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
                    },
                    [N.cR.Fantom]: {
                        "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
                        "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
                        "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
                        "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
                    },
                    [N.cR.Avalanche]: {
                        "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
                        "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
                        "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
                        "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
                    },
                    [N.cR.Optimism]: {
                        "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
                        "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
                        "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
                        "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
                    },
                    [N.cR.Arbitrum]: {
                        "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
                        "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
                        "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
                        "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
                    },
                    [N.cR.BinanceSmartChainMainnet]: {
                        "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
                        "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
                        "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
                        "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
                    },
                    [N.cR.Goerli]: {
                        "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
                        "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
                        "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
                        "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
                    },
                    [N.cR.Mumbai]: {
                        "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
                        "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
                        "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
                        "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
                    },
                    [N.cR.FantomTestnet]: {
                        "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
                        "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
                        "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
                        "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
                    },
                    [N.cR.AvalancheFujiTestnet]: {
                        "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
                        "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
                        "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
                        "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
                    },
                    [N.cR.OptimismGoerli]: {
                        "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
                        "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
                        "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
                        "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
                    },
                    [N.cR.ArbitrumGoerli]: {
                        "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
                        "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
                        "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
                        "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
                    },
                    [N.cR.BinanceSmartChainTestnet]: {
                        "nft-drop": "",
                        "edition-drop": "",
                        "token-drop": "",
                        "signature-drop": ""
                    },
                    [N.cR.Hardhat]: {
                        "nft-drop": "",
                        "edition-drop": "",
                        "token-drop": "",
                        "signature-drop": ""
                    },
                    [N.cR.Localhost]: {
                        "nft-drop": "",
                        "edition-drop": "",
                        "token-drop": "",
                        "signature-drop": ""
                    }
                },
                eS = [N.cR.Mainnet, N.cR.Goerli, N.cR.Polygon, N.cR.Mumbai, N.cR.Fantom, N.cR.FantomTestnet, N.cR.Avalanche, N.cR.AvalancheFujiTestnet, N.cR.Optimism, N.cR.OptimismGoerli, N.cR.Arbitrum, N.cR.ArbitrumGoerli, N.cR.BinanceSmartChainMainnet, N.cR.BinanceSmartChainTestnet, N.cR.Hardhat, N.cR.Localhost];

            function getDefaultTrustedForwarders(l) {
                let c = eS.find(c => c === l),
                    x = c ? N.cN[c].biconomyForwarder : N.dr,
                    U = c ? N.cN[c].openzeppelinForwarder : N.dr;
                return [U, x].filter(l => l !== N.dr)
            }

            function extractFunctionParamsFromAbi(l, c) {
                let x = N.e.parse(l || []);
                for (let l of x)
                    if ("function" === l.type && l.name === c) return l.inputs || [];
                return []
            }

            function getAllDetectedExtensionNames(l) {
                return function(l) {
                    let c = [];
                    return (0, N.ds)((0, N.c4)(l), c), c.map(l => l.name)
                }(l)
            }
            async function getEncodedConstructorParamsForThirdwebContract(l, c, x) {
                let U, Z = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                    $ = arguments.length > 4 ? arguments[4] : void 0,
                    Y = arguments.length > 5 ? arguments[5] : void 0,
                    q = arguments.length > 6 ? arguments[6] : void 0,
                    J = (0, N.c$)(c, {
                        clientId: $,
                        secretKey: Y
                    }),
                    X = await (0, N.cG)(N.cF, l, Z, x, $, Y),
                    en = X.metadataUri,
                    er = await (0, N.cH)(en, x),
                    ea = await (0, N.cs)(J);
                (0, em.Z)(ea, "Thirdweb stack not found");
                let {
                    extendedMetadata: eo
                } = await (0, N.cH)(en, x);
                if (eo ? .routerType === "plugin" || eo ? .routerType === "dynamic") {
                    let l = await (0, N.cA)(en, x, J, ea, $, Y);
                    U = l.find(l => "implementation" === l.type) ? .encodedArgs
                } else U = await (0, N.cD)(er.compilerMetadata, J, x, ea, q, $, Y);
                return U
            }
            async function predictThirdwebContractAddress(l, c, x) {
                let U = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                    Z = arguments.length > 4 ? arguments[4] : void 0,
                    $ = arguments.length > 5 ? arguments[5] : void 0,
                    Y = (0, N.c$)(c, {
                        clientId: Z,
                        secretKey: $
                    }),
                    q = await (0, N.cG)(N.cF, l, U, x, Z, $),
                    J = q.metadataUri,
                    X = await (0, N.cs)(Y);
                (0, em.Z)(X, "Thirdweb stack not found");
                let {
                    extendedMetadata: en
                } = await (0, N.cH)(J, x);
                if (en ? .routerType === "plugin" || en ? .routerType === "dynamic") {
                    let l = await (0, N.cA)(J, x, Y, X, Z, $),
                        c = l.find(l => "implementation" === l.type) ? .transaction.predictedAddress;
                    return (0, em.Z)(c, "Error computing address for plugin router"), c
                }
                let er = await (0, N.cC)("implementation", Y, x, X, {
                    contractName: l
                }, Z, $);
                return er.transaction.predictedAddress
            }
            async function getThirdwebContractAddress(l, c, x) {
                let U = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                    Z = arguments.length > 4 ? arguments[4] : void 0,
                    $ = arguments.length > 5 ? arguments[5] : void 0,
                    Y = (0, N.c$)(c, {
                        clientId: Z,
                        secretKey: $
                    }),
                    q = await predictThirdwebContractAddress(l, c, x, U, Z, $),
                    J = await (0, N.cq)(q, Y);
                return (0, em.Z)(J, "Contract not deployed yet"), q
            }
            let ek = {
                    PENDING: "Pending in queue"
                },
                eE = {
                    OK: "1"
                };
            async function verifyThirdwebPrebuiltImplementation(l, c, x, N, U) {
                let Z = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "latest",
                    $ = arguments.length > 6 ? arguments[6] : void 0,
                    Y = arguments.length > 7 ? arguments[7] : void 0,
                    q = arguments.length > 8 ? arguments[8] : void 0,
                    J = await getThirdwebContractAddress(l, c, U, Z, $, Y),
                    X = await getEncodedConstructorParamsForThirdwebContract(l, c, U, Z, $, Y, q);
                console.info(`Verifying ${l} at address ${J}`);
                let en = await verify(J, c, x, N, U, X ? .toString().replace("0x", ""));
                return en
            }
            async function verify(l, c, x, U, Z, $) {
                try {
                    let Y = (0, N.c$)(c, {}),
                        q = await (0, N.bJ)(l, Y, Z),
                        J = q.metadata.compiler.version,
                        X = await (0, N.cj)(q, Z),
                        en = q.metadata.sources,
                        er = {};
                    for (let l of Object.keys(en)) {
                        let c = X.find(c => l === c.filename);
                        if (!c) throw Error(`Could not find source file for ${l}`);
                        er[l] = {
                            content: c.source
                        }
                    }
                    let ea = {
                            language: "Solidity",
                            sources: er,
                            settings: {
                                optimizer: q.metadata.settings.optimizer,
                                evmVersion: q.metadata.settings.evmVersion,
                                remappings: q.metadata.settings.remappings,
                                outputSelection: {
                                    "*": {
                                        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
                                        "": ["ast"]
                                    }
                                }
                            }
                        },
                        eo = q.metadata.settings.compilationTarget,
                        el = Object.keys(eo),
                        ec = el[0],
                        eu = $ || await fetchConstructorParams(x, U, l, q.abi, Y, Z),
                        ed = {
                            apikey: U,
                            module: "contract",
                            action: "verifysourcecode",
                            contractaddress: l,
                            sourceCode: JSON.stringify(ea),
                            codeformat: "solidity-standard-json-input",
                            contractname: `${ec}:${q.name}`,
                            compilerversion: `v${J}`,
                            constructorArguements: eu
                        },
                        ep = new URLSearchParams({ ...ed
                        }),
                        eh = await eT()(x, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/x-www-form-urlencoded"
                            },
                            body: ep.toString()
                        }),
                        ey = await eh.json();
                    if (ey.status === eE.OK) return ey.result;
                    throw Error(`${ey.result}`)
                } catch (l) {
                    throw Error(l.toString())
                }
            }
            async function checkVerificationStatus(l, c, x) {
                let N = `${l}?module=contract&action=checkverifystatus&guid=${x}&apikey=${c}"`;
                return new Promise((l, c) => {
                    let x = setInterval(async () => {
                        try {
                            let c = await eT()(N, {
                                    method: "GET"
                                }),
                                U = await c.json();
                            U ? .result !== ek.PENDING && (clearInterval(x), l(U))
                        } catch (l) {
                            clearInterval(x), c(l)
                        }
                    }, 3e3)
                })
            }
            async function fetchConstructorParams(l, c, x, U, Z, $) {
                let J = (0, N.bV)(U);
                if (0 === J.length) return "";
                let X = new URLSearchParams({
                        apiKey: c,
                        module: "account",
                        action: "txlist",
                        address: x,
                        page: "1",
                        sort: "asc",
                        offset: "1"
                    }),
                    en = await eT()(l, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        },
                        body: X.toString()
                    }),
                    er = await en.json();
                if (!er || er.status !== eE.OK || void 0 === er.result[0]) return ""; {
                    let l = new Y.vU(U),
                        c = er.result[0].input,
                        N = "";
                    if (0 === l.deploy.inputs.length) return "";
                    try {
                        let l = await fetchDeployBytecodeFromPublishedContractMetadata(x, Z, $);
                        if (l) {
                            let x = l.startsWith("0x") ? l : `0x${l}`;
                            N = c.substring(x.length)
                        }
                    } catch (l) {}
                    if (!N) {
                        let l = [...c.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
                        l.length > 0 && (N = l[0][2])
                    }
                    if (!N) {
                        let l = 64 * J.length;
                        N = c.substring(c.length - l)
                    }
                    try {
                        q.$.decode(l.deploy.inputs, `0x${N}`)
                    } catch (l) {
                        throw Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.")
                    }
                    return N
                }
            }
            async function fetchDeployBytecodeFromPublishedContractMetadata(l, c, x) {
                let U = await (0, N.bZ)(l, c);
                if (U) {
                    let l = new J.CH((0, N.cP)(), eM, (0, N.c$)("polygon", {})),
                        c = await l.getPublishedUriFromCompilerUri(U);
                    if (0 === c.length) throw Error(`Could not resolve published metadata URI from ${U}`);
                    let Z = await Promise.all(c.filter(l => l.length > 0).map(l => (0, N.c3)(l, x)));
                    return Z.length > 0 ? await (await x.download(Z[0].bytecodeUri)).text() : void 0
                }
            }
            async function computeCloneFactoryAddress(l, c, x, U, Z) {
                return x || (x = await (0, N.cs)(l)), (await (0, N.cC)("infra", l, c, x, {
                    contractName: "TWCloneFactory"
                }, U, Z)).transaction.predictedAddress
            }
            async function deployCreate2Factory(l, c) {
                (0, em.Z)(l.provider, "No provider");
                let x = await (0, N.cq)(N.cm, l.provider);
                if (x) return N.cm;
                let U = await (0, N.cr)(l.provider),
                    Z = (await l.provider.getNetwork()).chainId,
                    $ = U ? Z : 0;
                console.debug(`ChainId ${Z} enforces EIP155: ${U}`);
                let Y = N.dt[Z] ? (0, N.cE)($, N.dt[Z].gasPrice) : (0, N.cE)($),
                    q = await (0, N.cq)(Y.deployment, l.provider);
                if (!q) {
                    let x = N.dt[Z] ? X.O$.from(N.dt[Z].gasPrice).mul(1e5) : (0, N.bg)("0.01");
                    (await l.provider.getBalance(Y.signer)).lt(x) && await (await l.sendTransaction({
                        to: Y.signer,
                        value: x
                    })).wait();
                    try {
                        console.debug(`deploying CREATE2 factory at: ${Y.deployment}`), c ? .notifier ? .("deploying", "create2Factory"), await (await l.provider.sendTransaction(Y.transaction)).wait(), c ? .notifier ? .("deployed", "create2Factory")
                    } catch (l) {
                        throw Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(l)}`)
                    }
                }
                return Y.deployment
            }

            function convertParamValues(l, c) {
                if (l.length !== c.length) throw Error(`Passed the wrong number of constructor arguments: ${c.length}, expected ${l.length}`);
                return l.map((l, x) => "tuple" === l || l.endsWith("[]") ? "string" == typeof c[x] ? JSON.parse(c[x]) : c[x] : "bytes32" === l ? ((0, em.Z)(en.isHexString(c[x]), `Could not parse bytes32 value. Expected valid hex string but got "${c[x]}".`), en.hexZeroPad(c[x], 32)) : l.startsWith("bytes") ? ((0, em.Z)(en.isHexString(c[x]), `Could not parse bytes value. Expected valid hex string but got "${c[x]}".`), c[x]) : l.startsWith("uint") || l.startsWith("int") ? X.O$.from(c[x].toString()) : c[x])
            }
            async function directDeployDeterministic(l, c, x, U, Z) {
                let $ = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 7e6;
                (0, em.Z)(x.provider, "Provider is required");
                let Y = l.startsWith("0x") ? l : `0x${l}`,
                    J = await deployCreate2Factory(x),
                    en = (0, N.bV)(c),
                    ea = en.map(l => l.type),
                    eo = convertParamValues(ea, U),
                    el = en.map(l => "tuple[]" === l.type ? er._R.from(l) : l.type),
                    ec = q.$.encode(el, eo),
                    eu = (0, N.cv)(Y, ec, J, Z),
                    ed = await (0, N.cq)(eu, x.provider),
                    ep = "";
                if (ed) throw Error(`Contract already deployed at ${eu}`); {
                    console.debug(`deploying contract via create2 factory at: ${eu}`), ep = (0, N.cu)(Y, ec, Z);
                    let l = {
                        to: J,
                        data: ep
                    };
                    try {
                        await x.estimateGas(l)
                    } catch (c) {
                        console.debug("error estimating gas while deploying prebuilt: ", c), l.gasLimit = X.O$.from($)
                    }
                    await (await x.sendTransaction(l)).wait()
                }
                return eu
            }
            async function directDeployDeterministicPublished(l, c) {
                let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                    U = arguments.length > 3 ? arguments[3] : void 0,
                    Z = arguments.length > 4 ? arguments[4] : void 0,
                    $ = arguments.length > 5 ? arguments[5] : void 0,
                    Y = arguments.length > 6 ? arguments[6] : void 0,
                    q = arguments.length > 7 ? arguments[7] : void 0,
                    J = arguments.length > 8 ? arguments[8] : void 0,
                    X = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 7e6,
                    en = (await (0, N.cG)(c, l, x, $, Y, q)).metadataUri,
                    {
                        compilerMetadata: er,
                        extendedMetadata: ea
                    } = await (0, N.cH)(en, $);
                return (0, em.Z)(ea ? .deployType === "standard", "Must be direct deploy"), await directDeployDeterministic(er.bytecode, er.abi, Z, U, J, X)
            }
            async function predictAddressDeterministic(l, c, x, U, Z) {
                let $ = l.startsWith("0x") ? l : `0x${l}`,
                    Y = await (0, N.cs)(x),
                    J = (0, N.bV)(c),
                    X = J.map(l => l.type),
                    en = convertParamValues(X, U),
                    ea = J.map(l => "tuple[]" === l.type ? er._R.from(l) : l.type),
                    eo = q.$.encode(ea, en),
                    el = (0, N.cv)($, eo, Y, Z);
                return el
            }
            async function predictAddressDeterministicPublished(l, c) {
                let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                    U = arguments.length > 3 ? arguments[3] : void 0,
                    Z = arguments.length > 4 ? arguments[4] : void 0,
                    $ = arguments.length > 5 ? arguments[5] : void 0,
                    Y = arguments.length > 6 ? arguments[6] : void 0,
                    q = arguments.length > 7 ? arguments[7] : void 0,
                    J = arguments.length > 8 ? arguments[8] : void 0,
                    X = (await (0, N.cG)(c, l, x, $, Y, q)).metadataUri,
                    {
                        compilerMetadata: en,
                        extendedMetadata: er
                    } = await (0, N.cH)(X, $);
                return (0, em.Z)(er ? .deployType === "standard", "Must be direct deploy"), await predictAddressDeterministic(en.bytecode, en.abi, Z, U, J)
            }
            async function getDeployArguments(l, c, x, U, Z) {
                let $ = await U.getChainId(),
                    Y = await U.getAddress(),
                    q = eS.find(l => l === $),
                    J = [];
                if (q) J = l === N.dd.contractType ? [] : getDefaultTrustedForwarders($);
                else {
                    let l = await (0, N.cx)(U.provider, Z);
                    J = [l]
                }
                switch (c.trusted_forwarders && c.trusted_forwarders.length > 0 && J.push(...c.trusted_forwarders), l) {
                    case N.dc.contractType:
                    case N.db.contractType:
                        let en = await N.dc.schema.deploy.parseAsync(c);
                        return [Y, en.name, en.symbol, x, J, en.primary_sale_recipient, en.fee_recipient, en.seller_fee_basis_points, en.platform_fee_basis_points, en.platform_fee_recipient];
                    case N.de.contractType:
                        let er = await N.de.schema.deploy.parseAsync(c);
                        return [Y, er.name, er.symbol, x, J, er.primary_sale_recipient, er.fee_recipient, er.seller_fee_basis_points, er.platform_fee_basis_points, er.platform_fee_recipient];
                    case N.da.contractType:
                        let ea = await N.da.schema.deploy.parseAsync(c);
                        return [Y, ea.name, ea.symbol, x, J, ea.fee_recipient, ea.seller_fee_basis_points];
                    case N.d6.contractType:
                    case N.d7.contractType:
                        let eo = await N.d6.schema.deploy.parseAsync(c);
                        return [Y, eo.name, eo.symbol, x, J, eo.primary_sale_recipient, eo.fee_recipient, eo.seller_fee_basis_points, eo.platform_fee_basis_points, eo.platform_fee_recipient];
                    case N.dg.contractType:
                    case N.dh.contractType:
                        let el = await N.dh.schema.deploy.parseAsync(c);
                        return [Y, el.name, el.symbol, x, J, el.primary_sale_recipient, el.platform_fee_recipient, el.platform_fee_basis_points];
                    case N.di.contractType:
                        let ec = await N.di.schema.deploy.parseAsync(c);
                        return [ec.name, x, J, ec.voting_token_address, ec.voting_delay_in_blocks, ec.voting_period_in_blocks, X.O$.from(ec.proposal_token_threshold), ec.voting_quorum_fraction];
                    case N.df.contractType:
                        let eu = await N.df.schema.deploy.parseAsync(c);
                        return [Y, x, J, eu.recipients.map(l => l.address), eu.recipients.map(l => X.O$.from(l.sharesBps))];
                    case N.d8.contractType:
                    case N.d9.contractType:
                        let ed = await N.d8.schema.deploy.parseAsync(c);
                        return [Y, x, J, ed.platform_fee_recipient, ed.platform_fee_basis_points];
                    case N.dd.contractType:
                        let ep = await N.dd.schema.deploy.parseAsync(c);
                        return [Y, ep.name, ep.symbol, x, J, ep.fee_recipient, ep.seller_fee_basis_points];
                    default:
                        return []
                }
            }
            let UserWallet = class UserWallet {
                events = new ef.Z;
                constructor(l, c, x) {
                    this.connection = new N.du(l, c), this.options = c, this.events = new ef.Z, this.storage = x
                }
                connect(l) {
                    this.connection.updateSignerOrProvider(l), this.events.emit("signerChanged", this.connection.getSigner())
                }
                async transfer(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : N.cW,
                        [U, Z, $] = await Promise.all([(0, N.cL)(l), (0, N.cL)(x), (0, N.ba)(this.connection.getProvider(), c, x)]),
                        Y = this.requireWallet();
                    if (!(0, N.b8)(Z)) return {
                        receipt: await this.createErc20(Z).sendTransaction("transfer", [U, $])
                    }; {
                        let l = await Y.getAddress(),
                            c = await Y.sendTransaction({
                                from: l,
                                to: U,
                                value: $
                            });
                        return {
                            receipt: await c.wait()
                        }
                    }
                }
                async balance() {
                    let l, c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N.cW;
                    this.requireWallet();
                    let x = await (0, N.cL)(c),
                        U = this.connection.getProvider();
                    return l = (0, N.b8)(x) ? await U.getBalance(await this.getAddress()) : await this.createErc20(x).read("balanceOf", [await this.getAddress()]), await (0, N.bc)(U, x, l)
                }
                async getAddress() {
                    return await this.requireWallet().getAddress()
                }
                async getChainId() {
                    return await this.requireWallet().getChainId()
                }
                async getNonce(l) {
                    let c = await this.connection.getProvider().getTransactionCount(await this.getAddress(), l);
                    return c
                }
                isConnected() {
                    try {
                        return this.requireWallet(), !0
                    } catch (l) {
                        return !1
                    }
                }
                async sign(l) {
                    let c = this.requireWallet();
                    return await c.signMessage(l)
                }
                async signTypedData(l, c, x) {
                    return await (0, N.dv)(this.requireWallet(), l, c, x)
                }
                recoverAddress(l, c) {
                    let x = ea.r(l),
                        N = en.arrayify(x);
                    return eo.recoverAddress(N, c)
                }
                async sendRawTransaction(l) {
                    let c = this.requireWallet(),
                        x = !!l.gasPrice,
                        U = !!l.maxFeePerGas && !!l.maxPriorityFeePerGas;
                    if (!(x || U)) {
                        let c = await (0, N.bL)(this.connection.getProvider());
                        l.maxFeePerGas = c.maxFeePerGas, l.maxPriorityFeePerGas = c.maxPriorityFeePerGas, l.gasPrice = c.gasPrice
                    }
                    return c.sendTransaction(l)
                }
                async executeRawTransaction(l) {
                    let c = await this.sendRawTransaction(l);
                    return {
                        receipt: await c.wait()
                    }
                }
                async requestFunds(l) {
                    let c = await this.getChainId();
                    if (c === N.cR.Localhost || c === N.cR.Hardhat) {
                        let x = new UserWallet(new el.Wallet(e_, (0, N.c$)(c, this.options)), this.options, this.storage);
                        return x.transfer(await this.getAddress(), l)
                    }
                    throw Error(`Requesting funds is not supported on chain: '${c}'.`)
                }
                requireWallet() {
                    let l = this.connection.getSigner();
                    return (0, em.Z)(l, "This action requires a connected wallet. Please pass a valid signer to the SDK."), l
                }
                createErc20(l) {
                    return new N.dw(this.connection.getSignerOrProvider(), l, ey, this.options, this.storage)
                }
            };
            let MultichainRegistry = class MultichainRegistry {
                constructor(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    this.storage = c, this.registryLogic = new N.dw(l, (0, N.cQ)(), Z, x, c), this.registryRouter = new N.dw(l, (0, N.cQ)(), $, x, c)
                }
                async updateSigner(l) {
                    this.registryLogic.updateSignerOrProvider(l), this.registryRouter.updateSignerOrProvider(l)
                }
                async getContractMetadataURI(l, c) {
                    return await this.registryLogic.read("getMetadataUri", [l, await (0, N.cL)(c)])
                }
                async getContractMetadata(l, c) {
                    let x = await this.getContractMetadataURI(l, c);
                    if (!x) throw Error(`No metadata URI found for contract ${c} on chain ${l}`);
                    return await this.storage.downloadJSON(x)
                }
                async getContractAddresses(l) {
                    return (await this.registryLogic.read("getAll", [await (0, N.cL)(l)])).filter(l => ec.isAddress(l.deploymentAddress) && l.deploymentAddress.toLowerCase() !== eu.d).map(l => ({
                        address: l.deploymentAddress,
                        chainId: l.chainId.toNumber()
                    }))
                }
                addContract = (0, N.dx)(async l => await this.addContracts.prepare([l]));
                addContracts = (0, N.dx)(async l => {
                    let c = await this.registryRouter.getSignerAddress(),
                        x = [],
                        U = new N.ag(this.registryLogic);
                    return l.forEach(l => {
                        x.push(U.encode("add", [c, l.address, l.chainId, l.metadataURI || ""]))
                    }), N.aW.fromContractWrapper({
                        contractWrapper: this.registryRouter,
                        method: "multicall",
                        args: [x]
                    })
                });
                removeContract = (0, N.dx)(async l => await this.removeContracts.prepare([l]));
                removeContracts = (0, N.dx)(async l => {
                    let c = await this.registryRouter.getSignerAddress(),
                        x = new N.ag(this.registryLogic),
                        U = await Promise.all(l.map(async l => x.encode("remove", [c, await (0, N.cL)(l.address), l.chainId])));
                    return N.aW.fromContractWrapper({
                        contractWrapper: this.registryRouter,
                        method: "multicall",
                        args: [U]
                    })
                })
            };
            let ContractVerifier = class ContractVerifier extends N.du {
                constructor(l, c, x) {
                    super(l, c), this.storage = x
                }
                updateSignerOrProvider(l) {
                    super.updateSignerOrProvider(l)
                }
                async verifyThirdwebContract(l, c, x) {
                    let N = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                        U = arguments.length > 4 ? arguments[4] : void 0,
                        Z = (await this.getProvider().getNetwork()).chainId,
                        $ = await verifyThirdwebPrebuiltImplementation(l, Z, c, x, this.storage, N, this.options.clientId, this.options.secretKey, U);
                    console.info("Checking verification status...");
                    let Y = await checkVerificationStatus(c, x, $);
                    console.info(Y)
                }
                async verifyContract(l, c, x, N) {
                    let U;
                    let Z = (await this.getProvider().getNetwork()).chainId;
                    if (N) {
                        let l = Object.values(N).map(l => ((0, em.Z)(l.type, "Param type is required"), l.type)),
                            c = Object.values(N).map(l => l.value);
                        U = q.$.encode(l, c)
                    }
                    let $ = await verify(l, Z, c, x, this.storage, U);
                    console.info("Checking verification status...");
                    let Y = await checkVerificationStatus(c, x, $);
                    console.info(Y)
                }
            };
            let ContractFactory = class ContractFactory extends N.dw {
                DEFAULT_VERSION_MAP = {
                    [N.dc.contractType]: 3,
                    [N.db.contractType]: 1,
                    [N.de.contractType]: 4,
                    [N.da.contractType]: 1,
                    [N.d6.contractType]: 2,
                    [N.d7.contractType]: 1,
                    [N.dg.contractType]: 2,
                    [N.dh.contractType]: 1,
                    [N.di.contractType]: 1,
                    [N.df.contractType]: 1,
                    [N.d8.contractType]: 2,
                    [N.d9.contractType]: 1,
                    [N.dd.contractType]: 2
                };
                constructor(l, c, x, N) {
                    super(c, l, eI, N, x), this.storage = x
                }
                deploy = (0, N.dx)(async (l, c, x, U, Z, $) => {
                    let Y = N.dj[l],
                        q = await Y.schema.deploy.parseAsync(c),
                        X = await this.storage.upload(q),
                        en = await this.getImplementation(Y, U) || void 0;
                    if (!en || en === eu.d) throw Error(`No implementation found for ${l}`);
                    let er = await Y.getAbi(en, this.getProvider(), this.storage),
                        ea = this.getSigner();
                    (0, em.Z)(ea, "A signer is required to deploy contracts");
                    let eo = await getDeployArguments(l, q, X, ea, this.storage),
                        el = J.CH.getInterface(er).encodeFunctionData("initialize", eo),
                        ec = await this.getProvider().getBlockNumber(),
                        eh = Z ? .saltForProxyDeploy ? ed.id(Z.saltForProxyDeploy) : ep.s(ec.toString());
                    return N.aW.fromContractWrapper({
                        contractWrapper: this,
                        method: "deployProxyByImplementation",
                        args: [en, el, eh],
                        parse: l => {
                            $ && $();
                            let c = this.parseLogs("ProxyDeployed", l.logs);
                            if (c.length < 1) throw Error("No ProxyDeployed event found");
                            let N = c[0].args.proxy;
                            return x.emit("contractDeployed", {
                                status: "completed",
                                contractAddress: N,
                                transactionHash: l.transactionHash
                            }), N
                        }
                    })
                });
                deployProxyByImplementation = (0, N.dx)(async (l, c, x, U, Z, $, Y) => {
                    let q = J.CH.getInterface(c).encodeFunctionData(x, U),
                        X = await this.getProvider().getBlockNumber(),
                        en = $ ? ed.id($) : ep.s(X.toString());
                    return N.aW.fromContractWrapper({
                        contractWrapper: this,
                        method: "deployProxyByImplementation",
                        args: [l, q, en],
                        parse: l => {
                            Y && Y();
                            let c = this.parseLogs("ProxyDeployed", l.logs);
                            if (c.length < 1) throw Error("No ProxyDeployed event found");
                            let x = c[0].args.proxy;
                            return Z.emit("contractDeployed", {
                                status: "completed",
                                contractAddress: x,
                                transactionHash: l.transactionHash
                            }), x
                        }
                    })
                });
                async getDeployArguments(l, c, x) {
                    let U = l === N.dd.contractType ? [] : await this.getDefaultTrustedForwarders();
                    switch (c.trusted_forwarders && c.trusted_forwarders.length > 0 && (U = c.trusted_forwarders), l) {
                        case N.dc.contractType:
                        case N.db.contractType:
                            let Z = await N.dc.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), Z.name, Z.symbol, x, U, Z.primary_sale_recipient, Z.fee_recipient, Z.seller_fee_basis_points, Z.platform_fee_basis_points, Z.platform_fee_recipient];
                        case N.de.contractType:
                            let $ = await N.de.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), $.name, $.symbol, x, U, $.primary_sale_recipient, $.fee_recipient, $.seller_fee_basis_points, $.platform_fee_basis_points, $.platform_fee_recipient];
                        case N.da.contractType:
                            let Y = await N.da.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), Y.name, Y.symbol, x, U, Y.fee_recipient, Y.seller_fee_basis_points];
                        case N.d6.contractType:
                        case N.d7.contractType:
                            let q = await N.d6.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), q.name, q.symbol, x, U, q.primary_sale_recipient, q.fee_recipient, q.seller_fee_basis_points, q.platform_fee_basis_points, q.platform_fee_recipient];
                        case N.dg.contractType:
                        case N.dh.contractType:
                            let J = await N.dh.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), J.name, J.symbol, x, U, J.primary_sale_recipient, J.platform_fee_recipient, J.platform_fee_basis_points];
                        case N.di.contractType:
                            let en = await N.di.schema.deploy.parseAsync(c);
                            return [en.name, x, U, en.voting_token_address, en.voting_delay_in_blocks, en.voting_period_in_blocks, X.O$.from(en.proposal_token_threshold), en.voting_quorum_fraction];
                        case N.df.contractType:
                            let er = await N.df.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), x, U, er.recipients.map(l => l.address), er.recipients.map(l => X.O$.from(l.sharesBps))];
                        case N.d8.contractType:
                            let ea = await N.d8.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), x, U, ea.platform_fee_recipient, ea.platform_fee_basis_points];
                        case N.d9.contractType:
                            let eo = await N.d9.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), x, U, eo.platform_fee_recipient, eo.platform_fee_basis_points];
                        case N.dd.contractType:
                            let el = await N.dd.schema.deploy.parseAsync(c);
                            return [await this.getSignerAddress(), el.name, el.symbol, x, U, el.fee_recipient, el.seller_fee_basis_points];
                        default:
                            return []
                    }
                }
                async getDefaultTrustedForwarders() {
                    let l = await this.getChainID();
                    return getDefaultTrustedForwarders(l)
                }
                async getImplementation(l, c) {
                    let x = ep.s(l.name),
                        N = await this.getChainID(),
                        U = function(l, c) {
                            if (l in eD) {
                                let x = eD[l];
                                if (c in x) return x[c]
                            }
                            return null
                        }(N, l.contractType);
                    return U && U.length > 0 && void 0 === c ? U : this.read("getImplementation", [x, void 0 !== c ? c : this.DEFAULT_VERSION_MAP[l.contractType]])
                }
                async getLatestVersion(l) {
                    let c = (0, N.dn)(l);
                    if (!c) throw Error(`Invalid contract type ${l}`);
                    let x = ep.s(c);
                    return this.read("currentVersion", [x])
                }
            };
            let ContractRegistry = class ContractRegistry extends N.dw {
                constructor(l, c, x, N) {
                    super(c, l, ex, N, x)
                }
                async getContractAddresses(l) {
                    return (await this.read("getAll", [await (0, N.cL)(l)])).filter(l => ec.isAddress(l) && l.toLowerCase() !== eu.d)
                }
                addContract = (0, N.dx)(async l => await this.addContracts.prepare([l]));
                addContracts = (0, N.dx)(async l => {
                    let c = await this.getSignerAddress(),
                        x = new N.ag(this),
                        U = (await Promise.all(l.map(l => (0, N.cL)(l)))).map(l => x.encode("add", [c, l]));
                    return N.aW.fromContractWrapper({
                        contractWrapper: this,
                        method: "multicall",
                        args: [U]
                    })
                });
                removeContract = (0, N.dx)(async l => await this.removeContracts.prepare([l]));
                removeContracts = (0, N.dx)(async l => {
                    let c = await this.getSignerAddress(),
                        x = new N.ag(this),
                        U = (await Promise.all(l.map(l => (0, N.cL)(l)))).map(l => x.encode("remove", [c, l]));
                    return N.aW.fromContractWrapper({
                        contractWrapper: this,
                        method: "multicall",
                        args: [U]
                    })
                })
            };
            let eN = N.w.merge(N.y).merge(N.I),
                eA = eN.merge(N.G).merge(N.z).merge(N.H),
                ej = N.w.merge(N.I),
                eO = ej.merge(N.H);
            let ThirdwebSDK = class ThirdwebSDK extends N.du {
                static async fromWallet(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        N = arguments.length > 3 ? arguments[3] : void 0,
                        U = await l.getSigner();
                    return ThirdwebSDK.fromSigner(U, c, x, N)
                }
                static fromSigner(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        U = arguments.length > 3 ? arguments[3] : void 0,
                        Z = l;
                    if (c) try {
                        let U = (0, N.c$)(c, x);
                        Z = l.connect(U)
                    } catch {}
                    let $ = new ThirdwebSDK(c || Z, c ? addChainToSupportedChains(c, x) : x, U);
                    return $.updateSignerOrProvider(Z), $
                }
                static fromPrivateKey(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        U = arguments.length > 3 ? arguments[3] : void 0,
                        Z = (0, N.c$)(c, x),
                        $ = new el.Wallet(l, Z);
                    return new ThirdwebSDK($, addChainToSupportedChains(c, x), U)
                }
                contractCache = new Map;
                constructor(l) {
                    var c;
                    let x = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        Z = arguments.length > 2 ? arguments[2] : void 0;
                    checkClientIdOrSecretKey("No API key. Please provide a clientId. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key", x.clientId, x.secretKey), super(l, x = addChainToSupportedChains(l, x)), (0, N.cS)(x ? .supportedChains);
                    let $ = (c = x, Z || new U.EA(c ? .gatewayUrls ? {
                        gatewayUrls: c.gatewayUrls,
                        clientId: c.clientId,
                        secretKey: c.secretKey
                    } : {
                        clientId: c ? .clientId,
                        secretKey: c ? .secretKey
                    }));
                    this.storage = $, this.storageHandler = $, this.wallet = new UserWallet(l, x, $), this.deployer = new ContractDeployer(l, x, $), this.verifier = new ContractVerifier(l, x, $), this.multiChainRegistry = new MultichainRegistry(l, this.storageHandler, this.options), this._publisher = new N.dy(l, this.options, this.storageHandler)
                }
                get auth() {
                    throw Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`)
                }
                async getNFTDrop(l) {
                    return await this.getContract(l, "nft-drop")
                }
                async getSignatureDrop(l) {
                    return await this.getContract(l, "signature-drop")
                }
                async getNFTCollection(l) {
                    return await this.getContract(l, "nft-collection")
                }
                async getEditionDrop(l) {
                    return await this.getContract(l, "edition-drop")
                }
                async getEdition(l) {
                    return await this.getContract(l, "edition")
                }
                async getTokenDrop(l) {
                    return await this.getContract(l, "token-drop")
                }
                async getToken(l) {
                    return await this.getContract(l, "token")
                }
                async getVote(l) {
                    return await this.getContract(l, "vote")
                }
                async getSplit(l) {
                    return await this.getContract(l, "split")
                }
                async getMarketplace(l) {
                    return await this.getContract(l, "marketplace")
                }
                async getMarketplaceV3(l) {
                    return await this.getContract(l, "marketplace-v3")
                }
                async getPack(l) {
                    return await this.getContract(l, "pack")
                }
                async getMultiwrap(l) {
                    return await this.getContract(l, "multiwrap")
                }
                async getContract(l, c) {
                    let x;
                    let U = await (0, N.cL)(l);
                    if (this.contractCache.has(U)) return this.contractCache.get(U);
                    if (U in ev.Z) return await this.getContractFromAbi(U, ev.Z[U]);
                    if (c && "custom" !== c) x = "string" == typeof c && c in N.dj ? await N.dj[c].initialize(this.getSignerOrProvider(), U, this.storage, this.options) : await this.getContractFromAbi(U, c);
                    else try {
                        let l = await this.getPublisher().fetchCompilerMetadataFromAddress(U);
                        x = await this.getContractFromAbi(U, l.abi)
                    } catch (c) {
                        let l = await this.resolveContractType(U);
                        if (l && "custom" !== l) {
                            let c = await N.dj[l].getAbi(U, this.getProvider(), this.storage);
                            x = await this.getContractFromAbi(U, c)
                        } else throw c
                    }
                    return this.contractCache.set(U, x), x
                }
                async getBuiltInContract(l, c) {
                    return await this.getContract(l, c)
                }
                async resolveContractType(l) {
                    try {
                        let c = new J.CH(await (0, N.cL)(l), eb, this.getProvider()),
                            x = eh.ZN(await c.contractType()).replace(/\x00/g, "");
                        return (0, N.dm)(x)
                    } catch (l) {
                        return "custom"
                    }
                }
                async getContractList(l) {
                    let c = await (await this.deployer.getRegistry()) ? .getContractAddresses(await N.cL(l)) || [],
                        x = (await this.getProvider().getNetwork()).chainId;
                    return await Promise.all(c.map(async l => ({
                        address: l,
                        chainId: x,
                        contractType: () => this.resolveContractType(l),
                        metadata: async () => (await this.getContract(l)).metadata.get(),
                        extensions: async () => getAllDetectedExtensionNames((await this.getContract(l)).abi)
                    })))
                }
                async getMultichainContractList(l) {
                    let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : eg.gL9,
                        x = await this.multiChainRegistry.getContractAddresses(l),
                        N = c.reduce((l, c) => (l[c.chainId] = c, l), {}),
                        U = {};
                    return x.map(l => {
                        let {
                            address: x,
                            chainId: Z
                        } = l;
                        if (!N[Z]) return {
                            address: x,
                            chainId: Z,
                            contractType: async () => "custom",
                            metadata: async () => ({
                                name: ""
                            }),
                            extensions: async () => []
                        };
                        try {
                            let l = U[Z];
                            return l || (l = new ThirdwebSDK(Z, { ...this.options,
                                readonlySettings: void 0,
                                supportedChains: c
                            }, this.storage), U[Z] = l), {
                                address: x,
                                chainId: Z,
                                contractType: () => l.resolveContractType(x),
                                metadata: async () => (await l.getContract(x)).metadata.get(),
                                extensions: async () => getAllDetectedExtensionNames((await l.getContract(x)).abi)
                            }
                        } catch (l) {
                            return {
                                address: x,
                                chainId: Z,
                                contractType: async () => "custom",
                                metadata: async () => ({
                                    name: ""
                                }),
                                extensions: async () => []
                            }
                        }
                    })
                }
                updateSignerOrProvider(l) {
                    super.updateSignerOrProvider(l), this.updateContractSignerOrProvider()
                }
                updateContractSignerOrProvider() {
                    for (let [, l] of (this.wallet.connect(this.getSignerOrProvider()), this.deployer.updateSignerOrProvider(this.getSignerOrProvider()), this._publisher.updateSignerOrProvider(this.getSignerOrProvider()), this.multiChainRegistry.updateSigner(this.getSignerOrProvider()), this.verifier.updateSignerOrProvider(this.getSignerOrProvider()), this.contractCache)) l.onNetworkUpdated(this.getSignerOrProvider())
                }
                async getContractFromAbi(l, c) {
                    let x = await (0, N.cL)(l);
                    if (this.contractCache.has(x)) return this.contractCache.get(x);
                    let [, U] = (0, N.d4)(this.getSignerOrProvider(), this.options), Z = "string" == typeof c ? JSON.parse(c) : c, $ = new N.dz(this.getSignerOrProvider(), x, await (0, N.dA)(x, N.e.parse(Z), U, this.options, this.storage), this.storageHandler, this.options, (await U.getNetwork()).chainId);
                    return this.contractCache.set(x, $), $
                }
                async getBalance(l) {
                    return (0, N.bc)(this.getProvider(), N.cW, await this.getProvider().getBalance(await (0, N.cL)(l)))
                }
                getPublisher() {
                    return this._publisher
                }
            };

            function addChainToSupportedChains(l, c) {
                return (0, N.d2)(l) && (c = { ...c,
                    supportedChains: [...c ? .supportedChains || [], l]
                }), c
            }
            let eP = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
            let ContractDeployer = class ContractDeployer extends N.du {
                transactionListener = l => {
                    "submitted" === l.status && this.events.emit("contractDeployed", {
                        status: "submitted",
                        transactionHash: l.transactionHash
                    })
                };
                constructor(l, c, x) {
                    super(l, c), this.storage = x, this.events = new ef.Z, this.getFactory(), this.getRegistry()
                }
                deployNFTCollection = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.db.contractType, l, "latest", c));
                deployNFTDrop = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.dc.contractType, l, "latest", c));
                deployLoyaltyCard = (0, N.dB)(async (l, c) => {
                    let x = await eA.parseAsync(l),
                        N = await this.storage.upload(x),
                        U = (await this.getProvider().getNetwork()).chainId,
                        Z = getDefaultTrustedForwarders(U);
                    l.trusted_forwarders && l.trusted_forwarders.length > 0 && Z.push(...l.trusted_forwarders);
                    let $ = await this.getSigner() ? .getAddress(),
                        Y = [$, x.name, x.symbol, N, Z, x.primary_sale_recipient, x.fee_recipient, x.seller_fee_basis_points, x.platform_fee_basis_points, x.platform_fee_recipient];
                    return await this.deployReleasedContract.prepare(eP, "LoyaltyCard", Y, c)
                });
                deployOpenEdition = (0, N.dB)(async (l, c) => {
                    let x = await N.dD.deploy.parseAsync(l),
                        U = await this.storage.upload(x),
                        Z = (await this.getProvider().getNetwork()).chainId,
                        $ = getDefaultTrustedForwarders(Z);
                    l.trusted_forwarders && l.trusted_forwarders.length > 0 && $.push(...l.trusted_forwarders);
                    let Y = await this.getSigner() ? .getAddress(),
                        q = [Y, x.name, x.symbol, U, $, x.primary_sale_recipient, x.fee_recipient, x.seller_fee_basis_points];
                    return await this.deployPublishedContract.prepare(eP, "OpenEditionERC721", q, c)
                });
                deploySignatureDrop = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.de.contractType, l, "latest", c));
                deployMultiwrap = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.da.contractType, l, "latest", c));
                deployEdition = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.d7.contractType, l, "latest", c));
                deployEditionDrop = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.d6.contractType, l, "latest", c));
                deployToken = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.dh.contractType, l, "latest", c));
                deployTokenDrop = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.dg.contractType, l, "latest", c));
                deployMarketplace = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.d8.contractType, l, "latest", c));
                deployMarketplaceV3 = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.d9.contractType, l, "latest", c));
                deployPack = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.dd.contractType, l, "latest", c));
                deploySplit = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.df.contractType, l, "latest", c));
                deployVote = (0, N.dB)(async (l, c) => await this.deployBuiltInContract.prepare(N.di.contractType, l, "latest", c));
                deployAirdropERC20 = (0, N.dB)(async (l, c) => {
                    let x = await eO.parseAsync(l),
                        N = await this.storage.upload(x),
                        U = (await this.getProvider().getNetwork()).chainId,
                        Z = getDefaultTrustedForwarders(U);
                    l.trusted_forwarders && l.trusted_forwarders.length > 0 && Z.push(...l.trusted_forwarders);
                    let $ = await this.getSigner() ? .getAddress(),
                        Y = [$, N, Z];
                    return await this.deployReleasedContract.prepare(eP, "AirdropERC20", Y, c)
                });
                deployAirdropERC721 = (0, N.dB)(async (l, c) => {
                    let x = await eO.parseAsync(l),
                        N = await this.storage.upload(x),
                        U = (await this.getProvider().getNetwork()).chainId,
                        Z = getDefaultTrustedForwarders(U);
                    l.trusted_forwarders && l.trusted_forwarders.length > 0 && Z.push(...l.trusted_forwarders);
                    let $ = await this.getSigner() ? .getAddress(),
                        Y = [$, N, Z];
                    return await this.deployReleasedContract.prepare(eP, "AirdropERC721", Y, c)
                });
                deployAirdropERC1155 = (0, N.dB)(async (l, c) => {
                    let x = await eO.parseAsync(l),
                        N = await this.storage.upload(x),
                        U = (await this.getProvider().getNetwork()).chainId,
                        Z = getDefaultTrustedForwarders(U);
                    l.trusted_forwarders && l.trusted_forwarders.length > 0 && Z.push(...l.trusted_forwarders);
                    let $ = await this.getSigner() ? .getAddress(),
                        Y = [$, N, Z];
                    return await this.deployReleasedContract.prepare(eP, "AirdropERC1155", Y, c)
                });
                deployBuiltInContract = (0, N.dB)((() => {
                    var l = this;
                    return async function(c, x) {
                        let U = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                            Z = arguments.length > 3 ? arguments[3] : void 0,
                            $ = l.getSigner();
                        (0, em.Z)($, "A signer is required to deploy contracts");
                        let Y = {
                            app_uri: N.dk[c],
                            ...await N.dj[c].schema.deploy.parseAsync(x)
                        };
                        if (l.hasLocalFactory()) {
                            let x;
                            try {
                                x = parseInt(U), isNaN(x) && (x = void 0)
                            } catch (l) {
                                x = void 0
                            }
                            let $ = await l.getFactory();
                            if (!$) throw Error("Factory not found");
                            return $.on(N.c_.Transaction, l.transactionListener), $.deploy.prepare(c, Y, l.events, x, Z, () => {
                                $.off(N.c_.Transaction, l.transactionListener)
                            })
                        }
                        let q = (0, N.dn)(c);
                        (0, em.Z)(q, "Contract name not found");
                        let J = await l.storage.upload(Y),
                            X = await getDeployArguments(c, Y, J, $, l.storage),
                            en = await l.fetchPublishedContractFromPolygon(eP, q, U);
                        return l.deployContractFromUri.prepare(en.metadataUri, X, Z)
                    }
                })());
                async getLatestBuiltInContractVersion(l) {
                    let c = await this.getFactory();
                    if (!c) throw Error("Factory not found");
                    return await c.getLatestVersion(l)
                }
                deployReleasedContract = (0, N.dB)((() => {
                    var l = this;
                    return async function(c, x, N) {
                        let U = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                            Z = arguments.length > 4 ? arguments[4] : void 0,
                            $ = await l.fetchPublishedContractFromPolygon(c, x, U);
                        return await l.deployContractFromUri.prepare($.metadataUri, N, Z)
                    }
                })());
                deployPublishedContract = this.deployReleasedContract;
                async deployPublishedContractDeterministic(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : eP,
                        N = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                        U = arguments.length > 4 ? arguments[4] : void 0,
                        Z = this.getSigner();
                    return (0, em.Z)(Z, "Signer is required"), directDeployDeterministicPublished(l, x, N, c, Z, this.storage, this.options.clientId, this.options.secretKey, U)
                }
                async predictAddressDeterministic(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : eP,
                        N = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "latest",
                        U = arguments.length > 4 ? arguments[4] : void 0,
                        Z = this.getProvider();
                    return (0, em.Z)(Z, "Provider is required"), predictAddressDeterministicPublished(l, x, N, c, Z, this.storage, this.options.clientId, this.options.secretKey, U)
                }
                deployViaFactory = (0, N.dx)(async (l, c, x, U, Z, $) => {
                    let Y = await (0, N.cL)(l),
                        q = await (0, N.cL)(c),
                        J = this.getSigner();
                    (0, em.Z)(J, "signer is required");
                    let X = new ContractFactory(Y, this.getSignerOrProvider(), this.storage, this.options);
                    return X.on(N.c_.Transaction, this.transactionListener), await X.deployProxyByImplementation.prepare(q, x, U, Z, this.events, $, () => {
                        X.off(N.c_.Transaction, this.transactionListener)
                    })
                });
                deployProxy = (0, N.dB)(async (l, c, U, Z) => {
                    let $ = await (0, N.cL)(l),
                        Y = J.CH.getInterface(c).encodeFunctionData(U, Z),
                        {
                            TWProxy__factory: q
                        } = await x.e(2427).then(x.bind(x, 82427));
                    return this.deployContractWithAbi.prepare(q.abi, q.bytecode, [$, Y])
                });
                deployViaAutoFactory = (0, N.dB)(async (l, c, x, U, Z, $) => {
                    let Y = await deployCreate2Factory(x, $),
                        q = await (0, N.cA)(l, this.storage, this.getProvider(), Y, this.options.clientId, this.options.secretKey),
                        J = q.find(l => "implementation" === l.type) ? .transaction.predictedAddress,
                        X = q.filter(l => l.transaction.data && l.transaction.data.length > 0),
                        en = X.filter(l => "infra" !== l.type).map(l => l.transaction),
                        er = X.filter(l => "infra" === l.type).map(l => l.transaction);
                    for (let l of (await (0, N.cB)(x, er, $), en)) try {
                        await (0, N.cz)(x, l, $)
                    } catch (c) {
                        console.debug(`Error deploying contract at ${l.predictedAddress}`, c ? .message)
                    }
                    let ea = await (0, N.cL)(J),
                        eo = await computeCloneFactoryAddress(this.getProvider(), this.storage, Y, this.options.clientId, this.options.secretKey);
                    $ ? .notifier ? .("deploying", "proxy");
                    let el = await this.deployViaFactory.prepare(eo, ea, c.compilerMetadata.abi, U, Z, $ ? .saltForProxyDeploy);
                    return $ ? .notifier ? .("deployed", "proxy"), el
                });
                deployViaCustomFactory = (0, N.dB)(async (l, c, x, U) => {
                    let Z;
                    let $ = c.extendedMetadata ? .factoryDeploymentData ? .customFactoryInput ? .customFactoryAddresses[U],
                        Y = await (0, N.cL)($);
                    (0, em.Z)(Y, `customFactoryAddress not found for chainId '${U}'`), (0, em.Z)(c.extendedMetadata ? .factoryDeploymentData ? .customFactoryInput ? .factoryFunction, "customFactoryFunction not set'");
                    let q = await (0, N.bJ)(Y, this.getProvider(), this.storage, this.options),
                        J = extractFunctionParamsFromAbi(q.abi, c.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map(l => l.type),
                        X = convertParamValues(J, l),
                        en = await N.aW.fromContractInfo({
                            contractAddress: Y,
                            contractAbi: q.abi,
                            provider: this.getProvider(),
                            signer: x,
                            method: c.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,
                            args: X,
                            parse: () => Z,
                            storage: this.storage
                        });
                    return Z = await en.simulate(), en
                });
                async getRegistry() {
                    return this._registry ? this._registry : this._registry = this.getProvider().getNetwork().then(async l => {
                        let {
                            chainId: c
                        } = l, x = (0, N.cO)(c, "twRegistry");
                        if (x) return new ContractRegistry(x, this.getSignerOrProvider(), this.storage, this.options)
                    })
                }
                async getFactory() {
                    return this._factory ? this._factory : this._factory = this.getProvider().getNetwork().then(async l => {
                        let {
                            chainId: c
                        } = l, x = (0, N.cO)(c, "twFactory");
                        if (!x) return;
                        let U = new ContractFactory(x, this.getSignerOrProvider(), this.storage, this.options);
                        return U
                    })
                }
                updateSignerOrProvider(l) {
                    super.updateSignerOrProvider(l), this.updateContractSignerOrProvider()
                }
                updateContractSignerOrProvider() {
                    this._factory ? .then(l => {
                        l ? .updateSignerOrProvider(this.getSignerOrProvider())
                    }).catch(() => {}), this._registry ? .then(l => {
                        l ? .updateSignerOrProvider(this.getSignerOrProvider())
                    }).catch(() => {})
                }
                deployContractFromUri = (0, N.dB)(async (l, c, x) => {
                    let U = this.getSigner();
                    (0, em.Z)(U, "A signer is required");
                    let {
                        compilerMetadata: Z,
                        extendedMetadata: $
                    } = await (0, N.cH)(l, this.storage), Y = x ? .forceDirectDeploy || !1, q = (await this.getProvider().getNetwork()).chainId, J = $ ? .networksForDeployment ? .networksEnabled.includes(q) || $ ? .networksForDeployment ? .allNetworks;
                    if ($ ? .networksForDeployment && !J) throw Error(`Deployments disabled on this network, with chainId: ${q}`);
                    if ($ && $.factoryDeploymentData && ($.isDeployableViaProxy || $.isDeployableViaFactory || $.deployType && "standard" !== $.deployType) && !Y) {
                        if ("customFactory" === $.deployType) return await this.deployViaCustomFactory.prepare(c, {
                            compilerMetadata: Z,
                            extendedMetadata: $
                        }, U, q); {
                            (0, em.Z)($.factoryDeploymentData.implementationInitializerFunction, "implementationInitializerFunction not set'");
                            let Y = extractFunctionParamsFromAbi(Z.abi, $.factoryDeploymentData.implementationInitializerFunction).map(l => l.type),
                                J = convertParamValues(Y, c),
                                X = $.factoryDeploymentData.implementationAddresses[q];
                            if (!X || "autoFactory" === $.deployType) return await this.deployViaAutoFactory.prepare(l, {
                                compilerMetadata: Z,
                                extendedMetadata: $
                            }, U, $.factoryDeploymentData.implementationInitializerFunction, J, x);
                            let en = await (0, N.cL)(X);
                            if ((0, em.Z)(en, `implementationAddress not found for chainId '${q}'`), $.isDeployableViaFactory) {
                                (0, em.Z)($.factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
                                let l = $.factoryDeploymentData.factoryAddresses[q];
                                (0, em.Z)(l, `isDeployableViaFactory is true and factoryAddress not found for chainId '${q}'`);
                                let c = await (0, N.cL)(l);
                                return await this.deployViaFactory.prepare(c, en, Z.abi, $.factoryDeploymentData.implementationInitializerFunction, J, x ? .saltForProxyDeploy)
                            }
                            if ($.isDeployableViaProxy) return await this.deployProxy.prepare(en, Z.abi, $.factoryDeploymentData.implementationInitializerFunction, J)
                        }
                    }
                    let X = Z.bytecode.startsWith("0x") ? Z.bytecode : `0x${Z.bytecode}`;
                    if (!en.isHexString(X)) throw Error(`Contract bytecode is invalid.

${X}`);
                    let er = (0, N.bV)(Z.abi).map(l => l.type),
                        ea = convertParamValues(er, c);
                    return this.deployContractWithAbi.prepare(Z.abi, X, ea)
                });
                deployContractWithAbi = (0, N.dB)(async (l, c, x) => {
                    let U = this.getSigner(),
                        Z = this.getProvider();
                    (0, em.Z)(U, "Signer is required to deploy contracts");
                    let $ = new J.lV(l, c).connect(U);
                    return new N.aX({
                        args: x,
                        provider: Z,
                        signer: U,
                        factory: $,
                        storage: this.storage,
                        events: this.events
                    })
                });
                async getTransactionsForDeploy(l, c) {
                    let x = [],
                        U = this.getProvider();
                    (0, em.Z)(U, "A provider is required");
                    let {
                        extendedMetadata: Z
                    } = await (0, N.cH)(l, this.storage), $ = c ? .forceDirectDeploy || !1;
                    if (Z && Z.factoryDeploymentData && (Z.isDeployableViaProxy || Z.isDeployableViaFactory || "autoFactory" === Z.deployType) && !$) {
                        let c = (await this.getProvider().getNetwork()).chainId,
                            $ = Z.factoryDeploymentData.implementationAddresses[c];
                        if (!$ || "autoFactory" === Z.deployType) {
                            let c = await (0, N.cs)(this.getProvider());
                            x.push({
                                contractType: "create2Factory",
                                addresses: [c]
                            });
                            let U = await (0, N.cA)(l, this.storage, this.getProvider(), c, this.options.clientId, this.options.secretKey),
                                Z = U.filter(l => l.transaction.data && l.transaction.data.length > 0),
                                $ = Z.filter(l => "infra" !== l.type).map(l => l.transaction);
                            $.forEach(l => {
                                x.push({
                                    contractType: "preset",
                                    addresses: [l.predictedAddress]
                                })
                            });
                            let Y = Z.filter(l => "infra" === l.type).map(l => l.transaction),
                                q = (0, N.cJ)(Y);
                            q.forEach(l => {
                                let c = l.map(l => l.predictedAddress);
                                x.push({
                                    contractType: "infra",
                                    addresses: c
                                })
                            })
                        }(x = (await Promise.all(x.map(async l => {
                            let c = (await Promise.all(l.addresses.map(async l => {
                                let c = await (0, N.cq)(l, U);
                                return c ? null : l
                            }))).filter(Boolean);
                            return c.length > 0 ? l : null
                        }))).filter(Boolean)).push({
                            contractType: "proxy",
                            addresses: []
                        })
                    } else x.push({
                        contractType: "custom",
                        addresses: []
                    });
                    return x
                }
                addDeployListener(l) {
                    this.events.on("contractDeployed", l)
                }
                removeDeployListener(l) {
                    this.events.off("contractDeployed", l)
                }
                removeAllDeployListeners() {
                    this.events.removeAllListeners("contractDeployed")
                }
                async fetchPublishedContractFromPolygon(l, c, x) {
                    let U = await (0, N.cL)(l),
                        Z = await new ThirdwebSDK("polygon", {
                            clientId: this.options.clientId,
                            secretKey: this.options.secretKey
                        }, this.storage).getPublisher().getVersion(U, c, x);
                    if (!Z) throw Error(`No published contract found for '${c}' at version '${x}' by '${U}'`);
                    return Z
                }
                hasLocalFactory() {
                    return !!(0, N.dC)("factoryAddress")
                }
            }
        },
        63112: function(l, c, x) {
            "use strict";
            x.d(c, {
                rV4: function() {
                    return N.c$
                },
                x9T: function() {
                    return U.T
                }
            });
            var N = x(27058),
                U = x(78438);
            x(56662), x(53010), x(41650), x(68870), x(9366), x(11953), globalThis.global = globalThis
        },
        9581: function(l, c, x) {
            "use strict";
            x(56662), x(53010), x(41650), x(68870), x(9366), x(11953)
        },
        29822: function(l, c, x) {
            "use strict";
            x.d(c, {
                EA: function() {
                    return ThirdwebStorage
                },
                XT: function() {
                    return isFileOrBuffer
                },
                jU: function() {
                    return isBrowser
                },
                ov: function() {
                    return replaceGatewayUrlWithScheme
                }
            });
            var N = x(48523),
                U = x(9366),
                Z = x.n(U),
                $ = x(65053),
                Y = x.n($),
                q = x(25566),
                J = x(67133).Buffer;
            let X = ".ipfscdn.io",
                en = [`https://{clientId}${X}/ipfs/{cid}/{path}`];

            function isTwGatewayUrl(l) {
                let c = new URL(l).hostname,
                    x = c.endsWith(X);
                return !!x || c.endsWith(".thirdwebstorage-staging.com")
            }
            let er = {
                    "ipfs://": [...en, "https://{cid}.ipfs.cf-ipfs.com/{path}", "https://{cid}.ipfs.dweb.link/{path}", "https://ipfs.io/ipfs/{cid}/{path}", "https://cloudflare-ipfs.com/ipfs/{cid}/{path}", "https://{cid}.ipfs.w3s.link/{path}", "https://w3s.link/ipfs/{cid}/{path}", "https://nftstorage.link/ipfs/{cid}/{path}", "https://gateway.pinata.cloud/ipfs/{cid}/{path}"]
                },
                ea = function(l) {
                    let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                    return void 0 !== q && q.env[l] ? q.env[l] : c
                }("CUSTOM_UPLOAD_SERVER_URL", "https://storage.thirdweb.com");

            function isBrowser() {
                return !0
            }

            function isFileInstance(l) {
                return x.g.File && l instanceof File
            }

            function isBufferInstance(l) {
                return x.g.Buffer && l instanceof J
            }

            function isBufferOrStringWithName(l) {
                return !!(l && l.name && l.data && "string" == typeof l.name && ("string" == typeof l.data || isBufferInstance(l.data)))
            }

            function isFileOrBuffer(l) {
                return isFileInstance(l) || isBufferInstance(l) || isBufferOrStringWithName(l)
            }

            function replaceGatewayUrlWithScheme(l, c) {
                for (let x of Object.keys(c))
                    for (let N of c[x]) {
                        if (N.includes("{cid}")) {
                            let c = function(l, c) {
                                let x = l.replace("{cid}", "(?<hash>[^/]+)").replace("{path}", "(?<path>[^?#]+)"),
                                    N = new RegExp(x),
                                    U = c.match(N);
                                if (U) {
                                    let l = U.groups ? .hash,
                                        x = U.groups ? .path,
                                        N = c.includes("?") ? c.substring(c.indexOf("?") + 1) : "";
                                    return {
                                        hash: l,
                                        path: x,
                                        query: N
                                    }
                                }
                            }(N, l);
                            if (!(c ? .hash && c ? .path)) return l; {
                                let l = c ? .query ? `?${c?.query}` : "";
                                return `${x}${c?.hash}/${c?.path}${l}`
                            }
                        }
                        if (l.startsWith(N)) return l.replace(N, x)
                    }
                return l
            }

            function replaceSchemeWithGatewayUrl(l, c) {
                let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    U = arguments.length > 3 ? arguments[3] : void 0,
                    Z = Object.keys(c).find(c => l.startsWith(c)),
                    $ = Z ? c[Z] : [];
                if (!Z && x > 0 || Z && x >= $.length) return;
                if (!Z) return l;
                let Y = l.replace(Z, "");
                return function(l, c, x) {
                    let U = c.split("/"),
                        Z = function(l) {
                            let c;
                            try {
                                let x = l.split("/")[0];
                                c = N.base32(x)
                            } catch (c) {
                                throw Error(`The CID ${l} is not valid.`)
                            }
                            return c
                        }(U[0]),
                        $ = U.slice(1).join("/"),
                        Y = l;
                    if (l.includes("{cid}") && l.includes("{path}") ? Y = Y.replace("{cid}", Z).replace("{path}", $) : l.includes("{cid}") ? Y = Y.replace("{cid}", Z) : Y += `${Z}/${$}`, l.includes("{clientId}")) {
                        if (!x) throw Error("Cannot use {clientId} in gateway URL without providing a client ID");
                        Y = Y.replace("{clientId}", x)
                    }
                    return Y
                }($[x], Y, U)
            }

            function replaceObjectSchemesWithGatewayUrls(l, c, x) {
                return "string" == typeof l ? replaceSchemeWithGatewayUrl(l, c, 0, x) : "object" == typeof l ? !l || isFileOrBuffer(l) ? l : Array.isArray(l) ? l.map(l => replaceObjectSchemesWithGatewayUrls(l, c, x)) : Object.fromEntries(Object.entries(l).map(l => {
                    let [N, U] = l;
                    return [N, replaceObjectSchemesWithGatewayUrls(U, c, x)]
                })) : l
            }
            var eo = {
                name: "@thirdweb-dev/storage",
                version: "1.2.11"
            };
            let StorageDownloader = class StorageDownloader {
                DEFAULT_TIMEOUT_IN_SECONDS = 60;
                DEFAULT_MAX_RETRIES = 3;
                constructor(l) {
                    this.secretKey = l.secretKey, this.clientId = l.clientId, this.defaultTimeout = l.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS
                }
                async download(l, c, x) {
                    var N;
                    let $ = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                        Y = x ? .maxRetries || this.DEFAULT_MAX_RETRIES;
                    if ($ > Y) return console.error("[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed."), new U.Response(JSON.stringify({
                        error: "Not Found"
                    }), {
                        status: 404,
                        headers: {
                            "Content-Type": "application/json"
                        }
                    });
                    let q = replaceSchemeWithGatewayUrl(l, c, $, this.clientId);
                    if (!q) return console.error("[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond."), new U.Response(JSON.stringify({
                        error: "Not Found"
                    }), {
                        status: 404,
                        headers: {
                            "Content-Type": "application/json"
                        }
                    });
                    $ > 0 && console.warn(`Retrying download with backup gateway URL: ${q}`);
                    let J = {};
                    if (isTwGatewayUrl(q)) {
                        let l = "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
                        this.secretKey ? J = {
                            "x-secret-key": this.secretKey
                        } : this.clientId && (q.includes("bundleId") || (q += l ? `?bundleId=${l}` : ""), J["x-client-Id"] = this.clientId), "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && (J = { ...J,
                            authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`
                        }), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && ((J = { ...J,
                            authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`
                        })["x-authorize-wallet"] = "true"), J["x-sdk-version"] = eo.version, J["x-sdk-name"] = eo.name, J["x-sdk-platform"] = l ? "react-native" : void 0 !== window.bridge ? "webGL" : "browser"
                    }
                    if (N = q, el.has(N)) return this.download(l, c, x, $ + 1);
                    let X = new AbortController,
                        en = x ? .timeoutInSeconds || this.defaultTimeout,
                        er = setTimeout(() => X.abort(), 1e3 * en),
                        ea = await Z()(q, {
                            headers: J,
                            signal: X.signal
                        }).catch(l => l);
                    if (er && clearTimeout(er), !("status" in ea)) throw Error(`Request timed out after ${en} seconds. ${isTwGatewayUrl(q)?"You can update the timeoutInSeconds option to increase the timeout.":"You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway."}`);
                    return ea.ok ? ea : 429 === ea.status ? (function(l, c) {
                        ec.has(l) && clearTimeout(ec.get(l));
                        let x = c.headers.get("Retry-After"),
                            N = 5e3;
                        if (x) {
                            let l = parseInt(x);
                            isNaN(l) || (N = 1e3 * l)
                        }
                        el.set(l, !0), ec.set(l, setTimeout(() => el.delete(l), N))
                    }(q, ea), this.download(l, c, x, $ + 1)) : 410 === ea.status ? (console.error(`Request to ${q} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${q} `), ea) : (console.warn(`Request to ${q} failed with status ${ea.status} - ${ea.statusText}`), 404 === ea.status && isTwGatewayUrl(q) || 408 !== ea.status && 429 !== ea.status && ea.status < 500) ? ea : this.download(l, c, x, $ + 1)
                }
            };
            let el = new Map,
                ec = new Map;
            let IpfsUploader = class IpfsUploader {
                constructor(l) {
                    this.uploadWithGatewayUrl = l ? .uploadWithGatewayUrl || !1, this.uploadServerUrl = l ? .uploadServerUrl || ea, this.clientId = l ? .clientId, this.secretKey = l ? .secretKey
                }
                async uploadBatch(l, c) {
                    if (c ? .uploadWithoutDirectory && l.length > 1) throw Error("[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!");
                    let x = new(Y()),
                        {
                            form: N,
                            fileNames: U
                        } = this.buildFormData(x, l, c);
                    return this.uploadBatchBrowser(N, U, c)
                }
                buildFormData(l, c, x) {
                    let N = new Map,
                        U = [];
                    for (let Z = 0; Z < c.length; Z++) {
                        let $ = c[Z],
                            Y = "",
                            q = $;
                        if (isFileInstance($)) {
                            if (x ? .rewriteFileNames) {
                                let l = "";
                                if ($.name) {
                                    let c = $.name.lastIndexOf(".");
                                    c > -1 && (l = $.name.substring(c))
                                }
                                Y = `${Z+x.rewriteFileNames.fileStartNumber}${l}`
                            } else Y = `${$.name}`
                        } else isBufferOrStringWithName($) ? (q = $.data, Y = x ? .rewriteFileNames ? `${Z+x.rewriteFileNames.fileStartNumber}` : `${$.name}`) : Y = x ? .rewriteFileNames ? `${Z+x.rewriteFileNames.fileStartNumber}` : `${Z}`;
                        let J = x ? .uploadWithoutDirectory ? "files" : `files/${Y}`;
                        if (N.has(Y)) {
                            if (function(l, c) {
                                    if (isFileInstance(l) && isFileInstance(c)) {
                                        if (l.name === c.name && l.lastModified === c.lastModified && l.size === c.size) return !0
                                    } else if (isBufferInstance(l) && isBufferInstance(c)) return l.equals(c);
                                    else if (isBufferOrStringWithName(l) && isBufferOrStringWithName(c) && l.name === c.name) {
                                        if ("string" == typeof l.data && "string" == typeof c.data) return l.data === c.data;
                                        if (isBufferInstance(l.data) && isBufferInstance(c.data)) return l.data.equals(c.data)
                                    }
                                    return !1
                                }(N.get(Y), $)) {
                                U.push(Y);
                                continue
                            }
                            throw Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${Y} was passed for more than one different file.`)
                        }
                        N.set(Y, $), U.push(Y), l.append("file", new Blob([q]), J)
                    }
                    let Z = {
                        name: "Storage SDK",
                        keyvalues: { ...x ? .metadata
                        }
                    };
                    return l.append("pinataMetadata", JSON.stringify(Z)), x ? .uploadWithoutDirectory && l.append("pinataOptions", JSON.stringify({
                        wrapWithDirectory: !1
                    })), {
                        form: l,
                        fileNames: U.map(l => encodeURIComponent(l))
                    }
                }
                async uploadBatchBrowser(l, c, x) {
                    return new Promise((N, U) => {
                        let Z = new XMLHttpRequest,
                            $ = setTimeout(() => {
                                Z.abort(), U(Error("Request to upload timed out! No upload progress received in 30s"))
                            }, 3e4);
                        Z.upload.addEventListener("loadstart", () => {
                            console.log(`[${Date.now()}] [IPFS] Started`)
                        }), Z.upload.addEventListener("progress", l => {
                            console.log(`[IPFS] Progress Event ${l.loaded}/${l.total}`), clearTimeout($), l.loaded < l.total ? $ = setTimeout(() => {
                                Z.abort(), U(Error("Request to upload timed out! No upload progress received in 30s"))
                            }, 3e4) : console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`), l.lengthComputable && x ? .onProgress && x ? .onProgress({
                                progress: l.loaded,
                                total: l.total
                            })
                        }), Z.addEventListener("load", () => {
                            if (console.log(`[${Date.now()}] [IPFS] Load`), clearTimeout($), Z.status >= 200 && Z.status < 300) {
                                let l;
                                try {
                                    l = JSON.parse(Z.responseText)
                                } catch (l) {
                                    return U(Error("Failed to parse JSON from upload response"))
                                }
                                let $ = l.IpfsHash;
                                if (!$) throw Error("Failed to get IPFS hash from upload response");
                                return x ? .uploadWithoutDirectory ? N([`ipfs://${$}`]) : N(c.map(l => `ipfs://${$}/${l}`))
                            }
                            return U(Error(`Upload failed with status ${Z.status} - ${Z.responseText}`))
                        }), Z.addEventListener("error", () => (console.log("[IPFS] Load"), clearTimeout($), 0 !== Z.readyState && 4 !== Z.readyState || 0 === Z.status) ? U(Error("Upload failed due to a network error.")) : U(Error("Unknown upload error occured"))), Z.open("POST", `${this.uploadServerUrl}/ipfs/upload`), this.secretKey ? Z.setRequestHeader("x-secret-key", this.secretKey) : this.clientId && Z.setRequestHeader("x-client-id", this.clientId);
                        let Y = "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
                        Y && Z.setRequestHeader("x-bundle-id", Y), Z.setRequestHeader("x-sdk-version", eo.version), Z.setRequestHeader("x-sdk-name", eo.name), Z.setRequestHeader("x-sdk-platform", Y ? "react-native" : void 0 !== window.bridge ? "webGL" : "browser"), "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && Z.setRequestHeader("authorization", `Bearer ${globalThis.TW_AUTH_TOKEN}`), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && (Z.setRequestHeader("authorization", `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`), Z.setRequestHeader("x-authorize-wallet", "true")), Z.send(l)
                    })
                }
                async uploadBatchNode(l, c, x) {
                    x ? .onProgress && console.warn("The onProgress option is only supported in the browser");
                    let N = {};
                    this.secretKey ? N["x-secret-key"] = this.secretKey : this.clientId && (N["x-client-id"] = this.clientId), "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis && (N["x-bundle-id"] = globalThis.APP_BUNDLE_ID), "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && (N.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && (N.authorization = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`, N["x-authorize-wallet"] = "true");
                    let U = await Z()(`${this.uploadServerUrl}/ipfs/upload`, {
                        method: "POST",
                        headers: { ...N,
                            ...l.getHeaders()
                        },
                        body: l.getBuffer()
                    });
                    if (!U.ok) {
                        if (401 === U.status) throw Error("Unauthorized - You don't have permission to use this service.");
                        throw Error(`Failed to upload files to IPFS - ${U.status} - ${U.statusText} - ${await U.text()}`)
                    }
                    let $ = await U.json(),
                        Y = $.IpfsHash;
                    if (!Y) throw Error("Failed to upload files to IPFS - Bad CID");
                    return x ? .uploadWithoutDirectory ? [`ipfs://${Y}`] : c.map(l => `ipfs://${Y}/${l}`)
                }
            };
            let ThirdwebStorage = class ThirdwebStorage {
                constructor(l) {
                    var c;
                    this.uploader = l ? .uploader || new IpfsUploader({
                        clientId: l ? .clientId,
                        secretKey: l ? .secretKey,
                        uploadServerUrl: l ? .uploadServerUrl
                    }), this.downloader = l ? .downloader || new StorageDownloader({
                        secretKey: l ? .secretKey,
                        clientId: l ? .clientId
                    }), this.gatewayUrls = function(l, c, x) {
                        let N = { ...er,
                            ...l
                        };
                        for (let l of Object.keys(N)) {
                            let U = N[l].map(l => {
                                if (c && l.includes("{clientId}")) return l.replace("{clientId}", c);
                                if (x && l.includes("{clientId}")) throw Error("Cannot use secretKey in browser context");
                                if (!l.includes("{clientId}")) return l
                            }).filter(l => void 0 !== l);
                            N[l] = U
                        }
                        return N
                    }(Array.isArray(c = l ? .gatewayUrls) ? {
                        "ipfs://": c
                    } : c || {}, l ? .clientId, l ? .secretKey), this.clientId = l ? .clientId
                }
                resolveScheme(l) {
                    return replaceSchemeWithGatewayUrl(l, this.gatewayUrls, 0, this.clientId)
                }
                async download(l, c) {
                    return this.downloader.download(l, this.gatewayUrls, c)
                }
                async downloadJSON(l, c) {
                    let x = await this.download(l, c),
                        N = await x.json();
                    return replaceObjectSchemesWithGatewayUrls(N, this.gatewayUrls, this.clientId)
                }
                async upload(l, c) {
                    let [x] = await this.uploadBatch([l], c);
                    return x
                }
                async uploadBatch(l, c) {
                    if (!(l = l.filter(l => void 0 !== l)).length) return [];
                    let x = l.map(l => isFileOrBuffer(l) || "string" == typeof l).every(l => !!l),
                        N = [];
                    if (x) N = await this.uploader.uploadBatch(l, c);
                    else {
                        let x = (await this.uploadAndReplaceFilesWithHashes(l, c)).map(l => "string" == typeof l ? l : JSON.stringify(l));
                        N = await this.uploader.uploadBatch(x, c)
                    }
                    return c ? .uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl ? N.map(l => this.resolveScheme(l)) : N
                }
                getGatewayUrls() {
                    return this.gatewayUrls
                }
                async uploadAndReplaceFilesWithHashes(l, c) {
                    let x = l;
                    x = function replaceObjectGatewayUrlsWithSchemes(l, c) {
                        return "string" == typeof l ? replaceGatewayUrlWithScheme(l, c) : "object" == typeof l ? !l || isFileOrBuffer(l) ? l : Array.isArray(l) ? l.map(l => replaceObjectGatewayUrlsWithSchemes(l, c)) : Object.fromEntries(Object.entries(l).map(l => {
                            let [x, N] = l;
                            return [x, replaceObjectGatewayUrlsWithSchemes(N, c)]
                        })) : l
                    }(x, this.gatewayUrls);
                    let N = function extractObjectFiles(l) {
                        let c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        if (isFileOrBuffer(l)) return c.push(l), c;
                        if ("object" == typeof l) {
                            if (!l) return c;
                            Array.isArray(l) ? l.forEach(l => extractObjectFiles(l, c)) : Object.keys(l).map(x => extractObjectFiles(l[x], c))
                        }
                        return c
                    }(x);
                    if (N.length) {
                        let l = await this.uploader.uploadBatch(N, c);
                        x = function replaceObjectFilesWithUris(l, c) {
                            if (isFileOrBuffer(l)) {
                                if (c.length) return l = c.shift();
                                console.warn("Not enough URIs to replace all files in object.")
                            }
                            return "object" == typeof l && l ? Array.isArray(l) ? l.map(l => replaceObjectFilesWithUris(l, c)) : Object.fromEntries(Object.entries(l).map(l => {
                                let [x, N] = l;
                                return [x, replaceObjectFilesWithUris(N, c)]
                            })) : l
                        }(x, l)
                    }
                    return (c ? .uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) && (x = replaceObjectSchemesWithGatewayUrls(x, this.gatewayUrls, this.clientId)), x
                }
            }
        },
        23780: function(l, c, x) {
            "use strict";

            function assertWindowEthereum(l) {
                return void 0 !== l && !!l && "ethereum" in l
            }
            x.d(c, {
                a: function() {
                    return assertWindowEthereum
                }
            })
        },
        33883: function(l, c, x) {
            "use strict";
            x.d(c, {
                a: function() {
                    return AbstractClientWallet
                },
                c: function() {
                    return createAsyncLocalStorage
                }
            });
            var N = x(92060),
                U = x(75460),
                Z = x(44931),
                $ = x(9409);
            let Y = "__TW__";
            let AsyncLocalStorage = class AsyncLocalStorage {
                constructor(l) {
                    this.name = l
                }
                getItem(l) {
                    return new Promise(c => {
                        c(localStorage.getItem(`${Y}/${this.name}/${l}`))
                    })
                }
                setItem(l, c) {
                    return new Promise((x, N) => {
                        try {
                            localStorage.setItem(`${Y}/${this.name}/${l}`, c), x()
                        } catch (l) {
                            N(l)
                        }
                    })
                }
                removeItem(l) {
                    return new Promise(c => {
                        localStorage.removeItem(`${Y}/${this.name}/${l}`), c()
                    })
                }
            };

            function createAsyncLocalStorage(l) {
                return new AsyncLocalStorage(l)
            }
            let q = {
                name: "thirdweb powered dApp",
                url: "https://thirdweb.com",
                description: "thirdweb powered dApp",
                logoUrl: "https://thirdweb.com/favicon.ico",
                isDarkMode: !0
            };
            var J = new WeakMap,
                X = new WeakSet,
                en = new WeakSet;
            let AbstractClientWallet = class AbstractClientWallet extends $.q {
                getMeta() {
                    return this.constructor.meta
                }
                constructor(l, c) {
                    super(), (0, N._)(this, en), (0, N._)(this, X), (0, U._)(this, J, {
                        writable: !0,
                        value: void 0
                    }), this.walletId = l, this.options = c, this.chains = (c ? .chains || Z.gL9).map(l => (0, Z.nRj)(l, c ? .clientId)), this.dappMetadata = c ? .dappMetadata || q, this.walletStorage = c ? .walletStorage || createAsyncLocalStorage(this.walletId)
                }
                async autoConnect(l) {
                    let c = l ? { ...l,
                        chainId: void 0
                    } : void 0;
                    return (0, N.a)(this, X, _connect2).call(this, !0, c)
                }
                async connect(l) {
                    (0, U.a)(this, J, l);
                    let c = await (0, N.a)(this, X, _connect2).call(this, !1, l);
                    if (!c) throw Error("Failed to connect to the wallet.");
                    return c
                }
                getConnectParams() {
                    return (0, U.b)(this, J)
                }
                async getSigner() {
                    let l = await this.getConnector();
                    if (!l) throw Error("Wallet not connected");
                    return await l.getSigner()
                }
                async disconnect() {
                    let l = await this.getConnector();
                    l && (await l.disconnect(), this.emit("disconnect"), l.removeAllListeners())
                }
                async switchChain(l) {
                    let c = await this.getConnector();
                    if (!c) throw Error("Wallet not connected");
                    if (!c.switchChain) throw Error("Wallet does not support switching chains");
                    return await c.switchChain(l)
                }
                async updateChains(l) {
                    this.chains = l.map(l => (0, Z.nRj)(l, this.options ? .clientId));
                    let c = await this.getConnector();
                    c.updateChains(this.chains)
                }
                getPersonalWallet() {}
            };
            async function _connect2(l, c) {
                let x = await this.getConnector();
                (0, N.a)(this, en, _subscribeToEvents2).call(this, x);
                let U = await x.isConnected();
                if (U) {
                    let l = await x.getAddress();
                    return x.setupListeners(), c ? .chainId && await x.switchChain(c ? .chainId), this.emit("connect", {
                        address: l,
                        chainId: await this.getChainId()
                    }), l
                }
                if (l) throw Error("Failed to auto connect to the wallet.");
                try {
                    let l = await x.connect(c);
                    return l
                } catch (l) {
                    throw Error(l.message)
                }
            }
            async function _subscribeToEvents2(l) {
                l.on("connect", l => {
                    this.emit("connect", {
                        address: l.account,
                        chainId: l.chain ? .id
                    })
                }), l.on("change", l => {
                    this.emit("change", {
                        address: l.account,
                        chainId: l.chain ? .id
                    })
                }), l.on("message", l => {
                    this.emit("message", l)
                }), l.on("disconnect", async () => {
                    this.emit("disconnect")
                }), l.on("error", l => this.emit("error", l))
            }
        },
        75460: function(l, c, x) {
            "use strict";

            function _checkPrivateRedeclaration(l, c) {
                if (c.has(l)) throw TypeError("Cannot initialize the same private elements twice on an object")
            }

            function _classPrivateFieldInitSpec(l, c, x) {
                _checkPrivateRedeclaration(l, c), c.set(l, x)
            }

            function _classExtractFieldDescriptor(l, c, x) {
                if (!c.has(l)) throw TypeError("attempted to " + x + " private field on non-instance");
                return c.get(l)
            }

            function _classPrivateFieldGet(l, c) {
                var x = _classExtractFieldDescriptor(l, c, "get");
                return x.get ? x.get.call(l) : x.value
            }

            function _classPrivateFieldSet(l, c, x) {
                var N = _classExtractFieldDescriptor(l, c, "set");
                return ! function(l, c, x) {
                    if (c.set) c.set.call(l, x);
                    else {
                        if (!c.writable) throw TypeError("attempted to set read only private field");
                        c.value = x
                    }
                }(l, N, x), x
            }
            x.d(c, {
                _: function() {
                    return _classPrivateFieldInitSpec
                },
                a: function() {
                    return _classPrivateFieldSet
                },
                b: function() {
                    return _classPrivateFieldGet
                },
                c: function() {
                    return _checkPrivateRedeclaration
                }
            })
        },
        92060: function(l, c, x) {
            "use strict";
            x.d(c, {
                _: function() {
                    return _classPrivateMethodInitSpec
                },
                a: function() {
                    return _classPrivateMethodGet
                }
            });
            var N = x(75460);

            function _classPrivateMethodInitSpec(l, c) {
                (0, N.c)(l, c), c.add(l)
            }

            function _classPrivateMethodGet(l, c, x) {
                if (!c.has(l)) throw TypeError("attempted to get private field on non-instance");
                return x
            }
        },
        64140: function(l, c, x) {
            "use strict";
            x.d(c, {
                C: function() {
                    return Connector
                },
                W: function() {
                    return WagmiAdapter
                }
            });
            var N = x(11953);
            let Connector = class Connector extends N.Z {};
            let WagmiAdapter = class WagmiAdapter extends Connector {
                constructor(l) {
                    super(), this.wagmiConnector = l
                }
                async connect(l) {
                    this.setupConnectorListeners();
                    let c = await this.wagmiConnector.connect(l);
                    return c.account
                }
                disconnect() {
                    return this.wagmiConnector.removeAllListeners("connect"), this.wagmiConnector.removeAllListeners("change"), this.wagmiConnector.disconnect()
                }
                isConnected() {
                    return this.wagmiConnector.isAuthorized()
                }
                getAddress() {
                    return this.wagmiConnector.getAccount()
                }
                getSigner() {
                    return this.wagmiConnector.getSigner()
                }
                getProvider() {
                    return this.wagmiConnector.getProvider()
                }
                async switchChain(l) {
                    if (!this.wagmiConnector.switchChain) throw Error("Switch chain not supported");
                    await this.wagmiConnector.switchChain(l)
                }
                setupConnectorListeners() {
                    this.wagmiConnector.addListener("connect", l => {
                        this.emit("connect", l)
                    }), this.wagmiConnector.addListener("change", l => {
                        this.emit("change", l)
                    }), this.wagmiConnector.addListener("disconnect", () => {
                        this.emit("disconnect")
                    })
                }
                async setupListeners() {
                    this.setupConnectorListeners(), await this.wagmiConnector.setupListeners()
                }
                updateChains(l) {
                    this.wagmiConnector.updateChains(l)
                }
            }
        },
        86985: function(l, c, x) {
            "use strict";
            x.d(c, {
                C: function() {
                    return N
                },
                S: function() {
                    return U
                }
            });
            let N = {
                    1: "https://safe-transaction-mainnet.safe.global",
                    5: "https://safe-transaction-goerli.safe.global",
                    10: "https://safe-transaction-optimism.safe.global",
                    56: "https://safe-transaction-bsc.safe.global",
                    100: "https://safe-transaction-gnosis-chain.safe.global",
                    137: "https://safe-transaction-polygon.safe.global",
                    43114: "https://safe-transaction-avalanche.safe.global",
                    42161: "https://safe-transaction-arbitrum.safe.global",
                    42220: "https://safe-transaction-celo.safe.global",
                    84531: "https://safe-transaction-base-testnet.safe.global",
                    1313161554: "https://safe-transaction-aurora.safe.global"
                },
                U = new Set(Object.keys(N).map(Number))
        },
        53061: function(l, c, x) {
            "use strict";

            function _defineProperty(l, c, x) {
                var N;
                return (c = "symbol" == typeof(N = function(l, c) {
                    if ("object" != typeof l || null === l) return l;
                    var x = l[Symbol.toPrimitive];
                    if (void 0 !== x) {
                        var N = x.call(l, c || "default");
                        if ("object" != typeof N) return N;
                        throw TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === c ? String : Number)(l)
                }(c, "string")) ? N : String(N)) in l ? Object.defineProperty(l, c, {
                    value: x,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : l[c] = x, l
            }
            x.d(c, {
                _: function() {
                    return _defineProperty
                }
            })
        },
        19679: function(l, c, x) {
            "use strict";
            x.d(c, {
                g: function() {
                    return getInjectedMetamaskProvider
                }
            });
            var N = x(23780);

            function getInjectedMetamaskProvider() {
                function getReady(l) {
                    let c = !!l ? .isMetaMask;
                    if (c && (!l.isBraveWallet || l._events || l._state) && !l.isRainbow && !l.isPhantom && !l.isAvalanche && !l.isBitKeep && !l.isMathWallet && !l.isZerion && !l.isKuCoinWallet && !l.isPortal && !l.isTokenPocket && !l.isTokenary) return l
                }
                if ((0, N.a)(globalThis.window)) return globalThis.window.ethereum ? .providers ? globalThis.window.ethereum.providers.find(getReady) : getReady(globalThis.window.ethereum)
            }
        },
        91318: function(l, c, x) {
            "use strict";

            function getInjectedPhantomProvider() {
                let l = window.phantom ? .ethereum;
                if (l ? .isPhantom) return l
            }
            x.d(c, {
                g: function() {
                    return getInjectedPhantomProvider
                }
            })
        },
        46184: function(l, c, x) {
            "use strict";
            x.d(c, {
                g: function() {
                    return getInjectedRainbowProvider
                }
            });
            var N = x(23780);

            function getInjectedRainbowProvider() {
                function getReady(l) {
                    let c = !!l ? .isRainbow;
                    if (c && (!l.isBraveWallet || l._events || l._state) && !l.isPhantom && !l.isAvalanche && !l.isBitKeep && !l.isMathWallet && !l.isZerion && !l.isKuCoinWallet && !l.isPortal && !l.isTokenPocket && !l.isTokenary) return l
                }
                if ((0, N.a)(globalThis.window)) return globalThis.window.ethereum ? .providers ? globalThis.window.ethereum.providers.find(getReady) : getReady(globalThis.window.ethereum)
            }
        },
        23743: function(l, c, x) {
            "use strict";
            x.d(c, {
                w: function() {
                    return N
                }
            });
            let N = {
                blocto: "blocto",
                coinbase: "coinbase",
                frame: "frame",
                localWallet: "localWallet",
                magicLink: "magicLink",
                metamask: "metamask",
                paper: "paper",
                rainbow: "rainbowWallet",
                smartWallet: "smartWallet",
                safe: "safe",
                trust: "trust",
                embeddedWallet: "embeddedWallet",
                walletConnectV1: "walletConnectV1",
                walletConnect: "walletConnect",
                phantom: "phantom"
            }
        },
        86684: function(l, c, x) {
            "use strict";
            x.d(c, {
                E: function() {
                    return Z
                },
                T: function() {
                    return N
                },
                W: function() {
                    return U
                }
            });
            let N = "145769e410f16970a79ff77b2d89a1e0",
                U = "wss://relay.walletconnect.com",
                Z = {
                    PERSONAL_SIGN: "personal_sign",
                    ETH_SIGN: "eth_sign",
                    ETH_SIGN_TRANSACTION: "eth_signTransaction",
                    ETH_SIGN_TYPED_DATA: "eth_signTypedData",
                    ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
                    ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
                    ETH_SEND_TRANSACTION: "eth_sendTransaction",
                    SWITCH_CHAIN: "wallet_switchEthereumChain"
                }
        },
        9409: function(l, c, x) {
            "use strict";
            x.d(c, {
                q: function() {
                    return AbstractWallet
                }
            });
            var N = x(53061),
                U = x(28410),
                Z = x(46795),
                $ = x(91798),
                Y = x(57273),
                q = x(12060),
                J = x(11953),
                X = x(27058);
            let en = [{
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "address",
                    name: "owner",
                    type: "address"
                }, {
                    indexed: !0,
                    internalType: "address",
                    name: "spender",
                    type: "address"
                }, {
                    indexed: !1,
                    internalType: "uint256",
                    name: "value",
                    type: "uint256"
                }],
                name: "Approval",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "address",
                    name: "from",
                    type: "address"
                }, {
                    indexed: !0,
                    internalType: "address",
                    name: "to",
                    type: "address"
                }, {
                    indexed: !1,
                    internalType: "uint256",
                    name: "value",
                    type: "uint256"
                }],
                name: "Transfer",
                type: "event"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "owner",
                    type: "address"
                }, {
                    internalType: "address",
                    name: "spender",
                    type: "address"
                }],
                name: "allowance",
                outputs: [{
                    internalType: "uint256",
                    name: "",
                    type: "uint256"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "spender",
                    type: "address"
                }, {
                    internalType: "uint256",
                    name: "value",
                    type: "uint256"
                }],
                name: "approve",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "nonpayable",
                type: "function"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "who",
                    type: "address"
                }],
                name: "balanceOf",
                outputs: [{
                    internalType: "uint256",
                    name: "",
                    type: "uint256"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [],
                name: "totalSupply",
                outputs: [{
                    internalType: "uint256",
                    name: "",
                    type: "uint256"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "to",
                    type: "address"
                }, {
                    internalType: "uint256",
                    name: "value",
                    type: "uint256"
                }],
                name: "transfer",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "nonpayable",
                type: "function"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "from",
                    type: "address"
                }, {
                    internalType: "address",
                    name: "to",
                    type: "address"
                }, {
                    internalType: "uint256",
                    name: "value",
                    type: "uint256"
                }],
                name: "transferFrom",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "nonpayable",
                type: "function"
            }, {
                inputs: [],
                name: "decimals",
                outputs: [{
                    internalType: "uint8",
                    name: "",
                    type: "uint8"
                }],
                stateMutability: "view",
                type: "function"
            }];

            function createErc20(l, c) {
                return new U.CH(c, en, l)
            }
            let er = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
            async function checkContractWalletSignature(l, c, x, N) {
                var Y;
                let q = new Z.r(`https://${N}.rpc.thirdweb.com${Y?`/${Y}`:""}${"undefined"!=typeof globalThis&&"APP_BUNDLE_ID"in globalThis?`?bundleId=${globalThis.APP_BUNDLE_ID}`:""}`),
                    J = new U.CH(x, er, q),
                    X = $.r(l);
                try {
                    let l = await J.isValidSignature(X, c);
                    return "0x1626ba7e" === l
                } catch {
                    return !1
                }
            }
            let AbstractWallet = class AbstractWallet extends J.Z {
                constructor() {
                    super(...arguments), (0, N._)(this, "type", "evm")
                }
                async getAddress() {
                    let l = await this.getSigner();
                    return l.getAddress()
                }
                async getBalance() {
                    let l, c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : X.cW,
                        x = await this.getSigner(),
                        N = await this.getAddress();
                    if (!x.provider) throw Error("Please connect a provider");
                    if ((0, X.b8)(c)) l = await x.provider.getBalance(N);
                    else {
                        let U = createErc20(x, c);
                        l = await U.balanceOf(N)
                    }
                    return await (0, X.bc)(x.provider, c, l)
                }
                async getChainId() {
                    let l = await this.getSigner();
                    return l.getChainId()
                }
                async transfer(l, c) {
                    let x = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : X.cW,
                        N = await this.getSigner(),
                        U = await this.getAddress();
                    if (!N.provider) throw Error("Please connect a provider");
                    let Z = await (0, X.ba)(N.provider, c, x);
                    if ((0, X.b8)(x)) {
                        let c = await N.sendTransaction({
                            from: U,
                            to: l,
                            value: Z
                        });
                        return {
                            receipt: await c.wait()
                        }
                    } {
                        let c = createErc20(N, x),
                            U = await c.transfer(l, Z);
                        return {
                            receipt: await U.wait()
                        }
                    }
                }
                async signMessage(l) {
                    let c = await this.getSigner();
                    return await c.signMessage(l)
                }
                async verifySignature(l, c, x, N) {
                    try {
                        let N = $.r(l),
                            U = Y.arrayify(N),
                            Z = q.recoverAddress(U, c);
                        if (Z === x) return !0
                    } catch {}
                    if (void 0 !== N) try {
                        let U = await checkContractWalletSignature(l, c, x, N || 1);
                        return U
                    } catch {}
                    return !1
                }
            }
        },
        52816: function(l, c, x) {
            "use strict";
            x.d(c, {
                S: function() {
                    return LocalWallet
                }
            });
            var N = x(92060),
                U = x(53061),
                Z = x(75460),
                $ = x(23743),
                Y = x(33883),
                q = x(44931),
                J = x(19796),
                X = x(61678),
                en = x(30686);
            x(9409), x(11953);
            let er = "localWalletData";
            var ea = new WeakMap,
                eo = new WeakSet;
            let LocalWallet = class LocalWallet extends Y.a {
                get walletName() {
                    return "Local Wallet"
                }
                constructor(l) {
                    super(LocalWallet.id, l), (0, N._)(this, eo), (0, Z._)(this, ea, {
                        writable: !0,
                        value: void 0
                    }), this.options = l || {}, (0, Z.a)(this, ea, l ? .storage || (0, Y.c)($.w.localWallet))
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            LocalWalletConnector: l
                        } = await x.e(5798).then(x.bind(x, 45798));
                        if (!this.ethersWallet) throw Error("wallet is not initialized");
                        let c = this.options.chain ? [...q.gL9, this.options.chain] : q.gL9;
                        this.connector = new l({
                            chain: this.options.chain || q.kJW,
                            ethersWallet: this.ethersWallet,
                            chains: this.options.chains || c,
                            clientId: this.options.clientId,
                            secretKey: this.options.secretKey
                        })
                    }
                    return this.connector
                }
                async loadOrCreate(l) {
                    await this.getSavedData(l.storage) ? await this.load(l) : (await this.generate(), await this.save(l))
                }
                async generate() {
                    if (this.ethersWallet) throw Error("wallet is already initialized");
                    let l = J.O(32);
                    return this.ethersWallet = new X.Wallet(l), this.ethersWallet.address
                }
                async
                import (l) {
                    if (this.ethersWallet) throw Error("wallet is already initialized");
                    if ("encryptedJson" in l) return this.ethersWallet = await X.Wallet.fromEncryptedJson(l.encryptedJson, l.password), this.ethersWallet.address;
                    if ("privateKey" in l) {
                        if (!l.encryption && !isValidPrivateKey(l.privateKey)) throw Error("invalid private key");
                        let c = await getDecryptor(l.encryption)(l.privateKey);
                        if (l.encryption && ("" === c || !isValidPrivateKey(c))) throw Error("invalid password");
                        return this.ethersWallet = new X.Wallet(c), this.ethersWallet.address
                    }
                    if ("mnemonic" in l) {
                        if (!l.encryption && !en.isValidMnemonic(l.mnemonic)) throw Error("invalid mnemonic");
                        let c = await getDecryptor(l.encryption)(l.mnemonic);
                        if (l.encryption && ("" === c || !en.isValidMnemonic(c))) throw Error("invalid password");
                        return this.ethersWallet = X.Wallet.fromMnemonic(c), this.ethersWallet.address
                    }
                    throw Error("invalid import strategy")
                }
                async load(l) {
                    if (this.ethersWallet) throw Error("wallet is already initialized");
                    let c = await this.getSavedData(l.storage);
                    if (!c) throw Error("No Saved wallet found in storage");
                    if (c.strategy !== l.strategy) throw Error(`Saved wallet data is not ${l.strategy}, it is ${c.strategy}`);
                    if ("encryptedJson" === l.strategy) return this.import({
                        encryptedJson: c.data,
                        password: l.password
                    });
                    if (c.isEncrypted && !l.encryption) throw Error("Saved wallet data is encrypted, but no password is provided");
                    if (!c.isEncrypted && l.encryption) throw Error("Saved wallet data is not encrypted, but encryption config is provided");
                    if ("privateKey" === l.strategy) return this.import({
                        privateKey: c.data,
                        encryption: l.encryption
                    });
                    if ("mnemonic" === l.strategy) return this.import({
                        mnemonic: c.data,
                        encryption: l.encryption
                    });
                    throw Error("invalid load strategy")
                }
                async save(l) {
                    let c = this.ethersWallet;
                    if (!c) throw Error("Wallet is not initialized");
                    if ("encryptedJson" === l.strategy) {
                        let x = await c.encrypt(l.password, {
                            scrypt: {
                                N: 1 << 32
                            }
                        });
                        await (0, N.a)(this, eo, _saveData2).call(this, {
                            address: c.address,
                            data: x,
                            strategy: "encryptedJson",
                            isEncrypted: !0
                        }, l.storage)
                    }
                    if ("privateKey" === l.strategy) {
                        let x = await getEncryptor(l.encryption)(c.privateKey);
                        await (0, N.a)(this, eo, _saveData2).call(this, {
                            address: c.address,
                            data: x,
                            strategy: "privateKey",
                            isEncrypted: !!l.encryption
                        }, l.storage)
                    }
                    if ("mnemonic" === l.strategy) {
                        if (!c.mnemonic) throw Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
                        let x = await getEncryptor(l.encryption)(c.mnemonic.phrase);
                        await (0, N.a)(this, eo, _saveData2).call(this, {
                            address: c.address,
                            data: x,
                            strategy: "mnemonic",
                            isEncrypted: !!l.encryption
                        }, l.storage)
                    }
                }
                async isSaved() {
                    try {
                        let l = await this.getSavedData(),
                            c = await this.getAddress();
                        if (l ? .address === c) return !0;
                        return !1
                    } catch (l) {
                        return !1
                    }
                }
                async deleteSaved() {
                    await (0, Z.b)(this, ea).removeItem(er)
                }
                async
                export (l) {
                    let c = this.ethersWallet;
                    if (!c) throw Error("Wallet is not initialized");
                    if ("encryptedJson" === l.strategy) return c.encrypt(l.password, {
                        scrypt: {
                            N: 1 << 32
                        }
                    });
                    if ("privateKey" === l.strategy) return getEncryptor(l.encryption)(c.privateKey);
                    if ("mnemonic" === l.strategy) {
                        if (!c.mnemonic) throw Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
                        return getEncryptor(l.encryption)(c.mnemonic.phrase)
                    }
                    throw Error("Invalid export strategy")
                }
                async getSavedData(l) {
                    let c = l || (0, Z.b)(this, ea);
                    try {
                        let l = await c.getItem(er);
                        if (!l) return null;
                        let x = JSON.parse(l);
                        if (!x) return null;
                        return x
                    } catch (l) {
                        return null
                    }
                }
                async disconnect() {
                    await super.disconnect(), this.ethersWallet = void 0
                }
            };
            async function _saveData2(l, c) {
                let x = c || (0, Z.b)(this, ea);
                await x.setItem(er, JSON.stringify(l))
            }
            async function defaultEncrypt(l, c) {
                let N = (await Promise.resolve().then(x.t.bind(x, 44155, 23))).default;
                return N.AES.encrypt(l, c).toString()
            }
            async function defaultDecrypt(l, c) {
                let N = (await Promise.resolve().then(x.t.bind(x, 44155, 23))).default;
                return N.AES.decrypt(l, c).toString(N.enc.Utf8)
            }

            function getDecryptor(l) {
                let noop = async l => l;
                return l ? c => (l.decrypt || defaultDecrypt)(c, l.password) : noop
            }

            function getEncryptor(l) {
                let noop = async l => l;
                return l ? c => (l.encrypt || defaultEncrypt)(c, l.password) : noop
            }

            function isValidPrivateKey(l) {
                return !!l.match(/^(0x)?[0-9a-f]{64}$/i)
            }(0, U._)(LocalWallet, "id", $.w.localWallet), (0, U._)(LocalWallet, "meta", {
                name: "Local Wallet",
                iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
            })
        },
        88672: function(l, c, x) {
            "use strict";
            x.d(c, {
                t: function() {
                    return MetaMaskWallet
                }
            });
            var N = x(53061),
                U = x(64140),
                Z = x(33883),
                $ = x(23743),
                Y = x(86684),
                q = x(19679);
            x(11953), x(9409);
            let MetaMaskWallet = class MetaMaskWallet extends Z.a {
                get walletName() {
                    return "MetaMask"
                }
                constructor(l) {
                    super(MetaMaskWallet.id, l), this.isInjected = !!(0, q.g)()
                }
                async getConnector() {
                    if (!this.connector) {
                        if (this.isInjected) {
                            let {
                                MetaMaskConnector: l
                            } = await x.e(6227).then(x.bind(x, 66227)), c = new l({
                                chains: this.chains,
                                connectorStorage: this.walletStorage,
                                options: {
                                    shimDisconnect: !0
                                }
                            });
                            this.metamaskConnector = c, this.connector = new U.W(c)
                        } else {
                            let {
                                WalletConnectConnector: l
                            } = await x.e(8759).then(x.bind(x, 48759)), c = new l({
                                chains: this.chains,
                                options: {
                                    projectId: this.options ? .projectId || Y.T,
                                    storage: this.walletStorage,
                                    qrcode: this.options ? .qrcode,
                                    dappMetadata: this.dappMetadata,
                                    qrModalOptions: this.options ? .qrModalOptions
                                }
                            });
                            c.getProvider().then(l => {
                                l.signer.client.on("session_request_sent", () => {
                                    this.emit("wc_session_request_sent")
                                })
                            }), this.walletConnectConnector = c, this.connector = new U.W(c)
                        }
                    }
                    return this.connector
                }
                async connectWithQrCode(l) {
                    await this.getConnector();
                    let c = this.walletConnectConnector;
                    if (!c) throw Error("WalletConnect connector not found");
                    let x = await c.getProvider();
                    x.on("display_uri", c => {
                        l.onQrCodeUri(c)
                    }), this.connect({
                        chainId: l.chainId
                    }).then(l.onConnected)
                }
                async switchAccount() {
                    if (!this.metamaskConnector) throw Error("Can not switch Account");
                    await this.metamaskConnector.switchAccount()
                }
            };
            (0, N._)(MetaMaskWallet, "meta", {
                name: "MetaMask",
                iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
                urls: {
                    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
                    android: "https://play.google.com/store/apps/details?id=io.metamask",
                    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
                }
            }), (0, N._)(MetaMaskWallet, "id", $.w.metamask)
        },
        53658: function(l, c, x) {
            "use strict";
            x.d(c, {
                I: function() {
                    return SignerWallet
                }
            });
            var N = x(75460),
                U = x(23743),
                Z = x(33883),
                $ = x(44931);
            x(9409), x(11953);
            var Y = new WeakMap;
            let SignerWallet = class SignerWallet extends Z.a {
                constructor(l) {
                    super("signerWallet", l), (0, N._)(this, Y, {
                        writable: !0,
                        value: void 0
                    }), this.options = l, this.signer = l.signer, (0, N.a)(this, Y, l ? .storage || (0, Z.c)(U.w.localWallet))
                }
                async getConnector() {
                    if (!this.connector) {
                        let {
                            SignerConnector: l
                        } = await x.e(783).then(x.bind(x, 60783));
                        this.signer || (this.signer = this.options.signer);
                        let c = this.options.chain ? [...$.gL9, this.options.chain] : $.gL9;
                        this.connector = new l({
                            chain: this.options.chain || $.kJW,
                            signer: this.signer,
                            chains: this.options.chains || c,
                            clientId: this.options.clientId,
                            secretKey: this.options.secretKey
                        })
                    }
                    return this.connector
                }
            }
        },
        1106: function(l, c, x) {
            "use strict";
            let N;
            x.d(c, {
                QY: function() {
                    return t5
                },
                i9: function() {
                    return tO
                },
                I8: function() {
                    return tA
                },
                ZF: function() {
                    return tI
                },
                Mb: function() {
                    return t_
                },
                yh: function() {
                    return Kt
                },
                sG: function() {
                    return tz
                }
            });
            var U = x(512),
                Z = x.n(U);
            let $ = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
                Y = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
                q = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

            function jsonParseTransform(l, c) {
                if ("__proto__" === l || "constructor" === l && c && "object" == typeof c && "prototype" in c) {
                    console.warn(`[destr] Dropping "${l}" key to prevent prototype pollution.`);
                    return
                }
                return c
            }

            function destr(l, c = {}) {
                if ("string" != typeof l) return l;
                let x = l.trim();
                if ('"' === l[0] && l.endsWith('"') && !l.includes("\\")) return x.slice(1, -1);
                if (x.length <= 9) {
                    let l = x.toLowerCase();
                    if ("true" === l) return !0;
                    if ("false" === l) return !1;
                    if ("undefined" === l) return;
                    if ("null" === l) return null;
                    if ("nan" === l) return Number.NaN;
                    if ("infinity" === l) return Number.POSITIVE_INFINITY;
                    if ("-infinity" === l) return Number.NEGATIVE_INFINITY
                }
                if (!q.test(l)) {
                    if (c.strict) throw SyntaxError("[destr] Invalid JSON");
                    return l
                }
                try {
                    if ($.test(l) || Y.test(l)) {
                        if (c.strict) throw Error("[destr] Possible prototype pollution");
                        return JSON.parse(l, jsonParseTransform)
                    }
                    return JSON.parse(l)
                } catch (x) {
                    if (c.strict) throw x;
                    return l
                }
            }
            var J = x(67133).Buffer;

            function asyncCall(l, ...c) {
                try {
                    var x;
                    return (x = l(...c)) && "function" == typeof x.then ? x : Promise.resolve(x)
                } catch (l) {
                    return Promise.reject(l)
                }
            }

            function stringify(l) {
                if (function(l) {
                        let c = typeof l;
                        return null === l || "object" !== c && "function" !== c
                    }(l)) return String(l);
                if (function(l) {
                        let c = Object.getPrototypeOf(l);
                        return !c || c.isPrototypeOf(Object)
                    }(l) || Array.isArray(l)) return JSON.stringify(l);
                if ("function" == typeof l.toJSON) return stringify(l.toJSON());
                throw Error("[unstorage] Cannot stringify value!")
            }
            let X = "base64:";

            function normalizeKey(l) {
                return l ? l.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : ""
            }

            function unstorage_8581f561_normalizeBaseKey(l) {
                return (l = normalizeKey(l)) ? l + ":" : ""
            }
            let memory = () => {
                let l = new Map;
                return {
                    name: "memory",
                    options: {},
                    hasItem: c => l.has(c),
                    getItem: c => l.get(c) ? ? null,
                    getItemRaw: c => l.get(c) ? ? null,
                    setItem(c, x) {
                        l.set(c, x)
                    },
                    setItemRaw(c, x) {
                        l.set(c, x)
                    },
                    removeItem(c) {
                        l.delete(c)
                    },
                    getKeys: () => Array.from(l.keys()),
                    clear() {
                        l.clear()
                    },
                    dispose() {
                        l.clear()
                    }
                }
            };

            function watch(l, c, x) {
                return l.watch ? l.watch((l, N) => c(l, x + N)) : () => {}
            }
            async function dispose(l) {
                "function" == typeof l.dispose && await asyncCall(l.dispose)
            }

            function promisifyRequest(l) {
                return new Promise((c, x) => {
                    l.oncomplete = l.onsuccess = () => c(l.result), l.onabort = l.onerror = () => x(l.error)
                })
            }

            function createStore(l, c) {
                let x = indexedDB.open(l);
                x.onupgradeneeded = () => x.result.createObjectStore(c);
                let N = promisifyRequest(x);
                return (l, x) => N.then(N => x(N.transaction(c, l).objectStore(c)))
            }

            function defaultGetStore() {
                return N || (N = createStore("keyval-store", "keyval")), N
            }

            function get(l, c = defaultGetStore()) {
                return c("readonly", c => promisifyRequest(c.get(l)))
            }
            var en = x(43283),
                z = (l = {}) => {
                    let c;
                    let x = l.base && l.base.length > 0 ? `${l.base}:` : "",
                        e = l => x + l;
                    return l.dbName && l.storeName && (c = createStore(l.dbName, l.storeName)), {
                        name: "idb-keyval",
                        options: l,
                        hasItem: async l => !(typeof await get(e(l), c) > "u"),
                        getItem: async l => await get(e(l), c) ? ? null,
                        setItem: (l, x) => (function(l, c, x = defaultGetStore()) {
                            return x("readwrite", x => (x.put(c, l), promisifyRequest(x.transaction)))
                        })(e(l), x, c),
                        removeItem: l => (function(l, c = defaultGetStore()) {
                            return c("readwrite", c => (c.delete(l), promisifyRequest(c.transaction)))
                        })(e(l), c),
                        getKeys: () => (function(l = defaultGetStore()) {
                            return l("readonly", l => {
                                var c;
                                if (l.getAllKeys) return promisifyRequest(l.getAllKeys());
                                let x = [];
                                return (c = l => x.push(l.key), l.openCursor().onsuccess = function() {
                                    this.result && (c(this.result), this.result.continue())
                                }, promisifyRequest(l.transaction)).then(() => x)
                            })
                        })(c),
                        clear: () => (function(l = defaultGetStore()) {
                            return l("readwrite", l => (l.clear(), promisifyRequest(l.transaction)))
                        })(c)
                    }
                };
            let _ = class _ {
                constructor() {
                    this.indexedDb = function(l = {}) {
                        let c = {
                                mounts: {
                                    "": l.driver || memory()
                                },
                                mountpoints: [""],
                                watching: !1,
                                watchListeners: [],
                                unwatch: {}
                            },
                            getMount = l => {
                                for (let x of c.mountpoints)
                                    if (l.startsWith(x)) return {
                                        base: x,
                                        relativeKey: l.slice(x.length),
                                        driver: c.mounts[x]
                                    };
                                return {
                                    base: "",
                                    relativeKey: l,
                                    driver: c.mounts[""]
                                }
                            },
                            getMounts = (l, x) => c.mountpoints.filter(c => c.startsWith(l) || x && l.startsWith(c)).map(x => ({
                                relativeBase: l.length > x.length ? l.slice(x.length) : void 0,
                                mountpoint: x,
                                driver: c.mounts[x]
                            })),
                            onChange = (l, x) => {
                                if (c.watching)
                                    for (let N of (x = normalizeKey(x), c.watchListeners)) N(l, x)
                            },
                            startWatch = async () => {
                                if (!c.watching)
                                    for (let l in c.watching = !0, c.mounts) c.unwatch[l] = await watch(c.mounts[l], onChange, l)
                            },
                            stopWatch = async () => {
                                if (c.watching) {
                                    for (let l in c.unwatch) await c.unwatch[l]();
                                    c.unwatch = {}, c.watching = !1
                                }
                            },
                            runBatch = (l, c, x) => {
                                let N = new Map,
                                    getBatch = l => {
                                        let c = N.get(l.base);
                                        return c || (c = {
                                            driver: l.driver,
                                            base: l.base,
                                            items: []
                                        }, N.set(l.base, c)), c
                                    };
                                for (let x of l) {
                                    let l = "string" == typeof x,
                                        N = normalizeKey(l ? x : x.key),
                                        U = l ? void 0 : x.value,
                                        Z = l || !x.options ? c : { ...c,
                                            ...x.options
                                        },
                                        $ = getMount(N);
                                    getBatch($).items.push({
                                        key: N,
                                        value: U,
                                        relativeKey: $.relativeKey,
                                        options: Z
                                    })
                                }
                                return Promise.all([...N.values()].map(l => x(l))).then(l => l.flat())
                            },
                            x = {
                                hasItem(l, c = {}) {
                                    l = normalizeKey(l);
                                    let {
                                        relativeKey: x,
                                        driver: N
                                    } = getMount(l);
                                    return asyncCall(N.hasItem, x, c)
                                },
                                getItem(l, c = {}) {
                                    l = normalizeKey(l);
                                    let {
                                        relativeKey: x,
                                        driver: N
                                    } = getMount(l);
                                    return asyncCall(N.getItem, x, c).then(l => destr(l))
                                },
                                getItems: (l, c) => runBatch(l, c, l => l.driver.getItems ? asyncCall(l.driver.getItems, l.items.map(l => ({
                                    key: l.relativeKey,
                                    options: l.options
                                })), c).then(c => c.map(c => ({
                                    key: function(...l) {
                                        return normalizeKey(l.join(":"))
                                    }(l.base, c.key),
                                    value: destr(c.value)
                                }))) : Promise.all(l.items.map(c => asyncCall(l.driver.getItem, c.relativeKey, c.options).then(l => ({
                                    key: c.key,
                                    value: destr(l)
                                }))))),
                                getItemRaw(l, c = {}) {
                                    l = normalizeKey(l);
                                    let {
                                        relativeKey: x,
                                        driver: N
                                    } = getMount(l);
                                    return N.getItemRaw ? asyncCall(N.getItemRaw, x, c) : asyncCall(N.getItem, x, c).then(l => "string" == typeof l && l.startsWith(X) ? J.from(l.slice(X.length), "base64") : l)
                                },
                                async setItem(l, c, N = {}) {
                                    if (void 0 === c) return x.removeItem(l);
                                    l = normalizeKey(l);
                                    let {
                                        relativeKey: U,
                                        driver: Z
                                    } = getMount(l);
                                    Z.setItem && (await asyncCall(Z.setItem, U, stringify(c), N), Z.watch || onChange("update", l))
                                },
                                async setItems(l, c) {
                                    await runBatch(l, c, async l => {
                                        if (l.driver.setItems) return asyncCall(l.driver.setItems, l.items.map(l => ({
                                            key: l.relativeKey,
                                            value: stringify(l.value),
                                            options: l.options
                                        })), c);
                                        l.driver.setItem && await Promise.all(l.items.map(c => asyncCall(l.driver.setItem, c.relativeKey, stringify(c.value), c.options)))
                                    })
                                },
                                async setItemRaw(l, c, N = {}) {
                                    if (void 0 === c) return x.removeItem(l, N);
                                    l = normalizeKey(l);
                                    let {
                                        relativeKey: U,
                                        driver: Z
                                    } = getMount(l);
                                    if (Z.setItemRaw) await asyncCall(Z.setItemRaw, U, c, N);
                                    else {
                                        if (!Z.setItem) return;
                                        await asyncCall(Z.setItem, U, function(l) {
                                            if ("string" == typeof l) return l;
                                            let c = J.from(l).toString("base64");
                                            return X + c
                                        }(c), N)
                                    }
                                    Z.watch || onChange("update", l)
                                },
                                async removeItem(l, c = {}) {
                                    "boolean" == typeof c && (c = {
                                        removeMeta: c
                                    }), l = normalizeKey(l);
                                    let {
                                        relativeKey: x,
                                        driver: N
                                    } = getMount(l);
                                    N.removeItem && (await asyncCall(N.removeItem, x, c), (c.removeMeta || c.removeMata) && await asyncCall(N.removeItem, x + "$", c), N.watch || onChange("remove", l))
                                },
                                async getMeta(l, c = {}) {
                                    "boolean" == typeof c && (c = {
                                        nativeOnly: c
                                    }), l = normalizeKey(l);
                                    let {
                                        relativeKey: x,
                                        driver: N
                                    } = getMount(l), U = Object.create(null);
                                    if (N.getMeta && Object.assign(U, await asyncCall(N.getMeta, x, c)), !c.nativeOnly) {
                                        let l = await asyncCall(N.getItem, x + "$", c).then(l => destr(l));
                                        l && "object" == typeof l && ("string" == typeof l.atime && (l.atime = new Date(l.atime)), "string" == typeof l.mtime && (l.mtime = new Date(l.mtime)), Object.assign(U, l))
                                    }
                                    return U
                                },
                                setMeta(l, c, x = {}) {
                                    return this.setItem(l + "$", c, x)
                                },
                                removeMeta(l, c = {}) {
                                    return this.removeItem(l + "$", c)
                                },
                                async getKeys(l, c = {}) {
                                    l = unstorage_8581f561_normalizeBaseKey(l);
                                    let x = getMounts(l, !0),
                                        N = [],
                                        U = [];
                                    for (let l of x) {
                                        let x = await asyncCall(l.driver.getKeys, l.relativeBase, c),
                                            Z = x.map(c => l.mountpoint + normalizeKey(c)).filter(l => !N.some(c => l.startsWith(c)));
                                        U.push(...Z), N = [l.mountpoint, ...N.filter(c => !c.startsWith(l.mountpoint))]
                                    }
                                    return l ? U.filter(c => c.startsWith(l) && !c.endsWith("$")) : U.filter(l => !l.endsWith("$"))
                                },
                                async clear(l, c = {}) {
                                    l = unstorage_8581f561_normalizeBaseKey(l), await Promise.all(getMounts(l, !1).map(async l => {
                                        if (l.driver.clear) return asyncCall(l.driver.clear, l.relativeBase, c);
                                        if (l.driver.removeItem) {
                                            let x = await l.driver.getKeys(l.relativeBase || "", c);
                                            return Promise.all(x.map(x => l.driver.removeItem(x, c)))
                                        }
                                    }))
                                },
                                async dispose() {
                                    await Promise.all(Object.values(c.mounts).map(l => dispose(l)))
                                },
                                watch: async l => (await startWatch(), c.watchListeners.push(l), async () => {
                                    c.watchListeners = c.watchListeners.filter(c => c !== l), 0 === c.watchListeners.length && await stopWatch()
                                }),
                                async unwatch() {
                                    c.watchListeners = [], await stopWatch()
                                },
                                mount(l, N) {
                                    if ((l = unstorage_8581f561_normalizeBaseKey(l)) && c.mounts[l]) throw Error(`already mounted at ${l}`);
                                    return l && (c.mountpoints.push(l), c.mountpoints.sort((l, c) => c.length - l.length)), c.mounts[l] = N, c.watching && Promise.resolve(watch(N, onChange, l)).then(x => {
                                        c.unwatch[l] = x
                                    }).catch(console.error), x
                                },
                                async unmount(l, x = !0) {
                                    (l = unstorage_8581f561_normalizeBaseKey(l)) && c.mounts[l] && (c.watching && l in c.unwatch && (c.unwatch[l](), delete c.unwatch[l]), x && await dispose(c.mounts[l]), c.mountpoints = c.mountpoints.filter(c => c !== l), delete c.mounts[l])
                                },
                                getMount(l = "") {
                                    l = normalizeKey(l) + ":";
                                    let c = getMount(l);
                                    return {
                                        driver: c.driver,
                                        base: c.base
                                    }
                                },
                                getMounts(l = "", c = {}) {
                                    l = normalizeKey(l);
                                    let x = getMounts(l, c.parents);
                                    return x.map(l => ({
                                        driver: l.driver,
                                        base: l.mountpoint
                                    }))
                                }
                            };
                        return x
                    }({
                        driver: z({
                            dbName: "WALLET_CONNECT_V2_INDEXED_DB",
                            storeName: "keyvaluestorage"
                        })
                    })
                }
                async getKeys() {
                    return this.indexedDb.getKeys()
                }
                async getEntries() {
                    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(l => [l.key, l.value])
                }
                async getItem(l) {
                    let c = await this.indexedDb.getItem(l);
                    if (null !== c) return c
                }
                async setItem(l, c) {
                    await this.indexedDb.setItem(l, (0, en.u)(c))
                }
                async removeItem(l) {
                    await this.indexedDb.removeItem(l)
                }
            };
            var er = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof x.g ? x.g : "u" > typeof self ? self : {},
                ea = {
                    exports: {}
                };

            function k(l) {
                var c;
                return [l[0], (0, en.D)(null != (c = l[1]) ? c : "")]
            }! function() {
                function t() {}
                t.prototype.getItem = function(l) {
                    return this.hasOwnProperty(l) ? String(this[l]) : null
                }, t.prototype.setItem = function(l, c) {
                    this[l] = String(c)
                }, t.prototype.removeItem = function(l) {
                    delete this[l]
                }, t.prototype.clear = function() {
                    let l = this;
                    Object.keys(l).forEach(function(c) {
                        l[c] = void 0, delete l[c]
                    })
                }, t.prototype.key = function(l) {
                    return l = l || 0, Object.keys(this)[l]
                }, t.prototype.__defineGetter__("length", function() {
                    return Object.keys(this).length
                }), "u" > typeof er && er.localStorage ? ea.exports = er.localStorage : "u" > typeof window && window.localStorage ? ea.exports = window.localStorage : ea.exports = new t
            }();
            let K = class K {
                constructor() {
                    this.localStorage = ea.exports
                }
                async getKeys() {
                    return Object.keys(this.localStorage)
                }
                async getEntries() {
                    return Object.entries(this.localStorage).map(k)
                }
                async getItem(l) {
                    let c = this.localStorage.getItem(l);
                    if (null !== c) return (0, en.D)(c)
                }
                async setItem(l, c) {
                    this.localStorage.setItem(l, (0, en.u)(c))
                }
                async removeItem(l) {
                    this.localStorage.removeItem(l)
                }
            };
            let O = async (l, c, x) => {
                    let N = "wc_storage_version",
                        U = await c.getItem(N);
                    if (U && U >= 1) {
                        x(c);
                        return
                    }
                    let Z = await l.getKeys();
                    if (!Z.length) {
                        x(c);
                        return
                    }
                    let $ = [];
                    for (; Z.length;) {
                        let x = Z.shift();
                        if (!x) continue;
                        let N = x.toLowerCase();
                        if (N.includes("wc@") || N.includes("walletconnect") || N.includes("wc_") || N.includes("wallet_connect")) {
                            let N = await l.getItem(x);
                            await c.setItem(x, N), $.push(x)
                        }
                    }
                    await c.setItem(N, 1), x(c), j(l, $)
                },
                j = async (l, c) => {
                    c.length && c.forEach(async c => {
                        await l.removeItem(c)
                    })
                };
            let h = class h {
                constructor() {
                    this.initialized = !1, this.setInitialized = l => {
                        this.storage = l, this.initialized = !0
                    };
                    let l = new K;
                    this.storage = l;
                    try {
                        let c = new _;
                        O(l, c, this.setInitialized)
                    } catch {
                        this.initialized = !0
                    }
                }
                async getKeys() {
                    return await this.initialize(), this.storage.getKeys()
                }
                async getEntries() {
                    return await this.initialize(), this.storage.getEntries()
                }
                async getItem(l) {
                    return await this.initialize(), this.storage.getItem(l)
                }
                async setItem(l, c) {
                    return await this.initialize(), this.storage.setItem(l, c)
                }
                async removeItem(l) {
                    return await this.initialize(), this.storage.removeItem(l)
                }
                async initialize() {
                    this.initialized || await new Promise(l => {
                        let c = setInterval(() => {
                            this.initialized && (clearInterval(c), l())
                        }, 20)
                    })
                }
            };
            var eo = x(58619),
                el = x(95097);
            let n = class n extends el.q {
                constructor(l) {
                    super()
                }
            };
            let ec = eo.FIVE_SECONDS,
                eu = {
                    pulse: "heartbeat_pulse"
                };
            let index_es_i = class index_es_i extends n {
                constructor(l) {
                    super(l), this.events = new U.EventEmitter, this.interval = ec, this.interval = l ? .interval || ec
                }
                static async init(l) {
                    let c = new index_es_i(l);
                    return await c.init(), c
                }
                async init() {
                    await this.initialize()
                }
                stop() {
                    clearInterval(this.intervalRef)
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async initialize() {
                    this.intervalRef = setInterval(() => this.pulse(), (0, eo.toMiliseconds)(this.interval))
                }
                pulse() {
                    this.events.emit(eu.pulse)
                }
            };
            var ed = x(33234),
                ep = x(49979),
                eh = x(80237),
                ey = x(35077);
            let ef = "base64url",
                em = "base58btc";
            var eg = x(72281),
                eb = x(21361),
                ev = x(34901);

            function encodeJSON(l) {
                return (0, eb.toString)((0, ev.fromString)((0, en.u)(l), "utf8"), ef)
            }

            function encodeIss(l) {
                let c = (0, ev.fromString)("K36", em),
                    x = "z" + (0, eb.toString)((0, eg.concat)([c, l]), em);
                return ["did", "key", x].join(":")
            }

            function generateKeyPair(l = (0, ey.randomBytes)(32)) {
                return eh._w(l)
            }
            async function signJWT(l, c, x, N, U = (0, eo.fromMiliseconds)(Date.now())) {
                var Z, $, Y;
                let q = {
                        alg: "EdDSA",
                        typ: "JWT"
                    },
                    J = encodeIss(N.publicKey),
                    X = {
                        iss: J,
                        sub: l,
                        aud: c,
                        iat: U,
                        exp: U + x
                    },
                    en = (Z = {
                        header: q,
                        payload: X
                    }, (0, ev.fromString)([encodeJSON(Z.header), encodeJSON(Z.payload)].join("."), "utf8")),
                    er = eh.Xx(N.secretKey, en);
                return [encodeJSON(($ = {
                    header: q,
                    payload: X,
                    signature: er
                }).header), encodeJSON($.payload), (Y = $.signature, (0, eb.toString)(Y, ef))].join(".")
            }
            x(69859);
            var ew = x(70723),
                eT = x(71188),
                eM = x(45280),
                eI = x(53620);
            let b = () => "u" > typeof WebSocket || "u" > typeof x.g && "u" > typeof x.g.WebSocket || "u" > typeof window && "u" > typeof window.WebSocket || "u" > typeof self && "u" > typeof self.WebSocket,
                a = l => l.split("?")[0],
                ex = "u" > typeof WebSocket ? WebSocket : "u" > typeof x.g && "u" > typeof x.g.WebSocket ? x.g.WebSocket : "u" > typeof window && "u" > typeof window.WebSocket ? window.WebSocket : "u" > typeof self && "u" > typeof self.WebSocket ? self.WebSocket : x(44623);
            let f = class f {
                constructor(l) {
                    if (this.url = l, this.events = new U.EventEmitter, this.registering = !1, !(0, eI.isWsUrl)(l)) throw Error(`Provided URL is not compatible with WebSocket connection: ${l}`);
                    this.url = l
                }
                get connected() {
                    return "u" > typeof this.socket
                }
                get connecting() {
                    return this.registering
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async open(l = this.url) {
                    await this.register(l)
                }
                async close() {
                    return new Promise((l, c) => {
                        if (typeof this.socket > "u") {
                            c(Error("Connection already closed"));
                            return
                        }
                        this.socket.onclose = c => {
                            this.onClose(c), l()
                        }, this.socket.close()
                    })
                }
                async send(l) {
                    typeof this.socket > "u" && (this.socket = await this.register());
                    try {
                        this.socket.send((0, en.u)(l))
                    } catch (c) {
                        this.onError(l.id, c)
                    }
                }
                register(l = this.url) {
                    if (!(0, eI.isWsUrl)(l)) throw Error(`Provided URL is not compatible with WebSocket connection: ${l}`);
                    if (this.registering) {
                        let l = this.events.getMaxListeners();
                        return (this.events.listenerCount("register_error") >= l || this.events.listenerCount("open") >= l) && this.events.setMaxListeners(l + 1), new Promise((l, c) => {
                            this.events.once("register_error", l => {
                                this.resetMaxListeners(), c(l)
                            }), this.events.once("open", () => {
                                if (this.resetMaxListeners(), typeof this.socket > "u") return c(Error("WebSocket connection is missing or invalid"));
                                l(this.socket)
                            })
                        })
                    }
                    return this.url = l, this.registering = !0, new Promise((c, x) => {
                        let N = new URLSearchParams(l).get("origin"),
                            U = (0, eI.isReactNative)() ? {
                                headers: {
                                    origin: N
                                }
                            } : {
                                rejectUnauthorized: !(0, eI.isLocalhostUrl)(l)
                            },
                            Z = new ex(l, [], U);
                        b() ? Z.onerror = l => {
                            x(this.emitError(l.error))
                        } : Z.on("error", l => {
                            x(this.emitError(l))
                        }), Z.onopen = () => {
                            this.onOpen(Z), c(Z)
                        }
                    })
                }
                onOpen(l) {
                    l.onmessage = l => this.onPayload(l), l.onclose = l => this.onClose(l), this.socket = l, this.registering = !1, this.events.emit("open")
                }
                onClose(l) {
                    this.socket = void 0, this.registering = !1, this.events.emit("close", l)
                }
                onPayload(l) {
                    if (typeof l.data > "u") return;
                    let c = "string" == typeof l.data ? (0, en.D)(l.data) : l.data;
                    this.events.emit("payload", c)
                }
                onError(l, c) {
                    let x = this.parseError(c),
                        N = x.message || x.toString(),
                        U = (0, eI.formatJsonRpcError)(l, N);
                    this.events.emit("payload", U)
                }
                parseError(l, c = this.url) {
                    return (0, eI.parseConnectionError)(l, a(c), "WS")
                }
                resetMaxListeners() {
                    this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
                }
                emitError(l) {
                    let c = this.parseError(Error(l ? .message || `WebSocket connection failed for host: ${a(this.url)}`));
                    return this.events.emit("register_error", c), c
                }
            };
            var eC = x(99780),
                e_ = x.n(eC),
                eD = x(31935),
                eS = x.n(eD),
                ek = x(25566),
                Xi = function(l, c) {
                    if (l.length >= 255) throw TypeError("Alphabet too long");
                    for (var x = new Uint8Array(256), N = 0; N < x.length; N++) x[N] = 255;
                    for (var U = 0; U < l.length; U++) {
                        var Z = l.charAt(U),
                            $ = Z.charCodeAt(0);
                        if (255 !== x[$]) throw TypeError(Z + " is ambiguous");
                        x[$] = U
                    }
                    var Y = l.length,
                        q = l.charAt(0),
                        J = Math.log(Y) / Math.log(256),
                        X = Math.log(256) / Math.log(Y);

                    function m(l) {
                        if ("string" != typeof l) throw TypeError("Expected String");
                        if (0 === l.length) return new Uint8Array;
                        var c = 0;
                        if (" " !== l[0]) {
                            for (var N = 0, U = 0; l[c] === q;) N++, c++;
                            for (var Z = (l.length - c) * J + 1 >>> 0, $ = new Uint8Array(Z); l[c];) {
                                var X = x[l.charCodeAt(c)];
                                if (255 === X) return;
                                for (var en = 0, er = Z - 1;
                                    (0 !== X || en < U) && -1 !== er; er--, en++) X += Y * $[er] >>> 0, $[er] = X % 256 >>> 0, X = X / 256 >>> 0;
                                if (0 !== X) throw Error("Non-zero carry");
                                U = en, c++
                            }
                            if (" " !== l[c]) {
                                for (var ea = Z - U; ea !== Z && 0 === $[ea];) ea++;
                                for (var eo = new Uint8Array(N + (Z - ea)), el = N; ea !== Z;) eo[el++] = $[ea++];
                                return eo
                            }
                        }
                    }
                    return {
                        encode: function(c) {
                            if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                            if (0 === c.length) return "";
                            for (var x = 0, N = 0, U = 0, Z = c.length; U !== Z && 0 === c[U];) U++, x++;
                            for (var $ = (Z - U) * X + 1 >>> 0, J = new Uint8Array($); U !== Z;) {
                                for (var en = c[U], er = 0, ea = $ - 1;
                                    (0 !== en || er < N) && -1 !== ea; ea--, er++) en += 256 * J[ea] >>> 0, J[ea] = en % Y >>> 0, en = en / Y >>> 0;
                                if (0 !== en) throw Error("Non-zero carry");
                                N = er, U++
                            }
                            for (var eo = $ - N; eo !== $ && 0 === J[eo];) eo++;
                            for (var el = q.repeat(x); eo < $; ++eo) el += l.charAt(J[eo]);
                            return el
                        },
                        decodeUnsafe: m,
                        decode: function(l) {
                            var x = m(l);
                            if (x) return x;
                            throw Error(`Non-${c} character`)
                        }
                    }
                };
            let Ue = l => {
                    if (l instanceof Uint8Array && "Uint8Array" === l.constructor.name) return l;
                    if (l instanceof ArrayBuffer) return new Uint8Array(l);
                    if (ArrayBuffer.isView(l)) return new Uint8Array(l.buffer, l.byteOffset, l.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                Wi = l => new TextEncoder().encode(l),
                Qi = l => new TextDecoder().decode(l);
            let Zi = class Zi {
                constructor(l, c, x) {
                    this.name = l, this.prefix = c, this.baseEncode = x
                }
                encode(l) {
                    if (l instanceof Uint8Array) return `${this.prefix}${this.baseEncode(l)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let es = class es {
                constructor(l, c, x) {
                    if (this.name = l, this.prefix = c, void 0 === c.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = x
                }
                decode(l) {
                    if ("string" == typeof l) {
                        if (l.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(l)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(l.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(l) {
                    return Fe(this, l)
                }
            };
            let ts = class ts {
                constructor(l) {
                    this.decoders = l
                }
                or(l) {
                    return Fe(this, l)
                }
                decode(l) {
                    let c = l[0],
                        x = this.decoders[c];
                    if (x) return x.decode(l);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(l)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let Fe = (l, c) => new ts({ ...l.decoders || {
                    [l.prefix]: l
                },
                ...c.decoders || {
                    [c.prefix]: c
                }
            });
            let is = class is {
                constructor(l, c, x, N) {
                    this.name = l, this.prefix = c, this.baseEncode = x, this.baseDecode = N, this.encoder = new Zi(l, c, x), this.decoder = new es(l, c, N)
                }
                encode(l) {
                    return this.encoder.encode(l)
                }
                decode(l) {
                    return this.decoder.decode(l)
                }
            };
            let Q = ({
                    name: l,
                    prefix: c,
                    encode: x,
                    decode: N
                }) => new is(l, c, x, N),
                V = ({
                    prefix: l,
                    name: c,
                    alphabet: x
                }) => {
                    let {
                        encode: N,
                        decode: U
                    } = Xi(x, c);
                    return Q({
                        prefix: l,
                        name: c,
                        encode: N,
                        decode: l => Ue(U(l))
                    })
                },
                ss = (l, c, x, N) => {
                    let U = {};
                    for (let l = 0; l < c.length; ++l) U[c[l]] = l;
                    let Z = l.length;
                    for (;
                        "=" === l[Z - 1];) --Z;
                    let $ = new Uint8Array(Z * x / 8 | 0),
                        Y = 0,
                        q = 0,
                        J = 0;
                    for (let c = 0; c < Z; ++c) {
                        let Z = U[l[c]];
                        if (void 0 === Z) throw SyntaxError(`Non-${N} character`);
                        q = q << x | Z, (Y += x) >= 8 && (Y -= 8, $[J++] = 255 & q >> Y)
                    }
                    if (Y >= x || 255 & q << 8 - Y) throw SyntaxError("Unexpected end of data");
                    return $
                },
                rs = (l, c, x) => {
                    let N = "=" === c[c.length - 1],
                        U = (1 << x) - 1,
                        Z = "",
                        $ = 0,
                        Y = 0;
                    for (let N = 0; N < l.length; ++N)
                        for (Y = Y << 8 | l[N], $ += 8; $ > x;) $ -= x, Z += c[U & Y >> $];
                    if ($ && (Z += c[U & Y << x - $]), N)
                        for (; Z.length * x & 7;) Z += "=";
                    return Z
                },
                index_es_y = ({
                    name: l,
                    prefix: c,
                    bitsPerChar: x,
                    alphabet: N
                }) => Q({
                    prefix: c,
                    name: l,
                    encode: l => rs(l, N, x),
                    decode: c => ss(c, N, x, l)
                }),
                eE = Q({
                    prefix: "\x00",
                    name: "identity",
                    encode: l => Qi(l),
                    decode: l => Wi(l)
                });
            var eN = Object.freeze({
                __proto__: null,
                identity: eE
            });
            let eA = index_es_y({
                prefix: "0",
                name: "base2",
                alphabet: "01",
                bitsPerChar: 1
            });
            var ej = Object.freeze({
                __proto__: null,
                base2: eA
            });
            let eO = index_es_y({
                prefix: "7",
                name: "base8",
                alphabet: "01234567",
                bitsPerChar: 3
            });
            var eP = Object.freeze({
                __proto__: null,
                base8: eO
            });
            let ez = V({
                prefix: "9",
                name: "base10",
                alphabet: "0123456789"
            });
            var eR = Object.freeze({
                __proto__: null,
                base10: ez
            });
            let eL = index_es_y({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                eB = index_es_y({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                });
            var eU = Object.freeze({
                __proto__: null,
                base16: eL,
                base16upper: eB
            });
            let eF = index_es_y({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                eW = index_es_y({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                eZ = index_es_y({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                eQ = index_es_y({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                eH = index_es_y({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                e$ = index_es_y({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                eY = index_es_y({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                eG = index_es_y({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                eV = index_es_y({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                });
            var eK = Object.freeze({
                __proto__: null,
                base32: eF,
                base32upper: eW,
                base32pad: eZ,
                base32padupper: eQ,
                base32hex: eH,
                base32hexupper: e$,
                base32hexpad: eY,
                base32hexpadupper: eG,
                base32z: eV
            });
            let eJ = V({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                eX = V({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                });
            var e0 = Object.freeze({
                __proto__: null,
                base36: eJ,
                base36upper: eX
            });
            let e2 = V({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                e1 = V({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                });
            var e5 = Object.freeze({
                __proto__: null,
                base58btc: e2,
                base58flickr: e1
            });
            let e4 = index_es_y({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                e3 = index_es_y({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                e6 = index_es_y({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                e8 = index_es_y({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                });
            var e9 = Object.freeze({
                __proto__: null,
                base64: e4,
                base64pad: e3,
                base64url: e6,
                base64urlpad: e8
            });
            let e7 = Array.from("\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                tt = e7.reduce((l, c, x) => (l[x] = c, l), []),
                tn = e7.reduce((l, c, x) => (l[c.codePointAt(0)] = x, l), []),
                tr = Q({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(l) {
                        return l.reduce((l, c) => l += tt[c], "")
                    },
                    decode: function(l) {
                        let c = [];
                        for (let x of l) {
                            let l = tn[x.codePointAt(0)];
                            if (void 0 === l) throw Error(`Non-base256emoji character: ${x}`);
                            c.push(l)
                        }
                        return new Uint8Array(c)
                    }
                });
            var ta = Object.freeze({
                __proto__: null,
                base256emoji: tr
            });

            function Me(l, c, x) {
                c = c || [], x = x || 0;
                for (var N = x; l >= 2147483648;) c[x++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[x++] = 255 & l | 128, l >>>= 7;
                return c[x] = 0 | l, Me.bytes = x - N + 1, c
            }

            function de(l, c) {
                var x, N = 0,
                    c = c || 0,
                    U = 0,
                    Z = c,
                    $ = l.length;
                do {
                    if (Z >= $) throw de.bytes = 0, RangeError("Could not decode varint");
                    x = l[Z++], N += U < 28 ? (127 & x) << U : (127 & x) * Math.pow(2, U), U += 7
                } while (x >= 128);
                return de.bytes = Z - c, N
            }
            var to = {
                encode: Me,
                decode: de,
                encodingLength: function(l) {
                    return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let Ve = (l, c, x = 0) => (to.encode(l, c, x), c),
                qe = l => to.encodingLength(l),
                ge = (l, c) => {
                    let x = c.byteLength,
                        N = qe(l),
                        U = N + qe(x),
                        Z = new Uint8Array(U + x);
                    return Ve(l, Z, 0), Ve(x, Z, N), Z.set(c, U), new or(l, x, c, Z)
                };
            let or = class or {
                constructor(l, c, x, N) {
                    this.code = l, this.size = c, this.digest = x, this.bytes = N
                }
            };
            let je = ({
                name: l,
                code: c,
                encode: x
            }) => new ar(l, c, x);
            let ar = class ar {
                constructor(l, c, x) {
                    this.name = l, this.code = c, this.encode = x
                }
                digest(l) {
                    if (l instanceof Uint8Array) {
                        let c = this.encode(l);
                        return c instanceof Uint8Array ? ge(this.code, c) : c.then(l => ge(this.code, l))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let Ge = l => async c => new Uint8Array(await crypto.subtle.digest(l, c)),
                tl = je({
                    name: "sha2-256",
                    code: 18,
                    encode: Ge("SHA-256")
                }),
                tc = je({
                    name: "sha2-512",
                    code: 19,
                    encode: Ge("SHA-512")
                });
            var tu = Object.freeze({
                    __proto__: null,
                    sha256: tl,
                    sha512: tc
                }),
                td = Object.freeze({
                    __proto__: null,
                    identity: {
                        code: 0,
                        name: "identity",
                        encode: Ue,
                        digest: l => ge(0, Ue(l))
                    }
                });
            new TextEncoder, new TextDecoder;
            let tp = { ...eN,
                ...ej,
                ...eP,
                ...eR,
                ...eU,
                ...eK,
                ...e0,
                ...e5,
                ...e9,
                ...ta
            };

            function Xe(l, c, x, N) {
                return {
                    name: l,
                    prefix: c,
                    encoder: {
                        name: l,
                        prefix: c,
                        encode: x
                    },
                    decoder: {
                        decode: N
                    }
                }
            }({ ...tu,
                ...td
            });
            let th = Xe("utf8", "u", l => "u" + new TextDecoder("utf8").decode(l), l => new TextEncoder().encode(l.substring(1))),
                ty = Xe("ascii", "a", l => {
                    let c = "a";
                    for (let x = 0; x < l.length; x++) c += String.fromCharCode(l[x]);
                    return c
                }, l => {
                    l = l.substring(1);
                    let c = function(l = 0) {
                        return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? globalThis.Buffer.allocUnsafe(l) : new Uint8Array(l)
                    }(l.length);
                    for (let x = 0; x < l.length; x++) c[x] = l.charCodeAt(x);
                    return c
                }),
                tf = {
                    utf8: th,
                    "utf-8": th,
                    hex: tp.base16,
                    latin1: ty,
                    ascii: ty,
                    binary: ty,
                    ...tp
                },
                tm = "core",
                tg = `wc@2:${tm}:`,
                tb = {
                    logger: "error"
                },
                tv = {
                    database: ":memory:"
                },
                tw = "client_ed25519_seed",
                tT = eo.ONE_DAY,
                tM = eo.SIX_HOURS,
                tI = "irn",
                tx = "wss://relay.walletconnect.com",
                tC = "wss://relay.walletconnect.org",
                t_ = {
                    message: "relayer_message",
                    message_ack: "relayer_message_ack",
                    connect: "relayer_connect",
                    disconnect: "relayer_disconnect",
                    error: "relayer_error",
                    connection_stalled: "relayer_connection_stalled",
                    transport_closed: "relayer_transport_closed",
                    publish: "relayer_publish"
                },
                tD = {
                    payload: "payload",
                    connect: "connect",
                    disconnect: "disconnect",
                    error: "error"
                },
                tS = eo.ONE_SECOND,
                tk = {
                    created: "subscription_created",
                    deleted: "subscription_deleted",
                    sync: "subscription_sync",
                    resubscribed: "subscription_resubscribed"
                },
                tE = 1e3 * eo.FIVE_SECONDS,
                tN = {
                    wc_pairingDelete: {
                        req: {
                            ttl: eo.ONE_DAY,
                            prompt: !1,
                            tag: 1e3
                        },
                        res: {
                            ttl: eo.ONE_DAY,
                            prompt: !1,
                            tag: 1001
                        }
                    },
                    wc_pairingPing: {
                        req: {
                            ttl: eo.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1002
                        },
                        res: {
                            ttl: eo.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1003
                        }
                    },
                    unregistered_method: {
                        req: {
                            ttl: eo.ONE_DAY,
                            prompt: !1,
                            tag: 0
                        },
                        res: {
                            ttl: eo.ONE_DAY,
                            prompt: !1,
                            tag: 0
                        }
                    }
                },
                tA = {
                    create: "pairing_create",
                    expire: "pairing_expire",
                    delete: "pairing_delete",
                    ping: "pairing_ping"
                },
                tj = {
                    created: "history_created",
                    updated: "history_updated",
                    deleted: "history_deleted",
                    sync: "history_sync"
                },
                tO = {
                    created: "expirer_created",
                    deleted: "expirer_deleted",
                    expired: "expirer_expired",
                    sync: "expirer_sync"
                },
                tP = "verify-api",
                tz = "https://verify.walletconnect.com",
                tR = "https://verify.walletconnect.org",
                tL = [tz, tR];
            let xt = class xt {
                constructor(l, c) {
                    this.core = l, this.logger = c, this.keychain = new Map, this.name = "keychain", this.version = "0.3", this.initialized = !1, this.storagePrefix = tg, this.init = async () => {
                        if (!this.initialized) {
                            let l = await this.getKeyChain();
                            "u" > typeof l && (this.keychain = l), this.initialized = !0
                        }
                    }, this.has = l => (this.isInitialized(), this.keychain.has(l)), this.set = async (l, c) => {
                        this.isInitialized(), this.keychain.set(l, c), await this.persist()
                    }, this.get = l => {
                        this.isInitialized();
                        let c = this.keychain.get(l);
                        if (typeof c > "u") {
                            let {
                                message: c
                            } = (0, ew.kCb)("NO_MATCHING_KEY", `${this.name}: ${l}`);
                            throw Error(c)
                        }
                        return c
                    }, this.del = async l => {
                        this.isInitialized(), this.keychain.delete(l), await this.persist()
                    }, this.core = l, this.logger = (0, ed.Ep)(c, this.name)
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                async setKeyChain(l) {
                    await this.core.storage.setItem(this.storageKey, (0, ew.KCv)(l))
                }
                async getKeyChain() {
                    let l = await this.core.storage.getItem(this.storageKey);
                    return "u" > typeof l ? (0, ew.IPd)(l) : void 0
                }
                async persist() {
                    await this.setKeyChain(this.keychain)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let Ot = class Ot {
                constructor(l, c, x) {
                    this.core = l, this.logger = c, this.name = "crypto", this.initialized = !1, this.init = async () => {
                        this.initialized || (await this.keychain.init(), this.initialized = !0)
                    }, this.hasKeys = l => (this.isInitialized(), this.keychain.has(l)), this.getClientId = async () => {
                        this.isInitialized();
                        let l = await this.getClientSeed(),
                            c = generateKeyPair(l);
                        return encodeIss(c.publicKey)
                    }, this.generateKeyPair = () => {
                        this.isInitialized();
                        let l = (0, ew.Au2)();
                        return this.setPrivateKey(l.publicKey, l.privateKey)
                    }, this.signJWT = async l => {
                        this.isInitialized();
                        let c = await this.getClientSeed(),
                            x = generateKeyPair(c),
                            N = (0, ew.jdp)();
                        return await signJWT(N, l, tT, x)
                    }, this.generateSharedKey = (l, c, x) => {
                        this.isInitialized();
                        let N = this.getPrivateKey(l),
                            U = (0, ew.m$A)(N, c);
                        return this.setSymKey(U, x)
                    }, this.setSymKey = async (l, c) => {
                        this.isInitialized();
                        let x = c || (0, ew.YmJ)(l);
                        return await this.keychain.set(x, l), x
                    }, this.deleteKeyPair = async l => {
                        this.isInitialized(), await this.keychain.del(l)
                    }, this.deleteSymKey = async l => {
                        this.isInitialized(), await this.keychain.del(l)
                    }, this.encode = async (l, c, x) => {
                        this.isInitialized();
                        let N = (0, ew.ENt)(x),
                            U = (0, en.u)(c);
                        if ((0, ew.Q8x)(N)) {
                            let c = N.senderPublicKey,
                                x = N.receiverPublicKey;
                            l = await this.generateSharedKey(c, x)
                        }
                        let Z = this.getSymKey(l),
                            {
                                type: $,
                                senderPublicKey: Y
                            } = N;
                        return (0, ew.HIp)({
                            type: $,
                            symKey: Z,
                            message: U,
                            senderPublicKey: Y
                        })
                    }, this.decode = async (l, c, x) => {
                        this.isInitialized();
                        let N = (0, ew.Llj)(c, x);
                        if ((0, ew.Q8x)(N)) {
                            let c = N.receiverPublicKey,
                                x = N.senderPublicKey;
                            l = await this.generateSharedKey(c, x)
                        }
                        try {
                            let x = this.getSymKey(l),
                                N = (0, ew.peR)({
                                    symKey: x,
                                    encoded: c
                                });
                            return (0, en.D)(N)
                        } catch (c) {
                            this.logger.error(`Failed to decode message from topic: '${l}', clientId: '${await this.getClientId()}'`), this.logger.error(c)
                        }
                    }, this.getPayloadType = l => {
                        let c = (0, ew.vBi)(l);
                        return (0, ew.WGe)(c.type)
                    }, this.getPayloadSenderPublicKey = l => {
                        let c = (0, ew.vBi)(l);
                        return c.senderPublicKey ? (0, eT.BB)(c.senderPublicKey, ew.AWt) : void 0
                    }, this.core = l, this.logger = (0, ed.Ep)(c, this.name), this.keychain = x || new xt(this.core, this.logger)
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                async setPrivateKey(l, c) {
                    return await this.keychain.set(l, c), l
                }
                getPrivateKey(l) {
                    return this.keychain.get(l)
                }
                async getClientSeed() {
                    let l = "";
                    try {
                        l = this.keychain.get(tw)
                    } catch {
                        l = (0, ew.jdp)(), await this.keychain.set(tw, l)
                    }
                    return function(l, c = "utf8") {
                        let x = tf[c];
                        if (!x) throw Error(`Unsupported encoding "${c}"`);
                        return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(l, "utf8") : x.decoder.decode(`${x.prefix}${l}`)
                    }(l, "base16")
                }
                getSymKey(l) {
                    return this.keychain.get(l)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let At = class At extends ep.kZ {
                constructor(l, c) {
                    super(l, c), this.logger = l, this.core = c, this.messages = new Map, this.name = "messages", this.version = "0.3", this.initialized = !1, this.storagePrefix = tg, this.init = async () => {
                        if (!this.initialized) {
                            this.logger.trace("Initialized");
                            try {
                                let l = await this.getRelayerMessages();
                                "u" > typeof l && (this.messages = l), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                                    type: "method",
                                    method: "restore",
                                    size: this.messages.size
                                })
                            } catch (l) {
                                this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(l)
                            } finally {
                                this.initialized = !0
                            }
                        }
                    }, this.set = async (l, c) => {
                        this.isInitialized();
                        let x = (0, ew.rjm)(c),
                            N = this.messages.get(l);
                        return typeof N > "u" && (N = {}), "u" > typeof N[x] || (N[x] = c, this.messages.set(l, N), await this.persist()), x
                    }, this.get = l => {
                        this.isInitialized();
                        let c = this.messages.get(l);
                        return typeof c > "u" && (c = {}), c
                    }, this.has = (l, c) => {
                        this.isInitialized();
                        let x = this.get(l),
                            N = (0, ew.rjm)(c);
                        return "u" > typeof x[N]
                    }, this.del = async l => {
                        this.isInitialized(), this.messages.delete(l), await this.persist()
                    }, this.logger = (0, ed.Ep)(l, this.name), this.core = c
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                async setRelayerMessages(l) {
                    await this.core.storage.setItem(this.storageKey, (0, ew.KCv)(l))
                }
                async getRelayerMessages() {
                    let l = await this.core.storage.getItem(this.storageKey);
                    return "u" > typeof l ? (0, ew.IPd)(l) : void 0
                }
                async persist() {
                    await this.setRelayerMessages(this.messages)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let vr = class vr extends ep.z9 {
                constructor(l, c) {
                    super(l, c), this.relayer = l, this.logger = c, this.events = new U.EventEmitter, this.name = "publisher", this.queue = new Map, this.publishTimeout = (0, eo.toMiliseconds)(eo.ONE_MINUTE), this.failedPublishTimeout = (0, eo.toMiliseconds)(eo.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (l, c, x) => {
                        var N;
                        this.logger.debug("Publishing Payload"), this.logger.trace({
                            type: "method",
                            method: "publish",
                            params: {
                                topic: l,
                                message: c,
                                opts: x
                            }
                        });
                        let U = x ? .ttl || tM,
                            Z = (0, ew._HE)(x),
                            $ = x ? .prompt || !1,
                            Y = x ? .tag || 0,
                            q = x ? .id || (0, eI.getBigIntRpcId)().toString(),
                            J = {
                                topic: l,
                                message: c,
                                opts: {
                                    ttl: U,
                                    relay: Z,
                                    prompt: $,
                                    tag: Y,
                                    id: q
                                }
                            },
                            X = `Failed to publish payload, please try again. id:${q} tag:${Y}`,
                            en = Date.now(),
                            er, ea = 1;
                        try {
                            for (; void 0 === er;) {
                                if (Date.now() - en > this.publishTimeout) throw Error(X);
                                this.logger.trace({
                                    id: q,
                                    attempts: ea
                                }, `publisher.publish - attempt ${ea}`), er = await await (0, ew.hFY)(this.rpcPublish(l, c, U, Z, $, Y, q).catch(l => this.logger.warn(l)), this.publishTimeout, X), ea++, er || await new Promise(l => setTimeout(l, this.failedPublishTimeout))
                            }
                            this.relayer.events.emit(t_.publish, J), this.logger.debug("Successfully Published Payload"), this.logger.trace({
                                type: "method",
                                method: "publish",
                                params: {
                                    id: q,
                                    topic: l,
                                    message: c,
                                    opts: x
                                }
                            })
                        } catch (l) {
                            if (this.logger.debug("Failed to Publish Payload"), this.logger.error(l), null != (N = x ? .internal) && N.throwOnFailedPublish) throw l;
                            this.queue.set(q, J)
                        }
                    }, this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.relayer = l, this.logger = (0, ed.Ep)(c, this.name), this.registerEventListeners()
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                rpcPublish(l, c, x, N, U, Z, $) {
                    var Y, q, J, X;
                    let en = {
                        method: (0, ew.cOS)(N.protocol).publish,
                        params: {
                            topic: l,
                            message: c,
                            ttl: x,
                            prompt: U,
                            tag: Z
                        },
                        id: $
                    };
                    return (0, ew.o8e)(null == (Y = en.params) ? void 0 : Y.prompt) && (null == (q = en.params) || delete q.prompt), (0, ew.o8e)(null == (J = en.params) ? void 0 : J.tag) && (null == (X = en.params) || delete X.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "message",
                        direction: "outgoing",
                        request: en
                    }), this.relayer.request(en)
                }
                removeRequestFromQueue(l) {
                    this.queue.delete(l)
                }
                checkQueue() {
                    this.queue.forEach(async l => {
                        let {
                            topic: c,
                            message: x,
                            opts: N
                        } = l;
                        await this.publish(c, x, N)
                    })
                }
                registerEventListeners() {
                    this.relayer.core.heartbeat.on(eu.pulse, () => {
                        if (this.needsTransportRestart) {
                            this.needsTransportRestart = !1, this.relayer.events.emit(t_.connection_stalled);
                            return
                        }
                        this.checkQueue()
                    }), this.relayer.on(t_.message_ack, l => {
                        this.removeRequestFromQueue(l.id.toString())
                    })
                }
            };
            let Ir = class Ir {
                constructor() {
                    this.map = new Map, this.set = (l, c) => {
                        let x = this.get(l);
                        this.exists(l, c) || this.map.set(l, [...x, c])
                    }, this.get = l => this.map.get(l) || [], this.exists = (l, c) => this.get(l).includes(c), this.delete = (l, c) => {
                        if (typeof c > "u") {
                            this.map.delete(l);
                            return
                        }
                        if (!this.map.has(l)) return;
                        let x = this.get(l);
                        if (!this.exists(l, c)) return;
                        let N = x.filter(l => l !== c);
                        if (!N.length) {
                            this.map.delete(l);
                            return
                        }
                        this.map.set(l, N)
                    }, this.clear = () => {
                        this.map.clear()
                    }
                }
                get topics() {
                    return Array.from(this.map.keys())
                }
            };
            var tB = Object.defineProperty,
                tU = Object.defineProperties,
                tF = Object.getOwnPropertyDescriptors,
                tW = Object.getOwnPropertySymbols,
                tZ = Object.prototype.hasOwnProperty,
                tQ = Object.prototype.propertyIsEnumerable,
                Nt = (l, c, x) => c in l ? tB(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                index_es_j = (l, c) => {
                    for (var x in c || (c = {})) tZ.call(c, x) && Nt(l, x, c[x]);
                    if (tW)
                        for (var x of tW(c)) tQ.call(c, x) && Nt(l, x, c[x]);
                    return l
                },
                fe = (l, c) => tU(l, tF(c));
            let Lt = class Lt extends ep.sY {
                constructor(l, c) {
                    super(l, c), this.relayer = l, this.logger = c, this.subscriptions = new Map, this.topicMap = new Ir, this.events = new U.EventEmitter, this.name = "subscription", this.version = "0.3", this.pending = new Map, this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = tg, this.subscribeTimeout = (0, eo.toMiliseconds)(eo.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId())
                    }, this.subscribe = async (l, c) => {
                        await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                            type: "method",
                            method: "subscribe",
                            params: {
                                topic: l,
                                opts: c
                            }
                        });
                        try {
                            let x = (0, ew._HE)(c),
                                N = {
                                    topic: l,
                                    relay: x
                                };
                            this.pending.set(l, N);
                            let U = await this.rpcSubscribe(l, x);
                            return "string" == typeof U && (this.onSubscribe(U, N), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                                type: "method",
                                method: "subscribe",
                                params: {
                                    topic: l,
                                    opts: c
                                }
                            })), U
                        } catch (l) {
                            throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(l), l
                        }
                    }, this.unsubscribe = async (l, c) => {
                        await this.restartToComplete(), this.isInitialized(), "u" > typeof c ? .id ? await this.unsubscribeById(l, c.id, c) : await this.unsubscribeByTopic(l, c)
                    }, this.isSubscribed = async l => {
                        if (this.topics.includes(l)) return !0;
                        let c = `${this.pendingSubscriptionWatchLabel}_${l}`;
                        return await new Promise((x, N) => {
                            let U = new eo.Watch;
                            U.start(c);
                            let Z = setInterval(() => {
                                !this.pending.has(l) && this.topics.includes(l) && (clearInterval(Z), U.stop(c), x(!0)), U.elapsed(c) >= tE && (clearInterval(Z), U.stop(c), N(Error("Subscription resolution timeout")))
                            }, this.pollingInterval)
                        }).catch(() => !1)
                    }, this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.start = async () => {
                        await this.onConnect()
                    }, this.stop = async () => {
                        await this.onDisconnect()
                    }, this.restart = async () => {
                        this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1
                    }, this.relayer = l, this.logger = (0, ed.Ep)(c, this.name), this.clientId = ""
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.subscriptions.size
                }
                get ids() {
                    return Array.from(this.subscriptions.keys())
                }
                get values() {
                    return Array.from(this.subscriptions.values())
                }
                get topics() {
                    return this.topicMap.topics
                }
                hasSubscription(l, c) {
                    let x = !1;
                    try {
                        x = this.getSubscription(l).topic === c
                    } catch {}
                    return x
                }
                onEnable() {
                    this.cached = [], this.initialized = !0
                }
                onDisable() {
                    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear()
                }
                async unsubscribeByTopic(l, c) {
                    let x = this.topicMap.get(l);
                    await Promise.all(x.map(async x => await this.unsubscribeById(l, x, c)))
                }
                async unsubscribeById(l, c, x) {
                    this.logger.debug("Unsubscribing Topic"), this.logger.trace({
                        type: "method",
                        method: "unsubscribe",
                        params: {
                            topic: l,
                            id: c,
                            opts: x
                        }
                    });
                    try {
                        let N = (0, ew._HE)(x);
                        await this.rpcUnsubscribe(l, c, N);
                        let U = (0, ew.D6H)("USER_DISCONNECTED", `${this.name}, ${l}`);
                        await this.onUnsubscribe(l, c, U), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                            type: "method",
                            method: "unsubscribe",
                            params: {
                                topic: l,
                                id: c,
                                opts: x
                            }
                        })
                    } catch (l) {
                        throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(l), l
                    }
                }
                async rpcSubscribe(l, c) {
                    let x = {
                        method: (0, ew.cOS)(c.protocol).subscribe,
                        params: {
                            topic: l
                        }
                    };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: x
                    });
                    try {
                        return await await (0, ew.hFY)(this.relayer.request(x).catch(l => this.logger.warn(l)), this.subscribeTimeout) ? (0, ew.rjm)(l + this.clientId) : null
                    } catch {
                        this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(t_.connection_stalled)
                    }
                    return null
                }
                async rpcBatchSubscribe(l) {
                    if (!l.length) return;
                    let c = l[0].relay,
                        x = {
                            method: (0, ew.cOS)(c.protocol).batchSubscribe,
                            params: {
                                topics: l.map(l => l.topic)
                            }
                        };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: x
                    });
                    try {
                        return await await (0, ew.hFY)(this.relayer.request(x).catch(l => this.logger.warn(l)), this.subscribeTimeout)
                    } catch {
                        this.relayer.events.emit(t_.connection_stalled)
                    }
                }
                async rpcBatchFetchMessages(l) {
                    let c;
                    if (!l.length) return;
                    let x = l[0].relay,
                        N = {
                            method: (0, ew.cOS)(x.protocol).batchFetchMessages,
                            params: {
                                topics: l.map(l => l.topic)
                            }
                        };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: N
                    });
                    try {
                        c = await await (0, ew.hFY)(this.relayer.request(N).catch(l => this.logger.warn(l)), this.subscribeTimeout)
                    } catch {
                        this.relayer.events.emit(t_.connection_stalled)
                    }
                    return c
                }
                rpcUnsubscribe(l, c, x) {
                    let N = {
                        method: (0, ew.cOS)(x.protocol).unsubscribe,
                        params: {
                            topic: l,
                            id: c
                        }
                    };
                    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: N
                    }), this.relayer.request(N)
                }
                onSubscribe(l, c) {
                    this.setSubscription(l, fe(index_es_j({}, c), {
                        id: l
                    })), this.pending.delete(c.topic)
                }
                onBatchSubscribe(l) {
                    l.length && l.forEach(l => {
                        this.setSubscription(l.id, index_es_j({}, l)), this.pending.delete(l.topic)
                    })
                }
                async onUnsubscribe(l, c, x) {
                    this.events.removeAllListeners(c), this.hasSubscription(c, l) && this.deleteSubscription(c, x), await this.relayer.messages.del(l)
                }
                async setRelayerSubscriptions(l) {
                    await this.relayer.core.storage.setItem(this.storageKey, l)
                }
                async getRelayerSubscriptions() {
                    return await this.relayer.core.storage.getItem(this.storageKey)
                }
                setSubscription(l, c) {
                    this.logger.debug("Setting subscription"), this.logger.trace({
                        type: "method",
                        method: "setSubscription",
                        id: l,
                        subscription: c
                    }), this.addSubscription(l, c)
                }
                addSubscription(l, c) {
                    this.subscriptions.set(l, index_es_j({}, c)), this.topicMap.set(c.topic, l), this.events.emit(tk.created, c)
                }
                getSubscription(l) {
                    this.logger.debug("Getting subscription"), this.logger.trace({
                        type: "method",
                        method: "getSubscription",
                        id: l
                    });
                    let c = this.subscriptions.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = (0, ew.kCb)("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw Error(c)
                    }
                    return c
                }
                deleteSubscription(l, c) {
                    this.logger.debug("Deleting subscription"), this.logger.trace({
                        type: "method",
                        method: "deleteSubscription",
                        id: l,
                        reason: c
                    });
                    let x = this.getSubscription(l);
                    this.subscriptions.delete(l), this.topicMap.delete(x.topic, l), this.events.emit(tk.deleted, fe(index_es_j({}, x), {
                        reason: c
                    }))
                }
                async persist() {
                    await this.setRelayerSubscriptions(this.values), this.events.emit(tk.sync)
                }
                async reset() {
                    if (this.cached.length) {
                        let l = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
                        for (let c = 0; c < l; c++) {
                            let l = this.cached.splice(0, this.batchSubscribeTopicsLimit);
                            await this.batchFetchMessages(l), await this.batchSubscribe(l)
                        }
                    }
                    this.events.emit(tk.resubscribed)
                }
                async restore() {
                    try {
                        let l = await this.getRelayerSubscriptions();
                        if (typeof l > "u" || !l.length) return;
                        if (this.subscriptions.size) {
                            let {
                                message: l
                            } = (0, ew.kCb)("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            subscriptions: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(l)
                    }
                }
                async batchSubscribe(l) {
                    if (!l.length) return;
                    let c = await this.rpcBatchSubscribe(l);
                    (0, ew.qt8)(c) && this.onBatchSubscribe(c.map((c, x) => fe(index_es_j({}, l[x]), {
                        id: c
                    })))
                }
                async batchFetchMessages(l) {
                    if (!l.length) return;
                    this.logger.trace(`Fetching batch messages for ${l.length} subscriptions`);
                    let c = await this.rpcBatchFetchMessages(l);
                    c && c.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(c.messages))
                }
                async onConnect() {
                    await this.restart(), this.onEnable()
                }
                onDisconnect() {
                    this.onDisable()
                }
                async checkPending() {
                    if (!this.initialized || !this.relayer.connected) return;
                    let l = [];
                    this.pending.forEach(c => {
                        l.push(c)
                    }), await this.batchSubscribe(l), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = [])
                }
                registerEventListeners() {
                    this.relayer.core.heartbeat.on(eu.pulse, async () => {
                        await this.checkPending()
                    }), this.events.on(tk.created, async l => {
                        let c = tk.created;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), await this.persist()
                    }), this.events.on(tk.deleted, async l => {
                        let c = tk.deleted;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), await this.persist()
                    })
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                async restartToComplete() {
                    this.restartInProgress && await new Promise(l => {
                        let c = setInterval(() => {
                            this.restartInProgress || (clearInterval(c), l())
                        }, this.pollingInterval)
                    })
                }
            };
            var tH = Object.defineProperty,
                t$ = Object.getOwnPropertySymbols,
                tY = Object.prototype.hasOwnProperty,
                tq = Object.prototype.propertyIsEnumerable,
                Ft = (l, c, x) => c in l ? tH(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                Ar = (l, c) => {
                    for (var x in c || (c = {})) tY.call(c, x) && Ft(l, x, c[x]);
                    if (t$)
                        for (var x of t$(c)) tq.call(c, x) && Ft(l, x, c[x]);
                    return l
                };
            let $t = class $t extends ep.oe {
                constructor(l) {
                    super(l), this.protocol = "wc", this.version = 2, this.events = new U.EventEmitter, this.name = "relayer", this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = new Map, this.heartBeatTimeout = (0, eo.toMiliseconds)(eo.THIRTY_SECONDS + eo.ONE_SECOND), this.request = async l => {
                        var c, x;
                        this.logger.debug("Publishing Request Payload");
                        let N = l.id || (0, eI.getBigIntRpcId)().toString();
                        await this.toEstablishConnection();
                        try {
                            let U = this.provider.request(l);
                            this.requestsInFlight.set(N, {
                                promise: U,
                                request: l
                            }), this.logger.trace({
                                id: N,
                                method: l.method,
                                topic: null == (c = l.params) ? void 0 : c.topic
                            }, "relayer.request - attempt to publish...");
                            let Z = await new Promise(async (l, c) => {
                                let d = () => {
                                    c(Error(`relayer.request - publish interrupted, id: ${N}`))
                                };
                                this.provider.on(tD.disconnect, d);
                                let x = await U;
                                this.provider.off(tD.disconnect, d), l(x)
                            });
                            return this.logger.trace({
                                id: N,
                                method: l.method,
                                topic: null == (x = l.params) ? void 0 : x.topic
                            }, "relayer.request - published"), Z
                        } catch (l) {
                            throw this.logger.debug(`Failed to Publish Request: ${N}`), l
                        } finally {
                            this.requestsInFlight.delete(N)
                        }
                    }, this.resetPingTimeout = () => {
                        if ((0, ew.UGU)()) try {
                            clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
                                var l, c, x;
                                null == (x = null == (c = null == (l = this.provider) ? void 0 : l.connection) ? void 0 : c.socket) || x.terminate()
                            }, this.heartBeatTimeout)
                        } catch (l) {
                            this.logger.warn(l)
                        }
                    }, this.onPayloadHandler = l => {
                        this.onProviderPayload(l), this.resetPingTimeout()
                    }, this.onConnectHandler = () => {
                        this.startPingTimeout(), this.events.emit(t_.connect)
                    }, this.onDisconnectHandler = () => {
                        this.onProviderDisconnect()
                    }, this.onProviderErrorHandler = l => {
                        this.logger.error(l), this.events.emit(t_.error, l), this.logger.info("Fatal socket error received, closing transport"), this.transportClose()
                    }, this.registerProviderListeners = () => {
                        this.provider.on(tD.payload, this.onPayloadHandler), this.provider.on(tD.connect, this.onConnectHandler), this.provider.on(tD.disconnect, this.onDisconnectHandler), this.provider.on(tD.error, this.onProviderErrorHandler)
                    }, this.core = l.core, this.logger = "u" > typeof l.logger && "string" != typeof l.logger ? (0, ed.Ep)(l.logger, this.name) : (0, ed.gw)((0, ed.jI)({
                        level: l.logger || "error"
                    })), this.messages = new At(this.logger, l.core), this.subscriber = new Lt(this, this.logger), this.publisher = new vr(this, this.logger), this.relayUrl = l ? .relayUrl || tx, this.projectId = l.projectId, this.bundleId = (0, ew.X_B)(), this.provider = {}
                }
                async init() {
                    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]);
                    try {
                        await this.transportOpen()
                    } catch {
                        this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${tC}...`), await this.restartTransport(tC)
                    }
                    this.initialized = !0, setTimeout(async () => {
                        0 === this.subscriber.topics.length && 0 === this.subscriber.pending.size && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1)
                    }, 1e4)
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get connected() {
                    var l, c, x;
                    return (null == (x = null == (c = null == (l = this.provider) ? void 0 : l.connection) ? void 0 : c.socket) ? void 0 : x.readyState) === 1
                }
                get connecting() {
                    var l, c, x;
                    return (null == (x = null == (c = null == (l = this.provider) ? void 0 : l.connection) ? void 0 : c.socket) ? void 0 : x.readyState) === 0
                }
                async publish(l, c, x) {
                    this.isInitialized(), await this.publisher.publish(l, c, x), await this.recordMessageEvent({
                        topic: l,
                        message: c,
                        publishedAt: Date.now()
                    })
                }
                async subscribe(l, c) {
                    var x;
                    this.isInitialized();
                    let N = (null == (x = this.subscriber.topicMap.get(l)) ? void 0 : x[0]) || "",
                        U, n = c => {
                            c.topic === l && (this.subscriber.off(tk.created, n), U())
                        };
                    return await Promise.all([new Promise(l => {
                        U = l, this.subscriber.on(tk.created, n)
                    }), new Promise(async x => {
                        N = await this.subscriber.subscribe(l, c) || N, x()
                    })]), N
                }
                async unsubscribe(l, c) {
                    this.isInitialized(), await this.subscriber.unsubscribe(l, c)
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async transportDisconnect() {
                    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
                        await Promise.all(Array.from(this.requestsInFlight.values()).map(l => l.promise))
                    } catch (l) {
                        this.logger.warn(l)
                    }
                    this.hasExperiencedNetworkDisruption || this.connected ? await (0, ew.hFY)(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect()
                }
                async transportClose() {
                    this.transportExplicitlyClosed = !0, await this.transportDisconnect()
                }
                async transportOpen(l) {
                    await this.confirmOnlineStateOrThrow(), l && l !== this.relayUrl && (this.relayUrl = l, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
                    try {
                        await new Promise(async (l, c) => {
                            let s = () => {
                                this.provider.off(tD.disconnect, s), c(Error("Connection interrupted while trying to subscribe"))
                            };
                            this.provider.on(tD.disconnect, s), await (0, ew.hFY)(this.provider.connect(), (0, eo.toMiliseconds)(eo.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch(l => {
                                c(l)
                            }), await this.subscriber.start(), this.hasExperiencedNetworkDisruption = !1, l()
                        })
                    } catch (l) {
                        if (this.logger.error(l), this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(l.message)) throw l
                    } finally {
                        this.connectionAttemptInProgress = !1
                    }
                }
                async restartTransport(l) {
                    this.connectionAttemptInProgress || (this.relayUrl = l || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen())
                }
                async confirmOnlineStateOrThrow() {
                    if (!await (0, ew.Ggh)()) throw Error("No internet connection detected. Please restart your network and try again.")
                }
                async handleBatchMessageEvents(l) {
                    if (l ? .length === 0) {
                        this.logger.trace("Batch message events is empty. Ignoring...");
                        return
                    }
                    let c = l.sort((l, c) => l.publishedAt - c.publishedAt);
                    for (let l of (this.logger.trace(`Batch of ${c.length} message events sorted`), c)) try {
                        await this.onMessageEvent(l)
                    } catch (l) {
                        this.logger.warn(l)
                    }
                    this.logger.trace(`Batch of ${c.length} message events processed`)
                }
                startPingTimeout() {
                    var l, c, x, N, U;
                    if ((0, ew.UGU)()) try {
                        null != (c = null == (l = this.provider) ? void 0 : l.connection) && c.socket && (null == (U = null == (N = null == (x = this.provider) ? void 0 : x.connection) ? void 0 : N.socket) || U.once("ping", () => {
                            this.resetPingTimeout()
                        })), this.resetPingTimeout()
                    } catch (l) {
                        this.logger.warn(l)
                    }
                }
                isConnectionStalled(l) {
                    return this.staleConnectionErrors.some(c => l.includes(c))
                }
                async createProvider() {
                    this.provider.connection && this.unregisterProviderListeners();
                    let l = await this.core.crypto.signJWT(this.relayUrl);
                    this.provider = new eM.r(new f((0, ew.$0m)({
                        sdkVersion: "2.13.1",
                        protocol: this.protocol,
                        version: this.version,
                        relayUrl: this.relayUrl,
                        projectId: this.projectId,
                        auth: l,
                        useOnCloseEvent: !0,
                        bundleId: this.bundleId
                    }))), this.registerProviderListeners()
                }
                async recordMessageEvent(l) {
                    let {
                        topic: c,
                        message: x
                    } = l;
                    await this.messages.set(c, x)
                }
                async shouldIgnoreMessageEvent(l) {
                    let {
                        topic: c,
                        message: x
                    } = l;
                    if (!x || 0 === x.length) return this.logger.debug(`Ignoring invalid/empty message: ${x}`), !0;
                    if (!await this.subscriber.isSubscribed(c)) return this.logger.debug(`Ignoring message for non-subscribed topic ${c}`), !0;
                    let N = this.messages.has(c, x);
                    return N && this.logger.debug(`Ignoring duplicate message: ${x}`), N
                }
                async onProviderPayload(l) {
                    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                            type: "payload",
                            direction: "incoming",
                            payload: l
                        }), (0, eI.isJsonRpcRequest)(l)) {
                        if (!l.method.endsWith("_subscription")) return;
                        let c = l.params,
                            {
                                topic: x,
                                message: N,
                                publishedAt: U
                            } = c.data,
                            Z = {
                                topic: x,
                                message: N,
                                publishedAt: U
                            };
                        this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Ar({
                            type: "event",
                            event: c.id
                        }, Z)), this.events.emit(c.id, Z), await this.acknowledgePayload(l), await this.onMessageEvent(Z)
                    } else(0, eI.isJsonRpcResponse)(l) && this.events.emit(t_.message_ack, l)
                }
                async onMessageEvent(l) {
                    await this.shouldIgnoreMessageEvent(l) || (this.events.emit(t_.message, l), await this.recordMessageEvent(l))
                }
                async acknowledgePayload(l) {
                    let c = (0, eI.formatJsonRpcResult)(l.id, !0);
                    await this.provider.connection.send(c)
                }
                unregisterProviderListeners() {
                    this.provider.off(tD.payload, this.onPayloadHandler), this.provider.off(tD.connect, this.onConnectHandler), this.provider.off(tD.disconnect, this.onDisconnectHandler), this.provider.off(tD.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout)
                }
                async registerEventListeners() {
                    let l = await (0, ew.Ggh)();
                    (0, ew.uwg)(async c => {
                        l !== c && (l = c, c ? await this.restartTransport().catch(l => this.logger.error(l)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1))
                    })
                }
                async onProviderDisconnect() {
                    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(t_.disconnect), this.connectionAttemptInProgress = !1, this.transportExplicitlyClosed || setTimeout(async () => {
                        await this.transportOpen().catch(l => this.logger.error(l))
                    }, (0, eo.toMiliseconds)(tS))
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                async toEstablishConnection() {
                    await this.confirmOnlineStateOrThrow(), this.connected || (this.connectionAttemptInProgress && await new Promise(l => {
                        let c = setInterval(() => {
                            this.connected && (clearInterval(c), l())
                        }, this.connectionStatusPollingInterval)
                    }), await this.transportOpen())
                }
            };
            var tG = Object.defineProperty,
                tV = Object.getOwnPropertySymbols,
                tK = Object.prototype.hasOwnProperty,
                tJ = Object.prototype.propertyIsEnumerable,
                Mt = (l, c, x) => c in l ? tG(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                kt = (l, c) => {
                    for (var x in c || (c = {})) tK.call(c, x) && Mt(l, x, c[x]);
                    if (tV)
                        for (var x of tV(c)) tJ.call(c, x) && Mt(l, x, c[x]);
                    return l
                };
            let Kt = class Kt extends ep.pZ {
                constructor(l, c, x, N = tg, U) {
                    super(l, c, x, N), this.core = l, this.logger = c, this.name = x, this.map = new Map, this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = tg, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => {
                            this.getKey && null !== l && !(0, ew.o8e)(l) ? this.map.set(this.getKey(l), l) : (0, ew.xWS)(l) ? this.map.set(l.id, l) : (0, ew.h1R)(l) && this.map.set(l.topic, l)
                        }), this.cached = [], this.initialized = !0)
                    }, this.set = async (l, c) => {
                        this.isInitialized(), this.map.has(l) ? await this.update(l, c) : (this.logger.debug("Setting value"), this.logger.trace({
                            type: "method",
                            method: "set",
                            key: l,
                            value: c
                        }), this.map.set(l, c), await this.persist())
                    }, this.get = l => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
                        type: "method",
                        method: "get",
                        key: l
                    }), this.getData(l)), this.getAll = l => (this.isInitialized(), l ? this.values.filter(c => Object.keys(l).every(x => e_()(c[x], l[x]))) : this.values), this.update = async (l, c) => {
                        this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                            type: "method",
                            method: "update",
                            key: l,
                            update: c
                        });
                        let x = kt(kt({}, this.getData(l)), c);
                        this.map.set(l, x), await this.persist()
                    }, this.delete = async (l, c) => {
                        this.isInitialized(), this.map.has(l) && (this.logger.debug("Deleting value"), this.logger.trace({
                            type: "method",
                            method: "delete",
                            key: l,
                            reason: c
                        }), this.map.delete(l), this.addToRecentlyDeleted(l), await this.persist())
                    }, this.logger = (0, ed.Ep)(c, this.name), this.storagePrefix = N, this.getKey = U
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.map.size
                }
                get keys() {
                    return Array.from(this.map.keys())
                }
                get values() {
                    return Array.from(this.map.values())
                }
                addToRecentlyDeleted(l) {
                    this.recentlyDeleted.push(l), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
                }
                async setDataStore(l) {
                    await this.core.storage.setItem(this.storageKey, l)
                }
                async getDataStore() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                getData(l) {
                    let c = this.map.get(l);
                    if (!c) {
                        if (this.recentlyDeleted.includes(l)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${l}`);
                            throw this.logger.error(c), Error(c)
                        }
                        let {
                            message: c
                        } = (0, ew.kCb)("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw this.logger.error(c), Error(c)
                    }
                    return c
                }
                async persist() {
                    await this.setDataStore(this.values)
                }
                async restore() {
                    try {
                        let l = await this.getDataStore();
                        if (typeof l > "u" || !l.length) return;
                        if (this.map.size) {
                            let {
                                message: l
                            } = (0, ew.kCb)("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            value: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(l)
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let Vt = class Vt {
                constructor(l, c) {
                    this.core = l, this.logger = c, this.name = "pairing", this.version = "0.3", this.events = new(Z()), this.initialized = !1, this.storagePrefix = tg, this.ignoredPayloadTypes = [ew.rVF], this.registeredMethods = [], this.init = async () => {
                        this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
                    }, this.register = ({
                        methods: l
                    }) => {
                        this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...l])]
                    }, this.create = async l => {
                        this.isInitialized();
                        let c = (0, ew.jdp)(),
                            x = await this.core.crypto.setSymKey(c),
                            N = (0, ew.gn4)(eo.FIVE_MINUTES),
                            U = {
                                protocol: tI
                            },
                            Z = (0, ew.Bvr)({
                                protocol: this.core.protocol,
                                version: this.core.version,
                                topic: x,
                                symKey: c,
                                relay: U,
                                expiryTimestamp: N,
                                methods: l ? .methods
                            });
                        return this.core.expirer.set(x, N), await this.pairings.set(x, {
                            topic: x,
                            expiry: N,
                            relay: U,
                            active: !1
                        }), await this.core.relayer.subscribe(x), {
                            topic: x,
                            uri: Z
                        }
                    }, this.pair = async l => {
                        this.isInitialized(), this.isValidPair(l);
                        let {
                            topic: c,
                            symKey: x,
                            relay: N,
                            expiryTimestamp: U,
                            methods: Z
                        } = (0, ew.heJ)(l.uri);
                        if (this.pairings.keys.includes(c) && this.pairings.get(c).active) throw Error(`Pairing already exists: ${c}. Please try again with a new connection URI.`);
                        let $ = U || (0, ew.gn4)(eo.FIVE_MINUTES),
                            Y = {
                                topic: c,
                                relay: N,
                                expiry: $,
                                active: !1,
                                methods: Z
                            };
                        return this.core.expirer.set(c, $), await this.pairings.set(c, Y), l.activatePairing && await this.activate({
                            topic: c
                        }), this.events.emit(tA.create, Y), this.core.crypto.keychain.has(c) || await this.core.crypto.setSymKey(x, c), await this.core.relayer.subscribe(c, {
                            relay: N
                        }), Y
                    }, this.activate = async ({
                        topic: l
                    }) => {
                        this.isInitialized();
                        let c = (0, ew.gn4)(eo.THIRTY_DAYS);
                        this.core.expirer.set(l, c), await this.pairings.update(l, {
                            active: !0,
                            expiry: c
                        })
                    }, this.ping = async l => {
                        this.isInitialized(), await this.isValidPing(l);
                        let {
                            topic: c
                        } = l;
                        if (this.pairings.keys.includes(c)) {
                            let l = await this.sendRequest(c, "wc_pairingPing", {}),
                                {
                                    done: x,
                                    resolve: N,
                                    reject: U
                                } = (0, ew.H1S)();
                            this.events.once((0, ew.E0T)("pairing_ping", l), ({
                                error: l
                            }) => {
                                l ? U(l) : N()
                            }), await x()
                        }
                    }, this.updateExpiry = async ({
                        topic: l,
                        expiry: c
                    }) => {
                        this.isInitialized(), await this.pairings.update(l, {
                            expiry: c
                        })
                    }, this.updateMetadata = async ({
                        topic: l,
                        metadata: c
                    }) => {
                        this.isInitialized(), await this.pairings.update(l, {
                            peerMetadata: c
                        })
                    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async l => {
                        this.isInitialized(), await this.isValidDisconnect(l);
                        let {
                            topic: c
                        } = l;
                        this.pairings.keys.includes(c) && (await this.sendRequest(c, "wc_pairingDelete", (0, ew.D6H)("USER_DISCONNECTED")), await this.deletePairing(c))
                    }, this.sendRequest = async (l, c, x) => {
                        let N = (0, eI.formatJsonRpcRequest)(c, x),
                            U = await this.core.crypto.encode(l, N),
                            Z = tN[c].req;
                        return this.core.history.set(l, N), this.core.relayer.publish(l, U, Z), N.id
                    }, this.sendResult = async (l, c, x) => {
                        let N = (0, eI.formatJsonRpcResult)(l, x),
                            U = await this.core.crypto.encode(c, N),
                            Z = await this.core.history.get(c, l),
                            $ = tN[Z.request.method].res;
                        await this.core.relayer.publish(c, U, $), await this.core.history.resolve(N)
                    }, this.sendError = async (l, c, x) => {
                        let N = (0, eI.formatJsonRpcError)(l, x),
                            U = await this.core.crypto.encode(c, N),
                            Z = await this.core.history.get(c, l),
                            $ = tN[Z.request.method] ? tN[Z.request.method].res : tN.unregistered_method.res;
                        await this.core.relayer.publish(c, U, $), await this.core.history.resolve(N)
                    }, this.deletePairing = async (l, c) => {
                        await this.core.relayer.unsubscribe(l), await Promise.all([this.pairings.delete(l, (0, ew.D6H)("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(l), c ? Promise.resolve() : this.core.expirer.del(l)])
                    }, this.cleanup = async () => {
                        let l = this.pairings.getAll().filter(l => (0, ew.BwD)(l.expiry));
                        await Promise.all(l.map(l => this.deletePairing(l.topic)))
                    }, this.onRelayEventRequest = l => {
                        let {
                            topic: c,
                            payload: x
                        } = l;
                        switch (x.method) {
                            case "wc_pairingPing":
                                return this.onPairingPingRequest(c, x);
                            case "wc_pairingDelete":
                                return this.onPairingDeleteRequest(c, x);
                            default:
                                return this.onUnknownRpcMethodRequest(c, x)
                        }
                    }, this.onRelayEventResponse = async l => {
                        let {
                            topic: c,
                            payload: x
                        } = l, N = (await this.core.history.get(c, x.id)).request.method;
                        return "wc_pairingPing" === N ? this.onPairingPingResponse(c, x) : this.onUnknownRpcMethodResponse(N)
                    }, this.onPairingPingRequest = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        try {
                            this.isValidPing({
                                topic: l
                            }), await this.sendResult(x, l, !0), this.events.emit(tA.ping, {
                                id: x,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError(x, l, c), this.logger.error(c)
                        }
                    }, this.onPairingPingResponse = (l, c) => {
                        let {
                            id: x
                        } = c;
                        setTimeout(() => {
                            (0, eI.isJsonRpcResult)(c) ? this.events.emit((0, ew.E0T)("pairing_ping", x), {}): (0, eI.isJsonRpcError)(c) && this.events.emit((0, ew.E0T)("pairing_ping", x), {
                                error: c.error
                            })
                        }, 500)
                    }, this.onPairingDeleteRequest = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        try {
                            this.isValidDisconnect({
                                topic: l
                            }), await this.deletePairing(l), this.events.emit(tA.delete, {
                                id: x,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError(x, l, c), this.logger.error(c)
                        }
                    }, this.onUnknownRpcMethodRequest = async (l, c) => {
                        let {
                            id: x,
                            method: N
                        } = c;
                        try {
                            if (this.registeredMethods.includes(N)) return;
                            let c = (0, ew.D6H)("WC_METHOD_UNSUPPORTED", N);
                            await this.sendError(x, l, c), this.logger.error(c)
                        } catch (c) {
                            await this.sendError(x, l, c), this.logger.error(c)
                        }
                    }, this.onUnknownRpcMethodResponse = l => {
                        this.registeredMethods.includes(l) || this.logger.error((0, ew.D6H)("WC_METHOD_UNSUPPORTED", l))
                    }, this.isValidPair = l => {
                        var c;
                        if (!(0, ew.EJd)(l)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("MISSING_OR_INVALID", `pair() params: ${l}`);
                            throw Error(c)
                        }
                        if (!(0, ew.jvJ)(l.uri)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("MISSING_OR_INVALID", `pair() uri: ${l.uri}`);
                            throw Error(c)
                        }
                        let x = (0, ew.heJ)(l.uri);
                        if (!(null != (c = x ? .relay) && c.protocol)) {
                            let {
                                message: l
                            } = (0, ew.kCb)("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                            throw Error(l)
                        }
                        if (!(null != x && x.symKey)) {
                            let {
                                message: l
                            } = (0, ew.kCb)("MISSING_OR_INVALID", "pair() uri#symKey");
                            throw Error(l)
                        }
                        if (null != x && x.expiryTimestamp && (0, eo.toMiliseconds)(x ? .expiryTimestamp) < Date.now()) {
                            let {
                                message: l
                            } = (0, ew.kCb)("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
                            throw Error(l)
                        }
                    }, this.isValidPing = async l => {
                        if (!(0, ew.EJd)(l)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("MISSING_OR_INVALID", `ping() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidPairingTopic(c)
                    }, this.isValidDisconnect = async l => {
                        if (!(0, ew.EJd)(l)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("MISSING_OR_INVALID", `disconnect() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidPairingTopic(c)
                    }, this.isValidPairingTopic = async l => {
                        if (!(0, ew.M_r)(l, !1)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("MISSING_OR_INVALID", `pairing topic should be a string: ${l}`);
                            throw Error(c)
                        }
                        if (!this.pairings.keys.includes(l)) {
                            let {
                                message: c
                            } = (0, ew.kCb)("NO_MATCHING_KEY", `pairing topic doesn't exist: ${l}`);
                            throw Error(c)
                        }
                        if ((0, ew.BwD)(this.pairings.get(l).expiry)) {
                            await this.deletePairing(l);
                            let {
                                message: c
                            } = (0, ew.kCb)("EXPIRED", `pairing topic: ${l}`);
                            throw Error(c)
                        }
                    }, this.core = l, this.logger = (0, ed.Ep)(c, this.name), this.pairings = new Kt(this.core, this.logger, this.name, this.storagePrefix)
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
                registerRelayerEvents() {
                    this.core.relayer.on(t_.message, async l => {
                        let {
                            topic: c,
                            message: x
                        } = l;
                        if (!this.pairings.keys.includes(c) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(x))) return;
                        let N = await this.core.crypto.decode(c, x);
                        try {
                            (0, eI.isJsonRpcRequest)(N) ? (this.core.history.set(c, N), this.onRelayEventRequest({
                                topic: c,
                                payload: N
                            })) : (0, eI.isJsonRpcResponse)(N) && (await this.core.history.resolve(N), await this.onRelayEventResponse({
                                topic: c,
                                payload: N
                            }), this.core.history.delete(c, N.id))
                        } catch (l) {
                            this.logger.error(l)
                        }
                    })
                }
                registerExpirerEvents() {
                    this.core.expirer.on(tO.expired, async l => {
                        let {
                            topic: c
                        } = (0, ew.iPz)(l.target);
                        c && this.pairings.keys.includes(c) && (await this.deletePairing(c, !0), this.events.emit(tA.expire, {
                            topic: c
                        }))
                    })
                }
            };
            let qt = class qt extends ep.yy {
                constructor(l, c) {
                    super(l, c), this.core = l, this.logger = c, this.records = new Map, this.events = new U.EventEmitter, this.name = "history", this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = tg, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => this.records.set(l.id, l)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
                    }, this.set = (l, c, x) => {
                        if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                                type: "method",
                                method: "set",
                                topic: l,
                                request: c,
                                chainId: x
                            }), this.records.has(c.id)) return;
                        let N = {
                            id: c.id,
                            topic: l,
                            request: {
                                method: c.method,
                                params: c.params || null
                            },
                            chainId: x,
                            expiry: (0, ew.gn4)(eo.THIRTY_DAYS)
                        };
                        this.records.set(N.id, N), this.persist(), this.events.emit(tj.created, N)
                    }, this.resolve = async l => {
                        if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                                type: "method",
                                method: "update",
                                response: l
                            }), !this.records.has(l.id)) return;
                        let c = await this.getRecord(l.id);
                        typeof c.response > "u" && (c.response = (0, eI.isJsonRpcError)(l) ? {
                            error: l.error
                        } : {
                            result: l.result
                        }, this.records.set(c.id, c), this.persist(), this.events.emit(tj.updated, c))
                    }, this.get = async (l, c) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
                        type: "method",
                        method: "get",
                        topic: l,
                        id: c
                    }), await this.getRecord(c)), this.delete = (l, c) => {
                        this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                            type: "method",
                            method: "delete",
                            id: c
                        }), this.values.forEach(x => {
                            x.topic !== l || "u" > typeof c && x.id !== c || (this.records.delete(x.id), this.events.emit(tj.deleted, x))
                        }), this.persist()
                    }, this.exists = async (l, c) => (this.isInitialized(), !!this.records.has(c) && (await this.getRecord(c)).topic === l), this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.logger = (0, ed.Ep)(c, this.name)
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get size() {
                    return this.records.size
                }
                get keys() {
                    return Array.from(this.records.keys())
                }
                get values() {
                    return Array.from(this.records.values())
                }
                get pending() {
                    let l = [];
                    return this.values.forEach(c => {
                        if ("u" > typeof c.response) return;
                        let x = {
                            topic: c.topic,
                            request: (0, eI.formatJsonRpcRequest)(c.request.method, c.request.params, c.id),
                            chainId: c.chainId
                        };
                        return l.push(x)
                    }), l
                }
                async setJsonRpcRecords(l) {
                    await this.core.storage.setItem(this.storageKey, l)
                }
                async getJsonRpcRecords() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                getRecord(l) {
                    this.isInitialized();
                    let c = this.records.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = (0, ew.kCb)("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw Error(c)
                    }
                    return c
                }
                async persist() {
                    await this.setJsonRpcRecords(this.values), this.events.emit(tj.sync)
                }
                async restore() {
                    try {
                        let l = await this.getJsonRpcRecords();
                        if (typeof l > "u" || !l.length) return;
                        if (this.records.size) {
                            let {
                                message: l
                            } = (0, ew.kCb)("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            records: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(l)
                    }
                }
                registerEventListeners() {
                    this.events.on(tj.created, l => {
                        let c = tj.created;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            record: l
                        })
                    }), this.events.on(tj.updated, l => {
                        let c = tj.updated;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            record: l
                        })
                    }), this.events.on(tj.deleted, l => {
                        let c = tj.deleted;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            record: l
                        })
                    }), this.core.heartbeat.on(eu.pulse, () => {
                        this.cleanup()
                    })
                }
                cleanup() {
                    try {
                        this.isInitialized();
                        let l = !1;
                        this.records.forEach(c => {
                            (0, eo.toMiliseconds)(c.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${c.id}`), this.records.delete(c.id), this.events.emit(tj.deleted, c, !1), l = !0)
                        }), l && this.persist()
                    } catch (l) {
                        this.logger.warn(l)
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let jt = class jt extends ep.D3 {
                constructor(l, c) {
                    super(l, c), this.core = l, this.logger = c, this.expirations = new Map, this.events = new U.EventEmitter, this.name = "expirer", this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = tg, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(l => this.expirations.set(l.target, l)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
                    }, this.has = l => {
                        try {
                            let c = this.formatTarget(l);
                            return "u" > typeof this.getExpiration(c)
                        } catch {
                            return !1
                        }
                    }, this.set = (l, c) => {
                        this.isInitialized();
                        let x = this.formatTarget(l),
                            N = {
                                target: x,
                                expiry: c
                            };
                        this.expirations.set(x, N), this.checkExpiry(x, N), this.events.emit(tO.created, {
                            target: x,
                            expiration: N
                        })
                    }, this.get = l => {
                        this.isInitialized();
                        let c = this.formatTarget(l);
                        return this.getExpiration(c)
                    }, this.del = l => {
                        if (this.isInitialized(), this.has(l)) {
                            let c = this.formatTarget(l),
                                x = this.getExpiration(c);
                            this.expirations.delete(c), this.events.emit(tO.deleted, {
                                target: c,
                                expiration: x
                            })
                        }
                    }, this.on = (l, c) => {
                        this.events.on(l, c)
                    }, this.once = (l, c) => {
                        this.events.once(l, c)
                    }, this.off = (l, c) => {
                        this.events.off(l, c)
                    }, this.removeListener = (l, c) => {
                        this.events.removeListener(l, c)
                    }, this.logger = (0, ed.Ep)(c, this.name)
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.expirations.size
                }
                get keys() {
                    return Array.from(this.expirations.keys())
                }
                get values() {
                    return Array.from(this.expirations.values())
                }
                formatTarget(l) {
                    if ("string" == typeof l) return (0, ew.Z42)(l);
                    if ("number" == typeof l) return (0, ew.GqV)(l);
                    let {
                        message: c
                    } = (0, ew.kCb)("UNKNOWN_TYPE", `Target type: ${typeof l}`);
                    throw Error(c)
                }
                async setExpirations(l) {
                    await this.core.storage.setItem(this.storageKey, l)
                }
                async getExpirations() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                async persist() {
                    await this.setExpirations(this.values), this.events.emit(tO.sync)
                }
                async restore() {
                    try {
                        let l = await this.getExpirations();
                        if (typeof l > "u" || !l.length) return;
                        if (this.expirations.size) {
                            let {
                                message: l
                            } = (0, ew.kCb)("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(l), Error(l)
                        }
                        this.cached = l, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            expirations: this.values
                        })
                    } catch (l) {
                        this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(l)
                    }
                }
                getExpiration(l) {
                    let c = this.expirations.get(l);
                    if (!c) {
                        let {
                            message: c
                        } = (0, ew.kCb)("NO_MATCHING_KEY", `${this.name}: ${l}`);
                        throw this.logger.warn(c), Error(c)
                    }
                    return c
                }
                checkExpiry(l, c) {
                    let {
                        expiry: x
                    } = c;
                    (0, eo.toMiliseconds)(x) - Date.now() <= 0 && this.expire(l, c)
                }
                expire(l, c) {
                    this.expirations.delete(l), this.events.emit(tO.expired, {
                        target: l,
                        expiration: c
                    })
                }
                checkExpirations() {
                    this.core.relayer.connected && this.expirations.forEach((l, c) => this.checkExpiry(c, l))
                }
                registerEventListeners() {
                    this.core.heartbeat.on(eu.pulse, () => this.checkExpirations()), this.events.on(tO.created, l => {
                        let c = tO.created;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), this.persist()
                    }), this.events.on(tO.expired, l => {
                        let c = tO.expired;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), this.persist()
                    }), this.events.on(tO.deleted, l => {
                        let c = tO.deleted;
                        this.logger.info(`Emitting ${c}`), this.logger.debug({
                            type: "event",
                            event: c,
                            data: l
                        }), this.persist()
                    })
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, ew.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                }
            };
            let Gt = class Gt extends ep.Yo {
                constructor(l, c) {
                    super(l, c), this.projectId = l, this.logger = c, this.name = tP, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async l => {
                        if (this.verifyDisabled || (0, ew.b$m)() || !(0, ew.jUY)()) return;
                        let c = this.getVerifyUrl(l ? .verifyUrl);
                        this.verifyUrl !== c && this.removeIframe(), this.verifyUrl = c;
                        try {
                            await this.createIframe()
                        } catch (l) {
                            this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(l)
                        }
                        if (!this.initialized) {
                            this.removeIframe(), this.verifyUrl = tR;
                            try {
                                await this.createIframe()
                            } catch (l) {
                                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(l), this.verifyDisabled = !0
                            }
                        }
                    }, this.register = async l => {
                        this.initialized ? this.sendPost(l.attestationId) : (this.addToQueue(l.attestationId), await this.init())
                    }, this.resolve = async l => {
                        let c;
                        if (this.isDevEnv) return "";
                        let x = this.getVerifyUrl(l ? .verifyUrl);
                        try {
                            c = await this.fetchAttestation(l.attestationId, x)
                        } catch (N) {
                            this.logger.info(`failed to resolve attestation: ${l.attestationId} from url: ${x}`), this.logger.info(N), c = await this.fetchAttestation(l.attestationId, tR)
                        }
                        return c
                    }, this.fetchAttestation = async (l, c) => {
                        this.logger.info(`resolving attestation: ${l} from url: ${c}`);
                        let x = this.startAbortTimer(2 * eo.ONE_SECOND),
                            N = await fetch(`${c}/attestation/${l}`, {
                                signal: this.abortController.signal
                            });
                        return clearTimeout(x), 200 === N.status ? await N.json() : void 0
                    }, this.addToQueue = l => {
                        this.queue.push(l)
                    }, this.processQueue = () => {
                        0 !== this.queue.length && (this.queue.forEach(l => this.sendPost(l)), this.queue = [])
                    }, this.sendPost = l => {
                        var c;
                        try {
                            if (!this.iframe) return;
                            null == (c = this.iframe.contentWindow) || c.postMessage(l, "*"), this.logger.info(`postMessage sent: ${l} ${this.verifyUrl}`)
                        } catch {}
                    }, this.createIframe = async () => {
                        let l;
                        let s = c => {
                            "verify_ready" === c.data && (this.onInit(), window.removeEventListener("message", s), l())
                        };
                        await Promise.race([new Promise(c => {
                            let x = document.getElementById(tP);
                            if (x) return this.iframe = x, this.onInit(), c();
                            window.addEventListener("message", s);
                            let N = document.createElement("iframe");
                            N.id = tP, N.src = `${this.verifyUrl}/${this.projectId}`, N.style.display = "none", document.body.append(N), this.iframe = N, l = c
                        }), new Promise((l, c) => setTimeout(() => {
                            window.removeEventListener("message", s), c("verify iframe load timeout")
                        }, (0, eo.toMiliseconds)(eo.FIVE_SECONDS)))])
                    }, this.onInit = () => {
                        this.initialized = !0, this.processQueue()
                    }, this.removeIframe = () => {
                        this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1)
                    }, this.getVerifyUrl = l => {
                        let c = l || tz;
                        return tL.includes(c) || (this.logger.info(`verify url: ${c}, not included in trusted list, assigning default: ${tz}`), c = tz), c
                    }, this.logger = (0, ed.Ep)(c, this.name), this.verifyUrl = tz, this.abortController = new AbortController, this.isDevEnv = (0, ew.UGU)() && ek.env.IS_VITEST
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                startAbortTimer(l) {
                    return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), (0, eo.toMiliseconds)(l))
                }
            };
            let Yt = class Yt extends ep.pX {
                constructor(l, c) {
                    super(l, c), this.projectId = l, this.logger = c, this.context = "echo", this.registerDeviceToken = async l => {
                        let {
                            clientId: c,
                            token: x,
                            notificationType: N,
                            enableEncrypted: U = !1
                        } = l, Z = `https://echo.walletconnect.com/${this.projectId}/clients`;
                        await eS()(Z, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                                client_id: c,
                                type: N,
                                token: x,
                                always_raw: U
                            })
                        })
                    }, this.logger = (0, ed.Ep)(c, this.context)
                }
            };
            var tX = Object.defineProperty,
                t0 = Object.getOwnPropertySymbols,
                t2 = Object.prototype.hasOwnProperty,
                t1 = Object.prototype.propertyIsEnumerable,
                Jt = (l, c, x) => c in l ? tX(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                Xt = (l, c) => {
                    for (var x in c || (c = {})) t2.call(c, x) && Jt(l, x, c[x]);
                    if (t0)
                        for (var x of t0(c)) t1.call(c, x) && Jt(l, x, c[x]);
                    return l
                };
            let ie = class ie extends ep.N1 {
                constructor(l) {
                    var c;
                    super(l), this.protocol = "wc", this.version = 2, this.name = tm, this.events = new U.EventEmitter, this.initialized = !1, this.on = (l, c) => this.events.on(l, c), this.once = (l, c) => this.events.once(l, c), this.off = (l, c) => this.events.off(l, c), this.removeListener = (l, c) => this.events.removeListener(l, c), this.projectId = l ? .projectId, this.relayUrl = l ? .relayUrl || tx, this.customStoragePrefix = null != l && l.customStoragePrefix ? `:${l.customStoragePrefix}` : "";
                    let x = (0, ed.jI)({
                            level: "string" == typeof l ? .logger && l.logger ? l.logger : tb.logger
                        }),
                        {
                            logger: N,
                            chunkLoggerController: Z
                        } = (0, ed.Rt)({
                            opts: x,
                            maxSizeInBytes: l ? .maxLogBlobSizeInBytes,
                            loggerOverride: l ? .logger
                        });
                    this.logChunkController = Z, null != (c = this.logChunkController) && c.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
                        var l, c;
                        null != (l = this.logChunkController) && l.downloadLogsBlobInBrowser && (null == (c = this.logChunkController) || c.downloadLogsBlobInBrowser({
                            clientId: await this.crypto.getClientId()
                        }))
                    }), this.logger = (0, ed.Ep)(N, this.name), this.heartbeat = new index_es_i, this.crypto = new Ot(this, this.logger, l ? .keychain), this.history = new qt(this, this.logger), this.expirer = new jt(this, this.logger), this.storage = null != l && l.storage ? l.storage : new h(Xt(Xt({}, tv), l ? .storageOptions)), this.relayer = new $t({
                        core: this,
                        logger: this.logger,
                        relayUrl: this.relayUrl,
                        projectId: this.projectId
                    }), this.pairing = new Vt(this, this.logger), this.verify = new Gt(this.projectId || "", this.logger), this.echoClient = new Yt(this.projectId || "", this.logger)
                }
                static async init(l) {
                    let c = new ie(l);
                    await c.initialize();
                    let x = await c.crypto.getClientId();
                    return await c.storage.setItem("WALLETCONNECT_CLIENT_ID", x), c
                }
                get context() {
                    return (0, ed.Fd)(this.logger)
                }
                async start() {
                    this.initialized || await this.initialize()
                }
                async getLogsBlob() {
                    var l;
                    return null == (l = this.logChunkController) ? void 0 : l.logsToBlob({
                        clientId: await this.crypto.getClientId()
                    })
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success")
                    } catch (l) {
                        throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, l), this.logger.error(l.message), l
                    }
                }
            };
            let t5 = ie
        },
        81431: function(l, c, x) {
            "use strict";

            function getBrowerCrypto() {
                return (null === x.g || void 0 === x.g ? void 0 : x.g.crypto) || (null === x.g || void 0 === x.g ? void 0 : x.g.msCrypto) || {}
            }

            function getSubtleCrypto() {
                let l = getBrowerCrypto();
                return l.subtle || l.webkitSubtle
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.isBrowserCryptoAvailable = c.getSubtleCrypto = c.getBrowerCrypto = void 0, c.getBrowerCrypto = getBrowerCrypto, c.getSubtleCrypto = getSubtleCrypto, c.isBrowserCryptoAvailable = function() {
                return !!getBrowerCrypto() && !!getSubtleCrypto()
            }
        },
        51164: function(l, c, x) {
            "use strict";
            var N = x(25566);

            function isReactNative() {
                return "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product
            }

            function isNode() {
                return void 0 !== N && void 0 !== N.versions && void 0 !== N.versions.node
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.isBrowser = c.isNode = c.isReactNative = void 0, c.isReactNative = isReactNative, c.isNode = isNode, c.isBrowser = function() {
                return !isReactNative() && !isNode()
            }
        },
        36014: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let N = x(75031);
            N.__exportStar(x(81431), c), N.__exportStar(x(51164), c)
        },
        75031: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                __assign: function() {
                    return __assign
                },
                __asyncDelegator: function() {
                    return __asyncDelegator
                },
                __asyncGenerator: function() {
                    return __asyncGenerator
                },
                __asyncValues: function() {
                    return __asyncValues
                },
                __await: function() {
                    return __await
                },
                __awaiter: function() {
                    return __awaiter
                },
                __classPrivateFieldGet: function() {
                    return __classPrivateFieldGet
                },
                __classPrivateFieldSet: function() {
                    return __classPrivateFieldSet
                },
                __createBinding: function() {
                    return __createBinding
                },
                __decorate: function() {
                    return __decorate
                },
                __exportStar: function() {
                    return __exportStar
                },
                __extends: function() {
                    return __extends
                },
                __generator: function() {
                    return __generator
                },
                __importDefault: function() {
                    return __importDefault
                },
                __importStar: function() {
                    return __importStar
                },
                __makeTemplateObject: function() {
                    return __makeTemplateObject
                },
                __metadata: function() {
                    return __metadata
                },
                __param: function() {
                    return __param
                },
                __read: function() {
                    return __read
                },
                __rest: function() {
                    return __rest
                },
                __spread: function() {
                    return __spread
                },
                __spreadArrays: function() {
                    return __spreadArrays
                },
                __values: function() {
                    return __values
                }
            });
            /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
            var extendStatics = function(l, c) {
                return (extendStatics = Object.setPrototypeOf || ({
                    __proto__: []
                }) instanceof Array && function(l, c) {
                    l.__proto__ = c
                } || function(l, c) {
                    for (var x in c) c.hasOwnProperty(x) && (l[x] = c[x])
                })(l, c)
            };

            function __extends(l, c) {
                function __() {
                    this.constructor = l
                }
                extendStatics(l, c), l.prototype = null === c ? Object.create(c) : (__.prototype = c.prototype, new __)
            }
            var __assign = function() {
                return (__assign = Object.assign || function(l) {
                    for (var c, x = 1, N = arguments.length; x < N; x++)
                        for (var U in c = arguments[x]) Object.prototype.hasOwnProperty.call(c, U) && (l[U] = c[U]);
                    return l
                }).apply(this, arguments)
            };

            function __rest(l, c) {
                var x = {};
                for (var N in l) Object.prototype.hasOwnProperty.call(l, N) && 0 > c.indexOf(N) && (x[N] = l[N]);
                if (null != l && "function" == typeof Object.getOwnPropertySymbols)
                    for (var U = 0, N = Object.getOwnPropertySymbols(l); U < N.length; U++) 0 > c.indexOf(N[U]) && Object.prototype.propertyIsEnumerable.call(l, N[U]) && (x[N[U]] = l[N[U]]);
                return x
            }

            function __decorate(l, c, x, N) {
                var U, Z = arguments.length,
                    $ = Z < 3 ? c : null === N ? N = Object.getOwnPropertyDescriptor(c, x) : N;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) $ = Reflect.decorate(l, c, x, N);
                else
                    for (var Y = l.length - 1; Y >= 0; Y--)(U = l[Y]) && ($ = (Z < 3 ? U($) : Z > 3 ? U(c, x, $) : U(c, x)) || $);
                return Z > 3 && $ && Object.defineProperty(c, x, $), $
            }

            function __param(l, c) {
                return function(x, N) {
                    c(x, N, l)
                }
            }

            function __metadata(l, c) {
                if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(l, c)
            }

            function __awaiter(l, c, x, N) {
                return new(x || (x = Promise))(function(U, Z) {
                    function fulfilled(l) {
                        try {
                            step(N.next(l))
                        } catch (l) {
                            Z(l)
                        }
                    }

                    function rejected(l) {
                        try {
                            step(N.throw(l))
                        } catch (l) {
                            Z(l)
                        }
                    }

                    function step(l) {
                        var c;
                        l.done ? U(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                            l(c)
                        })).then(fulfilled, rejected)
                    }
                    step((N = N.apply(l, c || [])).next())
                })
            }

            function __generator(l, c) {
                var x, N, U, Z, $ = {
                    label: 0,
                    sent: function() {
                        if (1 & U[0]) throw U[1];
                        return U[1]
                    },
                    trys: [],
                    ops: []
                };
                return Z = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, "function" == typeof Symbol && (Z[Symbol.iterator] = function() {
                    return this
                }), Z;

                function verb(Z) {
                    return function(Y) {
                        return function(Z) {
                            if (x) throw TypeError("Generator is already executing.");
                            for (; $;) try {
                                if (x = 1, N && (U = 2 & Z[0] ? N.return : Z[0] ? N.throw || ((U = N.return) && U.call(N), 0) : N.next) && !(U = U.call(N, Z[1])).done) return U;
                                switch (N = 0, U && (Z = [2 & Z[0], U.value]), Z[0]) {
                                    case 0:
                                    case 1:
                                        U = Z;
                                        break;
                                    case 4:
                                        return $.label++, {
                                            value: Z[1],
                                            done: !1
                                        };
                                    case 5:
                                        $.label++, N = Z[1], Z = [0];
                                        continue;
                                    case 7:
                                        Z = $.ops.pop(), $.trys.pop();
                                        continue;
                                    default:
                                        if (!(U = (U = $.trys).length > 0 && U[U.length - 1]) && (6 === Z[0] || 2 === Z[0])) {
                                            $ = 0;
                                            continue
                                        }
                                        if (3 === Z[0] && (!U || Z[1] > U[0] && Z[1] < U[3])) {
                                            $.label = Z[1];
                                            break
                                        }
                                        if (6 === Z[0] && $.label < U[1]) {
                                            $.label = U[1], U = Z;
                                            break
                                        }
                                        if (U && $.label < U[2]) {
                                            $.label = U[2], $.ops.push(Z);
                                            break
                                        }
                                        U[2] && $.ops.pop(), $.trys.pop();
                                        continue
                                }
                                Z = c.call(l, $)
                            } catch (l) {
                                Z = [6, l], N = 0
                            } finally {
                                x = U = 0
                            }
                            if (5 & Z[0]) throw Z[1];
                            return {
                                value: Z[0] ? Z[1] : void 0,
                                done: !0
                            }
                        }([Z, Y])
                    }
                }
            }

            function __createBinding(l, c, x, N) {
                void 0 === N && (N = x), l[N] = c[x]
            }

            function __exportStar(l, c) {
                for (var x in l) "default" === x || c.hasOwnProperty(x) || (c[x] = l[x])
            }

            function __values(l) {
                var c = "function" == typeof Symbol && Symbol.iterator,
                    x = c && l[c],
                    N = 0;
                if (x) return x.call(l);
                if (l && "number" == typeof l.length) return {
                    next: function() {
                        return l && N >= l.length && (l = void 0), {
                            value: l && l[N++],
                            done: !l
                        }
                    }
                };
                throw TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }

            function __read(l, c) {
                var x = "function" == typeof Symbol && l[Symbol.iterator];
                if (!x) return l;
                var N, U, Z = x.call(l),
                    $ = [];
                try {
                    for (;
                        (void 0 === c || c-- > 0) && !(N = Z.next()).done;) $.push(N.value)
                } catch (l) {
                    U = {
                        error: l
                    }
                } finally {
                    try {
                        N && !N.done && (x = Z.return) && x.call(Z)
                    } finally {
                        if (U) throw U.error
                    }
                }
                return $
            }

            function __spread() {
                for (var l = [], c = 0; c < arguments.length; c++) l = l.concat(__read(arguments[c]));
                return l
            }

            function __spreadArrays() {
                for (var l = 0, c = 0, x = arguments.length; c < x; c++) l += arguments[c].length;
                for (var N = Array(l), U = 0, c = 0; c < x; c++)
                    for (var Z = arguments[c], $ = 0, Y = Z.length; $ < Y; $++, U++) N[U] = Z[$];
                return N
            }

            function __await(l) {
                return this instanceof __await ? (this.v = l, this) : new __await(l)
            }

            function __asyncGenerator(l, c, x) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var N, U = x.apply(l, c || []),
                    Z = [];
                return N = {}, verb("next"), verb("throw"), verb("return"), N[Symbol.asyncIterator] = function() {
                    return this
                }, N;

                function verb(l) {
                    U[l] && (N[l] = function(c) {
                        return new Promise(function(x, N) {
                            Z.push([l, c, x, N]) > 1 || resume(l, c)
                        })
                    })
                }

                function resume(l, c) {
                    try {
                        var x;
                        (x = U[l](c)).value instanceof __await ? Promise.resolve(x.value.v).then(fulfill, reject) : settle(Z[0][2], x)
                    } catch (l) {
                        settle(Z[0][3], l)
                    }
                }

                function fulfill(l) {
                    resume("next", l)
                }

                function reject(l) {
                    resume("throw", l)
                }

                function settle(l, c) {
                    l(c), Z.shift(), Z.length && resume(Z[0][0], Z[0][1])
                }
            }

            function __asyncDelegator(l) {
                var c, x;
                return c = {}, verb("next"), verb("throw", function(l) {
                    throw l
                }), verb("return"), c[Symbol.iterator] = function() {
                    return this
                }, c;

                function verb(N, U) {
                    c[N] = l[N] ? function(c) {
                        return (x = !x) ? {
                            value: __await(l[N](c)),
                            done: "return" === N
                        } : U ? U(c) : c
                    } : U
                }
            }

            function __asyncValues(l) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var c, x = l[Symbol.asyncIterator];
                return x ? x.call(l) : (l = __values(l), c = {}, verb("next"), verb("throw"), verb("return"), c[Symbol.asyncIterator] = function() {
                    return this
                }, c);

                function verb(x) {
                    c[x] = l[x] && function(c) {
                        return new Promise(function(N, U) {
                            ! function(l, c, x, N) {
                                Promise.resolve(N).then(function(c) {
                                    l({
                                        value: c,
                                        done: x
                                    })
                                }, c)
                            }(N, U, (c = l[x](c)).done, c.value)
                        })
                    }
                }
            }

            function __makeTemplateObject(l, c) {
                return Object.defineProperty ? Object.defineProperty(l, "raw", {
                    value: c
                }) : l.raw = c, l
            }

            function __importStar(l) {
                if (l && l.__esModule) return l;
                var c = {};
                if (null != l)
                    for (var x in l) Object.hasOwnProperty.call(l, x) && (c[x] = l[x]);
                return c.default = l, c
            }

            function __importDefault(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            }

            function __classPrivateFieldGet(l, c) {
                if (!c.has(l)) throw TypeError("attempted to get private field on non-instance");
                return c.get(l)
            }

            function __classPrivateFieldSet(l, c, x) {
                if (!c.has(l)) throw TypeError("attempted to set private field on non-instance");
                return c.set(l, x), x
            }
        },
        95097: function(l, c, x) {
            "use strict";
            x.d(c, {
                q: function() {
                    return IEvents
                }
            });
            let IEvents = class IEvents {}
        },
        45280: function(l, c, x) {
            "use strict";
            x.d(c, {
                r: function() {
                    return o
                }
            });
            var N = x(512),
                U = x(53620);
            let o = class o extends U.IJsonRpcProvider {
                constructor(l) {
                    super(l), this.events = new N.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(l), this.connection.connected && this.registerEventListeners()
                }
                async connect(l = this.connection) {
                    await this.open(l)
                }
                async disconnect() {
                    await this.close()
                }
                on(l, c) {
                    this.events.on(l, c)
                }
                once(l, c) {
                    this.events.once(l, c)
                }
                off(l, c) {
                    this.events.off(l, c)
                }
                removeListener(l, c) {
                    this.events.removeListener(l, c)
                }
                async request(l, c) {
                    return this.requestStrict((0, U.formatJsonRpcRequest)(l.method, l.params || [], l.id || (0, U.getBigIntRpcId)().toString()), c)
                }
                async requestStrict(l, c) {
                    return new Promise(async (x, N) => {
                        if (!this.connection.connected) try {
                            await this.open()
                        } catch (l) {
                            N(l)
                        }
                        this.events.on(`${l.id}`, l => {
                            (0, U.isJsonRpcError)(l) ? N(l.error): x(l.result)
                        });
                        try {
                            await this.connection.send(l, c)
                        } catch (l) {
                            N(l)
                        }
                    })
                }
                setConnection(l = this.connection) {
                    return l
                }
                onPayload(l) {
                    this.events.emit("payload", l), (0, U.isJsonRpcResponse)(l) ? this.events.emit(`${l.id}`, l) : this.events.emit("message", {
                        type: l.method,
                        data: l.params
                    })
                }
                onClose(l) {
                    l && 3e3 === l.code && this.events.emit("error", Error(`WebSocket connection closed abnormally with code: ${l.code} ${l.reason?`(${l.reason})`:""}`)), this.events.emit("disconnect")
                }
                async open(l = this.connection) {
                    this.connection === l && this.connection.connected || (this.connection.connected && this.close(), "string" == typeof l && (await this.connection.open(l), l = this.connection), this.connection = this.setConnection(l), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
                }
                async close() {
                    await this.connection.close()
                }
                registerEventListeners() {
                    this.hasRegisteredEventListeners || (this.connection.on("payload", l => this.onPayload(l)), this.connection.on("close", l => this.onClose(l)), this.connection.on("error", l => this.events.emit("error", l)), this.connection.on("register_error", l => this.onClose()), this.hasRegisteredEventListeners = !0)
                }
            }
        },
        34103: function(l, c, x) {
            "use strict";
            x.d(c, {
                CA: function() {
                    return U
                },
                JV: function() {
                    return Y
                },
                O4: function() {
                    return N
                },
                dQ: function() {
                    return Z
                },
                xK: function() {
                    return $
                }
            });
            let N = "INTERNAL_ERROR",
                U = "SERVER_ERROR",
                Z = [-32700, -32600, -32601, -32602, -32603],
                $ = {
                    PARSE_ERROR: {
                        code: -32700,
                        message: "Parse error"
                    },
                    INVALID_REQUEST: {
                        code: -32600,
                        message: "Invalid Request"
                    },
                    METHOD_NOT_FOUND: {
                        code: -32601,
                        message: "Method not found"
                    },
                    INVALID_PARAMS: {
                        code: -32602,
                        message: "Invalid params"
                    },
                    [N]: {
                        code: -32603,
                        message: "Internal error"
                    },
                    [U]: {
                        code: -32e3,
                        message: "Server error"
                    }
                },
                Y = U
        },
        26637: function(l, c, x) {
            "use strict";
            var N = x(36014);
            x.o(N, "IJsonRpcProvider") && x.d(c, {
                IJsonRpcProvider: function() {
                    return N.IJsonRpcProvider
                }
            }), x.o(N, "formatJsonRpcError") && x.d(c, {
                formatJsonRpcError: function() {
                    return N.formatJsonRpcError
                }
            }), x.o(N, "formatJsonRpcRequest") && x.d(c, {
                formatJsonRpcRequest: function() {
                    return N.formatJsonRpcRequest
                }
            }), x.o(N, "formatJsonRpcResult") && x.d(c, {
                formatJsonRpcResult: function() {
                    return N.formatJsonRpcResult
                }
            }), x.o(N, "getBigIntRpcId") && x.d(c, {
                getBigIntRpcId: function() {
                    return N.getBigIntRpcId
                }
            }), x.o(N, "isHttpUrl") && x.d(c, {
                isHttpUrl: function() {
                    return N.isHttpUrl
                }
            }), x.o(N, "isJsonRpcError") && x.d(c, {
                isJsonRpcError: function() {
                    return N.isJsonRpcError
                }
            }), x.o(N, "isJsonRpcRequest") && x.d(c, {
                isJsonRpcRequest: function() {
                    return N.isJsonRpcRequest
                }
            }), x.o(N, "isJsonRpcResponse") && x.d(c, {
                isJsonRpcResponse: function() {
                    return N.isJsonRpcResponse
                }
            }), x.o(N, "isJsonRpcResult") && x.d(c, {
                isJsonRpcResult: function() {
                    return N.isJsonRpcResult
                }
            }), x.o(N, "isLocalhostUrl") && x.d(c, {
                isLocalhostUrl: function() {
                    return N.isLocalhostUrl
                }
            }), x.o(N, "isReactNative") && x.d(c, {
                isReactNative: function() {
                    return N.isReactNative
                }
            }), x.o(N, "isWsUrl") && x.d(c, {
                isWsUrl: function() {
                    return N.isWsUrl
                }
            }), x.o(N, "payloadId") && x.d(c, {
                payloadId: function() {
                    return N.payloadId
                }
            })
        },
        77507: function(l, c, x) {
            "use strict";
            x.d(c, {
                CX: function() {
                    return parseConnectionError
                },
                L2: function() {
                    return getErrorByCode
                },
                by: function() {
                    return getError
                },
                i5: function() {
                    return isReservedErrorCode
                }
            });
            var N = x(34103);

            function isReservedErrorCode(l) {
                return N.dQ.includes(l)
            }

            function getError(l) {
                return Object.keys(N.xK).includes(l) ? N.xK[l] : N.xK[N.JV]
            }

            function getErrorByCode(l) {
                let c = Object.values(N.xK).find(c => c.code === l);
                return c || N.xK[N.JV]
            }

            function parseConnectionError(l, c, x) {
                return l.message.includes("getaddrinfo ENOTFOUND") || l.message.includes("connect ECONNREFUSED") ? Error(`Unavailable ${x} RPC url at ${c}`) : l
            }
        },
        17957: function(l, c, x) {
            "use strict";
            x.d(c, {
                CS: function() {
                    return getBigIntRpcId
                },
                RI: function() {
                    return formatJsonRpcError
                },
                o0: function() {
                    return payloadId
                },
                sT: function() {
                    return formatJsonRpcRequest
                },
                tm: function() {
                    return formatJsonRpcResult
                }
            });
            var N = x(77507),
                U = x(34103);

            function payloadId(l = 3) {
                let c = Date.now() * Math.pow(10, l),
                    x = Math.floor(Math.random() * Math.pow(10, l));
                return c + x
            }

            function getBigIntRpcId(l = 6) {
                return BigInt(payloadId(l))
            }

            function formatJsonRpcRequest(l, c, x) {
                return {
                    id: x || payloadId(),
                    jsonrpc: "2.0",
                    method: l,
                    params: c
                }
            }

            function formatJsonRpcResult(l, c) {
                return {
                    id: l,
                    jsonrpc: "2.0",
                    result: c
                }
            }

            function formatJsonRpcError(l, c, x) {
                var Z;
                return {
                    id: l,
                    jsonrpc: "2.0",
                    error: void 0 === (Z = c) ? (0, N.by)(U.O4) : ("string" == typeof Z && (Z = Object.assign(Object.assign({}, (0, N.by)(U.CA)), {
                        message: Z
                    })), void 0 !== x && (Z.data = x), (0, N.i5)(Z.code) && (Z = (0, N.L2)(Z.code)), Z)
                }
            }
        },
        53620: function(l, c, x) {
            "use strict";
            x.d(c, {
                IJsonRpcProvider: function() {
                    return $.x0
                },
                formatJsonRpcError: function() {
                    return Z.RI
                },
                formatJsonRpcRequest: function() {
                    return Z.sT
                },
                formatJsonRpcResult: function() {
                    return Z.tm
                },
                getBigIntRpcId: function() {
                    return Z.CS
                },
                isHttpUrl: function() {
                    return Y.jK
                },
                isJsonRpcError: function() {
                    return q.jg
                },
                isJsonRpcRequest: function() {
                    return q.DW
                },
                isJsonRpcResponse: function() {
                    return q.u
                },
                isJsonRpcResult: function() {
                    return q.k4
                },
                isLocalhostUrl: function() {
                    return Y.JF
                },
                isWsUrl: function() {
                    return Y.UZ
                },
                parseConnectionError: function() {
                    return N.CX
                },
                payloadId: function() {
                    return Z.o0
                }
            }), x(34103);
            var N = x(77507),
                U = x(26637);
            x.o(U, "IJsonRpcProvider") && x.d(c, {
                IJsonRpcProvider: function() {
                    return U.IJsonRpcProvider
                }
            }), x.o(U, "formatJsonRpcError") && x.d(c, {
                formatJsonRpcError: function() {
                    return U.formatJsonRpcError
                }
            }), x.o(U, "formatJsonRpcRequest") && x.d(c, {
                formatJsonRpcRequest: function() {
                    return U.formatJsonRpcRequest
                }
            }), x.o(U, "formatJsonRpcResult") && x.d(c, {
                formatJsonRpcResult: function() {
                    return U.formatJsonRpcResult
                }
            }), x.o(U, "getBigIntRpcId") && x.d(c, {
                getBigIntRpcId: function() {
                    return U.getBigIntRpcId
                }
            }), x.o(U, "isHttpUrl") && x.d(c, {
                isHttpUrl: function() {
                    return U.isHttpUrl
                }
            }), x.o(U, "isJsonRpcError") && x.d(c, {
                isJsonRpcError: function() {
                    return U.isJsonRpcError
                }
            }), x.o(U, "isJsonRpcRequest") && x.d(c, {
                isJsonRpcRequest: function() {
                    return U.isJsonRpcRequest
                }
            }), x.o(U, "isJsonRpcResponse") && x.d(c, {
                isJsonRpcResponse: function() {
                    return U.isJsonRpcResponse
                }
            }), x.o(U, "isJsonRpcResult") && x.d(c, {
                isJsonRpcResult: function() {
                    return U.isJsonRpcResult
                }
            }), x.o(U, "isLocalhostUrl") && x.d(c, {
                isLocalhostUrl: function() {
                    return U.isLocalhostUrl
                }
            }), x.o(U, "isReactNative") && x.d(c, {
                isReactNative: function() {
                    return U.isReactNative
                }
            }), x.o(U, "isWsUrl") && x.d(c, {
                isWsUrl: function() {
                    return U.isWsUrl
                }
            }), x.o(U, "payloadId") && x.d(c, {
                payloadId: function() {
                    return U.payloadId
                }
            });
            var Z = x(17957),
                $ = x(32801),
                Y = x(59490),
                q = x(7739)
        },
        32801: function(l, c, x) {
            "use strict";
            x.d(c, {
                x0: function() {
                    return r
                }
            });
            let e = class e {};
            let n = class n extends e {
                constructor() {
                    super()
                }
            };
            let r = class r extends n {
                constructor(l) {
                    super()
                }
            }
        },
        59490: function(l, c, x) {
            "use strict";

            function matchRegexProtocol(l, c) {
                let x = function(l) {
                    let c = l.match(RegExp(/^\w+:/, "gi"));
                    if (c && c.length) return c[0]
                }(l);
                return void 0 !== x && new RegExp(c).test(x)
            }

            function isHttpUrl(l) {
                return matchRegexProtocol(l, "^https?:")
            }

            function isWsUrl(l) {
                return matchRegexProtocol(l, "^wss?:")
            }

            function isLocalhostUrl(l) {
                return RegExp("wss?://localhost(:d{2,5})?").test(l)
            }
            x.d(c, {
                JF: function() {
                    return isLocalhostUrl
                },
                UZ: function() {
                    return isWsUrl
                },
                jK: function() {
                    return isHttpUrl
                }
            })
        },
        7739: function(l, c, x) {
            "use strict";

            function isJsonRpcPayload(l) {
                return "object" == typeof l && "id" in l && "jsonrpc" in l && "2.0" === l.jsonrpc
            }

            function isJsonRpcRequest(l) {
                return isJsonRpcPayload(l) && "method" in l
            }

            function isJsonRpcResponse(l) {
                return isJsonRpcPayload(l) && (isJsonRpcResult(l) || isJsonRpcError(l))
            }

            function isJsonRpcResult(l) {
                return "result" in l
            }

            function isJsonRpcError(l) {
                return "error" in l
            }
            x.d(c, {
                DW: function() {
                    return isJsonRpcRequest
                },
                jg: function() {
                    return isJsonRpcError
                },
                k4: function() {
                    return isJsonRpcResult
                },
                u: function() {
                    return isJsonRpcResponse
                }
            })
        },
        44623: function(l) {
            "use strict";
            l.exports = function() {
                throw Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
            }
        },
        33234: function(l, c, x) {
            "use strict";
            x.d(c, {
                Ep: function() {
                    return E
                },
                Fd: function() {
                    return y
                },
                Rt: function() {
                    return A
                },
                gw: function() {
                    return U.a
                },
                jI: function() {
                    return k
                }
            });
            var N = x(90440),
                U = x.n(N),
                Z = x(43283);
            let $ = {
                    level: "info"
                },
                Y = "custom_context";
            let O = class O {
                constructor(l) {
                    this.nodeValue = l, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null
                }
                get value() {
                    return this.nodeValue
                }
                get size() {
                    return this.sizeInBytes
                }
            };
            let d = class d {
                constructor(l) {
                    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = l, this.sizeInBytes = 0
                }
                append(l) {
                    let c = new O(l);
                    if (c.size > this.maxSizeInBytes) throw Error(`[LinkedList] Value too big to insert into list: ${l} with size ${c.size}`);
                    for (; this.size + c.size > this.maxSizeInBytes;) this.shift();
                    this.head ? this.tail && (this.tail.next = c) : this.head = c, this.tail = c, this.lengthInNodes++, this.sizeInBytes += c.size
                }
                shift() {
                    if (!this.head) return;
                    let l = this.head;
                    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= l.size
                }
                toArray() {
                    let l = [],
                        c = this.head;
                    for (; null !== c;) l.push(c.value), c = c.next;
                    return l
                }
                get length() {
                    return this.lengthInNodes
                }
                get size() {
                    return this.sizeInBytes
                }
                toOrderedArray() {
                    return Array.from(this)
                }[Symbol.iterator]() {
                    let l = this.head;
                    return {
                        next: () => {
                            if (!l) return {
                                done: !0,
                                value: null
                            };
                            let c = l.value;
                            return l = l.next, {
                                done: !1,
                                value: c
                            }
                        }
                    }
                }
            };
            let L = class L {
                constructor(l, c = 1024e3) {
                    this.level = l ? ? "error", this.levelValue = N.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = c, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES)
                }
                forwardToConsole(l, c) {
                    c === N.levels.values.error ? console.error(l) : c === N.levels.values.warn ? console.warn(l) : c === N.levels.values.debug ? console.debug(l) : c === N.levels.values.trace ? console.trace(l) : console.log(l)
                }
                appendToLogs(l) {
                    this.logs.append((0, Z.u)({
                        timestamp: new Date().toISOString(),
                        log: l
                    }));
                    let c = "string" == typeof l ? JSON.parse(l).level : l.level;
                    c >= this.levelValue && this.forwardToConsole(l, c)
                }
                getLogs() {
                    return this.logs
                }
                clearLogs() {
                    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES)
                }
                getLogArray() {
                    return Array.from(this.logs)
                }
                logsToBlob(l) {
                    let c = this.getLogArray();
                    return c.push((0, Z.u)({
                        extraMetadata: l
                    })), new Blob(c, {
                        type: "application/json"
                    })
                }
            };
            let m = class m {
                constructor(l, c = 1024e3) {
                    this.baseChunkLogger = new L(l, c)
                }
                write(l) {
                    this.baseChunkLogger.appendToLogs(l)
                }
                getLogs() {
                    return this.baseChunkLogger.getLogs()
                }
                clearLogs() {
                    this.baseChunkLogger.clearLogs()
                }
                getLogArray() {
                    return this.baseChunkLogger.getLogArray()
                }
                logsToBlob(l) {
                    return this.baseChunkLogger.logsToBlob(l)
                }
                downloadLogsBlobInBrowser(l) {
                    let c = URL.createObjectURL(this.logsToBlob(l)),
                        x = document.createElement("a");
                    x.href = c, x.download = `walletconnect-logs-${new Date().toISOString()}.txt`, document.body.appendChild(x), x.click(), document.body.removeChild(x), URL.revokeObjectURL(c)
                }
            };
            let B = class B {
                constructor(l, c = 1024e3) {
                    this.baseChunkLogger = new L(l, c)
                }
                write(l) {
                    this.baseChunkLogger.appendToLogs(l)
                }
                getLogs() {
                    return this.baseChunkLogger.getLogs()
                }
                clearLogs() {
                    this.baseChunkLogger.clearLogs()
                }
                getLogArray() {
                    return this.baseChunkLogger.getLogArray()
                }
                logsToBlob(l) {
                    return this.baseChunkLogger.logsToBlob(l)
                }
            };
            var q = Object.defineProperty,
                J = Object.defineProperties,
                X = Object.getOwnPropertyDescriptors,
                en = Object.getOwnPropertySymbols,
                er = Object.prototype.hasOwnProperty,
                ea = Object.prototype.propertyIsEnumerable,
                f = (l, c, x) => c in l ? q(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                i = (l, c) => {
                    for (var x in c || (c = {})) er.call(c, x) && f(l, x, c[x]);
                    if (en)
                        for (var x of en(c)) ea.call(c, x) && f(l, x, c[x]);
                    return l
                },
                g = (l, c) => J(l, X(c));

            function k(l) {
                return g(i({}, l), {
                    level: l ? .level || $.level
                })
            }

            function y(l, c = Y) {
                return typeof l.bindings > "u" ? function(l, c = Y) {
                    return l[c] || ""
                }(l, c) : l.bindings().context || ""
            }

            function E(l, c, x = Y) {
                let N = function(l, c, x = Y) {
                        let N = y(l, x);
                        return N.trim() ? `${N}/${c}` : c
                    }(l, c, x),
                    U = l.child({
                        context: N
                    });
                return function(l, c, x = Y) {
                    return l[x] = c, l
                }(U, N, x)
            }

            function A(l) {
                return "u" > typeof l.loggerOverride && "string" != typeof l.loggerOverride ? {
                    logger: l.loggerOverride,
                    chunkLoggerController: null
                } : "u" > typeof window ? function(l) {
                    var c, x;
                    let N = new m(null == (c = l.opts) ? void 0 : c.level, l.maxSizeInBytes);
                    return {
                        logger: U()(g(i({}, l.opts), {
                            level: "trace",
                            browser: g(i({}, null == (x = l.opts) ? void 0 : x.browser), {
                                write: l => N.write(l)
                            })
                        })),
                        chunkLoggerController: N
                    }
                }(l) : function(l) {
                    var c;
                    let x = new B(null == (c = l.opts) ? void 0 : c.level, l.maxSizeInBytes);
                    return {
                        logger: U()(g(i({}, l.opts), {
                            level: "trace"
                        }), x),
                        chunkLoggerController: x
                    }
                }(l)
            }
        },
        18431: function(l, c, x) {
            "use strict";
            x.d(c, {
                iO: function() {
                    return N
                }
            });
            let N = {
                waku: {
                    publish: "waku_publish",
                    batchPublish: "waku_batchPublish",
                    subscribe: "waku_subscribe",
                    batchSubscribe: "waku_batchSubscribe",
                    subscription: "waku_subscription",
                    unsubscribe: "waku_unsubscribe",
                    batchUnsubscribe: "waku_batchUnsubscribe",
                    batchFetchMessages: "waku_batchFetchMessages"
                },
                irn: {
                    publish: "irn_publish",
                    batchPublish: "irn_batchPublish",
                    subscribe: "irn_subscribe",
                    batchSubscribe: "irn_batchSubscribe",
                    subscription: "irn_subscription",
                    unsubscribe: "irn_unsubscribe",
                    batchUnsubscribe: "irn_batchUnsubscribe",
                    batchFetchMessages: "irn_batchFetchMessages"
                },
                iridium: {
                    publish: "iridium_publish",
                    batchPublish: "iridium_batchPublish",
                    subscribe: "iridium_subscribe",
                    batchSubscribe: "iridium_batchSubscribe",
                    subscription: "iridium_subscription",
                    unsubscribe: "iridium_unsubscribe",
                    batchUnsubscribe: "iridium_batchUnsubscribe",
                    batchFetchMessages: "iridium_batchFetchMessages"
                }
            }
        },
        69859: function() {},
        43283: function(l, c, x) {
            "use strict";
            x.d(c, {
                D: function() {
                    return safeJsonParse
                },
                u: function() {
                    return safeJsonStringify
                }
            });
            let JSONStringify = l => JSON.stringify(l, (l, c) => "bigint" == typeof c ? c.toString() + "n" : c),
                JSONParse = l => {
                    let c = l.replace(/([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, '$1"$2n"$3');
                    return JSON.parse(c, (l, c) => {
                        let x = "string" == typeof c && c.match(/^\d+n$/);
                        return x ? BigInt(c.substring(0, c.length - 1)) : c
                    })
                };

            function safeJsonParse(l) {
                if ("string" != typeof l) throw Error(`Cannot safe json parse value of type ${typeof l}`);
                try {
                    return JSONParse(l)
                } catch (c) {
                    return l
                }
            }

            function safeJsonStringify(l) {
                return "string" == typeof l ? l : JSONStringify(l) || ""
            }
        },
        24621: function(l, c, x) {
            "use strict";
            x.d(c, {
                TN: function() {
                    return eI
                },
                ZP: function() {
                    return oe
                },
                lO: function() {
                    return el
                },
                pG: function() {
                    return eM
                }
            });
            var N = x(1106),
                U = x(33234),
                Z = x(49979),
                $ = x(70723),
                Y = x(512),
                q = x.n(Y),
                J = x(58619),
                X = x(53620);
            let en = "client",
                er = `wc@2:${en}:`,
                ea = {
                    name: en,
                    logger: "error"
                },
                eo = "WALLETCONNECT_DEEPLINK_CHOICE",
                el = "Proposal expired",
                ec = J.SEVEN_DAYS,
                eu = {
                    wc_sessionPropose: {
                        req: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1100
                        },
                        res: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1101
                        },
                        reject: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1120
                        },
                        autoReject: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1121
                        }
                    },
                    wc_sessionSettle: {
                        req: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1102
                        },
                        res: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1103
                        }
                    },
                    wc_sessionUpdate: {
                        req: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1104
                        },
                        res: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1105
                        }
                    },
                    wc_sessionExtend: {
                        req: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1106
                        },
                        res: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1107
                        }
                    },
                    wc_sessionRequest: {
                        req: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1108
                        },
                        res: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1109
                        }
                    },
                    wc_sessionEvent: {
                        req: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1110
                        },
                        res: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1111
                        }
                    },
                    wc_sessionDelete: {
                        req: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1112
                        },
                        res: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1113
                        }
                    },
                    wc_sessionPing: {
                        req: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1114
                        },
                        res: {
                            ttl: J.ONE_DAY,
                            prompt: !1,
                            tag: 1115
                        }
                    },
                    wc_sessionAuthenticate: {
                        req: {
                            ttl: J.ONE_HOUR,
                            prompt: !0,
                            tag: 1116
                        },
                        res: {
                            ttl: J.ONE_HOUR,
                            prompt: !1,
                            tag: 1117
                        },
                        reject: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1118
                        },
                        autoReject: {
                            ttl: J.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1119
                        }
                    }
                },
                ed = {
                    min: J.FIVE_MINUTES,
                    max: J.SEVEN_DAYS
                },
                ep = {
                    idle: "IDLE",
                    active: "ACTIVE"
                },
                eh = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"],
                ey = "wc@1.5:auth:",
                ef = `${ey}:PUB_KEY`;
            var em = Object.defineProperty,
                eg = Object.defineProperties,
                eb = Object.getOwnPropertyDescriptors,
                ev = Object.getOwnPropertySymbols,
                ew = Object.prototype.hasOwnProperty,
                eT = Object.prototype.propertyIsEnumerable,
                We = (l, c, x) => c in l ? em(l, c, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: x
                }) : l[c] = x,
                y = (l, c) => {
                    for (var x in c || (c = {})) ew.call(c, x) && We(l, x, c[x]);
                    if (ev)
                        for (var x of ev(c)) eT.call(c, x) && We(l, x, c[x]);
                    return l
                },
                L = (l, c) => eg(l, eb(c));
            let Zt = class Zt extends Z.W3 {
                constructor(l) {
                    super(l), this.name = "engine", this.events = new(q()), this.initialized = !1, this.requestQueue = {
                        state: ep.idle,
                        queue: []
                    }, this.sessionRequestQueue = {
                        state: ep.idle,
                        queue: []
                    }, this.requestQueueDelay = J.ONE_SECOND, this.expectedPairingMethodMap = new Map, this.recentlyDeletedMap = new Map, this.recentlyDeletedLimit = 200, this.init = async () => {
                        this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                            methods: Object.keys(eu)
                        }), this.initialized = !0, setTimeout(() => {
                            this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
                        }, (0, J.toMiliseconds)(this.requestQueueDelay)))
                    }, this.connect = async l => {
                        await this.isInitialized();
                        let c = L(y({}, l), {
                            requiredNamespaces: l.requiredNamespaces || {},
                            optionalNamespaces: l.optionalNamespaces || {}
                        });
                        await this.isValidConnect(c);
                        let {
                            pairingTopic: x,
                            requiredNamespaces: U,
                            optionalNamespaces: Z,
                            sessionProperties: Y,
                            relays: q
                        } = c, X = x, en, er = !1;
                        try {
                            X && (er = this.client.core.pairing.pairings.get(X).active)
                        } catch (l) {
                            throw this.client.logger.error(`connect() -> pairing.get(${X}) failed`), l
                        }
                        if (!X || !er) {
                            let {
                                topic: l,
                                uri: c
                            } = await this.client.core.pairing.create();
                            X = l, en = c
                        }
                        if (!X) {
                            let {
                                message: l
                            } = (0, $.kCb)("NO_MATCHING_KEY", `connect() pairing topic: ${X}`);
                            throw Error(l)
                        }
                        let ea = await this.client.core.crypto.generateKeyPair(),
                            eo = eu.wc_sessionPropose.req.ttl || J.FIVE_MINUTES,
                            ec = (0, $.gn4)(eo),
                            ed = y({
                                requiredNamespaces: U,
                                optionalNamespaces: Z,
                                relays: q ? ? [{
                                    protocol: N.ZF
                                }],
                                proposer: {
                                    publicKey: ea,
                                    metadata: this.client.metadata
                                },
                                expiryTimestamp: ec,
                                pairingTopic: X
                            }, Y && {
                                sessionProperties: Y
                            }),
                            {
                                reject: ep,
                                resolve: eh,
                                done: ey
                            } = (0, $.H1S)(eo, el);
                        this.events.once((0, $.E0T)("session_connect"), async ({
                            error: l,
                            session: c
                        }) => {
                            if (l) ep(l);
                            else if (c) {
                                c.self.publicKey = ea;
                                let l = L(y({}, c), {
                                    pairingTopic: ed.pairingTopic,
                                    requiredNamespaces: ed.requiredNamespaces,
                                    optionalNamespaces: ed.optionalNamespaces
                                });
                                await this.client.session.set(c.topic, l), await this.setExpiry(c.topic, c.expiry), X && await this.client.core.pairing.updateMetadata({
                                    topic: X,
                                    metadata: c.peer.metadata
                                }), this.cleanupDuplicatePairings(l), eh(l)
                            }
                        });
                        let ef = await this.sendRequest({
                            topic: X,
                            method: "wc_sessionPropose",
                            params: ed,
                            throwOnFailedPublish: !0
                        });
                        return await this.setProposal(ef, y({
                            id: ef
                        }, ed)), {
                            uri: en,
                            approval: ey
                        }
                    }, this.pair = async l => {
                        await this.isInitialized();
                        try {
                            return await this.client.core.pairing.pair(l)
                        } catch (l) {
                            throw this.client.logger.error("pair() failed"), l
                        }
                    }, this.approve = async l => {
                        let c;
                        await this.isInitialized();
                        try {
                            await this.isValidApprove(l)
                        } catch (l) {
                            throw this.client.logger.error("approve() -> isValidApprove() failed"), l
                        }
                        let {
                            id: x,
                            relayProtocol: N,
                            namespaces: U,
                            sessionProperties: Z,
                            sessionConfig: Y
                        } = l;
                        try {
                            c = this.client.proposal.get(x)
                        } catch (l) {
                            throw this.client.logger.error(`approve() -> proposal.get(${x}) failed`), l
                        }
                        let {
                            pairingTopic: q,
                            proposer: J,
                            requiredNamespaces: X,
                            optionalNamespaces: en
                        } = c, er = await this.client.core.crypto.generateKeyPair(), ea = J.publicKey, eo = await this.client.core.crypto.generateSharedKey(er, ea), el = y(y({
                            relay: {
                                protocol: N ? ? "irn"
                            },
                            namespaces: U,
                            controller: {
                                publicKey: er,
                                metadata: this.client.metadata
                            },
                            expiry: (0, $.gn4)(ec)
                        }, Z && {
                            sessionProperties: Z
                        }), Y && {
                            sessionConfig: Y
                        });
                        await this.client.core.relayer.subscribe(eo);
                        let eu = L(y({}, el), {
                            topic: eo,
                            requiredNamespaces: X,
                            optionalNamespaces: en,
                            pairingTopic: q,
                            acknowledged: !1,
                            self: el.controller,
                            peer: {
                                publicKey: J.publicKey,
                                metadata: J.metadata
                            },
                            controller: er
                        });
                        await this.client.session.set(eo, eu);
                        try {
                            await this.sendResult({
                                id: x,
                                topic: q,
                                result: {
                                    relay: {
                                        protocol: N ? ? "irn"
                                    },
                                    responderPublicKey: er
                                },
                                throwOnFailedPublish: !0
                            }), await this.sendRequest({
                                topic: eo,
                                method: "wc_sessionSettle",
                                params: el,
                                throwOnFailedPublish: !0
                            })
                        } catch (l) {
                            throw this.client.logger.error(l), this.client.session.delete(eo, (0, $.D6H)("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(eo), l
                        }
                        return await this.client.core.pairing.updateMetadata({
                            topic: q,
                            metadata: J.metadata
                        }), await this.client.proposal.delete(x, (0, $.D6H)("USER_DISCONNECTED")), await this.client.core.pairing.activate({
                            topic: q
                        }), await this.setExpiry(eo, (0, $.gn4)(ec)), {
                            topic: eo,
                            acknowledged: () => new Promise(l => setTimeout(() => l(this.client.session.get(eo)), 500))
                        }
                    }, this.reject = async l => {
                        let c;
                        await this.isInitialized();
                        try {
                            await this.isValidReject(l)
                        } catch (l) {
                            throw this.client.logger.error("reject() -> isValidReject() failed"), l
                        }
                        let {
                            id: x,
                            reason: N
                        } = l;
                        try {
                            c = this.client.proposal.get(x).pairingTopic
                        } catch (l) {
                            throw this.client.logger.error(`reject() -> proposal.get(${x}) failed`), l
                        }
                        c && (await this.sendError({
                            id: x,
                            topic: c,
                            error: N,
                            rpcOpts: eu.wc_sessionPropose.reject
                        }), await this.client.proposal.delete(x, (0, $.D6H)("USER_DISCONNECTED")))
                    }, this.update = async l => {
                        await this.isInitialized();
                        try {
                            await this.isValidUpdate(l)
                        } catch (l) {
                            throw this.client.logger.error("update() -> isValidUpdate() failed"), l
                        }
                        let {
                            topic: c,
                            namespaces: x
                        } = l, {
                            done: N,
                            resolve: U,
                            reject: Z
                        } = (0, $.H1S)(), Y = (0, X.payloadId)(), q = (0, X.getBigIntRpcId)().toString(), J = this.client.session.get(c).namespaces;
                        return this.events.once((0, $.E0T)("session_update", Y), ({
                            error: l
                        }) => {
                            l ? Z(l) : U()
                        }), await this.client.session.update(c, {
                            namespaces: x
                        }), await this.sendRequest({
                            topic: c,
                            method: "wc_sessionUpdate",
                            params: {
                                namespaces: x
                            },
                            throwOnFailedPublish: !0,
                            clientRpcId: Y,
                            relayRpcId: q
                        }).catch(l => {
                            this.client.logger.error(l), this.client.session.update(c, {
                                namespaces: J
                            }), Z(l)
                        }), {
                            acknowledged: N
                        }
                    }, this.extend = async l => {
                        await this.isInitialized();
                        try {
                            await this.isValidExtend(l)
                        } catch (l) {
                            throw this.client.logger.error("extend() -> isValidExtend() failed"), l
                        }
                        let {
                            topic: c
                        } = l, x = (0, X.payloadId)(), {
                            done: N,
                            resolve: U,
                            reject: Z
                        } = (0, $.H1S)();
                        return this.events.once((0, $.E0T)("session_extend", x), ({
                            error: l
                        }) => {
                            l ? Z(l) : U()
                        }), await this.setExpiry(c, (0, $.gn4)(ec)), this.sendRequest({
                            topic: c,
                            method: "wc_sessionExtend",
                            params: {},
                            clientRpcId: x,
                            throwOnFailedPublish: !0
                        }).catch(l => {
                            Z(l)
                        }), {
                            acknowledged: N
                        }
                    }, this.request = async l => {
                        await this.isInitialized();
                        try {
                            await this.isValidRequest(l)
                        } catch (l) {
                            throw this.client.logger.error("request() -> isValidRequest() failed"), l
                        }
                        let {
                            chainId: c,
                            request: x,
                            topic: N,
                            expiry: U = eu.wc_sessionRequest.req.ttl
                        } = l, Z = this.client.session.get(N), Y = (0, X.payloadId)(), q = (0, X.getBigIntRpcId)().toString(), {
                            done: J,
                            resolve: en,
                            reject: er
                        } = (0, $.H1S)(U, "Request expired. Please try again.");
                        return this.events.once((0, $.E0T)("session_request", Y), ({
                            error: l,
                            result: c
                        }) => {
                            l ? er(l) : en(c)
                        }), await Promise.all([new Promise(async l => {
                            await this.sendRequest({
                                clientRpcId: Y,
                                relayRpcId: q,
                                topic: N,
                                method: "wc_sessionRequest",
                                params: {
                                    request: L(y({}, x), {
                                        expiryTimestamp: (0, $.gn4)(U)
                                    }),
                                    chainId: c
                                },
                                expiry: U,
                                throwOnFailedPublish: !0
                            }).catch(l => er(l)), this.client.events.emit("session_request_sent", {
                                topic: N,
                                request: x,
                                chainId: c,
                                id: Y
                            }), l()
                        }), new Promise(async l => {
                            var c;
                            if (!(null != (c = Z.sessionConfig) && c.disableDeepLink)) {
                                let l = await (0, $.bW6)(this.client.core.storage, eo);
                                (0, $.HhN)({
                                    id: Y,
                                    topic: N,
                                    wcDeepLink: l
                                })
                            }
                            l()
                        }), J()]).then(l => l[2])
                    }, this.respond = async l => {
                        await this.isInitialized(), await this.isValidRespond(l);
                        let {
                            topic: c,
                            response: x
                        } = l, {
                            id: N
                        } = x;
                        (0, X.isJsonRpcResult)(x) ? await this.sendResult({
                            id: N,
                            topic: c,
                            result: x.result,
                            throwOnFailedPublish: !0
                        }): (0, X.isJsonRpcError)(x) && await this.sendError({
                            id: N,
                            topic: c,
                            error: x.error
                        }), this.cleanupAfterResponse(l)
                    }, this.ping = async l => {
                        await this.isInitialized();
                        try {
                            await this.isValidPing(l)
                        } catch (l) {
                            throw this.client.logger.error("ping() -> isValidPing() failed"), l
                        }
                        let {
                            topic: c
                        } = l;
                        if (this.client.session.keys.includes(c)) {
                            let l = (0, X.payloadId)(),
                                x = (0, X.getBigIntRpcId)().toString(),
                                {
                                    done: N,
                                    resolve: U,
                                    reject: Z
                                } = (0, $.H1S)();
                            this.events.once((0, $.E0T)("session_ping", l), ({
                                error: l
                            }) => {
                                l ? Z(l) : U()
                            }), await Promise.all([this.sendRequest({
                                topic: c,
                                method: "wc_sessionPing",
                                params: {},
                                throwOnFailedPublish: !0,
                                clientRpcId: l,
                                relayRpcId: x
                            }), N()])
                        } else this.client.core.pairing.pairings.keys.includes(c) && await this.client.core.pairing.ping({
                            topic: c
                        })
                    }, this.emit = async l => {
                        await this.isInitialized(), await this.isValidEmit(l);
                        let {
                            topic: c,
                            event: x,
                            chainId: N
                        } = l, U = (0, X.getBigIntRpcId)().toString();
                        await this.sendRequest({
                            topic: c,
                            method: "wc_sessionEvent",
                            params: {
                                event: x,
                                chainId: N
                            },
                            throwOnFailedPublish: !0,
                            relayRpcId: U
                        })
                    }, this.disconnect = async l => {
                        await this.isInitialized(), await this.isValidDisconnect(l);
                        let {
                            topic: c
                        } = l;
                        if (this.client.session.keys.includes(c)) await this.sendRequest({
                            topic: c,
                            method: "wc_sessionDelete",
                            params: (0, $.D6H)("USER_DISCONNECTED"),
                            throwOnFailedPublish: !0
                        }), await this.deleteSession({
                            topic: c,
                            emitEvent: !1
                        });
                        else if (this.client.core.pairing.pairings.keys.includes(c)) await this.client.core.pairing.disconnect({
                            topic: c
                        });
                        else {
                            let {
                                message: l
                            } = (0, $.kCb)("MISMATCHED_TOPIC", `Session or pairing topic not found: ${c}`);
                            throw Error(l)
                        }
                    }, this.find = l => (this.isInitialized(), this.client.session.getAll().filter(c => (0, $.Ih8)(c, l))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async l => {
                        this.isInitialized(), this.isValidAuthenticate(l);
                        let {
                            chains: c,
                            statement: x = "",
                            uri: N,
                            domain: U,
                            nonce: Z,
                            type: Y,
                            exp: q,
                            nbf: J,
                            methods: en = [],
                            expiry: er
                        } = l, ea = [...l.resources || []], {
                            topic: eo,
                            uri: el
                        } = await this.client.core.pairing.create({
                            methods: ["wc_sessionAuthenticate"]
                        });
                        this.client.logger.info({
                            message: "Generated new pairing",
                            pairing: {
                                topic: eo,
                                uri: el
                            }
                        });
                        let ed = await this.client.core.crypto.generateKeyPair(),
                            ep = (0, $.YmJ)(ed);
                        if (await Promise.all([this.client.auth.authKeys.set(ef, {
                                responseTopic: ep,
                                publicKey: ed
                            }), this.client.auth.pairingTopics.set(ep, {
                                topic: ep,
                                pairingTopic: eo
                            })]), await this.client.core.relayer.subscribe(ep), this.client.logger.info(`sending request to new pairing topic: ${eo}`), en.length > 0) {
                            let {
                                namespace: l
                            } = (0, $.DQe)(c[0]), x = (0, $.IkP)(l, "request", en);
                            (0, $.hA9)(ea) && (x = (0, $.qJM)(x, ea.pop())), ea.push(x)
                        }
                        let eh = er && er > eu.wc_sessionAuthenticate.req.ttl ? er : eu.wc_sessionAuthenticate.req.ttl,
                            ey = {
                                authPayload: {
                                    type: Y ? ? "caip122",
                                    chains: c,
                                    statement: x,
                                    aud: N,
                                    domain: U,
                                    version: "1",
                                    nonce: Z,
                                    iat: new Date().toISOString(),
                                    exp: q,
                                    nbf: J,
                                    resources: ea
                                },
                                requester: {
                                    publicKey: ed,
                                    metadata: this.client.metadata
                                },
                                expiryTimestamp: (0, $.gn4)(eh)
                            },
                            em = {
                                eip155: {
                                    chains: c,
                                    methods: [...new Set(["personal_sign", ...en])],
                                    events: ["chainChanged", "accountsChanged"]
                                }
                            },
                            eg = {
                                requiredNamespaces: {},
                                optionalNamespaces: em,
                                relays: [{
                                    protocol: "irn"
                                }],
                                pairingTopic: eo,
                                proposer: {
                                    publicKey: ed,
                                    metadata: this.client.metadata
                                },
                                expiryTimestamp: (0, $.gn4)(eu.wc_sessionPropose.req.ttl)
                            },
                            {
                                done: eb,
                                resolve: ev,
                                reject: ew
                            } = (0, $.H1S)(eh, "Request expired"),
                            W = async ({
                                error: l,
                                session: c
                            }) => {
                                if (this.events.off((0, $.E0T)("session_request", eT), ce), l) ew(l);
                                else if (c) {
                                    c.self.publicKey = ed, await this.client.session.set(c.topic, c), await this.setExpiry(c.topic, c.expiry), eo && await this.client.core.pairing.updateMetadata({
                                        topic: eo,
                                        metadata: c.peer.metadata
                                    });
                                    let l = this.client.session.get(c.topic);
                                    await this.deleteProposal(eM), ev({
                                        session: l
                                    })
                                }
                            },
                            ce = async l => {
                                let c;
                                if (await this.deletePendingAuthRequest(eT, {
                                        message: "fulfilled",
                                        code: 0
                                    }), l.error) {
                                    let c = (0, $.D6H)("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
                                    return l.error.code === c.code ? void 0 : (this.events.off((0, $.E0T)("session_connect"), W), ew(l.error.message))
                                }
                                await this.deleteProposal(eM), this.events.off((0, $.E0T)("session_connect"), W);
                                let {
                                    cacaos: x,
                                    responder: N
                                } = l.result, U = [], Z = [];
                                for (let l of x) {
                                    await (0, $.c4l)({
                                        cacao: l,
                                        projectId: this.client.core.projectId
                                    }) || (this.client.logger.error(l, "Signature verification failed"), ew((0, $.D6H)("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
                                    let {
                                        p: c
                                    } = l, x = (0, $.hA9)(c.resources), N = [(0, $.DJo)(c.iss)], Y = (0, $.NmC)(c.iss);
                                    if (x) {
                                        let l = (0, $.Y31)(x),
                                            c = (0, $.ouN)(x);
                                        U.push(...l), N.push(...c)
                                    }
                                    for (let l of N) Z.push(`${l}:${Y}`)
                                }
                                let Y = await this.client.core.crypto.generateSharedKey(ed, N.publicKey);
                                U.length > 0 && (c = {
                                    topic: Y,
                                    acknowledged: !0,
                                    self: {
                                        publicKey: ed,
                                        metadata: this.client.metadata
                                    },
                                    peer: N,
                                    controller: N.publicKey,
                                    expiry: (0, $.gn4)(ec),
                                    requiredNamespaces: {},
                                    optionalNamespaces: {},
                                    relay: {
                                        protocol: "irn"
                                    },
                                    pairingTopic: eo,
                                    namespaces: (0, $.E12)([...new Set(U)], [...new Set(Z)])
                                }, await this.client.core.relayer.subscribe(Y), await this.client.session.set(Y, c), c = this.client.session.get(Y)), ev({
                                    auths: x,
                                    session: c
                                })
                            },
                            eT = (0, X.payloadId)(),
                            eM = (0, X.payloadId)();
                        this.events.once((0, $.E0T)("session_connect"), W), this.events.once((0, $.E0T)("session_request", eT), ce);
                        try {
                            await Promise.all([this.sendRequest({
                                topic: eo,
                                method: "wc_sessionAuthenticate",
                                params: ey,
                                expiry: l.expiry,
                                throwOnFailedPublish: !0,
                                clientRpcId: eT
                            }), this.sendRequest({
                                topic: eo,
                                method: "wc_sessionPropose",
                                params: eg,
                                expiry: eu.wc_sessionPropose.req.ttl,
                                throwOnFailedPublish: !0,
                                clientRpcId: eM
                            })])
                        } catch (l) {
                            throw this.events.off((0, $.E0T)("session_connect"), W), this.events.off((0, $.E0T)("session_request", eT), ce), l
                        }
                        return await this.setProposal(eM, y({
                            id: eM
                        }, eg)), await this.setAuthRequest(eT, {
                            request: L(y({}, ey), {
                                verifyContext: {}
                            }),
                            pairingTopic: eo
                        }), {
                            uri: el,
                            response: eb
                        }
                    }, this.approveSessionAuthenticate = async l => {
                        let c;
                        this.isInitialized();
                        let {
                            id: x,
                            auths: N
                        } = l, U = this.getPendingAuthRequest(x);
                        if (!U) throw Error(`Could not find pending auth request with id ${x}`);
                        let Z = U.requester.publicKey,
                            Y = await this.client.core.crypto.generateKeyPair(),
                            q = (0, $.YmJ)(Z),
                            J = {
                                type: $.rVF,
                                receiverPublicKey: Z,
                                senderPublicKey: Y
                            },
                            X = [],
                            en = [];
                        for (let l of N) {
                            if (!await (0, $.c4l)({
                                    cacao: l,
                                    projectId: this.client.core.projectId
                                })) {
                                let l = (0, $.D6H)("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
                                throw await this.sendError({
                                    id: x,
                                    topic: q,
                                    error: l,
                                    encodeOpts: J
                                }), Error(l.message)
                            }
                            let {
                                p: c
                            } = l, N = (0, $.hA9)(c.resources), U = [(0, $.DJo)(c.iss)], Z = (0, $.NmC)(c.iss);
                            if (N) {
                                let l = (0, $.Y31)(N),
                                    c = (0, $.ouN)(N);
                                X.push(...l), U.push(...c)
                            }
                            for (let l of U) en.push(`${l}:${Z}`)
                        }
                        let er = await this.client.core.crypto.generateSharedKey(Y, Z);
                        return X ? .length > 0 && (c = {
                            topic: er,
                            acknowledged: !0,
                            self: {
                                publicKey: Y,
                                metadata: this.client.metadata
                            },
                            peer: {
                                publicKey: Z,
                                metadata: U.requester.metadata
                            },
                            controller: Z,
                            expiry: (0, $.gn4)(ec),
                            authentication: N,
                            requiredNamespaces: {},
                            optionalNamespaces: {},
                            relay: {
                                protocol: "irn"
                            },
                            pairingTopic: "",
                            namespaces: (0, $.E12)([...new Set(X)], [...new Set(en)])
                        }, await this.client.core.relayer.subscribe(er), await this.client.session.set(er, c)), await this.sendResult({
                            topic: q,
                            id: x,
                            result: {
                                cacaos: N,
                                responder: {
                                    publicKey: Y,
                                    metadata: this.client.metadata
                                }
                            },
                            encodeOpts: J,
                            throwOnFailedPublish: !0
                        }), await this.client.auth.requests.delete(x, {
                            message: "fulfilled",
                            code: 0
                        }), await this.client.core.pairing.activate({
                            topic: U.pairingTopic
                        }), {
                            session: c
                        }
                    }, this.rejectSessionAuthenticate = async l => {
                        await this.isInitialized();
                        let {
                            id: c,
                            reason: x
                        } = l, N = this.getPendingAuthRequest(c);
                        if (!N) throw Error(`Could not find pending auth request with id ${c}`);
                        let U = N.requester.publicKey,
                            Z = await this.client.core.crypto.generateKeyPair(),
                            Y = (0, $.YmJ)(U),
                            q = {
                                type: $.rVF,
                                receiverPublicKey: U,
                                senderPublicKey: Z
                            };
                        await this.sendError({
                            id: c,
                            topic: Y,
                            error: x,
                            encodeOpts: q,
                            rpcOpts: eu.wc_sessionAuthenticate.reject
                        }), await this.client.auth.requests.delete(c, {
                            message: "rejected",
                            code: 0
                        }), await this.client.proposal.delete(c, (0, $.D6H)("USER_DISCONNECTED"))
                    }, this.formatAuthMessage = l => {
                        this.isInitialized();
                        let {
                            request: c,
                            iss: x
                        } = l;
                        return (0, $.wvx)(c, x)
                    }, this.cleanupDuplicatePairings = async l => {
                        if (l.pairingTopic) try {
                            let c = this.client.core.pairing.pairings.get(l.pairingTopic),
                                x = this.client.core.pairing.pairings.getAll().filter(x => {
                                    var N, U;
                                    return (null == (N = x.peerMetadata) ? void 0 : N.url) && (null == (U = x.peerMetadata) ? void 0 : U.url) === l.peer.metadata.url && x.topic && x.topic !== c.topic
                                });
                            if (0 === x.length) return;
                            this.client.logger.info(`Cleaning up ${x.length} duplicate pairing(s)`), await Promise.all(x.map(l => this.client.core.pairing.disconnect({
                                topic: l.topic
                            }))), this.client.logger.info("Duplicate pairings clean up finished")
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    }, this.deleteSession = async l => {
                        var c;
                        let {
                            topic: x,
                            expirerHasDeleted: N = !1,
                            emitEvent: U = !0,
                            id: Z = 0
                        } = l, {
                            self: Y
                        } = this.client.session.get(x);
                        await this.client.core.relayer.unsubscribe(x), await this.client.session.delete(x, (0, $.D6H)("USER_DISCONNECTED")), this.addToRecentlyDeleted(x, "session"), this.client.core.crypto.keychain.has(Y.publicKey) && await this.client.core.crypto.deleteKeyPair(Y.publicKey), this.client.core.crypto.keychain.has(x) && await this.client.core.crypto.deleteSymKey(x), N || this.client.core.expirer.del(x), this.client.core.storage.removeItem(eo).catch(l => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach(l => {
                            l.topic === x && this.deletePendingSessionRequest(l.id, (0, $.D6H)("USER_DISCONNECTED"))
                        }), x === (null == (c = this.sessionRequestQueue.queue[0]) ? void 0 : c.topic) && (this.sessionRequestQueue.state = ep.idle), U && this.client.events.emit("session_delete", {
                            id: Z,
                            topic: x
                        })
                    }, this.deleteProposal = async (l, c) => {
                        await Promise.all([this.client.proposal.delete(l, (0, $.D6H)("USER_DISCONNECTED")), c ? Promise.resolve() : this.client.core.expirer.del(l)]), this.addToRecentlyDeleted(l, "proposal")
                    }, this.deletePendingSessionRequest = async (l, c, x = !1) => {
                        await Promise.all([this.client.pendingRequest.delete(l, c), x ? Promise.resolve() : this.client.core.expirer.del(l)]), this.addToRecentlyDeleted(l, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(c => c.id !== l), x && (this.sessionRequestQueue.state = ep.idle, this.client.events.emit("session_request_expire", {
                            id: l
                        }))
                    }, this.deletePendingAuthRequest = async (l, c, x = !1) => {
                        await Promise.all([this.client.auth.requests.delete(l, c), x ? Promise.resolve() : this.client.core.expirer.del(l)])
                    }, this.setExpiry = async (l, c) => {
                        this.client.session.keys.includes(l) && (this.client.core.expirer.set(l, c), await this.client.session.update(l, {
                            expiry: c
                        }))
                    }, this.setProposal = async (l, c) => {
                        this.client.core.expirer.set(l, (0, $.gn4)(eu.wc_sessionPropose.req.ttl)), await this.client.proposal.set(l, c)
                    }, this.setAuthRequest = async (l, c) => {
                        let {
                            request: x,
                            pairingTopic: N
                        } = c;
                        this.client.core.expirer.set(l, x.expiryTimestamp), await this.client.auth.requests.set(l, {
                            authPayload: x.authPayload,
                            requester: x.requester,
                            expiryTimestamp: x.expiryTimestamp,
                            id: l,
                            pairingTopic: N,
                            verifyContext: x.verifyContext
                        })
                    }, this.setPendingSessionRequest = async l => {
                        let {
                            id: c,
                            topic: x,
                            params: N,
                            verifyContext: U
                        } = l, Z = N.request.expiryTimestamp || (0, $.gn4)(eu.wc_sessionRequest.req.ttl);
                        this.client.core.expirer.set(c, Z), await this.client.pendingRequest.set(c, {
                            id: c,
                            topic: x,
                            params: N,
                            verifyContext: U
                        })
                    }, this.sendRequest = async l => {
                        let c;
                        let {
                            topic: x,
                            method: N,
                            params: U,
                            expiry: Z,
                            relayRpcId: Y,
                            clientRpcId: q,
                            throwOnFailedPublish: J
                        } = l, en = (0, X.formatJsonRpcRequest)(N, U, q);
                        if ((0, $.jUY)() && eh.includes(N)) {
                            let l = (0, $.rjm)(JSON.stringify(en));
                            this.client.core.verify.register({
                                attestationId: l
                            })
                        }
                        try {
                            c = await this.client.core.crypto.encode(x, en)
                        } catch (l) {
                            throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${x} failed`), l
                        }
                        let er = eu[N].req;
                        return Z && (er.ttl = Z), Y && (er.id = Y), this.client.core.history.set(x, en), J ? (er.internal = L(y({}, er.internal), {
                            throwOnFailedPublish: !0
                        }), await this.client.core.relayer.publish(x, c, er)) : this.client.core.relayer.publish(x, c, er).catch(l => this.client.logger.error(l)), en.id
                    }, this.sendResult = async l => {
                        let c, x;
                        let {
                            id: N,
                            topic: U,
                            result: Z,
                            throwOnFailedPublish: $,
                            encodeOpts: Y
                        } = l, q = (0, X.formatJsonRpcResult)(N, Z);
                        try {
                            c = await this.client.core.crypto.encode(U, q, Y)
                        } catch (l) {
                            throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${U} failed`), l
                        }
                        try {
                            x = await this.client.core.history.get(U, N)
                        } catch (l) {
                            throw this.client.logger.error(`sendResult() -> history.get(${U}, ${N}) failed`), l
                        }
                        let J = eu[x.request.method].res;
                        $ ? (J.internal = L(y({}, J.internal), {
                            throwOnFailedPublish: !0
                        }), await this.client.core.relayer.publish(U, c, J)) : this.client.core.relayer.publish(U, c, J).catch(l => this.client.logger.error(l)), await this.client.core.history.resolve(q)
                    }, this.sendError = async l => {
                        let c, x;
                        let {
                            id: N,
                            topic: U,
                            error: Z,
                            encodeOpts: $,
                            rpcOpts: Y
                        } = l, q = (0, X.formatJsonRpcError)(N, Z);
                        try {
                            c = await this.client.core.crypto.encode(U, q, $)
                        } catch (l) {
                            throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${U} failed`), l
                        }
                        try {
                            x = await this.client.core.history.get(U, N)
                        } catch (l) {
                            throw this.client.logger.error(`sendError() -> history.get(${U}, ${N}) failed`), l
                        }
                        let J = Y || eu[x.request.method].res;
                        this.client.core.relayer.publish(U, c, J), await this.client.core.history.resolve(q)
                    }, this.cleanup = async () => {
                        let l = [],
                            c = [];
                        this.client.session.getAll().forEach(c => {
                            let x = !1;
                            (0, $.BwD)(c.expiry) && (x = !0), this.client.core.crypto.keychain.has(c.topic) || (x = !0), x && l.push(c.topic)
                        }), this.client.proposal.getAll().forEach(l => {
                            (0, $.BwD)(l.expiryTimestamp) && c.push(l.id)
                        }), await Promise.all([...l.map(l => this.deleteSession({
                            topic: l
                        })), ...c.map(l => this.deleteProposal(l))])
                    }, this.onRelayEventRequest = async l => {
                        this.requestQueue.queue.push(l), await this.processRequestsQueue()
                    }, this.processRequestsQueue = async () => {
                        if (this.requestQueue.state === ep.active) {
                            this.client.logger.info("Request queue already active, skipping...");
                            return
                        }
                        for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                            this.requestQueue.state = ep.active;
                            let l = this.requestQueue.queue.shift();
                            if (l) try {
                                this.processRequest(l), await new Promise(l => setTimeout(l, 300))
                            } catch (l) {
                                this.client.logger.warn(l)
                            }
                        }
                        this.requestQueue.state = ep.idle
                    }, this.processRequest = l => {
                        let {
                            topic: c,
                            payload: x
                        } = l, N = x.method;
                        if (!this.shouldIgnorePairingRequest({
                                topic: c,
                                requestMethod: N
                            })) switch (N) {
                            case "wc_sessionPropose":
                                return this.onSessionProposeRequest(c, x);
                            case "wc_sessionSettle":
                                return this.onSessionSettleRequest(c, x);
                            case "wc_sessionUpdate":
                                return this.onSessionUpdateRequest(c, x);
                            case "wc_sessionExtend":
                                return this.onSessionExtendRequest(c, x);
                            case "wc_sessionPing":
                                return this.onSessionPingRequest(c, x);
                            case "wc_sessionDelete":
                                return this.onSessionDeleteRequest(c, x);
                            case "wc_sessionRequest":
                                return this.onSessionRequest(c, x);
                            case "wc_sessionEvent":
                                return this.onSessionEventRequest(c, x);
                            case "wc_sessionAuthenticate":
                                return this.onSessionAuthenticateRequest(c, x);
                            default:
                                return this.client.logger.info(`Unsupported request method ${N}`)
                        }
                    }, this.onRelayEventResponse = async l => {
                        let {
                            topic: c,
                            payload: x
                        } = l, N = (await this.client.core.history.get(c, x.id)).request.method;
                        switch (N) {
                            case "wc_sessionPropose":
                                return this.onSessionProposeResponse(c, x);
                            case "wc_sessionSettle":
                                return this.onSessionSettleResponse(c, x);
                            case "wc_sessionUpdate":
                                return this.onSessionUpdateResponse(c, x);
                            case "wc_sessionExtend":
                                return this.onSessionExtendResponse(c, x);
                            case "wc_sessionPing":
                                return this.onSessionPingResponse(c, x);
                            case "wc_sessionRequest":
                                return this.onSessionRequestResponse(c, x);
                            case "wc_sessionAuthenticate":
                                return this.onSessionAuthenticateResponse(c, x);
                            default:
                                return this.client.logger.info(`Unsupported response method ${N}`)
                        }
                    }, this.onRelayEventUnknownPayload = l => {
                        let {
                            topic: c
                        } = l, {
                            message: x
                        } = (0, $.kCb)("MISSING_OR_INVALID", `Decoded payload on topic ${c} is not identifiable as a JSON-RPC request or a response.`);
                        throw Error(x)
                    }, this.shouldIgnorePairingRequest = l => {
                        let {
                            topic: c,
                            requestMethod: x
                        } = l, N = this.expectedPairingMethodMap.get(c);
                        return !(!N || N.includes(x)) && !!(N.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0)
                    }, this.onSessionProposeRequest = async (l, c) => {
                        let {
                            params: x,
                            id: N
                        } = c;
                        try {
                            this.isValidConnect(y({}, c.params));
                            let U = x.expiryTimestamp || (0, $.gn4)(eu.wc_sessionPropose.req.ttl),
                                Z = y({
                                    id: N,
                                    pairingTopic: l,
                                    expiryTimestamp: U
                                }, x);
                            await this.setProposal(N, Z);
                            let Y = (0, $.rjm)(JSON.stringify(c)),
                                q = await this.getVerifyContext(Y, Z.proposer.metadata);
                            this.client.events.emit("session_proposal", {
                                id: N,
                                params: Z,
                                verifyContext: q
                            })
                        } catch (c) {
                            await this.sendError({
                                id: N,
                                topic: l,
                                error: c,
                                rpcOpts: eu.wc_sessionPropose.autoReject
                            }), this.client.logger.error(c)
                        }
                    }, this.onSessionProposeResponse = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        if ((0, X.isJsonRpcResult)(c)) {
                            let {
                                result: N
                            } = c;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                result: N
                            });
                            let U = this.client.proposal.get(x);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                proposal: U
                            });
                            let Z = U.proposer.publicKey;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                selfPublicKey: Z
                            });
                            let $ = N.responderPublicKey;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                peerPublicKey: $
                            });
                            let Y = await this.client.core.crypto.generateSharedKey(Z, $);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                sessionTopic: Y
                            });
                            let q = await this.client.core.relayer.subscribe(Y);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                subscriptionId: q
                            }), await this.client.core.pairing.activate({
                                topic: l
                            })
                        } else if ((0, X.isJsonRpcError)(c)) {
                            await this.client.proposal.delete(x, (0, $.D6H)("USER_DISCONNECTED"));
                            let l = (0, $.E0T)("session_connect");
                            if (0 === this.events.listenerCount(l)) throw Error(`emitting ${l} without any listeners, 954`);
                            this.events.emit((0, $.E0T)("session_connect"), {
                                error: c.error
                            })
                        }
                    }, this.onSessionSettleRequest = async (l, c) => {
                        let {
                            id: x,
                            params: N
                        } = c;
                        try {
                            this.isValidSessionSettleRequest(N);
                            let {
                                relay: x,
                                controller: U,
                                expiry: Z,
                                namespaces: Y,
                                sessionProperties: q,
                                sessionConfig: J
                            } = c.params, X = y(y({
                                topic: l,
                                relay: x,
                                expiry: Z,
                                namespaces: Y,
                                acknowledged: !0,
                                pairingTopic: "",
                                requiredNamespaces: {},
                                optionalNamespaces: {},
                                controller: U.publicKey,
                                self: {
                                    publicKey: "",
                                    metadata: this.client.metadata
                                },
                                peer: {
                                    publicKey: U.publicKey,
                                    metadata: U.metadata
                                }
                            }, q && {
                                sessionProperties: q
                            }), J && {
                                sessionConfig: J
                            });
                            await this.sendResult({
                                id: c.id,
                                topic: l,
                                result: !0,
                                throwOnFailedPublish: !0
                            });
                            let en = (0, $.E0T)("session_connect");
                            if (0 === this.events.listenerCount(en)) throw Error(`emitting ${en} without any listeners 997`);
                            this.events.emit((0, $.E0T)("session_connect"), {
                                session: X
                            })
                        } catch (c) {
                            await this.sendError({
                                id: x,
                                topic: l,
                                error: c
                            }), this.client.logger.error(c)
                        }
                    }, this.onSessionSettleResponse = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        (0, X.isJsonRpcResult)(c) ? (await this.client.session.update(l, {
                            acknowledged: !0
                        }), this.events.emit((0, $.E0T)("session_approve", x), {})) : (0, X.isJsonRpcError)(c) && (await this.client.session.delete(l, (0, $.D6H)("USER_DISCONNECTED")), this.events.emit((0, $.E0T)("session_approve", x), {
                            error: c.error
                        }))
                    }, this.onSessionUpdateRequest = async (l, c) => {
                        let {
                            params: x,
                            id: N
                        } = c;
                        try {
                            let c = `${l}_session_update`,
                                U = $.O6B.get(c);
                            if (U && this.isRequestOutOfSync(U, N)) {
                                this.client.logger.info(`Discarding out of sync request - ${N}`), this.sendError({
                                    id: N,
                                    topic: l,
                                    error: (0, $.D6H)("INVALID_UPDATE_REQUEST")
                                });
                                return
                            }
                            this.isValidUpdate(y({
                                topic: l
                            }, x));
                            try {
                                $.O6B.set(c, N), await this.client.session.update(l, {
                                    namespaces: x.namespaces
                                }), await this.sendResult({
                                    id: N,
                                    topic: l,
                                    result: !0,
                                    throwOnFailedPublish: !0
                                })
                            } catch (l) {
                                throw $.O6B.delete(c), l
                            }
                            this.client.events.emit("session_update", {
                                id: N,
                                topic: l,
                                params: x
                            })
                        } catch (c) {
                            await this.sendError({
                                id: N,
                                topic: l,
                                error: c
                            }), this.client.logger.error(c)
                        }
                    }, this.isRequestOutOfSync = (l, c) => parseInt(c.toString().slice(0, -3)) <= parseInt(l.toString().slice(0, -3)), this.onSessionUpdateResponse = (l, c) => {
                        let {
                            id: x
                        } = c, N = (0, $.E0T)("session_update", x);
                        if (0 === this.events.listenerCount(N)) throw Error(`emitting ${N} without any listeners`);
                        (0, X.isJsonRpcResult)(c) ? this.events.emit((0, $.E0T)("session_update", x), {}): (0, X.isJsonRpcError)(c) && this.events.emit((0, $.E0T)("session_update", x), {
                            error: c.error
                        })
                    }, this.onSessionExtendRequest = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        try {
                            this.isValidExtend({
                                topic: l
                            }), await this.setExpiry(l, (0, $.gn4)(ec)), await this.sendResult({
                                id: x,
                                topic: l,
                                result: !0,
                                throwOnFailedPublish: !0
                            }), this.client.events.emit("session_extend", {
                                id: x,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError({
                                id: x,
                                topic: l,
                                error: c
                            }), this.client.logger.error(c)
                        }
                    }, this.onSessionExtendResponse = (l, c) => {
                        let {
                            id: x
                        } = c, N = (0, $.E0T)("session_extend", x);
                        if (0 === this.events.listenerCount(N)) throw Error(`emitting ${N} without any listeners`);
                        (0, X.isJsonRpcResult)(c) ? this.events.emit((0, $.E0T)("session_extend", x), {}): (0, X.isJsonRpcError)(c) && this.events.emit((0, $.E0T)("session_extend", x), {
                            error: c.error
                        })
                    }, this.onSessionPingRequest = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        try {
                            this.isValidPing({
                                topic: l
                            }), await this.sendResult({
                                id: x,
                                topic: l,
                                result: !0,
                                throwOnFailedPublish: !0
                            }), this.client.events.emit("session_ping", {
                                id: x,
                                topic: l
                            })
                        } catch (c) {
                            await this.sendError({
                                id: x,
                                topic: l,
                                error: c
                            }), this.client.logger.error(c)
                        }
                    }, this.onSessionPingResponse = (l, c) => {
                        let {
                            id: x
                        } = c, N = (0, $.E0T)("session_ping", x);
                        if (0 === this.events.listenerCount(N)) throw Error(`emitting ${N} without any listeners`);
                        setTimeout(() => {
                            (0, X.isJsonRpcResult)(c) ? this.events.emit((0, $.E0T)("session_ping", x), {}): (0, X.isJsonRpcError)(c) && this.events.emit((0, $.E0T)("session_ping", x), {
                                error: c.error
                            })
                        }, 500)
                    }, this.onSessionDeleteRequest = async (l, c) => {
                        let {
                            id: x
                        } = c;
                        try {
                            this.isValidDisconnect({
                                topic: l,
                                reason: c.params
                            }), await Promise.all([new Promise(c => {
                                this.client.core.relayer.once(N.Mb.publish, async () => {
                                    c(await this.deleteSession({
                                        topic: l,
                                        id: x
                                    }))
                                })
                            }), this.sendResult({
                                id: x,
                                topic: l,
                                result: !0,
                                throwOnFailedPublish: !0
                            }), this.cleanupPendingSentRequestsForTopic({
                                topic: l,
                                error: (0, $.D6H)("USER_DISCONNECTED")
                            })])
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    }, this.onSessionRequest = async (l, c) => {
                        var x;
                        let {
                            id: N,
                            params: U
                        } = c;
                        try {
                            await this.isValidRequest(y({
                                topic: l
                            }, U));
                            let c = (0, $.rjm)(JSON.stringify((0, X.formatJsonRpcRequest)("wc_sessionRequest", U, N))),
                                Z = this.client.session.get(l),
                                Y = await this.getVerifyContext(c, Z.peer.metadata),
                                q = {
                                    id: N,
                                    topic: l,
                                    params: U,
                                    verifyContext: Y
                                };
                            await this.setPendingSessionRequest(q), null != (x = this.client.signConfig) && x.disableRequestQueue ? this.emitSessionRequest(q) : (this.addSessionRequestToSessionRequestQueue(q), this.processSessionRequestQueue())
                        } catch (c) {
                            await this.sendError({
                                id: N,
                                topic: l,
                                error: c
                            }), this.client.logger.error(c)
                        }
                    }, this.onSessionRequestResponse = (l, c) => {
                        let {
                            id: x
                        } = c, N = (0, $.E0T)("session_request", x);
                        if (0 === this.events.listenerCount(N)) throw Error(`emitting ${N} without any listeners`);
                        (0, X.isJsonRpcResult)(c) ? this.events.emit((0, $.E0T)("session_request", x), {
                            result: c.result
                        }): (0, X.isJsonRpcError)(c) && this.events.emit((0, $.E0T)("session_request", x), {
                            error: c.error
                        })
                    }, this.onSessionEventRequest = async (l, c) => {
                        let {
                            id: x,
                            params: N
                        } = c;
                        try {
                            let c = `${l}_session_event_${N.event.name}`,
                                U = $.O6B.get(c);
                            if (U && this.isRequestOutOfSync(U, x)) {
                                this.client.logger.info(`Discarding out of sync request - ${x}`);
                                return
                            }
                            this.isValidEmit(y({
                                topic: l
                            }, N)), this.client.events.emit("session_event", {
                                id: x,
                                topic: l,
                                params: N
                            }), $.O6B.set(c, x)
                        } catch (c) {
                            await this.sendError({
                                id: x,
                                topic: l,
                                error: c
                            }), this.client.logger.error(c)
                        }
                    }, this.onSessionAuthenticateResponse = (l, c) => {
                        let {
                            id: x
                        } = c;
                        this.client.logger.trace({
                            type: "method",
                            method: "onSessionAuthenticateResponse",
                            topic: l,
                            payload: c
                        }), (0, X.isJsonRpcResult)(c) ? this.events.emit((0, $.E0T)("session_request", x), {
                            result: c.result
                        }) : (0, X.isJsonRpcError)(c) && this.events.emit((0, $.E0T)("session_request", x), {
                            error: c.error
                        })
                    }, this.onSessionAuthenticateRequest = async (l, c) => {
                        try {
                            let {
                                requester: x,
                                authPayload: N,
                                expiryTimestamp: U
                            } = c.params, Z = (0, $.rjm)(JSON.stringify(c)), Y = await this.getVerifyContext(Z, this.client.metadata), q = {
                                requester: x,
                                pairingTopic: l,
                                id: c.id,
                                authPayload: N,
                                verifyContext: Y,
                                expiryTimestamp: U
                            };
                            await this.setAuthRequest(c.id, {
                                request: q,
                                pairingTopic: l
                            }), this.client.events.emit("session_authenticate", {
                                topic: l,
                                params: c.params,
                                id: c.id
                            })
                        } catch (Z) {
                            this.client.logger.error(Z);
                            let x = c.params.requester.publicKey,
                                N = await this.client.core.crypto.generateKeyPair(),
                                U = {
                                    type: $.rVF,
                                    receiverPublicKey: x,
                                    senderPublicKey: N
                                };
                            await this.sendError({
                                id: c.id,
                                topic: l,
                                error: Z,
                                encodeOpts: U,
                                rpcOpts: eu.wc_sessionAuthenticate.autoReject
                            })
                        }
                    }, this.addSessionRequestToSessionRequestQueue = l => {
                        this.sessionRequestQueue.queue.push(l)
                    }, this.cleanupAfterResponse = l => {
                        this.deletePendingSessionRequest(l.response.id, {
                            message: "fulfilled",
                            code: 0
                        }), setTimeout(() => {
                            this.sessionRequestQueue.state = ep.idle, this.processSessionRequestQueue()
                        }, (0, J.toMiliseconds)(this.requestQueueDelay))
                    }, this.cleanupPendingSentRequestsForTopic = ({
                        topic: l,
                        error: c
                    }) => {
                        let x = this.client.core.history.pending;
                        x.length > 0 && x.filter(c => c.topic === l && "wc_sessionRequest" === c.request.method).forEach(l => {
                            let x = l.request.id,
                                N = (0, $.E0T)("session_request", x);
                            if (0 === this.events.listenerCount(N)) throw Error(`emitting ${N} without any listeners`);
                            this.events.emit((0, $.E0T)("session_request", l.request.id), {
                                error: c
                            })
                        })
                    }, this.processSessionRequestQueue = () => {
                        if (this.sessionRequestQueue.state === ep.active) {
                            this.client.logger.info("session request queue is already active.");
                            return
                        }
                        let l = this.sessionRequestQueue.queue[0];
                        if (!l) {
                            this.client.logger.info("session request queue is empty.");
                            return
                        }
                        try {
                            this.sessionRequestQueue.state = ep.active, this.emitSessionRequest(l)
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    }, this.emitSessionRequest = l => {
                        this.client.events.emit("session_request", l)
                    }, this.onPairingCreated = l => {
                        if (l.methods && this.expectedPairingMethodMap.set(l.topic, l.methods), l.active) return;
                        let c = this.client.proposal.getAll().find(c => c.pairingTopic === l.topic);
                        c && this.onSessionProposeRequest(l.topic, (0, X.formatJsonRpcRequest)("wc_sessionPropose", {
                            requiredNamespaces: c.requiredNamespaces,
                            optionalNamespaces: c.optionalNamespaces,
                            relays: c.relays,
                            proposer: c.proposer,
                            sessionProperties: c.sessionProperties
                        }, c.id))
                    }, this.isValidConnect = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(l)}`);
                            throw Error(c)
                        }
                        let {
                            pairingTopic: c,
                            requiredNamespaces: x,
                            optionalNamespaces: N,
                            sessionProperties: U,
                            relays: Z
                        } = l;
                        if ((0, $.o8e)(c) || await this.isValidPairingTopic(c), !(0, $.PMr)(Z, !0)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `connect() relays: ${Z}`);
                            throw Error(l)
                        }(0, $.o8e)(x) || 0 === (0, $.L5o)(x) || this.validateNamespaces(x, "requiredNamespaces"), (0, $.o8e)(N) || 0 === (0, $.L5o)(N) || this.validateNamespaces(N, "optionalNamespaces"), (0, $.o8e)(U) || this.validateSessionProps(U, "sessionProperties")
                    }, this.validateNamespaces = (l, c) => {
                        let x = (0, $.naP)(l, "connect()", c);
                        if (x) throw Error(x.message)
                    }, this.isValidApprove = async l => {
                        if (!(0, $.EJd)(l)) throw Error((0, $.kCb)("MISSING_OR_INVALID", `approve() params: ${l}`).message);
                        let {
                            id: c,
                            namespaces: x,
                            relayProtocol: N,
                            sessionProperties: U
                        } = l;
                        this.checkRecentlyDeleted(c), await this.isValidProposalId(c);
                        let Z = this.client.proposal.get(c),
                            Y = (0, $.ing)(x, "approve()");
                        if (Y) throw Error(Y.message);
                        let q = (0, $.rFo)(Z.requiredNamespaces, x, "approve()");
                        if (q) throw Error(q.message);
                        if (!(0, $.M_r)(N, !0)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `approve() relayProtocol: ${N}`);
                            throw Error(l)
                        }(0, $.o8e)(U) || this.validateSessionProps(U, "sessionProperties")
                    }, this.isValidReject = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `reject() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            id: c,
                            reason: x
                        } = l;
                        if (this.checkRecentlyDeleted(c), await this.isValidProposalId(c), !(0, $.H4H)(x)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(x)}`);
                            throw Error(l)
                        }
                    }, this.isValidSessionSettleRequest = l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            relay: c,
                            controller: x,
                            namespaces: N,
                            expiry: U
                        } = l;
                        if (!(0, $.Z26)(c)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                            throw Error(l)
                        }
                        let Z = (0, $.DdM)(x, "onSessionSettleRequest()");
                        if (Z) throw Error(Z.message);
                        let Y = (0, $.ing)(N, "onSessionSettleRequest()");
                        if (Y) throw Error(Y.message);
                        if ((0, $.BwD)(U)) {
                            let {
                                message: l
                            } = (0, $.kCb)("EXPIRED", "onSessionSettleRequest()");
                            throw Error(l)
                        }
                    }, this.isValidUpdate = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `update() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c,
                            namespaces: x
                        } = l;
                        this.checkRecentlyDeleted(c), await this.isValidSessionTopic(c);
                        let N = this.client.session.get(c),
                            U = (0, $.ing)(x, "update()");
                        if (U) throw Error(U.message);
                        let Z = (0, $.rFo)(N.requiredNamespaces, x, "update()");
                        if (Z) throw Error(Z.message)
                    }, this.isValidExtend = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `extend() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        this.checkRecentlyDeleted(c), await this.isValidSessionTopic(c)
                    }, this.isValidRequest = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `request() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c,
                            request: x,
                            chainId: N,
                            expiry: U
                        } = l;
                        this.checkRecentlyDeleted(c), await this.isValidSessionTopic(c);
                        let {
                            namespaces: Z
                        } = this.client.session.get(c);
                        if (!(0, $.p8o)(Z, N)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `request() chainId: ${N}`);
                            throw Error(l)
                        }
                        if (!(0, $.hHR)(x)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `request() ${JSON.stringify(x)}`);
                            throw Error(l)
                        }
                        if (!(0, $.alS)(Z, N, x.method)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `request() method: ${x.method}`);
                            throw Error(l)
                        }
                        if (U && !(0, $.ONw)(U, ed)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `request() expiry: ${U}. Expiry must be a number (in seconds) between ${ed.min} and ${ed.max}`);
                            throw Error(l)
                        }
                    }, this.isValidRespond = async l => {
                        var c;
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `respond() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: x,
                            response: N
                        } = l;
                        try {
                            await this.isValidSessionTopic(x)
                        } catch (x) {
                            throw null != (c = l ? .response) && c.id && this.cleanupAfterResponse(l), x
                        }
                        if (!(0, $.JTI)(N)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(N)}`);
                            throw Error(l)
                        }
                    }, this.isValidPing = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `ping() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidSessionOrPairingTopic(c)
                    }, this.isValidEmit = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `emit() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c,
                            event: x,
                            chainId: N
                        } = l;
                        await this.isValidSessionTopic(c);
                        let {
                            namespaces: U
                        } = this.client.session.get(c);
                        if (!(0, $.p8o)(U, N)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `emit() chainId: ${N}`);
                            throw Error(l)
                        }
                        if (!(0, $.nfW)(x)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(x)}`);
                            throw Error(l)
                        }
                        if (!(0, $.B95)(U, N, x.name)) {
                            let {
                                message: l
                            } = (0, $.kCb)("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(x)}`);
                            throw Error(l)
                        }
                    }, this.isValidDisconnect = async l => {
                        if (!(0, $.EJd)(l)) {
                            let {
                                message: c
                            } = (0, $.kCb)("MISSING_OR_INVALID", `disconnect() params: ${l}`);
                            throw Error(c)
                        }
                        let {
                            topic: c
                        } = l;
                        await this.isValidSessionOrPairingTopic(c)
                    }, this.isValidAuthenticate = l => {
                        let {
                            chains: c,
                            uri: x,
                            domain: N,
                            nonce: U
                        } = l;
                        if (!Array.isArray(c) || 0 === c.length) throw Error("chains is required and must be a non-empty array");
                        if (!(0, $.M_r)(x, !1)) throw Error("uri is required parameter");
                        if (!(0, $.M_r)(N, !1)) throw Error("domain is required parameter");
                        if (!(0, $.M_r)(U, !1)) throw Error("nonce is required parameter");
                        if ([...new Set(c.map(l => (0, $.DQe)(l).namespace))].length > 1) throw Error("Multi-namespace requests are not supported. Please request single namespace only.");
                        let {
                            namespace: Z
                        } = (0, $.DQe)(c[0]);
                        if ("eip155" !== Z) throw Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")
                    }, this.getVerifyContext = async (l, c) => {
                        let x = {
                            verified: {
                                verifyUrl: c.verifyUrl || N.sG,
                                validation: "UNKNOWN",
                                origin: c.url || ""
                            }
                        };
                        try {
                            let N = await this.client.core.verify.resolve({
                                attestationId: l,
                                verifyUrl: c.verifyUrl
                            });
                            N && (x.verified.origin = N.origin, x.verified.isScam = N.isScam, x.verified.validation = N.origin === new URL(c.url).origin ? "VALID" : "INVALID")
                        } catch (l) {
                            this.client.logger.info(l)
                        }
                        return this.client.logger.info(`Verify context: ${JSON.stringify(x)}`), x
                    }, this.validateSessionProps = (l, c) => {
                        Object.values(l).forEach(l => {
                            if (!(0, $.M_r)(l, !1)) {
                                let {
                                    message: x
                                } = (0, $.kCb)("MISSING_OR_INVALID", `${c} must be in Record<string, string> format. Received: ${JSON.stringify(l)}`);
                                throw Error(x)
                            }
                        })
                    }, this.getPendingAuthRequest = l => {
                        let c = this.client.auth.requests.get(l);
                        return "object" == typeof c ? c : void 0
                    }, this.addToRecentlyDeleted = (l, c) => {
                        if (this.recentlyDeletedMap.set(l, c), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                            let l = 0,
                                c = this.recentlyDeletedLimit / 2;
                            for (let x of this.recentlyDeletedMap.keys()) {
                                if (l++ >= c) break;
                                this.recentlyDeletedMap.delete(x)
                            }
                        }
                    }, this.checkRecentlyDeleted = l => {
                        let c = this.recentlyDeletedMap.get(l);
                        if (c) {
                            let {
                                message: x
                            } = (0, $.kCb)("MISSING_OR_INVALID", `Record was recently deleted - ${c}: ${l}`);
                            throw Error(x)
                        }
                    }
                }
                async isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: l
                        } = (0, $.kCb)("NOT_INITIALIZED", this.name);
                        throw Error(l)
                    }
                    await this.client.core.relayer.confirmOnlineStateOrThrow()
                }
                registerRelayerEvents() {
                    this.client.core.relayer.on(N.Mb.message, async l => {
                        let {
                            topic: c,
                            message: x
                        } = l, {
                            publicKey: N
                        } = this.client.auth.authKeys.keys.includes(ef) ? this.client.auth.authKeys.get(ef) : {
                            responseTopic: void 0,
                            publicKey: void 0
                        }, U = await this.client.core.crypto.decode(c, x, {
                            receiverPublicKey: N
                        });
                        try {
                            (0, X.isJsonRpcRequest)(U) ? (this.client.core.history.set(c, U), this.onRelayEventRequest({
                                topic: c,
                                payload: U
                            })) : (0, X.isJsonRpcResponse)(U) ? (await this.client.core.history.resolve(U), await this.onRelayEventResponse({
                                topic: c,
                                payload: U
                            }), this.client.core.history.delete(c, U.id)) : this.onRelayEventUnknownPayload({
                                topic: c,
                                payload: U
                            })
                        } catch (l) {
                            this.client.logger.error(l)
                        }
                    })
                }
                registerExpirerEvents() {
                    this.client.core.expirer.on(N.i9.expired, async l => {
                        let {
                            topic: c,
                            id: x
                        } = (0, $.iPz)(l.target);
                        return x && this.client.pendingRequest.keys.includes(x) ? await this.deletePendingSessionRequest(x, (0, $.kCb)("EXPIRED"), !0) : x && this.client.auth.requests.keys.includes(x) ? await this.deletePendingAuthRequest(x, (0, $.kCb)("EXPIRED"), !0) : void(c ? this.client.session.keys.includes(c) && (await this.deleteSession({
                            topic: c,
                            expirerHasDeleted: !0
                        }), this.client.events.emit("session_expire", {
                            topic: c
                        })) : x && (await this.deleteProposal(x, !0), this.client.events.emit("proposal_expire", {
                            id: x
                        })))
                    })
                }
                registerPairingEvents() {
                    this.client.core.pairing.events.on(N.I8.create, l => this.onPairingCreated(l)), this.client.core.pairing.events.on(N.I8.delete, l => {
                        this.addToRecentlyDeleted(l.topic, "pairing")
                    })
                }
                isValidPairingTopic(l) {
                    if (!(0, $.M_r)(l, !1)) {
                        let {
                            message: c
                        } = (0, $.kCb)("MISSING_OR_INVALID", `pairing topic should be a string: ${l}`);
                        throw Error(c)
                    }
                    if (!this.client.core.pairing.pairings.keys.includes(l)) {
                        let {
                            message: c
                        } = (0, $.kCb)("NO_MATCHING_KEY", `pairing topic doesn't exist: ${l}`);
                        throw Error(c)
                    }
                    if ((0, $.BwD)(this.client.core.pairing.pairings.get(l).expiry)) {
                        let {
                            message: c
                        } = (0, $.kCb)("EXPIRED", `pairing topic: ${l}`);
                        throw Error(c)
                    }
                }
                async isValidSessionTopic(l) {
                    if (!(0, $.M_r)(l, !1)) {
                        let {
                            message: c
                        } = (0, $.kCb)("MISSING_OR_INVALID", `session topic should be a string: ${l}`);
                        throw Error(c)
                    }
                    if (this.checkRecentlyDeleted(l), !this.client.session.keys.includes(l)) {
                        let {
                            message: c
                        } = (0, $.kCb)("NO_MATCHING_KEY", `session topic doesn't exist: ${l}`);
                        throw Error(c)
                    }
                    if ((0, $.BwD)(this.client.session.get(l).expiry)) {
                        await this.deleteSession({
                            topic: l
                        });
                        let {
                            message: c
                        } = (0, $.kCb)("EXPIRED", `session topic: ${l}`);
                        throw Error(c)
                    }
                    if (!this.client.core.crypto.keychain.has(l)) {
                        let {
                            message: c
                        } = (0, $.kCb)("MISSING_OR_INVALID", `session topic does not exist in keychain: ${l}`);
                        throw await this.deleteSession({
                            topic: l
                        }), Error(c)
                    }
                }
                async isValidSessionOrPairingTopic(l) {
                    if (this.checkRecentlyDeleted(l), this.client.session.keys.includes(l)) await this.isValidSessionTopic(l);
                    else if (this.client.core.pairing.pairings.keys.includes(l)) this.isValidPairingTopic(l);
                    else if ((0, $.M_r)(l, !1)) {
                        let {
                            message: c
                        } = (0, $.kCb)("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${l}`);
                        throw Error(c)
                    } else {
                        let {
                            message: c
                        } = (0, $.kCb)("MISSING_OR_INVALID", `session or pairing topic should be a string: ${l}`);
                        throw Error(c)
                    }
                }
                async isValidProposalId(l) {
                    if (!(0, $.Q01)(l)) {
                        let {
                            message: c
                        } = (0, $.kCb)("MISSING_OR_INVALID", `proposal id should be a number: ${l}`);
                        throw Error(c)
                    }
                    if (!this.client.proposal.keys.includes(l)) {
                        let {
                            message: c
                        } = (0, $.kCb)("NO_MATCHING_KEY", `proposal id doesn't exist: ${l}`);
                        throw Error(c)
                    }
                    if ((0, $.BwD)(this.client.proposal.get(l).expiryTimestamp)) {
                        await this.deleteProposal(l);
                        let {
                            message: c
                        } = (0, $.kCb)("EXPIRED", `proposal id: ${l}`);
                        throw Error(c)
                    }
                }
            };
            let ei = class ei extends N.yh {
                constructor(l, c) {
                    super(l, c, "proposal", er), this.core = l, this.logger = c
                }
            };
            let Ze = class Ze extends N.yh {
                constructor(l, c) {
                    super(l, c, "session", er), this.core = l, this.logger = c
                }
            };
            let ti = class ti extends N.yh {
                constructor(l, c) {
                    super(l, c, "request", er, l => l.id), this.core = l, this.logger = c
                }
            };
            let ii = class ii extends N.yh {
                constructor(l, c) {
                    super(l, c, "authKeys", ey, () => ef), this.core = l, this.logger = c
                }
            };
            let si = class si extends N.yh {
                constructor(l, c) {
                    super(l, c, "pairingTopics", ey), this.core = l, this.logger = c
                }
            };
            let ri = class ri extends N.yh {
                constructor(l, c) {
                    super(l, c, "requests", ey, l => l.id), this.core = l, this.logger = c
                }
            };
            let ni = class ni {
                constructor(l, c) {
                    this.core = l, this.logger = c, this.authKeys = new ii(this.core, this.logger), this.pairingTopics = new si(this.core, this.logger), this.requests = new ri(this.core, this.logger)
                }
                async init() {
                    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init()
                }
            };
            let oe = class oe extends Z.lV {
                constructor(l) {
                    super(l), this.protocol = "wc", this.version = 2, this.name = ea.name, this.events = new Y.EventEmitter, this.on = (l, c) => this.events.on(l, c), this.once = (l, c) => this.events.once(l, c), this.off = (l, c) => this.events.off(l, c), this.removeListener = (l, c) => this.events.removeListener(l, c), this.removeAllListeners = l => this.events.removeAllListeners(l), this.connect = async l => {
                        try {
                            return await this.engine.connect(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.pair = async l => {
                        try {
                            return await this.engine.pair(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.approve = async l => {
                        try {
                            return await this.engine.approve(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.reject = async l => {
                        try {
                            return await this.engine.reject(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.update = async l => {
                        try {
                            return await this.engine.update(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.extend = async l => {
                        try {
                            return await this.engine.extend(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.request = async l => {
                        try {
                            return await this.engine.request(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.respond = async l => {
                        try {
                            return await this.engine.respond(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.ping = async l => {
                        try {
                            return await this.engine.ping(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.emit = async l => {
                        try {
                            return await this.engine.emit(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.disconnect = async l => {
                        try {
                            return await this.engine.disconnect(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.find = l => {
                        try {
                            return this.engine.find(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.getPendingSessionRequests = () => {
                        try {
                            return this.engine.getPendingSessionRequests()
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.authenticate = async l => {
                        try {
                            return await this.engine.authenticate(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.formatAuthMessage = l => {
                        try {
                            return this.engine.formatAuthMessage(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.approveSessionAuthenticate = async l => {
                        try {
                            return await this.engine.approveSessionAuthenticate(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.rejectSessionAuthenticate = async l => {
                        try {
                            return await this.engine.rejectSessionAuthenticate(l)
                        } catch (l) {
                            throw this.logger.error(l.message), l
                        }
                    }, this.name = l ? .name || ea.name, this.metadata = l ? .metadata || (0, $.DaH)(), this.signConfig = l ? .signConfig;
                    let c = "u" > typeof l ? .logger && "string" != typeof l ? .logger ? l.logger : (0, U.gw)((0, U.jI)({
                        level: l ? .logger || ea.logger
                    }));
                    this.core = l ? .core || new N.QY(l), this.logger = (0, U.Ep)(c, this.name), this.session = new Ze(this.core, this.logger), this.proposal = new ei(this.core, this.logger), this.pendingRequest = new ti(this.core, this.logger), this.engine = new Zt(this), this.auth = new ni(this.core, this.logger)
                }
                static async init(l) {
                    let c = new oe(l);
                    return await c.initialize(), c
                }
                get context() {
                    return (0, U.Fd)(this.logger)
                }
                get pairing() {
                    return this.core.pairing.pairings
                }
                validateMetadata(l) {
                    if (!l.name) throw Error("name is required value in metadata");
                    if (!l.description) throw Error("description is required value in metadata");
                    if (!l.url) throw Error("url is required value in metadata")
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.validateMetadata(this.metadata), await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), await this.auth.init(), this.core.verify.init({
                            verifyUrl: this.metadata.verifyUrl
                        }), this.logger.info("SignClient Initialization Success")
                    } catch (l) {
                        throw this.logger.info("SignClient Initialization Failure"), this.logger.error(l.message), l
                    }
                }
            };
            let eM = Ze,
                eI = oe
        },
        72852: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let N = x(1812);
            N.__exportStar(x(83343), c), N.__exportStar(x(38520), c)
        },
        83343: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.ONE_THOUSAND = c.ONE_HUNDRED = void 0, c.ONE_HUNDRED = 100, c.ONE_THOUSAND = 1e3
        },
        38520: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.ONE_YEAR = c.FOUR_WEEKS = c.THREE_WEEKS = c.TWO_WEEKS = c.ONE_WEEK = c.THIRTY_DAYS = c.SEVEN_DAYS = c.FIVE_DAYS = c.THREE_DAYS = c.ONE_DAY = c.TWENTY_FOUR_HOURS = c.TWELVE_HOURS = c.SIX_HOURS = c.THREE_HOURS = c.ONE_HOUR = c.SIXTY_MINUTES = c.THIRTY_MINUTES = c.TEN_MINUTES = c.FIVE_MINUTES = c.ONE_MINUTE = c.SIXTY_SECONDS = c.THIRTY_SECONDS = c.TEN_SECONDS = c.FIVE_SECONDS = c.ONE_SECOND = void 0, c.ONE_SECOND = 1, c.FIVE_SECONDS = 5, c.TEN_SECONDS = 10, c.THIRTY_SECONDS = 30, c.SIXTY_SECONDS = 60, c.ONE_MINUTE = c.SIXTY_SECONDS, c.FIVE_MINUTES = 5 * c.ONE_MINUTE, c.TEN_MINUTES = 10 * c.ONE_MINUTE, c.THIRTY_MINUTES = 30 * c.ONE_MINUTE, c.SIXTY_MINUTES = 60 * c.ONE_MINUTE, c.ONE_HOUR = c.SIXTY_MINUTES, c.THREE_HOURS = 3 * c.ONE_HOUR, c.SIX_HOURS = 6 * c.ONE_HOUR, c.TWELVE_HOURS = 12 * c.ONE_HOUR, c.TWENTY_FOUR_HOURS = 24 * c.ONE_HOUR, c.ONE_DAY = c.TWENTY_FOUR_HOURS, c.THREE_DAYS = 3 * c.ONE_DAY, c.FIVE_DAYS = 5 * c.ONE_DAY, c.SEVEN_DAYS = 7 * c.ONE_DAY, c.THIRTY_DAYS = 30 * c.ONE_DAY, c.ONE_WEEK = c.SEVEN_DAYS, c.TWO_WEEKS = 2 * c.ONE_WEEK, c.THREE_WEEKS = 3 * c.ONE_WEEK, c.FOUR_WEEKS = 4 * c.ONE_WEEK, c.ONE_YEAR = 365 * c.ONE_DAY
        },
        58619: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let N = x(1812);
            N.__exportStar(x(6954), c), N.__exportStar(x(91895), c), N.__exportStar(x(21087), c), N.__exportStar(x(72852), c)
        },
        21087: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let N = x(1812);
            N.__exportStar(x(36448), c)
        },
        36448: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.IWatch = void 0, c.IWatch = class {}
        },
        24810: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.fromMiliseconds = c.toMiliseconds = void 0;
            let N = x(72852);
            c.toMiliseconds = function(l) {
                return l * N.ONE_THOUSAND
            }, c.fromMiliseconds = function(l) {
                return Math.floor(l / N.ONE_THOUSAND)
            }
        },
        18995: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.delay = void 0, c.delay = function(l) {
                return new Promise(c => {
                    setTimeout(() => {
                        c(!0)
                    }, l)
                })
            }
        },
        6954: function(l, c, x) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            });
            let N = x(1812);
            N.__exportStar(x(18995), c), N.__exportStar(x(24810), c)
        },
        91895: function(l, c) {
            "use strict";
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.Watch = void 0;
            let Watch = class Watch {
                constructor() {
                    this.timestamps = new Map
                }
                start(l) {
                    if (this.timestamps.has(l)) throw Error(`Watch already started for label: ${l}`);
                    this.timestamps.set(l, {
                        started: Date.now()
                    })
                }
                stop(l) {
                    let c = this.get(l);
                    if (void 0 !== c.elapsed) throw Error(`Watch already stopped for label: ${l}`);
                    let x = Date.now() - c.started;
                    this.timestamps.set(l, {
                        started: c.started,
                        elapsed: x
                    })
                }
                get(l) {
                    let c = this.timestamps.get(l);
                    if (void 0 === c) throw Error(`No timestamp found for label: ${l}`);
                    return c
                }
                elapsed(l) {
                    let c = this.get(l),
                        x = c.elapsed || Date.now() - c.started;
                    return x
                }
            };
            c.Watch = Watch, c.default = Watch
        },
        1812: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                __assign: function() {
                    return __assign
                },
                __asyncDelegator: function() {
                    return __asyncDelegator
                },
                __asyncGenerator: function() {
                    return __asyncGenerator
                },
                __asyncValues: function() {
                    return __asyncValues
                },
                __await: function() {
                    return __await
                },
                __awaiter: function() {
                    return __awaiter
                },
                __classPrivateFieldGet: function() {
                    return __classPrivateFieldGet
                },
                __classPrivateFieldSet: function() {
                    return __classPrivateFieldSet
                },
                __createBinding: function() {
                    return __createBinding
                },
                __decorate: function() {
                    return __decorate
                },
                __exportStar: function() {
                    return __exportStar
                },
                __extends: function() {
                    return __extends
                },
                __generator: function() {
                    return __generator
                },
                __importDefault: function() {
                    return __importDefault
                },
                __importStar: function() {
                    return __importStar
                },
                __makeTemplateObject: function() {
                    return __makeTemplateObject
                },
                __metadata: function() {
                    return __metadata
                },
                __param: function() {
                    return __param
                },
                __read: function() {
                    return __read
                },
                __rest: function() {
                    return __rest
                },
                __spread: function() {
                    return __spread
                },
                __spreadArrays: function() {
                    return __spreadArrays
                },
                __values: function() {
                    return __values
                }
            });
            /*! *****************************************************************************
            Copyright (c) Microsoft Corporation.

            Permission to use, copy, modify, and/or distribute this software for any
            purpose with or without fee is hereby granted.

            THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THIS SOFTWARE.
            ***************************************************************************** */
            var extendStatics = function(l, c) {
                return (extendStatics = Object.setPrototypeOf || ({
                    __proto__: []
                }) instanceof Array && function(l, c) {
                    l.__proto__ = c
                } || function(l, c) {
                    for (var x in c) c.hasOwnProperty(x) && (l[x] = c[x])
                })(l, c)
            };

            function __extends(l, c) {
                function __() {
                    this.constructor = l
                }
                extendStatics(l, c), l.prototype = null === c ? Object.create(c) : (__.prototype = c.prototype, new __)
            }
            var __assign = function() {
                return (__assign = Object.assign || function(l) {
                    for (var c, x = 1, N = arguments.length; x < N; x++)
                        for (var U in c = arguments[x]) Object.prototype.hasOwnProperty.call(c, U) && (l[U] = c[U]);
                    return l
                }).apply(this, arguments)
            };

            function __rest(l, c) {
                var x = {};
                for (var N in l) Object.prototype.hasOwnProperty.call(l, N) && 0 > c.indexOf(N) && (x[N] = l[N]);
                if (null != l && "function" == typeof Object.getOwnPropertySymbols)
                    for (var U = 0, N = Object.getOwnPropertySymbols(l); U < N.length; U++) 0 > c.indexOf(N[U]) && Object.prototype.propertyIsEnumerable.call(l, N[U]) && (x[N[U]] = l[N[U]]);
                return x
            }

            function __decorate(l, c, x, N) {
                var U, Z = arguments.length,
                    $ = Z < 3 ? c : null === N ? N = Object.getOwnPropertyDescriptor(c, x) : N;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) $ = Reflect.decorate(l, c, x, N);
                else
                    for (var Y = l.length - 1; Y >= 0; Y--)(U = l[Y]) && ($ = (Z < 3 ? U($) : Z > 3 ? U(c, x, $) : U(c, x)) || $);
                return Z > 3 && $ && Object.defineProperty(c, x, $), $
            }

            function __param(l, c) {
                return function(x, N) {
                    c(x, N, l)
                }
            }

            function __metadata(l, c) {
                if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(l, c)
            }

            function __awaiter(l, c, x, N) {
                return new(x || (x = Promise))(function(U, Z) {
                    function fulfilled(l) {
                        try {
                            step(N.next(l))
                        } catch (l) {
                            Z(l)
                        }
                    }

                    function rejected(l) {
                        try {
                            step(N.throw(l))
                        } catch (l) {
                            Z(l)
                        }
                    }

                    function step(l) {
                        var c;
                        l.done ? U(l.value) : ((c = l.value) instanceof x ? c : new x(function(l) {
                            l(c)
                        })).then(fulfilled, rejected)
                    }
                    step((N = N.apply(l, c || [])).next())
                })
            }

            function __generator(l, c) {
                var x, N, U, Z, $ = {
                    label: 0,
                    sent: function() {
                        if (1 & U[0]) throw U[1];
                        return U[1]
                    },
                    trys: [],
                    ops: []
                };
                return Z = {
                    next: verb(0),
                    throw: verb(1),
                    return: verb(2)
                }, "function" == typeof Symbol && (Z[Symbol.iterator] = function() {
                    return this
                }), Z;

                function verb(Z) {
                    return function(Y) {
                        return function(Z) {
                            if (x) throw TypeError("Generator is already executing.");
                            for (; $;) try {
                                if (x = 1, N && (U = 2 & Z[0] ? N.return : Z[0] ? N.throw || ((U = N.return) && U.call(N), 0) : N.next) && !(U = U.call(N, Z[1])).done) return U;
                                switch (N = 0, U && (Z = [2 & Z[0], U.value]), Z[0]) {
                                    case 0:
                                    case 1:
                                        U = Z;
                                        break;
                                    case 4:
                                        return $.label++, {
                                            value: Z[1],
                                            done: !1
                                        };
                                    case 5:
                                        $.label++, N = Z[1], Z = [0];
                                        continue;
                                    case 7:
                                        Z = $.ops.pop(), $.trys.pop();
                                        continue;
                                    default:
                                        if (!(U = (U = $.trys).length > 0 && U[U.length - 1]) && (6 === Z[0] || 2 === Z[0])) {
                                            $ = 0;
                                            continue
                                        }
                                        if (3 === Z[0] && (!U || Z[1] > U[0] && Z[1] < U[3])) {
                                            $.label = Z[1];
                                            break
                                        }
                                        if (6 === Z[0] && $.label < U[1]) {
                                            $.label = U[1], U = Z;
                                            break
                                        }
                                        if (U && $.label < U[2]) {
                                            $.label = U[2], $.ops.push(Z);
                                            break
                                        }
                                        U[2] && $.ops.pop(), $.trys.pop();
                                        continue
                                }
                                Z = c.call(l, $)
                            } catch (l) {
                                Z = [6, l], N = 0
                            } finally {
                                x = U = 0
                            }
                            if (5 & Z[0]) throw Z[1];
                            return {
                                value: Z[0] ? Z[1] : void 0,
                                done: !0
                            }
                        }([Z, Y])
                    }
                }
            }

            function __createBinding(l, c, x, N) {
                void 0 === N && (N = x), l[N] = c[x]
            }

            function __exportStar(l, c) {
                for (var x in l) "default" === x || c.hasOwnProperty(x) || (c[x] = l[x])
            }

            function __values(l) {
                var c = "function" == typeof Symbol && Symbol.iterator,
                    x = c && l[c],
                    N = 0;
                if (x) return x.call(l);
                if (l && "number" == typeof l.length) return {
                    next: function() {
                        return l && N >= l.length && (l = void 0), {
                            value: l && l[N++],
                            done: !l
                        }
                    }
                };
                throw TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.")
            }

            function __read(l, c) {
                var x = "function" == typeof Symbol && l[Symbol.iterator];
                if (!x) return l;
                var N, U, Z = x.call(l),
                    $ = [];
                try {
                    for (;
                        (void 0 === c || c-- > 0) && !(N = Z.next()).done;) $.push(N.value)
                } catch (l) {
                    U = {
                        error: l
                    }
                } finally {
                    try {
                        N && !N.done && (x = Z.return) && x.call(Z)
                    } finally {
                        if (U) throw U.error
                    }
                }
                return $
            }

            function __spread() {
                for (var l = [], c = 0; c < arguments.length; c++) l = l.concat(__read(arguments[c]));
                return l
            }

            function __spreadArrays() {
                for (var l = 0, c = 0, x = arguments.length; c < x; c++) l += arguments[c].length;
                for (var N = Array(l), U = 0, c = 0; c < x; c++)
                    for (var Z = arguments[c], $ = 0, Y = Z.length; $ < Y; $++, U++) N[U] = Z[$];
                return N
            }

            function __await(l) {
                return this instanceof __await ? (this.v = l, this) : new __await(l)
            }

            function __asyncGenerator(l, c, x) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var N, U = x.apply(l, c || []),
                    Z = [];
                return N = {}, verb("next"), verb("throw"), verb("return"), N[Symbol.asyncIterator] = function() {
                    return this
                }, N;

                function verb(l) {
                    U[l] && (N[l] = function(c) {
                        return new Promise(function(x, N) {
                            Z.push([l, c, x, N]) > 1 || resume(l, c)
                        })
                    })
                }

                function resume(l, c) {
                    try {
                        var x;
                        (x = U[l](c)).value instanceof __await ? Promise.resolve(x.value.v).then(fulfill, reject) : settle(Z[0][2], x)
                    } catch (l) {
                        settle(Z[0][3], l)
                    }
                }

                function fulfill(l) {
                    resume("next", l)
                }

                function reject(l) {
                    resume("throw", l)
                }

                function settle(l, c) {
                    l(c), Z.shift(), Z.length && resume(Z[0][0], Z[0][1])
                }
            }

            function __asyncDelegator(l) {
                var c, x;
                return c = {}, verb("next"), verb("throw", function(l) {
                    throw l
                }), verb("return"), c[Symbol.iterator] = function() {
                    return this
                }, c;

                function verb(N, U) {
                    c[N] = l[N] ? function(c) {
                        return (x = !x) ? {
                            value: __await(l[N](c)),
                            done: "return" === N
                        } : U ? U(c) : c
                    } : U
                }
            }

            function __asyncValues(l) {
                if (!Symbol.asyncIterator) throw TypeError("Symbol.asyncIterator is not defined.");
                var c, x = l[Symbol.asyncIterator];
                return x ? x.call(l) : (l = __values(l), c = {}, verb("next"), verb("throw"), verb("return"), c[Symbol.asyncIterator] = function() {
                    return this
                }, c);

                function verb(x) {
                    c[x] = l[x] && function(c) {
                        return new Promise(function(N, U) {
                            ! function(l, c, x, N) {
                                Promise.resolve(N).then(function(c) {
                                    l({
                                        value: c,
                                        done: x
                                    })
                                }, c)
                            }(N, U, (c = l[x](c)).done, c.value)
                        })
                    }
                }
            }

            function __makeTemplateObject(l, c) {
                return Object.defineProperty ? Object.defineProperty(l, "raw", {
                    value: c
                }) : l.raw = c, l
            }

            function __importStar(l) {
                if (l && l.__esModule) return l;
                var c = {};
                if (null != l)
                    for (var x in l) Object.hasOwnProperty.call(l, x) && (c[x] = l[x]);
                return c.default = l, c
            }

            function __importDefault(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            }

            function __classPrivateFieldGet(l, c) {
                if (!c.has(l)) throw TypeError("attempted to get private field on non-instance");
                return c.get(l)
            }

            function __classPrivateFieldSet(l, c, x) {
                if (!c.has(l)) throw TypeError("attempted to set private field on non-instance");
                return c.set(l, x), x
            }
        },
        49979: function(l, c, x) {
            "use strict";
            x.d(c, {
                D3: function() {
                    return E
                },
                N1: function() {
                    return n
                },
                W3: function() {
                    return w
                },
                Yo: function() {
                    return y
                },
                kZ: function() {
                    return a
                },
                lV: function() {
                    return b
                },
                oe: function() {
                    return g
                },
                pX: function() {
                    return v
                },
                pZ: function() {
                    return p
                },
                sY: function() {
                    return d
                },
                yy: function() {
                    return h
                },
                z9: function() {
                    return u
                }
            });
            var N = x(95097);
            x(512);
            let n = class n extends N.q {
                constructor(l) {
                    super(), this.opts = l, this.protocol = "wc", this.version = 2
                }
            };
            let h = class h extends N.q {
                constructor(l, c) {
                    super(), this.core = l, this.logger = c, this.records = new Map
                }
            };
            let a = class a {
                constructor(l, c) {
                    this.logger = l, this.core = c
                }
            };
            let u = class u extends N.q {
                constructor(l, c) {
                    super(), this.relayer = l, this.logger = c
                }
            };
            let g = class g extends N.q {
                constructor(l) {
                    super()
                }
            };
            let p = class p {
                constructor(l, c, x, N) {
                    this.core = l, this.logger = c, this.name = x
                }
            };
            let d = class d extends N.q {
                constructor(l, c) {
                    super(), this.relayer = l, this.logger = c
                }
            };
            let E = class E extends N.q {
                constructor(l, c) {
                    super(), this.core = l, this.logger = c
                }
            };
            let y = class y {
                constructor(l, c) {
                    this.projectId = l, this.logger = c
                }
            };
            let v = class v {
                constructor(l, c) {
                    this.projectId = l, this.logger = c
                }
            };
            let b = class b {
                constructor(l) {
                    this.opts = l, this.protocol = "wc", this.version = 2
                }
            };
            let w = class w {
                constructor(l) {
                    this.client = l
                }
            }
        },
        849: function(l, c) {
            "use strict";

            function getFromWindow(l) {
                let c;
                return "undefined" != typeof window && void 0 !== window[l] && (c = window[l]), c
            }

            function getFromWindowOrThrow(l) {
                let c = getFromWindow(l);
                if (!c) throw Error(`${l} is not defined in Window`);
                return c
            }
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.getLocalStorage = c.getLocalStorageOrThrow = c.getCrypto = c.getCryptoOrThrow = c.getLocation = c.getLocationOrThrow = c.getNavigator = c.getNavigatorOrThrow = c.getDocument = c.getDocumentOrThrow = c.getFromWindowOrThrow = c.getFromWindow = void 0, c.getFromWindow = getFromWindow, c.getFromWindowOrThrow = getFromWindowOrThrow, c.getDocumentOrThrow = function() {
                return getFromWindowOrThrow("document")
            }, c.getDocument = function() {
                return getFromWindow("document")
            }, c.getNavigatorOrThrow = function() {
                return getFromWindowOrThrow("navigator")
            }, c.getNavigator = function() {
                return getFromWindow("navigator")
            }, c.getLocationOrThrow = function() {
                return getFromWindowOrThrow("location")
            }, c.getLocation = function() {
                return getFromWindow("location")
            }, c.getCryptoOrThrow = function() {
                return getFromWindowOrThrow("crypto")
            }, c.getCrypto = function() {
                return getFromWindow("crypto")
            }, c.getLocalStorageOrThrow = function() {
                return getFromWindowOrThrow("localStorage")
            }, c.getLocalStorage = function() {
                return getFromWindow("localStorage")
            }
        },
        36073: function(l, c, x) {
            "use strict";
            c.D = void 0;
            let N = x(849);
            c.D = function() {
                let l, c, x;
                try {
                    l = N.getDocumentOrThrow(), c = N.getLocationOrThrow()
                } catch (l) {
                    return null
                }

                function getWindowMetadataOfAny(...c) {
                    let x = l.getElementsByTagName("meta");
                    for (let l = 0; l < x.length; l++) {
                        let N = x[l],
                            U = ["itemprop", "property", "name"].map(l => N.getAttribute(l)).filter(l => !!l && c.includes(l));
                        if (U.length && U) {
                            let l = N.getAttribute("content");
                            if (l) return l
                        }
                    }
                    return ""
                }
                let U = ((x = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title")) || (x = l.title), x),
                    Z = function() {
                        let l = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
                        return l
                    }(),
                    $ = c.origin,
                    Y = function() {
                        let x = l.getElementsByTagName("link"),
                            N = [];
                        for (let l = 0; l < x.length; l++) {
                            let U = x[l],
                                Z = U.getAttribute("rel");
                            if (Z && Z.toLowerCase().indexOf("icon") > -1) {
                                let l = U.getAttribute("href");
                                if (l) {
                                    if (-1 === l.toLowerCase().indexOf("https:") && -1 === l.toLowerCase().indexOf("http:") && 0 !== l.indexOf("//")) {
                                        let x = c.protocol + "//" + c.host;
                                        if (0 === l.indexOf("/")) x += l;
                                        else {
                                            let N = c.pathname.split("/");
                                            N.pop();
                                            let U = N.join("/");
                                            x += U + "/" + l
                                        }
                                        N.push(x)
                                    } else if (0 === l.indexOf("//")) {
                                        let x = c.protocol + l;
                                        N.push(x)
                                    } else N.push(l)
                                }
                            }
                        }
                        return N
                    }();
                return {
                    description: Z,
                    url: $,
                    icons: Y,
                    name: U
                }
            }
        },
        66179: function(l) {
            "use strict";
            ! function(c) {
                function checkInt(l) {
                    return parseInt(l) === l
                }

                function checkInts(l) {
                    if (!checkInt(l.length)) return !1;
                    for (var c = 0; c < l.length; c++)
                        if (!checkInt(l[c]) || l[c] < 0 || l[c] > 255) return !1;
                    return !0
                }

                function coerceArray(l, c) {
                    if (l.buffer && ArrayBuffer.isView(l) && "Uint8Array" === l.name) return c && (l = l.slice ? l.slice() : Array.prototype.slice.call(l)), l;
                    if (Array.isArray(l)) {
                        if (!checkInts(l)) throw Error("Array contains invalid value: " + l);
                        return new Uint8Array(l)
                    }
                    if (checkInt(l.length) && checkInts(l)) return new Uint8Array(l);
                    throw Error("unsupported array-like object")
                }

                function createArray(l) {
                    return new Uint8Array(l)
                }

                function copyArray(l, c, x, N, U) {
                    (null != N || null != U) && (l = l.slice ? l.slice(N, U) : Array.prototype.slice.call(l, N, U)), c.set(l, x)
                }
                var x, N = (x = "0123456789abcdef", {
                        toBytes: function(l) {
                            for (var c = [], x = 0; x < l.length; x += 2) c.push(parseInt(l.substr(x, 2), 16));
                            return c
                        },
                        fromBytes: function(l) {
                            for (var c = [], N = 0; N < l.length; N++) {
                                var U = l[N];
                                c.push(x[(240 & U) >> 4] + x[15 & U])
                            }
                            return c.join("")
                        }
                    }),
                    U = {
                        16: 10,
                        24: 12,
                        32: 14
                    },
                    Z = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
                    $ = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
                    Y = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
                    q = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986],
                    J = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766],
                    X = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126],
                    en = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436],
                    er = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890],
                    ea = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935],
                    eo = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600],
                    el = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480],
                    ec = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795],
                    eu = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855],
                    ed = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150],
                    ep = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

                function convertToInt32(l) {
                    for (var c = [], x = 0; x < l.length; x += 4) c.push(l[x] << 24 | l[x + 1] << 16 | l[x + 2] << 8 | l[x + 3]);
                    return c
                }
                var AES = function(l) {
                    if (!(this instanceof AES)) throw Error("AES must be instanitated with `new`");
                    Object.defineProperty(this, "key", {
                        value: coerceArray(l, !0)
                    }), this._prepare()
                };
                AES.prototype._prepare = function() {
                    var l = U[this.key.length];
                    if (null == l) throw Error("invalid key size (must be 16, 24 or 32 bytes)");
                    this._Ke = [], this._Kd = [];
                    for (var c = 0; c <= l; c++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
                    for (var x = (l + 1) * 4, N = this.key.length / 4, Y = convertToInt32(this.key), c = 0; c < N; c++) q = c >> 2, this._Ke[q][c % 4] = Y[c], this._Kd[l - q][c % 4] = Y[c];
                    for (var q, J, X = 0, en = N; en < x;) {
                        if (J = Y[N - 1], Y[0] ^= $[J >> 16 & 255] << 24 ^ $[J >> 8 & 255] << 16 ^ $[255 & J] << 8 ^ $[J >> 24 & 255] ^ Z[X] << 24, X += 1, 8 != N)
                            for (var c = 1; c < N; c++) Y[c] ^= Y[c - 1];
                        else {
                            for (var c = 1; c < N / 2; c++) Y[c] ^= Y[c - 1];
                            J = Y[N / 2 - 1], Y[N / 2] ^= $[255 & J] ^ $[J >> 8 & 255] << 8 ^ $[J >> 16 & 255] << 16 ^ $[J >> 24 & 255] << 24;
                            for (var c = N / 2 + 1; c < N; c++) Y[c] ^= Y[c - 1]
                        }
                        for (var er, ea, c = 0; c < N && en < x;) er = en >> 2, ea = en % 4, this._Ke[er][ea] = Y[c], this._Kd[l - er][ea] = Y[c++], en++
                    }
                    for (var er = 1; er < l; er++)
                        for (var ea = 0; ea < 4; ea++) J = this._Kd[er][ea], this._Kd[er][ea] = ec[J >> 24 & 255] ^ eu[J >> 16 & 255] ^ ed[J >> 8 & 255] ^ ep[255 & J]
                }, AES.prototype.encrypt = function(l) {
                    if (16 != l.length) throw Error("invalid plaintext size (must be 16 bytes)");
                    for (var c = this._Ke.length - 1, x = [0, 0, 0, 0], N = convertToInt32(l), U = 0; U < 4; U++) N[U] ^= this._Ke[0][U];
                    for (var Z = 1; Z < c; Z++) {
                        for (var U = 0; U < 4; U++) x[U] = q[N[U] >> 24 & 255] ^ J[N[(U + 1) % 4] >> 16 & 255] ^ X[N[(U + 2) % 4] >> 8 & 255] ^ en[255 & N[(U + 3) % 4]] ^ this._Ke[Z][U];
                        N = x.slice()
                    }
                    for (var Y, er = createArray(16), U = 0; U < 4; U++) Y = this._Ke[c][U], er[4 * U] = ($[N[U] >> 24 & 255] ^ Y >> 24) & 255, er[4 * U + 1] = ($[N[(U + 1) % 4] >> 16 & 255] ^ Y >> 16) & 255, er[4 * U + 2] = ($[N[(U + 2) % 4] >> 8 & 255] ^ Y >> 8) & 255, er[4 * U + 3] = ($[255 & N[(U + 3) % 4]] ^ Y) & 255;
                    return er
                }, AES.prototype.decrypt = function(l) {
                    if (16 != l.length) throw Error("invalid ciphertext size (must be 16 bytes)");
                    for (var c = this._Kd.length - 1, x = [0, 0, 0, 0], N = convertToInt32(l), U = 0; U < 4; U++) N[U] ^= this._Kd[0][U];
                    for (var Z = 1; Z < c; Z++) {
                        for (var U = 0; U < 4; U++) x[U] = er[N[U] >> 24 & 255] ^ ea[N[(U + 3) % 4] >> 16 & 255] ^ eo[N[(U + 2) % 4] >> 8 & 255] ^ el[255 & N[(U + 1) % 4]] ^ this._Kd[Z][U];
                        N = x.slice()
                    }
                    for (var $, q = createArray(16), U = 0; U < 4; U++) $ = this._Kd[c][U], q[4 * U] = (Y[N[U] >> 24 & 255] ^ $ >> 24) & 255, q[4 * U + 1] = (Y[N[(U + 3) % 4] >> 16 & 255] ^ $ >> 16) & 255, q[4 * U + 2] = (Y[N[(U + 2) % 4] >> 8 & 255] ^ $ >> 8) & 255, q[4 * U + 3] = (Y[255 & N[(U + 1) % 4]] ^ $) & 255;
                    return q
                };
                var ModeOfOperationECB = function(l) {
                    if (!(this instanceof ModeOfOperationECB)) throw Error("AES must be instanitated with `new`");
                    this.description = "Electronic Code Block", this.name = "ecb", this._aes = new AES(l)
                };
                ModeOfOperationECB.prototype.encrypt = function(l) {
                    if ((l = coerceArray(l)).length % 16 != 0) throw Error("invalid plaintext size (must be multiple of 16 bytes)");
                    for (var c = createArray(l.length), x = createArray(16), N = 0; N < l.length; N += 16) copyArray(l, x, 0, N, N + 16), copyArray(x = this._aes.encrypt(x), c, N);
                    return c
                }, ModeOfOperationECB.prototype.decrypt = function(l) {
                    if ((l = coerceArray(l)).length % 16 != 0) throw Error("invalid ciphertext size (must be multiple of 16 bytes)");
                    for (var c = createArray(l.length), x = createArray(16), N = 0; N < l.length; N += 16) copyArray(l, x, 0, N, N + 16), copyArray(x = this._aes.decrypt(x), c, N);
                    return c
                };
                var ModeOfOperationCBC = function(l, c) {
                    if (!(this instanceof ModeOfOperationCBC)) throw Error("AES must be instanitated with `new`");
                    if (this.description = "Cipher Block Chaining", this.name = "cbc", c) {
                        if (16 != c.length) throw Error("invalid initialation vector size (must be 16 bytes)")
                    } else c = createArray(16);
                    this._lastCipherblock = coerceArray(c, !0), this._aes = new AES(l)
                };
                ModeOfOperationCBC.prototype.encrypt = function(l) {
                    if ((l = coerceArray(l)).length % 16 != 0) throw Error("invalid plaintext size (must be multiple of 16 bytes)");
                    for (var c = createArray(l.length), x = createArray(16), N = 0; N < l.length; N += 16) {
                        copyArray(l, x, 0, N, N + 16);
                        for (var U = 0; U < 16; U++) x[U] ^= this._lastCipherblock[U];
                        this._lastCipherblock = this._aes.encrypt(x), copyArray(this._lastCipherblock, c, N)
                    }
                    return c
                }, ModeOfOperationCBC.prototype.decrypt = function(l) {
                    if ((l = coerceArray(l)).length % 16 != 0) throw Error("invalid ciphertext size (must be multiple of 16 bytes)");
                    for (var c = createArray(l.length), x = createArray(16), N = 0; N < l.length; N += 16) {
                        copyArray(l, x, 0, N, N + 16), x = this._aes.decrypt(x);
                        for (var U = 0; U < 16; U++) c[N + U] = x[U] ^ this._lastCipherblock[U];
                        copyArray(l, this._lastCipherblock, 0, N, N + 16)
                    }
                    return c
                };
                var ModeOfOperationCFB = function(l, c, x) {
                    if (!(this instanceof ModeOfOperationCFB)) throw Error("AES must be instanitated with `new`");
                    if (this.description = "Cipher Feedback", this.name = "cfb", c) {
                        if (16 != c.length) throw Error("invalid initialation vector size (must be 16 size)")
                    } else c = createArray(16);
                    x || (x = 1), this.segmentSize = x, this._shiftRegister = coerceArray(c, !0), this._aes = new AES(l)
                };
                ModeOfOperationCFB.prototype.encrypt = function(l) {
                    if (l.length % this.segmentSize != 0) throw Error("invalid plaintext size (must be segmentSize bytes)");
                    for (var c, x = coerceArray(l, !0), N = 0; N < x.length; N += this.segmentSize) {
                        c = this._aes.encrypt(this._shiftRegister);
                        for (var U = 0; U < this.segmentSize; U++) x[N + U] ^= c[U];
                        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), copyArray(x, this._shiftRegister, 16 - this.segmentSize, N, N + this.segmentSize)
                    }
                    return x
                }, ModeOfOperationCFB.prototype.decrypt = function(l) {
                    if (l.length % this.segmentSize != 0) throw Error("invalid ciphertext size (must be segmentSize bytes)");
                    for (var c, x = coerceArray(l, !0), N = 0; N < x.length; N += this.segmentSize) {
                        c = this._aes.encrypt(this._shiftRegister);
                        for (var U = 0; U < this.segmentSize; U++) x[N + U] ^= c[U];
                        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), copyArray(l, this._shiftRegister, 16 - this.segmentSize, N, N + this.segmentSize)
                    }
                    return x
                };
                var ModeOfOperationOFB = function(l, c) {
                    if (!(this instanceof ModeOfOperationOFB)) throw Error("AES must be instanitated with `new`");
                    if (this.description = "Output Feedback", this.name = "ofb", c) {
                        if (16 != c.length) throw Error("invalid initialation vector size (must be 16 bytes)")
                    } else c = createArray(16);
                    this._lastPrecipher = coerceArray(c, !0), this._lastPrecipherIndex = 16, this._aes = new AES(l)
                };
                ModeOfOperationOFB.prototype.encrypt = function(l) {
                    for (var c = coerceArray(l, !0), x = 0; x < c.length; x++) 16 === this._lastPrecipherIndex && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), c[x] ^= this._lastPrecipher[this._lastPrecipherIndex++];
                    return c
                }, ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
                var Counter = function(l) {
                    if (!(this instanceof Counter)) throw Error("Counter must be instanitated with `new`");
                    0 === l || l || (l = 1), "number" == typeof l ? (this._counter = createArray(16), this.setValue(l)) : this.setBytes(l)
                };
                Counter.prototype.setValue = function(l) {
                    if ("number" != typeof l || parseInt(l) != l) throw Error("invalid counter value (must be an integer)");
                    for (var c = 15; c >= 0; --c) this._counter[c] = l % 256, l >>= 8
                }, Counter.prototype.setBytes = function(l) {
                    if (16 != (l = coerceArray(l, !0)).length) throw Error("invalid counter bytes size (must be 16 bytes)");
                    this._counter = l
                }, Counter.prototype.increment = function() {
                    for (var l = 15; l >= 0; l--)
                        if (255 === this._counter[l]) this._counter[l] = 0;
                        else {
                            this._counter[l]++;
                            break
                        }
                };
                var ModeOfOperationCTR = function(l, c) {
                    if (!(this instanceof ModeOfOperationCTR)) throw Error("AES must be instanitated with `new`");
                    this.description = "Counter", this.name = "ctr", c instanceof Counter || (c = new Counter(c)), this._counter = c, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new AES(l)
                };
                ModeOfOperationCTR.prototype.encrypt = function(l) {
                    for (var c = coerceArray(l, !0), x = 0; x < c.length; x++) 16 === this._remainingCounterIndex && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), c[x] ^= this._remainingCounter[this._remainingCounterIndex++];
                    return c
                }, ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt, l.exports = {
                    AES: AES,
                    Counter: Counter,
                    ModeOfOperation: {
                        ecb: ModeOfOperationECB,
                        cbc: ModeOfOperationCBC,
                        cfb: ModeOfOperationCFB,
                        ofb: ModeOfOperationOFB,
                        ctr: ModeOfOperationCTR
                    },
                    utils: {
                        hex: N,
                        utf8: {
                            toBytes: function(l) {
                                var c = [],
                                    x = 0;
                                for (l = encodeURI(l); x < l.length;) {
                                    var N = l.charCodeAt(x++);
                                    37 === N ? (c.push(parseInt(l.substr(x, 2), 16)), x += 2) : c.push(N)
                                }
                                return coerceArray(c)
                            },
                            fromBytes: function(l) {
                                for (var c = [], x = 0; x < l.length;) {
                                    var N = l[x];
                                    N < 128 ? (c.push(String.fromCharCode(N)), x++) : N > 191 && N < 224 ? (c.push(String.fromCharCode((31 & N) << 6 | 63 & l[x + 1])), x += 2) : (c.push(String.fromCharCode((15 & N) << 12 | (63 & l[x + 1]) << 6 | 63 & l[x + 2])), x += 3)
                                }
                                return c.join("")
                            }
                        }
                    },
                    padding: {
                        pkcs7: {
                            pad: function(l) {
                                var c = 16 - (l = coerceArray(l, !0)).length % 16,
                                    x = createArray(l.length + c);
                                copyArray(l, x);
                                for (var N = l.length; N < x.length; N++) x[N] = c;
                                return x
                            },
                            strip: function(l) {
                                if ((l = coerceArray(l, !0)).length < 16) throw Error("PKCS#7 invalid length");
                                var c = l[l.length - 1];
                                if (c > 16) throw Error("PKCS#7 padding byte out of range");
                                for (var x = l.length - c, N = 0; N < c; N++)
                                    if (l[x + N] !== c) throw Error("PKCS#7 invalid padding byte");
                                var U = createArray(x);
                                return copyArray(l, U, 0, 0, x), U
                            }
                        }
                    },
                    _arrayTest: {
                        coerceArray: coerceArray,
                        createArray: createArray,
                        copyArray: copyArray
                    }
                }
            }(0)
        },
        81542: function(l) {
            "use strict";
            l.exports = function(l) {
                if (l.length >= 255) throw TypeError("Alphabet too long");
                for (var c = new Uint8Array(256), x = 0; x < c.length; x++) c[x] = 255;
                for (var N = 0; N < l.length; N++) {
                    var U = l.charAt(N),
                        Z = U.charCodeAt(0);
                    if (255 !== c[Z]) throw TypeError(U + " is ambiguous");
                    c[Z] = N
                }
                var $ = l.length,
                    Y = l.charAt(0),
                    q = Math.log($) / Math.log(256),
                    J = Math.log(256) / Math.log($);

                function decodeUnsafe(l) {
                    if ("string" != typeof l) throw TypeError("Expected String");
                    if (0 === l.length) return new Uint8Array;
                    for (var x = 0, N = 0, U = 0; l[x] === Y;) N++, x++;
                    for (var Z = (l.length - x) * q + 1 >>> 0, J = new Uint8Array(Z); l[x];) {
                        var X = c[l.charCodeAt(x)];
                        if (255 === X) return;
                        for (var en = 0, er = Z - 1;
                            (0 !== X || en < U) && -1 !== er; er--, en++) X += $ * J[er] >>> 0, J[er] = X % 256 >>> 0, X = X / 256 >>> 0;
                        if (0 !== X) throw Error("Non-zero carry");
                        U = en, x++
                    }
                    for (var ea = Z - U; ea !== Z && 0 === J[ea];) ea++;
                    for (var eo = new Uint8Array(N + (Z - ea)), el = N; ea !== Z;) eo[el++] = J[ea++];
                    return eo
                }
                return {
                    encode: function(c) {
                        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                        if (0 === c.length) return "";
                        for (var x = 0, N = 0, U = 0, Z = c.length; U !== Z && 0 === c[U];) U++, x++;
                        for (var q = (Z - U) * J + 1 >>> 0, X = new Uint8Array(q); U !== Z;) {
                            for (var en = c[U], er = 0, ea = q - 1;
                                (0 !== en || er < N) && -1 !== ea; ea--, er++) en += 256 * X[ea] >>> 0, X[ea] = en % $ >>> 0, en = en / $ >>> 0;
                            if (0 !== en) throw Error("Non-zero carry");
                            N = er, U++
                        }
                        for (var eo = q - N; eo !== q && 0 === X[eo];) eo++;
                        for (var el = Y.repeat(x); eo < q; ++eo) el += l.charAt(X[eo]);
                        return el
                    },
                    decodeUnsafe: decodeUnsafe,
                    decode: function(l) {
                        var c = decodeUnsafe(l);
                        if (c) return c;
                        throw Error("Non-base" + $ + " character")
                    }
                }
            }
        },
        34699: function(l, c) {
            "use strict";
            c.byteLength = function(l) {
                var c = getLens(l),
                    x = c[0],
                    N = c[1];
                return (x + N) * 3 / 4 - N
            }, c.toByteArray = function(l) {
                var c, x, Z = getLens(l),
                    $ = Z[0],
                    Y = Z[1],
                    q = new U(($ + Y) * 3 / 4 - Y),
                    J = 0,
                    X = Y > 0 ? $ - 4 : $;
                for (x = 0; x < X; x += 4) c = N[l.charCodeAt(x)] << 18 | N[l.charCodeAt(x + 1)] << 12 | N[l.charCodeAt(x + 2)] << 6 | N[l.charCodeAt(x + 3)], q[J++] = c >> 16 & 255, q[J++] = c >> 8 & 255, q[J++] = 255 & c;
                return 2 === Y && (c = N[l.charCodeAt(x)] << 2 | N[l.charCodeAt(x + 1)] >> 4, q[J++] = 255 & c), 1 === Y && (c = N[l.charCodeAt(x)] << 10 | N[l.charCodeAt(x + 1)] << 4 | N[l.charCodeAt(x + 2)] >> 2, q[J++] = c >> 8 & 255, q[J++] = 255 & c), q
            }, c.fromByteArray = function(l) {
                for (var c, N = l.length, U = N % 3, Z = [], $ = 0, Y = N - U; $ < Y; $ += 16383) Z.push(function(l, c, N) {
                    for (var U, Z = [], $ = c; $ < N; $ += 3) Z.push(x[(U = (l[$] << 16 & 16711680) + (l[$ + 1] << 8 & 65280) + (255 & l[$ + 2])) >> 18 & 63] + x[U >> 12 & 63] + x[U >> 6 & 63] + x[63 & U]);
                    return Z.join("")
                }(l, $, $ + 16383 > Y ? Y : $ + 16383));
                return 1 === U ? Z.push(x[(c = l[N - 1]) >> 2] + x[c << 4 & 63] + "==") : 2 === U && Z.push(x[(c = (l[N - 2] << 8) + l[N - 1]) >> 10] + x[c >> 4 & 63] + x[c << 2 & 63] + "="), Z.join("")
            };
            for (var x = [], N = [], U = "undefined" != typeof Uint8Array ? Uint8Array : Array, Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", $ = 0, Y = Z.length; $ < Y; ++$) x[$] = Z[$], N[Z.charCodeAt($)] = $;

            function getLens(l) {
                var c = l.length;
                if (c % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
                var x = l.indexOf("="); - 1 === x && (x = c);
                var N = x === c ? 0 : 4 - x % 4;
                return [x, N]
            }
            N["-".charCodeAt(0)] = 62, N["_".charCodeAt(0)] = 63
        },
        68870: function(l, c, x) {
            let N = x(81542);
            l.exports = N("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
        },
        78133: function(l, c, x) {
            var N = x(67133).Buffer;
            l.exports = function(l) {
                for (var c = new N(l.length), x = 0, U = l.length - 1; x <= U; ++x, --U) c[x] = l[U], c[U] = l[x];
                return c
            }
        },
        67133: function(l, c, x) {
            "use strict";
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */
            let N = x(34699),
                U = x(19087),
                Z = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;

            function createBuffer(l) {
                if (l > 2147483647) throw RangeError('The value "' + l + '" is invalid for option "size"');
                let c = new Uint8Array(l);
                return Object.setPrototypeOf(c, Buffer.prototype), c
            }

            function Buffer(l, c, x) {
                if ("number" == typeof l) {
                    if ("string" == typeof c) throw TypeError('The "string" argument must be of type string. Received type number');
                    return allocUnsafe(l)
                }
                return from(l, c, x)
            }

            function from(l, c, x) {
                if ("string" == typeof l) return function(l, c) {
                    if (("string" != typeof c || "" === c) && (c = "utf8"), !Buffer.isEncoding(c)) throw TypeError("Unknown encoding: " + c);
                    let x = 0 | byteLength(l, c),
                        N = createBuffer(x),
                        U = N.write(l, c);
                    return U !== x && (N = N.slice(0, U)), N
                }(l, c);
                if (ArrayBuffer.isView(l)) return function(l) {
                    if (isInstance(l, Uint8Array)) {
                        let c = new Uint8Array(l);
                        return fromArrayBuffer(c.buffer, c.byteOffset, c.byteLength)
                    }
                    return fromArrayLike(l)
                }(l);
                if (null == l) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l);
                if (isInstance(l, ArrayBuffer) || l && isInstance(l.buffer, ArrayBuffer) || "undefined" != typeof SharedArrayBuffer && (isInstance(l, SharedArrayBuffer) || l && isInstance(l.buffer, SharedArrayBuffer))) return fromArrayBuffer(l, c, x);
                if ("number" == typeof l) throw TypeError('The "value" argument must not be of type number. Received type number');
                let N = l.valueOf && l.valueOf();
                if (null != N && N !== l) return Buffer.from(N, c, x);
                let U = function(l) {
                    var c;
                    if (Buffer.isBuffer(l)) {
                        let c = 0 | checked(l.length),
                            x = createBuffer(c);
                        return 0 === x.length || l.copy(x, 0, 0, c), x
                    }
                    return void 0 !== l.length ? "number" != typeof l.length || (c = l.length) != c ? createBuffer(0) : fromArrayLike(l) : "Buffer" === l.type && Array.isArray(l.data) ? fromArrayLike(l.data) : void 0
                }(l);
                if (U) return U;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof l[Symbol.toPrimitive]) return Buffer.from(l[Symbol.toPrimitive]("string"), c, x);
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof l)
            }

            function assertSize(l) {
                if ("number" != typeof l) throw TypeError('"size" argument must be of type number');
                if (l < 0) throw RangeError('The value "' + l + '" is invalid for option "size"')
            }

            function allocUnsafe(l) {
                return assertSize(l), createBuffer(l < 0 ? 0 : 0 | checked(l))
            }

            function fromArrayLike(l) {
                let c = l.length < 0 ? 0 : 0 | checked(l.length),
                    x = createBuffer(c);
                for (let N = 0; N < c; N += 1) x[N] = 255 & l[N];
                return x
            }

            function fromArrayBuffer(l, c, x) {
                let N;
                if (c < 0 || l.byteLength < c) throw RangeError('"offset" is outside of buffer bounds');
                if (l.byteLength < c + (x || 0)) throw RangeError('"length" is outside of buffer bounds');
                return Object.setPrototypeOf(N = void 0 === c && void 0 === x ? new Uint8Array(l) : void 0 === x ? new Uint8Array(l, c) : new Uint8Array(l, c, x), Buffer.prototype), N
            }

            function checked(l) {
                if (l >= 2147483647) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");
                return 0 | l
            }

            function byteLength(l, c) {
                if (Buffer.isBuffer(l)) return l.length;
                if (ArrayBuffer.isView(l) || isInstance(l, ArrayBuffer)) return l.byteLength;
                if ("string" != typeof l) throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof l);
                let x = l.length,
                    N = arguments.length > 2 && !0 === arguments[2];
                if (!N && 0 === x) return 0;
                let U = !1;
                for (;;) switch (c) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return x;
                    case "utf8":
                    case "utf-8":
                        return utf8ToBytes(l).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * x;
                    case "hex":
                        return x >>> 1;
                    case "base64":
                        return base64ToBytes(l).length;
                    default:
                        if (U) return N ? -1 : utf8ToBytes(l).length;
                        c = ("" + c).toLowerCase(), U = !0
                }
            }

            function slowToString(l, c, x) {
                let U = !1;
                if ((void 0 === c || c < 0) && (c = 0), c > this.length || ((void 0 === x || x > this.length) && (x = this.length), x <= 0 || (x >>>= 0) <= (c >>>= 0))) return "";
                for (l || (l = "utf8");;) switch (l) {
                    case "hex":
                        return function(l, c, x) {
                            let N = l.length;
                            (!c || c < 0) && (c = 0), (!x || x < 0 || x > N) && (x = N);
                            let U = "";
                            for (let N = c; N < x; ++N) U += q[l[N]];
                            return U
                        }(this, c, x);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, c, x);
                    case "ascii":
                        return function(l, c, x) {
                            let N = "";
                            x = Math.min(l.length, x);
                            for (let U = c; U < x; ++U) N += String.fromCharCode(127 & l[U]);
                            return N
                        }(this, c, x);
                    case "latin1":
                    case "binary":
                        return function(l, c, x) {
                            let N = "";
                            x = Math.min(l.length, x);
                            for (let U = c; U < x; ++U) N += String.fromCharCode(l[U]);
                            return N
                        }(this, c, x);
                    case "base64":
                        var Z, $;
                        return Z = c, $ = x, 0 === Z && $ === this.length ? N.fromByteArray(this) : N.fromByteArray(this.slice(Z, $));
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return function(l, c, x) {
                            let N = l.slice(c, x),
                                U = "";
                            for (let l = 0; l < N.length - 1; l += 2) U += String.fromCharCode(N[l] + 256 * N[l + 1]);
                            return U
                        }(this, c, x);
                    default:
                        if (U) throw TypeError("Unknown encoding: " + l);
                        l = (l + "").toLowerCase(), U = !0
                }
            }

            function swap(l, c, x) {
                let N = l[c];
                l[c] = l[x], l[x] = N
            }

            function bidirectionalIndexOf(l, c, x, N, U) {
                var Z;
                if (0 === l.length) return -1;
                if ("string" == typeof x ? (N = x, x = 0) : x > 2147483647 ? x = 2147483647 : x < -2147483648 && (x = -2147483648), (Z = x = +x) != Z && (x = U ? 0 : l.length - 1), x < 0 && (x = l.length + x), x >= l.length) {
                    if (U) return -1;
                    x = l.length - 1
                } else if (x < 0) {
                    if (!U) return -1;
                    x = 0
                }
                if ("string" == typeof c && (c = Buffer.from(c, N)), Buffer.isBuffer(c)) return 0 === c.length ? -1 : arrayIndexOf(l, c, x, N, U);
                if ("number" == typeof c) return (c &= 255, "function" == typeof Uint8Array.prototype.indexOf) ? U ? Uint8Array.prototype.indexOf.call(l, c, x) : Uint8Array.prototype.lastIndexOf.call(l, c, x) : arrayIndexOf(l, [c], x, N, U);
                throw TypeError("val must be string, number or Buffer")
            }

            function arrayIndexOf(l, c, x, N, U) {
                let Z, $ = 1,
                    Y = l.length,
                    q = c.length;
                if (void 0 !== N && ("ucs2" === (N = String(N).toLowerCase()) || "ucs-2" === N || "utf16le" === N || "utf-16le" === N)) {
                    if (l.length < 2 || c.length < 2) return -1;
                    $ = 2, Y /= 2, q /= 2, x /= 2
                }

                function read(l, c) {
                    return 1 === $ ? l[c] : l.readUInt16BE(c * $)
                }
                if (U) {
                    let N = -1;
                    for (Z = x; Z < Y; Z++)
                        if (read(l, Z) === read(c, -1 === N ? 0 : Z - N)) {
                            if (-1 === N && (N = Z), Z - N + 1 === q) return N * $
                        } else -1 !== N && (Z -= Z - N), N = -1
                } else
                    for (x + q > Y && (x = Y - q), Z = x; Z >= 0; Z--) {
                        let x = !0;
                        for (let N = 0; N < q; N++)
                            if (read(l, Z + N) !== read(c, N)) {
                                x = !1;
                                break
                            }
                        if (x) return Z
                    }
                return -1
            }

            function utf8Slice(l, c, x) {
                x = Math.min(l.length, x);
                let N = [],
                    U = c;
                for (; U < x;) {
                    let c = l[U],
                        Z = null,
                        $ = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                    if (U + $ <= x) {
                        let x, N, Y, q;
                        switch ($) {
                            case 1:
                                c < 128 && (Z = c);
                                break;
                            case 2:
                                (192 & (x = l[U + 1])) == 128 && (q = (31 & c) << 6 | 63 & x) > 127 && (Z = q);
                                break;
                            case 3:
                                x = l[U + 1], N = l[U + 2], (192 & x) == 128 && (192 & N) == 128 && (q = (15 & c) << 12 | (63 & x) << 6 | 63 & N) > 2047 && (q < 55296 || q > 57343) && (Z = q);
                                break;
                            case 4:
                                x = l[U + 1], N = l[U + 2], Y = l[U + 3], (192 & x) == 128 && (192 & N) == 128 && (192 & Y) == 128 && (q = (15 & c) << 18 | (63 & x) << 12 | (63 & N) << 6 | 63 & Y) > 65535 && q < 1114112 && (Z = q)
                        }
                    }
                    null === Z ? (Z = 65533, $ = 1) : Z > 65535 && (Z -= 65536, N.push(Z >>> 10 & 1023 | 55296), Z = 56320 | 1023 & Z), N.push(Z), U += $
                }
                return function(l) {
                    let c = l.length;
                    if (c <= 4096) return String.fromCharCode.apply(String, l);
                    let x = "",
                        N = 0;
                    for (; N < c;) x += String.fromCharCode.apply(String, l.slice(N, N += 4096));
                    return x
                }(N)
            }

            function checkOffset(l, c, x) {
                if (l % 1 != 0 || l < 0) throw RangeError("offset is not uint");
                if (l + c > x) throw RangeError("Trying to access beyond buffer length")
            }

            function checkInt(l, c, x, N, U, Z) {
                if (!Buffer.isBuffer(l)) throw TypeError('"buffer" argument must be a Buffer instance');
                if (c > U || c < Z) throw RangeError('"value" argument is out of bounds');
                if (x + N > l.length) throw RangeError("Index out of range")
            }

            function wrtBigUInt64LE(l, c, x, N, U) {
                checkIntBI(c, N, U, l, x, 7);
                let Z = Number(c & BigInt(4294967295));
                l[x++] = Z, Z >>= 8, l[x++] = Z, Z >>= 8, l[x++] = Z, Z >>= 8, l[x++] = Z;
                let $ = Number(c >> BigInt(32) & BigInt(4294967295));
                return l[x++] = $, $ >>= 8, l[x++] = $, $ >>= 8, l[x++] = $, $ >>= 8, l[x++] = $, x
            }

            function wrtBigUInt64BE(l, c, x, N, U) {
                checkIntBI(c, N, U, l, x, 7);
                let Z = Number(c & BigInt(4294967295));
                l[x + 7] = Z, Z >>= 8, l[x + 6] = Z, Z >>= 8, l[x + 5] = Z, Z >>= 8, l[x + 4] = Z;
                let $ = Number(c >> BigInt(32) & BigInt(4294967295));
                return l[x + 3] = $, $ >>= 8, l[x + 2] = $, $ >>= 8, l[x + 1] = $, $ >>= 8, l[x] = $, x + 8
            }

            function checkIEEE754(l, c, x, N, U, Z) {
                if (x + N > l.length || x < 0) throw RangeError("Index out of range")
            }

            function writeFloat(l, c, x, N, Z) {
                return c = +c, x >>>= 0, Z || checkIEEE754(l, c, x, 4, 34028234663852886e22, -34028234663852886e22), U.write(l, c, x, N, 23, 4), x + 4
            }

            function writeDouble(l, c, x, N, Z) {
                return c = +c, x >>>= 0, Z || checkIEEE754(l, c, x, 8, 17976931348623157e292, -17976931348623157e292), U.write(l, c, x, N, 52, 8), x + 8
            }
            c.Buffer = Buffer, c.SlowBuffer = function(l) {
                return +l != l && (l = 0), Buffer.alloc(+l)
            }, c.INSPECT_MAX_BYTES = 50, c.kMaxLength = 2147483647, Buffer.TYPED_ARRAY_SUPPORT = function() {
                try {
                    let l = new Uint8Array(1),
                        c = {
                            foo: function() {
                                return 42
                            }
                        };
                    return Object.setPrototypeOf(c, Uint8Array.prototype), Object.setPrototypeOf(l, c), 42 === l.foo()
                } catch (l) {
                    return !1
                }
            }(), Buffer.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this)) return this.buffer
                }
            }), Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this)) return this.byteOffset
                }
            }), Buffer.poolSize = 8192, Buffer.from = function(l, c, x) {
                return from(l, c, x)
            }, Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer, Uint8Array), Buffer.alloc = function(l, c, x) {
                return (assertSize(l), l <= 0) ? createBuffer(l) : void 0 !== c ? "string" == typeof x ? createBuffer(l).fill(c, x) : createBuffer(l).fill(c) : createBuffer(l)
            }, Buffer.allocUnsafe = function(l) {
                return allocUnsafe(l)
            }, Buffer.allocUnsafeSlow = function(l) {
                return allocUnsafe(l)
            }, Buffer.isBuffer = function(l) {
                return null != l && !0 === l._isBuffer && l !== Buffer.prototype
            }, Buffer.compare = function(l, c) {
                if (isInstance(l, Uint8Array) && (l = Buffer.from(l, l.offset, l.byteLength)), isInstance(c, Uint8Array) && (c = Buffer.from(c, c.offset, c.byteLength)), !Buffer.isBuffer(l) || !Buffer.isBuffer(c)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (l === c) return 0;
                let x = l.length,
                    N = c.length;
                for (let U = 0, Z = Math.min(x, N); U < Z; ++U)
                    if (l[U] !== c[U]) {
                        x = l[U], N = c[U];
                        break
                    }
                return x < N ? -1 : N < x ? 1 : 0
            }, Buffer.isEncoding = function(l) {
                switch (String(l).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, Buffer.concat = function(l, c) {
                let x;
                if (!Array.isArray(l)) throw TypeError('"list" argument must be an Array of Buffers');
                if (0 === l.length) return Buffer.alloc(0);
                if (void 0 === c)
                    for (x = 0, c = 0; x < l.length; ++x) c += l[x].length;
                let N = Buffer.allocUnsafe(c),
                    U = 0;
                for (x = 0; x < l.length; ++x) {
                    let c = l[x];
                    if (isInstance(c, Uint8Array)) U + c.length > N.length ? (Buffer.isBuffer(c) || (c = Buffer.from(c)), c.copy(N, U)) : Uint8Array.prototype.set.call(N, c, U);
                    else if (Buffer.isBuffer(c)) c.copy(N, U);
                    else throw TypeError('"list" argument must be an Array of Buffers');
                    U += c.length
                }
                return N
            }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
                let l = this.length;
                if (l % 2 != 0) throw RangeError("Buffer size must be a multiple of 16-bits");
                for (let c = 0; c < l; c += 2) swap(this, c, c + 1);
                return this
            }, Buffer.prototype.swap32 = function() {
                let l = this.length;
                if (l % 4 != 0) throw RangeError("Buffer size must be a multiple of 32-bits");
                for (let c = 0; c < l; c += 4) swap(this, c, c + 3), swap(this, c + 1, c + 2);
                return this
            }, Buffer.prototype.swap64 = function() {
                let l = this.length;
                if (l % 8 != 0) throw RangeError("Buffer size must be a multiple of 64-bits");
                for (let c = 0; c < l; c += 8) swap(this, c, c + 7), swap(this, c + 1, c + 6), swap(this, c + 2, c + 5), swap(this, c + 3, c + 4);
                return this
            }, Buffer.prototype.toString = function() {
                let l = this.length;
                return 0 === l ? "" : 0 == arguments.length ? utf8Slice(this, 0, l) : slowToString.apply(this, arguments)
            }, Buffer.prototype.toLocaleString = Buffer.prototype.toString, Buffer.prototype.equals = function(l) {
                if (!Buffer.isBuffer(l)) throw TypeError("Argument must be a Buffer");
                return this === l || 0 === Buffer.compare(this, l)
            }, Buffer.prototype.inspect = function() {
                let l = "",
                    x = c.INSPECT_MAX_BYTES;
                return l = this.toString("hex", 0, x).replace(/(.{2})/g, "$1 ").trim(), this.length > x && (l += " ... "), "<Buffer " + l + ">"
            }, Z && (Buffer.prototype[Z] = Buffer.prototype.inspect), Buffer.prototype.compare = function(l, c, x, N, U) {
                if (isInstance(l, Uint8Array) && (l = Buffer.from(l, l.offset, l.byteLength)), !Buffer.isBuffer(l)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
                if (void 0 === c && (c = 0), void 0 === x && (x = l ? l.length : 0), void 0 === N && (N = 0), void 0 === U && (U = this.length), c < 0 || x > l.length || N < 0 || U > this.length) throw RangeError("out of range index");
                if (N >= U && c >= x) return 0;
                if (N >= U) return -1;
                if (c >= x) return 1;
                if (c >>>= 0, x >>>= 0, N >>>= 0, U >>>= 0, this === l) return 0;
                let Z = U - N,
                    $ = x - c,
                    Y = Math.min(Z, $),
                    q = this.slice(N, U),
                    J = l.slice(c, x);
                for (let l = 0; l < Y; ++l)
                    if (q[l] !== J[l]) {
                        Z = q[l], $ = J[l];
                        break
                    }
                return Z < $ ? -1 : $ < Z ? 1 : 0
            }, Buffer.prototype.includes = function(l, c, x) {
                return -1 !== this.indexOf(l, c, x)
            }, Buffer.prototype.indexOf = function(l, c, x) {
                return bidirectionalIndexOf(this, l, c, x, !0)
            }, Buffer.prototype.lastIndexOf = function(l, c, x) {
                return bidirectionalIndexOf(this, l, c, x, !1)
            }, Buffer.prototype.write = function(l, c, x, N) {
                var U, Z, $, Y, q, J, X, en;
                if (void 0 === c) N = "utf8", x = this.length, c = 0;
                else if (void 0 === x && "string" == typeof c) N = c, x = this.length, c = 0;
                else if (isFinite(c)) c >>>= 0, isFinite(x) ? (x >>>= 0, void 0 === N && (N = "utf8")) : (N = x, x = void 0);
                else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                let er = this.length - c;
                if ((void 0 === x || x > er) && (x = er), l.length > 0 && (x < 0 || c < 0) || c > this.length) throw RangeError("Attempt to write outside buffer bounds");
                N || (N = "utf8");
                let ea = !1;
                for (;;) switch (N) {
                    case "hex":
                        return function(l, c, x, N) {
                            let U;
                            x = Number(x) || 0;
                            let Z = l.length - x;
                            N ? (N = Number(N)) > Z && (N = Z) : N = Z;
                            let $ = c.length;
                            for (N > $ / 2 && (N = $ / 2), U = 0; U < N; ++U) {
                                let N = parseInt(c.substr(2 * U, 2), 16);
                                if (N != N) break;
                                l[x + U] = N
                            }
                            return U
                        }(this, l, c, x);
                    case "utf8":
                    case "utf-8":
                        return U = c, Z = x, blitBuffer(utf8ToBytes(l, this.length - U), this, U, Z);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return $ = c, Y = x, blitBuffer(function(l) {
                            let c = [];
                            for (let x = 0; x < l.length; ++x) c.push(255 & l.charCodeAt(x));
                            return c
                        }(l), this, $, Y);
                    case "base64":
                        return q = c, J = x, blitBuffer(base64ToBytes(l), this, q, J);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return X = c, en = x, blitBuffer(function(l, c) {
                            let x, N;
                            let U = [];
                            for (let Z = 0; Z < l.length && !((c -= 2) < 0); ++Z) N = (x = l.charCodeAt(Z)) >> 8, U.push(x % 256), U.push(N);
                            return U
                        }(l, this.length - X), this, X, en);
                    default:
                        if (ea) throw TypeError("Unknown encoding: " + N);
                        N = ("" + N).toLowerCase(), ea = !0
                }
            }, Buffer.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }, Buffer.prototype.slice = function(l, c) {
                let x = this.length;
                l = ~~l, c = void 0 === c ? x : ~~c, l < 0 ? (l += x) < 0 && (l = 0) : l > x && (l = x), c < 0 ? (c += x) < 0 && (c = 0) : c > x && (c = x), c < l && (c = l);
                let N = this.subarray(l, c);
                return Object.setPrototypeOf(N, Buffer.prototype), N
            }, Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function(l, c, x) {
                l >>>= 0, c >>>= 0, x || checkOffset(l, c, this.length);
                let N = this[l],
                    U = 1,
                    Z = 0;
                for (; ++Z < c && (U *= 256);) N += this[l + Z] * U;
                return N
            }, Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function(l, c, x) {
                l >>>= 0, c >>>= 0, x || checkOffset(l, c, this.length);
                let N = this[l + --c],
                    U = 1;
                for (; c > 0 && (U *= 256);) N += this[l + --c] * U;
                return N
            }, Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 1, this.length), this[l]
            }, Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 2, this.length), this[l] | this[l + 1] << 8
            }, Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 2, this.length), this[l] << 8 | this[l + 1]
            }, Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3]
            }, Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3])
            }, Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function(l) {
                validateNumber(l >>>= 0, "offset");
                let c = this[l],
                    x = this[l + 7];
                (void 0 === c || void 0 === x) && boundsError(l, this.length - 8);
                let N = c + 256 * this[++l] + 65536 * this[++l] + 16777216 * this[++l],
                    U = this[++l] + 256 * this[++l] + 65536 * this[++l] + 16777216 * x;
                return BigInt(N) + (BigInt(U) << BigInt(32))
            }), Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function(l) {
                validateNumber(l >>>= 0, "offset");
                let c = this[l],
                    x = this[l + 7];
                (void 0 === c || void 0 === x) && boundsError(l, this.length - 8);
                let N = 16777216 * c + 65536 * this[++l] + 256 * this[++l] + this[++l],
                    U = 16777216 * this[++l] + 65536 * this[++l] + 256 * this[++l] + x;
                return (BigInt(N) << BigInt(32)) + BigInt(U)
            }), Buffer.prototype.readIntLE = function(l, c, x) {
                l >>>= 0, c >>>= 0, x || checkOffset(l, c, this.length);
                let N = this[l],
                    U = 1,
                    Z = 0;
                for (; ++Z < c && (U *= 256);) N += this[l + Z] * U;
                return N >= (U *= 128) && (N -= Math.pow(2, 8 * c)), N
            }, Buffer.prototype.readIntBE = function(l, c, x) {
                l >>>= 0, c >>>= 0, x || checkOffset(l, c, this.length);
                let N = c,
                    U = 1,
                    Z = this[l + --N];
                for (; N > 0 && (U *= 256);) Z += this[l + --N] * U;
                return Z >= (U *= 128) && (Z -= Math.pow(2, 8 * c)), Z
            }, Buffer.prototype.readInt8 = function(l, c) {
                return (l >>>= 0, c || checkOffset(l, 1, this.length), 128 & this[l]) ? -((255 - this[l] + 1) * 1) : this[l]
            }, Buffer.prototype.readInt16LE = function(l, c) {
                l >>>= 0, c || checkOffset(l, 2, this.length);
                let x = this[l] | this[l + 1] << 8;
                return 32768 & x ? 4294901760 | x : x
            }, Buffer.prototype.readInt16BE = function(l, c) {
                l >>>= 0, c || checkOffset(l, 2, this.length);
                let x = this[l + 1] | this[l] << 8;
                return 32768 & x ? 4294901760 | x : x
            }, Buffer.prototype.readInt32LE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24
            }, Buffer.prototype.readInt32BE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]
            }, Buffer.prototype.readBigInt64LE = defineBigIntMethod(function(l) {
                validateNumber(l >>>= 0, "offset");
                let c = this[l],
                    x = this[l + 7];
                (void 0 === c || void 0 === x) && boundsError(l, this.length - 8);
                let N = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (x << 24);
                return (BigInt(N) << BigInt(32)) + BigInt(c + 256 * this[++l] + 65536 * this[++l] + 16777216 * this[++l])
            }), Buffer.prototype.readBigInt64BE = defineBigIntMethod(function(l) {
                validateNumber(l >>>= 0, "offset");
                let c = this[l],
                    x = this[l + 7];
                (void 0 === c || void 0 === x) && boundsError(l, this.length - 8);
                let N = (c << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
                return (BigInt(N) << BigInt(32)) + BigInt(16777216 * this[++l] + 65536 * this[++l] + 256 * this[++l] + x)
            }), Buffer.prototype.readFloatLE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 4, this.length), U.read(this, l, !0, 23, 4)
            }, Buffer.prototype.readFloatBE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 4, this.length), U.read(this, l, !1, 23, 4)
            }, Buffer.prototype.readDoubleLE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 8, this.length), U.read(this, l, !0, 52, 8)
            }, Buffer.prototype.readDoubleBE = function(l, c) {
                return l >>>= 0, c || checkOffset(l, 8, this.length), U.read(this, l, !1, 52, 8)
            }, Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function(l, c, x, N) {
                if (l = +l, c >>>= 0, x >>>= 0, !N) {
                    let N = Math.pow(2, 8 * x) - 1;
                    checkInt(this, l, c, x, N, 0)
                }
                let U = 1,
                    Z = 0;
                for (this[c] = 255 & l; ++Z < x && (U *= 256);) this[c + Z] = l / U & 255;
                return c + x
            }, Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function(l, c, x, N) {
                if (l = +l, c >>>= 0, x >>>= 0, !N) {
                    let N = Math.pow(2, 8 * x) - 1;
                    checkInt(this, l, c, x, N, 0)
                }
                let U = x - 1,
                    Z = 1;
                for (this[c + U] = 255 & l; --U >= 0 && (Z *= 256);) this[c + U] = l / Z & 255;
                return c + x
            }, Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 1, 255, 0), this[c] = 255 & l, c + 1
            }, Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 2, 65535, 0), this[c] = 255 & l, this[c + 1] = l >>> 8, c + 2
            }, Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 2, 65535, 0), this[c] = l >>> 8, this[c + 1] = 255 & l, c + 2
            }, Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 4, 4294967295, 0), this[c + 3] = l >>> 24, this[c + 2] = l >>> 16, this[c + 1] = l >>> 8, this[c] = 255 & l, c + 4
            }, Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 4, 4294967295, 0), this[c] = l >>> 24, this[c + 1] = l >>> 16, this[c + 2] = l >>> 8, this[c + 3] = 255 & l, c + 4
            }, Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function(l, c = 0) {
                return wrtBigUInt64LE(this, l, c, BigInt(0), BigInt("0xffffffffffffffff"))
            }), Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function(l, c = 0) {
                return wrtBigUInt64BE(this, l, c, BigInt(0), BigInt("0xffffffffffffffff"))
            }), Buffer.prototype.writeIntLE = function(l, c, x, N) {
                if (l = +l, c >>>= 0, !N) {
                    let N = Math.pow(2, 8 * x - 1);
                    checkInt(this, l, c, x, N - 1, -N)
                }
                let U = 0,
                    Z = 1,
                    $ = 0;
                for (this[c] = 255 & l; ++U < x && (Z *= 256);) l < 0 && 0 === $ && 0 !== this[c + U - 1] && ($ = 1), this[c + U] = (l / Z >> 0) - $ & 255;
                return c + x
            }, Buffer.prototype.writeIntBE = function(l, c, x, N) {
                if (l = +l, c >>>= 0, !N) {
                    let N = Math.pow(2, 8 * x - 1);
                    checkInt(this, l, c, x, N - 1, -N)
                }
                let U = x - 1,
                    Z = 1,
                    $ = 0;
                for (this[c + U] = 255 & l; --U >= 0 && (Z *= 256);) l < 0 && 0 === $ && 0 !== this[c + U + 1] && ($ = 1), this[c + U] = (l / Z >> 0) - $ & 255;
                return c + x
            }, Buffer.prototype.writeInt8 = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[c] = 255 & l, c + 1
            }, Buffer.prototype.writeInt16LE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 2, 32767, -32768), this[c] = 255 & l, this[c + 1] = l >>> 8, c + 2
            }, Buffer.prototype.writeInt16BE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 2, 32767, -32768), this[c] = l >>> 8, this[c + 1] = 255 & l, c + 2
            }, Buffer.prototype.writeInt32LE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 4, 2147483647, -2147483648), this[c] = 255 & l, this[c + 1] = l >>> 8, this[c + 2] = l >>> 16, this[c + 3] = l >>> 24, c + 4
            }, Buffer.prototype.writeInt32BE = function(l, c, x) {
                return l = +l, c >>>= 0, x || checkInt(this, l, c, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[c] = l >>> 24, this[c + 1] = l >>> 16, this[c + 2] = l >>> 8, this[c + 3] = 255 & l, c + 4
            }, Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function(l, c = 0) {
                return wrtBigUInt64LE(this, l, c, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function(l, c = 0) {
                return wrtBigUInt64BE(this, l, c, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), Buffer.prototype.writeFloatLE = function(l, c, x) {
                return writeFloat(this, l, c, !0, x)
            }, Buffer.prototype.writeFloatBE = function(l, c, x) {
                return writeFloat(this, l, c, !1, x)
            }, Buffer.prototype.writeDoubleLE = function(l, c, x) {
                return writeDouble(this, l, c, !0, x)
            }, Buffer.prototype.writeDoubleBE = function(l, c, x) {
                return writeDouble(this, l, c, !1, x)
            }, Buffer.prototype.copy = function(l, c, x, N) {
                if (!Buffer.isBuffer(l)) throw TypeError("argument should be a Buffer");
                if (x || (x = 0), N || 0 === N || (N = this.length), c >= l.length && (c = l.length), c || (c = 0), N > 0 && N < x && (N = x), N === x || 0 === l.length || 0 === this.length) return 0;
                if (c < 0) throw RangeError("targetStart out of bounds");
                if (x < 0 || x >= this.length) throw RangeError("Index out of range");
                if (N < 0) throw RangeError("sourceEnd out of bounds");
                N > this.length && (N = this.length), l.length - c < N - x && (N = l.length - c + x);
                let U = N - x;
                return this === l && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(c, x, N) : Uint8Array.prototype.set.call(l, this.subarray(x, N), c), U
            }, Buffer.prototype.fill = function(l, c, x, N) {
                let U;
                if ("string" == typeof l) {
                    if ("string" == typeof c ? (N = c, c = 0, x = this.length) : "string" == typeof x && (N = x, x = this.length), void 0 !== N && "string" != typeof N) throw TypeError("encoding must be a string");
                    if ("string" == typeof N && !Buffer.isEncoding(N)) throw TypeError("Unknown encoding: " + N);
                    if (1 === l.length) {
                        let c = l.charCodeAt(0);
                        ("utf8" === N && c < 128 || "latin1" === N) && (l = c)
                    }
                } else "number" == typeof l ? l &= 255 : "boolean" == typeof l && (l = Number(l));
                if (c < 0 || this.length < c || this.length < x) throw RangeError("Out of range index");
                if (x <= c) return this;
                if (c >>>= 0, x = void 0 === x ? this.length : x >>> 0, l || (l = 0), "number" == typeof l)
                    for (U = c; U < x; ++U) this[U] = l;
                else {
                    let Z = Buffer.isBuffer(l) ? l : Buffer.from(l, N),
                        $ = Z.length;
                    if (0 === $) throw TypeError('The value "' + l + '" is invalid for argument "value"');
                    for (U = 0; U < x - c; ++U) this[U + c] = Z[U % $]
                }
                return this
            };
            let $ = {};

            function E(l, c, x) {
                $[l] = class extends x {
                    constructor() {
                        super(), Object.defineProperty(this, "message", {
                            value: c.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${l}]`, this.stack, delete this.name
                    }
                    get code() {
                        return l
                    }
                    set code(l) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: l,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${l}]: ${this.message}`
                    }
                }
            }

            function addNumericalSeparator(l) {
                let c = "",
                    x = l.length,
                    N = "-" === l[0] ? 1 : 0;
                for (; x >= N + 4; x -= 3) c = `_${l.slice(x-3,x)}${c}`;
                return `${l.slice(0,x)}${c}`
            }

            function checkIntBI(l, c, x, N, U, Z) {
                if (l > x || l < c) {
                    let N;
                    let U = "bigint" == typeof c ? "n" : "";
                    throw N = Z > 3 ? 0 === c || c === BigInt(0) ? `>= 0${U} and < 2${U} ** ${(Z+1)*8}${U}` : `>= -(2${U} ** ${(Z+1)*8-1}${U}) and < 2 ** ${(Z+1)*8-1}${U}` : `>= ${c}${U} and <= ${x}${U}`, new $.ERR_OUT_OF_RANGE("value", N, l)
                }
                validateNumber(U, "offset"), (void 0 === N[U] || void 0 === N[U + Z]) && boundsError(U, N.length - (Z + 1))
            }

            function validateNumber(l, c) {
                if ("number" != typeof l) throw new $.ERR_INVALID_ARG_TYPE(c, "number", l)
            }

            function boundsError(l, c, x) {
                if (Math.floor(l) !== l) throw validateNumber(l, x), new $.ERR_OUT_OF_RANGE(x || "offset", "an integer", l);
                if (c < 0) throw new $.ERR_BUFFER_OUT_OF_BOUNDS;
                throw new $.ERR_OUT_OF_RANGE(x || "offset", `>= ${x?1:0} and <= ${c}`, l)
            }
            E("ERR_BUFFER_OUT_OF_BOUNDS", function(l) {
                return l ? `${l} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }, RangeError), E("ERR_INVALID_ARG_TYPE", function(l, c) {
                return `The "${l}" argument must be of type number. Received type ${typeof c}`
            }, TypeError), E("ERR_OUT_OF_RANGE", function(l, c, x) {
                let N = `The value of "${l}" is out of range.`,
                    U = x;
                return Number.isInteger(x) && Math.abs(x) > 4294967296 ? U = addNumericalSeparator(String(x)) : "bigint" == typeof x && (U = String(x), (x > BigInt(2) ** BigInt(32) || x < -(BigInt(2) ** BigInt(32))) && (U = addNumericalSeparator(U)), U += "n"), N += ` It must be ${c}. Received ${U}`
            }, RangeError);
            let Y = /[^+/0-9A-Za-z-_]/g;

            function utf8ToBytes(l, c) {
                let x;
                c = c || 1 / 0;
                let N = l.length,
                    U = null,
                    Z = [];
                for (let $ = 0; $ < N; ++$) {
                    if ((x = l.charCodeAt($)) > 55295 && x < 57344) {
                        if (!U) {
                            if (x > 56319 || $ + 1 === N) {
                                (c -= 3) > -1 && Z.push(239, 191, 189);
                                continue
                            }
                            U = x;
                            continue
                        }
                        if (x < 56320) {
                            (c -= 3) > -1 && Z.push(239, 191, 189), U = x;
                            continue
                        }
                        x = (U - 55296 << 10 | x - 56320) + 65536
                    } else U && (c -= 3) > -1 && Z.push(239, 191, 189);
                    if (U = null, x < 128) {
                        if ((c -= 1) < 0) break;
                        Z.push(x)
                    } else if (x < 2048) {
                        if ((c -= 2) < 0) break;
                        Z.push(x >> 6 | 192, 63 & x | 128)
                    } else if (x < 65536) {
                        if ((c -= 3) < 0) break;
                        Z.push(x >> 12 | 224, x >> 6 & 63 | 128, 63 & x | 128)
                    } else if (x < 1114112) {
                        if ((c -= 4) < 0) break;
                        Z.push(x >> 18 | 240, x >> 12 & 63 | 128, x >> 6 & 63 | 128, 63 & x | 128)
                    } else throw Error("Invalid code point")
                }
                return Z
            }

            function base64ToBytes(l) {
                return N.toByteArray(function(l) {
                    if ((l = (l = l.split("=")[0]).trim().replace(Y, "")).length < 2) return "";
                    for (; l.length % 4 != 0;) l += "=";
                    return l
                }(l))
            }

            function blitBuffer(l, c, x, N) {
                let U;
                for (U = 0; U < N && !(U + x >= c.length) && !(U >= l.length); ++U) c[U + x] = l[U];
                return U
            }

            function isInstance(l, c) {
                return l instanceof c || null != l && null != l.constructor && null != l.constructor.name && l.constructor.name === c.name
            }
            let q = function() {
                let l = "0123456789abcdef",
                    c = Array(256);
                for (let x = 0; x < 16; ++x) {
                    let N = 16 * x;
                    for (let U = 0; U < 16; ++U) c[N + U] = l[x] + l[U]
                }
                return c
            }();

            function defineBigIntMethod(l) {
                return "undefined" == typeof BigInt ? BufferBigIntNotDefined : l
            }

            function BufferBigIntNotDefined() {
                throw Error("BigInt not supported")
            }
        },
        44463: function(l, c, x) {
            "use strict";
            let N = x(59631);
            l.exports = function(l, c = "utf8") {
                let x = N[c];
                if (!x) throw Error(`Unsupported encoding "${c}"`);
                return x.encoder.encode(l).substring(1)
            }
        },
        59631: function(l, c, x) {
            "use strict";
            let {
                bases: N
            } = x(44035);

            function createCodec(l, c, x, N) {
                return {
                    name: l,
                    prefix: c,
                    encoder: {
                        name: l,
                        prefix: c,
                        encode: x
                    },
                    decoder: {
                        decode: N
                    }
                }
            }
            let U = createCodec("utf8", "u", l => {
                    let c = new TextDecoder("utf8");
                    return "u" + c.decode(l)
                }, l => {
                    let c = new TextEncoder;
                    return c.encode(l.substring(1))
                }),
                Z = createCodec("ascii", "a", l => {
                    let c = "a";
                    for (let x = 0; x < l.length; x++) c += String.fromCharCode(l[x]);
                    return c
                }, l => {
                    l = l.substring(1);
                    let c = new Uint8Array(l.length);
                    for (let x = 0; x < l.length; x++) c[x] = l.charCodeAt(x);
                    return c
                }),
                $ = {
                    utf8: U,
                    "utf-8": U,
                    hex: N.base16,
                    latin1: Z,
                    ascii: Z,
                    binary: Z,
                    ...N
                };
            l.exports = $
        },
        27498: function(l, c, x) {
            "use strict";
            let N = x(34001),
                U = x(21497);
            l.exports = function(l) {
                try {
                    l = new N(l)
                } catch (c) {
                    throw U(c, `invalid cid: ${l}`)
                }
                return 1 !== l.version && (l = l.toV1()), l.toBaseEncodedString("base32")
            }
        },
        84701: function(l, c, x) {
            "use strict";
            let N = x(34313);
            l.exports = function() {
                let l = [];
                for (let c of Object.values(N.names)) l.push({
                    name: c.name,
                    code: c.code
                });
                return l
            }
        },
        29051: function(l, c, x) {
            "use strict";
            let N = x(34001);
            l.exports = function() {
                let l = [];
                for (let [c, x] of Object.entries(N.codecs)) l.push({
                    name: c,
                    code: x
                });
                return l
            }
        },
        45827: function(l, c, x) {
            "use strict";
            let N = x(34001),
                U = x(84701),
                Z = x(29051),
                $ = x(21497),
                Y = x(34313),
                q = x(20400),
                J = x(44463);

            function isString(l) {
                return "[object String]" === Object.prototype.toString.call(l)
            }

            function findBase(l) {
                let c = U().find(c => c.code === l || c.name === l);
                if (!c) throw Error(`invalid multibase: ${l}`);
                return c
            }
            l.exports = function(l, c) {
                var x, U;
                let X = (c = c || {}).format || "%s";
                if ("prefix" === X && (X = "%P"), !isString(X) || -1 === X.indexOf("%")) throw Error(`invalid format string: ${X}`);
                let en = l;
                try {
                    l = new N(l)
                } catch (c) {
                    throw $(c, `invalid cid: ${l}`)
                }
                if (null != c.cidVersion && l.version !== c.cidVersion) {
                    if (0 === c.cidVersion) l = l.toV0();
                    else if (1 === c.cidVersion) l = l.toV1();
                    else throw Error(`invalid cid version: ${c.cidVersion}`)
                }
                let er = "base58btc";
                return c.base ? er = findBase(c.base).name : isString(en) && (er = Y.isEncoded(en) || er), X.replace(/%([a-zA-Z%])/g, (x = l, U = er, (l, c) => {
                    switch (c) {
                        case "%":
                            return "%";
                        case "b":
                            return U;
                        case "B":
                            return findBase(U).code;
                        case "v":
                            return `cidv${x.version}`;
                        case "V":
                            return x.version.toString();
                        case "c":
                            return x.codec;
                        case "C":
                            return (function(l) {
                                let c = Z().find(c => c.name === l.codec);
                                if (!c) throw Error(`invalid codec: ${l.codec}`);
                                return c.code
                            })(x).toString();
                        case "h":
                            return q.decode(x.multihash).name;
                        case "H":
                            return q.decode(x.multihash).code.toString();
                        case "L":
                            return q.decode(x.multihash).length.toString();
                        case "m":
                            return J(Y.encode(U, x.multihash));
                        case "M":
                            return J(x.multihash, U);
                        case "d":
                            return J(Y.encode(U, q.decode(x.multihash).digest));
                        case "D":
                            return J(q.decode(x.multihash).digest, U);
                        case "s":
                            return x.toString(U);
                        case "S":
                            return 1 === x.version ? x.toString(U).slice(1) : J(x.bytes, U);
                        case "P":
                            return function(l) {
                                let {
                                    name: c,
                                    length: x
                                } = q.decode(l.multihash);
                                return `cidv${l.version}-${l.codec}-${c}-${x}`
                            }(x);
                        default:
                            throw Error(`unrecognized specifier in format string: ${c}`)
                    }
                }))
            }
        },
        98111: function(l, c, x) {
            "use strict";
            let N = x(20400);
            l.exports = function() {
                let l = [];
                for (let [c, x] of Object.entries(N.names)) l.push({
                    name: c,
                    code: x
                });
                return l
            }
        },
        93337: function(l, c, x) {
            "use strict";
            c.base32 = x(27498), c.bases = x(84701), c.codecs = x(29051), c.format = x(45827), c.hashes = x(98111)
        },
        48523: function(l, c, x) {
            "use strict";
            l.exports = x(93337)
        },
        91956: function(l, c, x) {
            "use strict";
            let N = x(20400);
            l.exports = {
                checkCIDComponents: function(l) {
                    if (null == l) return "null values are not valid CIDs";
                    if (!(0 === l.version || 1 === l.version)) return "Invalid version, must be a number equal to 1 or 0";
                    if ("string" != typeof l.codec) return "codec must be string";
                    if (0 === l.version) {
                        if ("dag-pb" !== l.codec) return "codec must be 'dag-pb' for CIDv0";
                        if ("base58btc" !== l.multibaseName) return "multibaseName must be 'base58btc' for CIDv0"
                    }
                    if (!(l.multihash instanceof Uint8Array)) return "multihash must be a Uint8Array";
                    try {
                        N.validate(l.multihash)
                    } catch (c) {
                        let l = c.message;
                        return l || (l = "Multihash validation failed"), l
                    }
                }
            }
        },
        34001: function(l, c, x) {
            "use strict";
            let N = x(20400),
                U = x(34313),
                Z = x(97284),
                $ = x(91956),
                {
                    concat: Y
                } = x(72281),
                {
                    toString: q
                } = x(21361),
                {
                    equals: J
                } = x(49605),
                X = Z.nameToCode,
                en = Object.keys(X).reduce((l, c) => (l[X[c]] = c, l), {}),
                er = Symbol.for("@ipld/js-cid/CID");
            let CID = class CID {
                constructor(l, c, x, $) {
                    if (this.version, this.codec, this.multihash, Object.defineProperty(this, er, {
                            value: !0
                        }), CID.isCID(l)) {
                        this.version = l.version, this.codec = l.codec, this.multihash = l.multihash, this.multibaseName = l.multibaseName || (0 === l.version ? "base58btc" : "base32");
                        return
                    }
                    if ("string" == typeof l) {
                        let c = U.isEncoded(l);
                        if (c) {
                            let x = U.decode(l);
                            this.version = parseInt(x[0].toString(), 16), this.codec = Z.getCodec(x.slice(1)), this.multihash = Z.rmPrefix(x.slice(1)), this.multibaseName = c
                        } else this.version = 0, this.codec = "dag-pb", this.multihash = N.fromB58String(l), this.multibaseName = "base58btc";
                        CID.validateCID(this), Object.defineProperty(this, "string", {
                            value: l
                        });
                        return
                    }
                    if (l instanceof Uint8Array) {
                        let c = parseInt(l[0].toString(), 16);
                        1 === c ? (this.version = c, this.codec = Z.getCodec(l.slice(1)), this.multihash = Z.rmPrefix(l.slice(1)), this.multibaseName = "base32") : (this.version = 0, this.codec = "dag-pb", this.multihash = l, this.multibaseName = "base58btc"), CID.validateCID(this);
                        return
                    }
                    this.version = l, "number" == typeof c && (c = en[c]), this.codec = c, this.multihash = x, this.multibaseName = $ || (0 === l ? "base58btc" : "base32"), CID.validateCID(this)
                }
                get bytes() {
                    let l = this._bytes;
                    if (!l) {
                        if (0 === this.version) l = this.multihash;
                        else if (1 === this.version) {
                            let c = Z.getCodeVarint(this.codec);
                            l = Y([
                                [1], c, this.multihash
                            ], 1 + c.byteLength + this.multihash.byteLength)
                        } else throw Error("unsupported version");
                        Object.defineProperty(this, "_bytes", {
                            value: l
                        })
                    }
                    return l
                }
                get prefix() {
                    let l = Z.getCodeVarint(this.codec),
                        c = N.prefix(this.multihash),
                        x = Y([
                            [this.version], l, c
                        ], 1 + l.byteLength + c.byteLength);
                    return x
                }
                get code() {
                    return X[this.codec]
                }
                toV0() {
                    if ("dag-pb" !== this.codec) throw Error("Cannot convert a non dag-pb CID to CIDv0");
                    let {
                        name: l,
                        length: c
                    } = N.decode(this.multihash);
                    if ("sha2-256" !== l) throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                    if (32 !== c) throw Error("Cannot convert non 32 byte multihash CID to CIDv0");
                    return new CID(0, this.codec, this.multihash)
                }
                toV1() {
                    return new CID(1, this.codec, this.multihash, this.multibaseName)
                }
                toBaseEncodedString(l = this.multibaseName) {
                    let c;
                    if (this.string && 0 !== this.string.length && l === this.multibaseName) return this.string;
                    if (0 === this.version) {
                        if ("base58btc" !== l) throw Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
                        c = N.toB58String(this.multihash)
                    } else if (1 === this.version) c = q(U.encode(l, this.bytes));
                    else throw Error("unsupported version");
                    return l === this.multibaseName && Object.defineProperty(this, "string", {
                        value: c
                    }), c
                }[Symbol.for("nodejs.util.inspect.custom")]() {
                    return "CID(" + this.toString() + ")"
                }
                toString(l) {
                    return this.toBaseEncodedString(l)
                }
                toJSON() {
                    return {
                        codec: this.codec,
                        version: this.version,
                        hash: this.multihash
                    }
                }
                equals(l) {
                    return this.codec === l.codec && this.version === l.version && J(this.multihash, l.multihash)
                }
                static validateCID(l) {
                    let c = $.checkCIDComponents(l);
                    if (c) throw Error(c)
                }
                static isCID(l) {
                    return l instanceof CID || !!(l && l[er])
                }
            };
            CID.codecs = X, l.exports = CID
        },
        2390: function(l, c, x) {
            "use strict";
            var N = x(25809),
                U = {
                    "text/plain": "Text",
                    "text/html": "Url",
                    default: "Text"
                };
            l.exports = function(l, c) {
                var x, Z, $, Y, q, J, X, en, er = !1;
                c || (c = {}), $ = c.debug || !1;
                try {
                    if (q = N(), J = document.createRange(), X = document.getSelection(), (en = document.createElement("span")).textContent = l, en.ariaHidden = "true", en.style.all = "unset", en.style.position = "fixed", en.style.top = 0, en.style.clip = "rect(0, 0, 0, 0)", en.style.whiteSpace = "pre", en.style.webkitUserSelect = "text", en.style.MozUserSelect = "text", en.style.msUserSelect = "text", en.style.userSelect = "text", en.addEventListener("copy", function(x) {
                            if (x.stopPropagation(), c.format) {
                                if (x.preventDefault(), void 0 === x.clipboardData) {
                                    $ && console.warn("unable to use e.clipboardData"), $ && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
                                    var N = U[c.format] || U.default;
                                    window.clipboardData.setData(N, l)
                                } else x.clipboardData.clearData(), x.clipboardData.setData(c.format, l)
                            }
                            c.onCopy && (x.preventDefault(), c.onCopy(x.clipboardData))
                        }), document.body.appendChild(en), J.selectNodeContents(en), X.addRange(J), !document.execCommand("copy")) throw Error("copy command was unsuccessful");
                    er = !0
                } catch (N) {
                    $ && console.error("unable to copy using execCommand: ", N), $ && console.warn("trying IE specific stuff");
                    try {
                        window.clipboardData.setData(c.format || "text", l), c.onCopy && c.onCopy(window.clipboardData), er = !0
                    } catch (N) {
                        $ && console.error("unable to copy using clipboardData: ", N), $ && console.error("falling back to prompt"), x = "message" in c ? c.message : "Copy to clipboard: #{key}, Enter", Z = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C", Y = x.replace(/#{\s*key\s*}/g, Z), window.prompt(Y, l)
                    }
                } finally {
                    X && ("function" == typeof X.removeRange ? X.removeRange(J) : X.removeAllRanges()), en && document.body.removeChild(en), q()
                }
                return er
            }
        },
        9366: function(l, c) {
            var x = "undefined" != typeof self ? self : this,
                N = function() {
                    function F() {
                        this.fetch = !1, this.DOMException = x.DOMException
                    }
                    return F.prototype = x, new F
                }();
            (function(l) {
                var c = {
                    searchParams: "URLSearchParams" in N,
                    iterable: "Symbol" in N && "iterator" in Symbol,
                    blob: "FileReader" in N && "Blob" in N && function() {
                        try {
                            return new Blob, !0
                        } catch (l) {
                            return !1
                        }
                    }(),
                    formData: "FormData" in N,
                    arrayBuffer: "ArrayBuffer" in N
                };
                if (c.arrayBuffer) var x = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    U = ArrayBuffer.isView || function(l) {
                        return l && x.indexOf(Object.prototype.toString.call(l)) > -1
                    };

                function normalizeName(l) {
                    if ("string" != typeof l && (l = String(l)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(l)) throw TypeError("Invalid character in header field name");
                    return l.toLowerCase()
                }

                function normalizeValue(l) {
                    return "string" != typeof l && (l = String(l)), l
                }

                function iteratorFor(l) {
                    var x = {
                        next: function() {
                            var c = l.shift();
                            return {
                                done: void 0 === c,
                                value: c
                            }
                        }
                    };
                    return c.iterable && (x[Symbol.iterator] = function() {
                        return x
                    }), x
                }

                function Headers(l) {
                    this.map = {}, l instanceof Headers ? l.forEach(function(l, c) {
                        this.append(c, l)
                    }, this) : Array.isArray(l) ? l.forEach(function(l) {
                        this.append(l[0], l[1])
                    }, this) : l && Object.getOwnPropertyNames(l).forEach(function(c) {
                        this.append(c, l[c])
                    }, this)
                }

                function consumed(l) {
                    if (l.bodyUsed) return Promise.reject(TypeError("Already read"));
                    l.bodyUsed = !0
                }

                function fileReaderReady(l) {
                    return new Promise(function(c, x) {
                        l.onload = function() {
                            c(l.result)
                        }, l.onerror = function() {
                            x(l.error)
                        }
                    })
                }

                function readBlobAsArrayBuffer(l) {
                    var c = new FileReader,
                        x = fileReaderReady(c);
                    return c.readAsArrayBuffer(l), x
                }

                function bufferClone(l) {
                    if (l.slice) return l.slice(0);
                    var c = new Uint8Array(l.byteLength);
                    return c.set(new Uint8Array(l)), c.buffer
                }

                function Body() {
                    return this.bodyUsed = !1, this._initBody = function(l) {
                        if (this._bodyInit = l, l) {
                            if ("string" == typeof l) this._bodyText = l;
                            else if (c.blob && Blob.prototype.isPrototypeOf(l)) this._bodyBlob = l;
                            else if (c.formData && FormData.prototype.isPrototypeOf(l)) this._bodyFormData = l;
                            else if (c.searchParams && URLSearchParams.prototype.isPrototypeOf(l)) this._bodyText = l.toString();
                            else {
                                var x;
                                c.arrayBuffer && c.blob && (x = l) && DataView.prototype.isPrototypeOf(x) ? (this._bodyArrayBuffer = bufferClone(l.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(l) || U(l)) ? this._bodyArrayBuffer = bufferClone(l) : this._bodyText = l = Object.prototype.toString.call(l)
                            }
                        } else this._bodyText = "";
                        !this.headers.get("content-type") && ("string" == typeof l ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : c.searchParams && URLSearchParams.prototype.isPrototypeOf(l) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, c.blob && (this.blob = function() {
                        var l = consumed(this);
                        if (l) return l;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (!this._bodyFormData) return Promise.resolve(new Blob([this._bodyText]));
                        throw Error("could not read FormData body as blob")
                    }, this.arrayBuffer = function() {
                        return this._bodyArrayBuffer ? consumed(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(readBlobAsArrayBuffer)
                    }), this.text = function() {
                        var l, c, x, N = consumed(this);
                        if (N) return N;
                        if (this._bodyBlob) return l = this._bodyBlob, x = fileReaderReady(c = new FileReader), c.readAsText(l), x;
                        if (this._bodyArrayBuffer) return Promise.resolve(function(l) {
                            for (var c = new Uint8Array(l), x = Array(c.length), N = 0; N < c.length; N++) x[N] = String.fromCharCode(c[N]);
                            return x.join("")
                        }(this._bodyArrayBuffer));
                        if (!this._bodyFormData) return Promise.resolve(this._bodyText);
                        throw Error("could not read FormData body as text")
                    }, c.formData && (this.formData = function() {
                        return this.text().then(decode)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                Headers.prototype.append = function(l, c) {
                    l = normalizeName(l), c = normalizeValue(c);
                    var x = this.map[l];
                    this.map[l] = x ? x + ", " + c : c
                }, Headers.prototype.delete = function(l) {
                    delete this.map[normalizeName(l)]
                }, Headers.prototype.get = function(l) {
                    return l = normalizeName(l), this.has(l) ? this.map[l] : null
                }, Headers.prototype.has = function(l) {
                    return this.map.hasOwnProperty(normalizeName(l))
                }, Headers.prototype.set = function(l, c) {
                    this.map[normalizeName(l)] = normalizeValue(c)
                }, Headers.prototype.forEach = function(l, c) {
                    for (var x in this.map) this.map.hasOwnProperty(x) && l.call(c, this.map[x], x, this)
                }, Headers.prototype.keys = function() {
                    var l = [];
                    return this.forEach(function(c, x) {
                        l.push(x)
                    }), iteratorFor(l)
                }, Headers.prototype.values = function() {
                    var l = [];
                    return this.forEach(function(c) {
                        l.push(c)
                    }), iteratorFor(l)
                }, Headers.prototype.entries = function() {
                    var l = [];
                    return this.forEach(function(c, x) {
                        l.push([x, c])
                    }), iteratorFor(l)
                }, c.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
                var Z = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                function Request(l, c) {
                    var x, N, U = (c = c || {}).body;
                    if (l instanceof Request) {
                        if (l.bodyUsed) throw TypeError("Already read");
                        this.url = l.url, this.credentials = l.credentials, c.headers || (this.headers = new Headers(l.headers)), this.method = l.method, this.mode = l.mode, this.signal = l.signal, U || null == l._bodyInit || (U = l._bodyInit, l.bodyUsed = !0)
                    } else this.url = String(l);
                    if (this.credentials = c.credentials || this.credentials || "same-origin", (c.headers || !this.headers) && (this.headers = new Headers(c.headers)), this.method = (N = (x = c.method || this.method || "GET").toUpperCase(), Z.indexOf(N) > -1 ? N : x), this.mode = c.mode || this.mode || null, this.signal = c.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && U) throw TypeError("Body not allowed for GET or HEAD requests");
                    this._initBody(U)
                }

                function decode(l) {
                    var c = new FormData;
                    return l.trim().split("&").forEach(function(l) {
                        if (l) {
                            var x = l.split("="),
                                N = x.shift().replace(/\+/g, " "),
                                U = x.join("=").replace(/\+/g, " ");
                            c.append(decodeURIComponent(N), decodeURIComponent(U))
                        }
                    }), c
                }

                function Response(l, c) {
                    c || (c = {}), this.type = "default", this.status = void 0 === c.status ? 200 : c.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in c ? c.statusText : "OK", this.headers = new Headers(c.headers), this.url = c.url || "", this._initBody(l)
                }
                Request.prototype.clone = function() {
                    return new Request(this, {
                        body: this._bodyInit
                    })
                }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function() {
                    return new Response(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new Headers(this.headers),
                        url: this.url
                    })
                }, Response.error = function() {
                    var l = new Response(null, {
                        status: 0,
                        statusText: ""
                    });
                    return l.type = "error", l
                };
                var $ = [301, 302, 303, 307, 308];
                Response.redirect = function(l, c) {
                    if (-1 === $.indexOf(c)) throw RangeError("Invalid status code");
                    return new Response(null, {
                        status: c,
                        headers: {
                            location: l
                        }
                    })
                }, l.DOMException = N.DOMException;
                try {
                    new l.DOMException
                } catch (c) {
                    l.DOMException = function(l, c) {
                        this.message = l, this.name = c;
                        var x = Error(l);
                        this.stack = x.stack
                    }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException
                }

                function fetch(x, N) {
                    return new Promise(function(U, Z) {
                        var $ = new Request(x, N);
                        if ($.signal && $.signal.aborted) return Z(new l.DOMException("Aborted", "AbortError"));
                        var Y = new XMLHttpRequest;

                        function abortXhr() {
                            Y.abort()
                        }
                        Y.onload = function() {
                            var l, c, x = {
                                status: Y.status,
                                statusText: Y.statusText,
                                headers: (l = Y.getAllResponseHeaders() || "", c = new Headers, l.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(l) {
                                    var x = l.split(":"),
                                        N = x.shift().trim();
                                    if (N) {
                                        var U = x.join(":").trim();
                                        c.append(N, U)
                                    }
                                }), c)
                            };
                            x.url = "responseURL" in Y ? Y.responseURL : x.headers.get("X-Request-URL");
                            var N = "response" in Y ? Y.response : Y.responseText;
                            U(new Response(N, x))
                        }, Y.onerror = function() {
                            Z(TypeError("Network request failed"))
                        }, Y.ontimeout = function() {
                            Z(TypeError("Network request failed"))
                        }, Y.onabort = function() {
                            Z(new l.DOMException("Aborted", "AbortError"))
                        }, Y.open($.method, $.url, !0), "include" === $.credentials ? Y.withCredentials = !0 : "omit" === $.credentials && (Y.withCredentials = !1), "responseType" in Y && c.blob && (Y.responseType = "blob"), $.headers.forEach(function(l, c) {
                            Y.setRequestHeader(c, l)
                        }), $.signal && ($.signal.addEventListener("abort", abortXhr), Y.onreadystatechange = function() {
                            4 === Y.readyState && $.signal.removeEventListener("abort", abortXhr)
                        }), Y.send(void 0 === $._bodyInit ? null : $._bodyInit)
                    })
                }
                fetch.polyfill = !0, N.fetch || (N.fetch = fetch, N.Headers = Headers, N.Request = Request, N.Response = Response), l.Headers = Headers, l.Request = Request, l.Response = Response, l.fetch = fetch, Object.defineProperty(l, "__esModule", {
                    value: !0
                })
            })({}), N.fetch.ponyfill = !0, delete N.fetch.polyfill, (c = N.fetch).default = N.fetch, c.fetch = N.fetch, c.Headers = N.Headers, c.Request = N.Request, c.Response = N.Response, l.exports = c
        },
        58005: function(l) {
            "use strict";
            var c = "%[a-f0-9]{2}",
                x = RegExp("(" + c + ")|([^%]+?)", "gi"),
                N = RegExp("(" + c + ")+", "gi");
            l.exports = function(l) {
                if ("string" != typeof l) throw TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof l + "`");
                try {
                    return l = l.replace(/\+/g, " "), decodeURIComponent(l)
                } catch (c) {
                    return function(l) {
                        for (var c = {
                                "%FE%FF": "",
                                "%FF%FE": ""
                            }, U = N.exec(l); U;) {
                            try {
                                c[U[0]] = decodeURIComponent(U[0])
                            } catch (l) {
                                var Z = function(l) {
                                    try {
                                        return decodeURIComponent(l)
                                    } catch (U) {
                                        for (var c = l.match(x) || [], N = 1; N < c.length; N++) c = (l = (function decodeComponents(l, c) {
                                            try {
                                                return [decodeURIComponent(l.join(""))]
                                            } catch (l) {}
                                            if (1 === l.length) return l;
                                            c = c || 1;
                                            var x = l.slice(0, c),
                                                N = l.slice(c);
                                            return Array.prototype.concat.call([], decodeComponents(x), decodeComponents(N))
                                        })(c, N).join("")).match(x) || [];
                                        return l
                                    }
                                }(U[0]);
                                Z !== U[0] && (c[U[0]] = Z)
                            }
                            U = N.exec(l)
                        }
                        c["%C2"] = "";
                        for (var $ = Object.keys(c), Y = 0; Y < $.length; Y++) {
                            var q = $[Y];
                            l = l.replace(RegExp(q, "g"), c[q])
                        }
                        return l
                    }(l)
                }
            }
        },
        69954: function(l, c, x) {
            "use strict";
            x.d(c, {
                qY: function() {
                    return detect
                }
            });
            var N = x(25566),
                __spreadArray = function(l, c, x) {
                    if (x || 2 == arguments.length)
                        for (var N, U = 0, Z = c.length; U < Z; U++) !N && U in c || (N || (N = Array.prototype.slice.call(c, 0, U)), N[U] = c[U]);
                    return l.concat(N || Array.prototype.slice.call(c))
                },
                BrowserInfo = function(l, c, x) {
                    this.name = l, this.version = c, this.os = x, this.type = "browser"
                },
                NodeInfo = function(l) {
                    this.version = l, this.type = "node", this.name = "node", this.os = N.platform
                },
                SearchBotDeviceInfo = function(l, c, x, N) {
                    this.name = l, this.version = c, this.os = x, this.bot = N, this.type = "bot-device"
                },
                BotInfo = function() {
                    this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
                },
                ReactNativeInfo = function() {
                    this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
                },
                U = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
                Z = [
                    ["aol", /AOLShield\/([0-9\._]+)/],
                    ["edge", /Edge\/([0-9\._]+)/],
                    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
                    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
                    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
                    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
                    ["silk", /\bSilk\/([0-9._-]+)\b/],
                    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
                    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
                    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
                    ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
                    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
                    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
                    ["fxios", /FxiOS\/([0-9\.]+)/],
                    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
                    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
                    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
                    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
                    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
                    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
                    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
                    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
                    ["ie", /MSIE\s(7\.0)/],
                    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
                    ["android", /Android\s([0-9\.]+)/],
                    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
                    ["safari", /Version\/([0-9\._]+).*Safari/],
                    ["facebook", /FB[AS]V\/([0-9\.]+)/],
                    ["instagram", /Instagram\s([0-9\.]+)/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
                    ["curl", /^curl\/([0-9\.]+)$/],
                    ["searchbot", /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]
                ],
                $ = [
                    ["iOS", /iP(hone|od|ad)/],
                    ["Android OS", /Android/],
                    ["BlackBerry OS", /BlackBerry|BB10/],
                    ["Windows Mobile", /IEMobile/],
                    ["Amazon OS", /Kindle/],
                    ["Windows 3.11", /Win16/],
                    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
                    ["Windows 98", /(Windows 98)|(Win98)/],
                    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
                    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
                    ["Windows Server 2003", /(Windows NT 5.2)/],
                    ["Windows Vista", /(Windows NT 6.0)/],
                    ["Windows 7", /(Windows NT 6.1)/],
                    ["Windows 8", /(Windows NT 6.2)/],
                    ["Windows 8.1", /(Windows NT 6.3)/],
                    ["Windows 10", /(Windows NT 10.0)/],
                    ["Windows ME", /Windows ME/],
                    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
                    ["Open BSD", /OpenBSD/],
                    ["Sun OS", /SunOS/],
                    ["Chrome OS", /CrOS/],
                    ["Linux", /(Linux)|(X11)/],
                    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
                    ["QNX", /QNX/],
                    ["BeOS", /BeOS/],
                    ["OS/2", /OS\/2/]
                ];

            function detect(l) {
                return l ? parseUserAgent(l) : "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product ? new ReactNativeInfo : "undefined" != typeof navigator ? parseUserAgent(navigator.userAgent) : void 0 !== N && N.version ? new NodeInfo(N.version.slice(1)) : null
            }

            function parseUserAgent(l) {
                var c = "" !== l && Z.reduce(function(c, x) {
                    var N = x[0],
                        U = x[1];
                    if (c) return c;
                    var Z = U.exec(l);
                    return !!Z && [N, Z]
                }, !1);
                if (!c) return null;
                var x = c[0],
                    N = c[1];
                if ("searchbot" === x) return new BotInfo;
                var Y = N[1] && N[1].split(".").join("_").split("_").slice(0, 3);
                Y ? Y.length < 3 && (Y = __spreadArray(__spreadArray([], Y, !0), function(l) {
                    for (var c = [], x = 0; x < l; x++) c.push("0");
                    return c
                }(3 - Y.length), !0)) : Y = [];
                var q = Y.join("."),
                    J = function(l) {
                        for (var c = 0, x = $.length; c < x; c++) {
                            var N = $[c],
                                U = N[0];
                            if (N[1].exec(l)) return U
                        }
                        return null
                    }(l),
                    X = U.exec(l);
                return X && X[1] ? new SearchBotDeviceInfo(x, q, J, X[1]) : new BrowserInfo(x, q, J)
            }
        },
        78343: function(l) {
            "use strict";
            var c = {
                single_source_shortest_paths: function(l, x, N) {
                    var U, Z, $, Y, q, J, X, en = {},
                        er = {};
                    er[x] = 0;
                    var ea = c.PriorityQueue.make();
                    for (ea.push(x, 0); !ea.empty();)
                        for ($ in Z = (U = ea.pop()).value, Y = U.cost, q = l[Z] || {}) q.hasOwnProperty($) && (J = Y + q[$], X = er[$], (void 0 === er[$] || X > J) && (er[$] = J, ea.push($, J), en[$] = Z));
                    if (void 0 !== N && void 0 === er[N]) throw Error(["Could not find a path from ", x, " to ", N, "."].join(""));
                    return en
                },
                extract_shortest_path_from_predecessor_list: function(l, c) {
                    for (var x = [], N = c; N;) x.push(N), l[N], N = l[N];
                    return x.reverse(), x
                },
                find_path: function(l, x, N) {
                    var U = c.single_source_shortest_paths(l, x, N);
                    return c.extract_shortest_path_from_predecessor_list(U, N)
                },
                PriorityQueue: {
                    make: function(l) {
                        var x, N = c.PriorityQueue,
                            U = {};
                        for (x in l = l || {}, N) N.hasOwnProperty(x) && (U[x] = N[x]);
                        return U.queue = [], U.sorter = l.sorter || N.default_sorter, U
                    },
                    default_sorter: function(l, c) {
                        return l.cost - c.cost
                    },
                    push: function(l, c) {
                        this.queue.push({
                            value: l,
                            cost: c
                        }), this.queue.sort(this.sorter)
                    },
                    pop: function() {
                        return this.queue.shift()
                    },
                    empty: function() {
                        return 0 === this.queue.length
                    }
                }
            };
            l.exports = c
        },
        53216: function(l) {
            "use strict";
            l.exports = function(l) {
                for (var c = [], x = l.length, N = 0; N < x; N++) {
                    var U = l.charCodeAt(N);
                    if (U >= 55296 && U <= 56319 && x > N + 1) {
                        var Z = l.charCodeAt(N + 1);
                        Z >= 56320 && Z <= 57343 && (U = (U - 55296) * 1024 + Z - 56320 + 65536, N += 1)
                    }
                    if (U < 128) {
                        c.push(U);
                        continue
                    }
                    if (U < 2048) {
                        c.push(U >> 6 | 192), c.push(63 & U | 128);
                        continue
                    }
                    if (U < 55296 || U >= 57344 && U < 65536) {
                        c.push(U >> 12 | 224), c.push(U >> 6 & 63 | 128), c.push(63 & U | 128);
                        continue
                    }
                    if (U >= 65536 && U <= 1114111) {
                        c.push(U >> 18 | 240), c.push(U >> 12 & 63 | 128), c.push(U >> 6 & 63 | 128), c.push(63 & U | 128);
                        continue
                    }
                    c.push(239, 191, 189)
                }
                return new Uint8Array(c).buffer
            }
        },
        6691: function(l, c, x) {
            "use strict";
            var N = this && this.__createBinding || (Object.create ? function(l, c, x, N) {
                    void 0 === N && (N = x), Object.defineProperty(l, N, {
                        enumerable: !0,
                        get: function() {
                            return c[x]
                        }
                    })
                } : function(l, c, x, N) {
                    void 0 === N && (N = x), l[N] = c[x]
                }),
                U = this && this.__setModuleDefault || (Object.create ? function(l, c) {
                    Object.defineProperty(l, "default", {
                        enumerable: !0,
                        value: c
                    })
                } : function(l, c) {
                    l.default = c
                }),
                Z = this && this.__importStar || function(l) {
                    if (l && l.__esModule) return l;
                    var c = {};
                    if (null != l)
                        for (var x in l) "default" !== x && Object.prototype.hasOwnProperty.call(l, x) && N(c, l, x);
                    return U(c, l), c
                };
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.formatBytes32String = c.Utf8ErrorFuncs = c.toUtf8String = c.toUtf8CodePoints = c.toUtf8Bytes = c._toEscapedUtf8String = c.nameprep = c.hexDataSlice = c.hexDataLength = c.hexZeroPad = c.hexValue = c.hexStripZeros = c.hexConcat = c.isHexString = c.hexlify = c.base64 = c.base58 = c.TransactionDescription = c.LogDescription = c.Interface = c.SigningKey = c.HDNode = c.defaultPath = c.isBytesLike = c.isBytes = c.zeroPad = c.stripZeros = c.concat = c.arrayify = c.shallowCopy = c.resolveProperties = c.getStatic = c.defineReadOnly = c.deepCopy = c.checkProperties = c.poll = c.fetchJson = c._fetchData = c.RLP = c.Logger = c.checkResultErrors = c.FormatTypes = c.ParamType = c.FunctionFragment = c.EventFragment = c.ErrorFragment = c.ConstructorFragment = c.Fragment = c.defaultAbiCoder = c.AbiCoder = void 0, c.Indexed = c.Utf8ErrorReason = c.UnicodeNormalizationForm = c.SupportedAlgorithm = c.mnemonicToSeed = c.isValidMnemonic = c.entropyToMnemonic = c.mnemonicToEntropy = c.getAccountPath = c.verifyTypedData = c.verifyMessage = c.recoverPublicKey = c.computePublicKey = c.recoverAddress = c.computeAddress = c.getJsonWalletAddress = c.TransactionTypes = c.serializeTransaction = c.parseTransaction = c.accessListify = c.joinSignature = c.splitSignature = c.soliditySha256 = c.solidityKeccak256 = c.solidityPack = c.shuffled = c.randomBytes = c.sha512 = c.sha256 = c.ripemd160 = c.keccak256 = c.computeHmac = c.commify = c.parseUnits = c.formatUnits = c.parseEther = c.formatEther = c.isAddress = c.getCreate2Address = c.getContractAddress = c.getIcapAddress = c.getAddress = c._TypedDataEncoder = c.id = c.isValidName = c.namehash = c.hashMessage = c.dnsEncode = c.parseBytes32String = void 0;
            var $ = x(39219);
            Object.defineProperty(c, "AbiCoder", {
                enumerable: !0,
                get: function() {
                    return $.AbiCoder
                }
            }), Object.defineProperty(c, "checkResultErrors", {
                enumerable: !0,
                get: function() {
                    return $.checkResultErrors
                }
            }), Object.defineProperty(c, "ConstructorFragment", {
                enumerable: !0,
                get: function() {
                    return $.ConstructorFragment
                }
            }), Object.defineProperty(c, "defaultAbiCoder", {
                enumerable: !0,
                get: function() {
                    return $.defaultAbiCoder
                }
            }), Object.defineProperty(c, "ErrorFragment", {
                enumerable: !0,
                get: function() {
                    return $.ErrorFragment
                }
            }), Object.defineProperty(c, "EventFragment", {
                enumerable: !0,
                get: function() {
                    return $.EventFragment
                }
            }), Object.defineProperty(c, "FormatTypes", {
                enumerable: !0,
                get: function() {
                    return $.FormatTypes
                }
            }), Object.defineProperty(c, "Fragment", {
                enumerable: !0,
                get: function() {
                    return $.Fragment
                }
            }), Object.defineProperty(c, "FunctionFragment", {
                enumerable: !0,
                get: function() {
                    return $.FunctionFragment
                }
            }), Object.defineProperty(c, "Indexed", {
                enumerable: !0,
                get: function() {
                    return $.Indexed
                }
            }), Object.defineProperty(c, "Interface", {
                enumerable: !0,
                get: function() {
                    return $.Interface
                }
            }), Object.defineProperty(c, "LogDescription", {
                enumerable: !0,
                get: function() {
                    return $.LogDescription
                }
            }), Object.defineProperty(c, "ParamType", {
                enumerable: !0,
                get: function() {
                    return $.ParamType
                }
            }), Object.defineProperty(c, "TransactionDescription", {
                enumerable: !0,
                get: function() {
                    return $.TransactionDescription
                }
            });
            var Y = x(18994);
            Object.defineProperty(c, "getAddress", {
                enumerable: !0,
                get: function() {
                    return Y.getAddress
                }
            }), Object.defineProperty(c, "getCreate2Address", {
                enumerable: !0,
                get: function() {
                    return Y.getCreate2Address
                }
            }), Object.defineProperty(c, "getContractAddress", {
                enumerable: !0,
                get: function() {
                    return Y.getContractAddress
                }
            }), Object.defineProperty(c, "getIcapAddress", {
                enumerable: !0,
                get: function() {
                    return Y.getIcapAddress
                }
            }), Object.defineProperty(c, "isAddress", {
                enumerable: !0,
                get: function() {
                    return Y.isAddress
                }
            });
            var q = Z(x(30101));
            c.base64 = q;
            var J = x(63221);
            Object.defineProperty(c, "base58", {
                enumerable: !0,
                get: function() {
                    return J.Base58
                }
            });
            var X = x(57273);
            Object.defineProperty(c, "arrayify", {
                enumerable: !0,
                get: function() {
                    return X.arrayify
                }
            }), Object.defineProperty(c, "concat", {
                enumerable: !0,
                get: function() {
                    return X.concat
                }
            }), Object.defineProperty(c, "hexConcat", {
                enumerable: !0,
                get: function() {
                    return X.hexConcat
                }
            }), Object.defineProperty(c, "hexDataSlice", {
                enumerable: !0,
                get: function() {
                    return X.hexDataSlice
                }
            }), Object.defineProperty(c, "hexDataLength", {
                enumerable: !0,
                get: function() {
                    return X.hexDataLength
                }
            }), Object.defineProperty(c, "hexlify", {
                enumerable: !0,
                get: function() {
                    return X.hexlify
                }
            }), Object.defineProperty(c, "hexStripZeros", {
                enumerable: !0,
                get: function() {
                    return X.hexStripZeros
                }
            }), Object.defineProperty(c, "hexValue", {
                enumerable: !0,
                get: function() {
                    return X.hexValue
                }
            }), Object.defineProperty(c, "hexZeroPad", {
                enumerable: !0,
                get: function() {
                    return X.hexZeroPad
                }
            }), Object.defineProperty(c, "isBytes", {
                enumerable: !0,
                get: function() {
                    return X.isBytes
                }
            }), Object.defineProperty(c, "isBytesLike", {
                enumerable: !0,
                get: function() {
                    return X.isBytesLike
                }
            }), Object.defineProperty(c, "isHexString", {
                enumerable: !0,
                get: function() {
                    return X.isHexString
                }
            }), Object.defineProperty(c, "joinSignature", {
                enumerable: !0,
                get: function() {
                    return X.joinSignature
                }
            }), Object.defineProperty(c, "zeroPad", {
                enumerable: !0,
                get: function() {
                    return X.zeroPad
                }
            }), Object.defineProperty(c, "splitSignature", {
                enumerable: !0,
                get: function() {
                    return X.splitSignature
                }
            }), Object.defineProperty(c, "stripZeros", {
                enumerable: !0,
                get: function() {
                    return X.stripZeros
                }
            });
            var en = x(89613);
            Object.defineProperty(c, "_TypedDataEncoder", {
                enumerable: !0,
                get: function() {
                    return en._TypedDataEncoder
                }
            }), Object.defineProperty(c, "dnsEncode", {
                enumerable: !0,
                get: function() {
                    return en.dnsEncode
                }
            }), Object.defineProperty(c, "hashMessage", {
                enumerable: !0,
                get: function() {
                    return en.hashMessage
                }
            }), Object.defineProperty(c, "id", {
                enumerable: !0,
                get: function() {
                    return en.id
                }
            }), Object.defineProperty(c, "isValidName", {
                enumerable: !0,
                get: function() {
                    return en.isValidName
                }
            }), Object.defineProperty(c, "namehash", {
                enumerable: !0,
                get: function() {
                    return en.namehash
                }
            });
            var er = x(30686);
            Object.defineProperty(c, "defaultPath", {
                enumerable: !0,
                get: function() {
                    return er.defaultPath
                }
            }), Object.defineProperty(c, "entropyToMnemonic", {
                enumerable: !0,
                get: function() {
                    return er.entropyToMnemonic
                }
            }), Object.defineProperty(c, "getAccountPath", {
                enumerable: !0,
                get: function() {
                    return er.getAccountPath
                }
            }), Object.defineProperty(c, "HDNode", {
                enumerable: !0,
                get: function() {
                    return er.HDNode
                }
            }), Object.defineProperty(c, "isValidMnemonic", {
                enumerable: !0,
                get: function() {
                    return er.isValidMnemonic
                }
            }), Object.defineProperty(c, "mnemonicToEntropy", {
                enumerable: !0,
                get: function() {
                    return er.mnemonicToEntropy
                }
            }), Object.defineProperty(c, "mnemonicToSeed", {
                enumerable: !0,
                get: function() {
                    return er.mnemonicToSeed
                }
            });
            var ea = x(80948);
            Object.defineProperty(c, "getJsonWalletAddress", {
                enumerable: !0,
                get: function() {
                    return ea.getJsonWalletAddress
                }
            });
            var eo = x(14184);
            Object.defineProperty(c, "keccak256", {
                enumerable: !0,
                get: function() {
                    return eo.keccak256
                }
            });
            var el = x(36288);
            Object.defineProperty(c, "Logger", {
                enumerable: !0,
                get: function() {
                    return el.Logger
                }
            });
            var ec = x(85766);
            Object.defineProperty(c, "computeHmac", {
                enumerable: !0,
                get: function() {
                    return ec.computeHmac
                }
            }), Object.defineProperty(c, "ripemd160", {
                enumerable: !0,
                get: function() {
                    return ec.ripemd160
                }
            }), Object.defineProperty(c, "sha256", {
                enumerable: !0,
                get: function() {
                    return ec.sha256
                }
            }), Object.defineProperty(c, "sha512", {
                enumerable: !0,
                get: function() {
                    return ec.sha512
                }
            });
            var eu = x(47293);
            Object.defineProperty(c, "solidityKeccak256", {
                enumerable: !0,
                get: function() {
                    return eu.keccak256
                }
            }), Object.defineProperty(c, "solidityPack", {
                enumerable: !0,
                get: function() {
                    return eu.pack
                }
            }), Object.defineProperty(c, "soliditySha256", {
                enumerable: !0,
                get: function() {
                    return eu.sha256
                }
            });
            var ed = x(64791);
            Object.defineProperty(c, "randomBytes", {
                enumerable: !0,
                get: function() {
                    return ed.randomBytes
                }
            }), Object.defineProperty(c, "shuffled", {
                enumerable: !0,
                get: function() {
                    return ed.shuffled
                }
            });
            var ep = x(17213);
            Object.defineProperty(c, "checkProperties", {
                enumerable: !0,
                get: function() {
                    return ep.checkProperties
                }
            }), Object.defineProperty(c, "deepCopy", {
                enumerable: !0,
                get: function() {
                    return ep.deepCopy
                }
            }), Object.defineProperty(c, "defineReadOnly", {
                enumerable: !0,
                get: function() {
                    return ep.defineReadOnly
                }
            }), Object.defineProperty(c, "getStatic", {
                enumerable: !0,
                get: function() {
                    return ep.getStatic
                }
            }), Object.defineProperty(c, "resolveProperties", {
                enumerable: !0,
                get: function() {
                    return ep.resolveProperties
                }
            }), Object.defineProperty(c, "shallowCopy", {
                enumerable: !0,
                get: function() {
                    return ep.shallowCopy
                }
            });
            var eh = Z(x(7054));
            c.RLP = eh;
            var ey = x(74731);
            Object.defineProperty(c, "computePublicKey", {
                enumerable: !0,
                get: function() {
                    return ey.computePublicKey
                }
            }), Object.defineProperty(c, "recoverPublicKey", {
                enumerable: !0,
                get: function() {
                    return ey.recoverPublicKey
                }
            }), Object.defineProperty(c, "SigningKey", {
                enumerable: !0,
                get: function() {
                    return ey.SigningKey
                }
            });
            var ef = x(10914);
            Object.defineProperty(c, "formatBytes32String", {
                enumerable: !0,
                get: function() {
                    return ef.formatBytes32String
                }
            }), Object.defineProperty(c, "nameprep", {
                enumerable: !0,
                get: function() {
                    return ef.nameprep
                }
            }), Object.defineProperty(c, "parseBytes32String", {
                enumerable: !0,
                get: function() {
                    return ef.parseBytes32String
                }
            }), Object.defineProperty(c, "_toEscapedUtf8String", {
                enumerable: !0,
                get: function() {
                    return ef._toEscapedUtf8String
                }
            }), Object.defineProperty(c, "toUtf8Bytes", {
                enumerable: !0,
                get: function() {
                    return ef.toUtf8Bytes
                }
            }), Object.defineProperty(c, "toUtf8CodePoints", {
                enumerable: !0,
                get: function() {
                    return ef.toUtf8CodePoints
                }
            }), Object.defineProperty(c, "toUtf8String", {
                enumerable: !0,
                get: function() {
                    return ef.toUtf8String
                }
            }), Object.defineProperty(c, "Utf8ErrorFuncs", {
                enumerable: !0,
                get: function() {
                    return ef.Utf8ErrorFuncs
                }
            });
            var em = x(12060);
            Object.defineProperty(c, "accessListify", {
                enumerable: !0,
                get: function() {
                    return em.accessListify
                }
            }), Object.defineProperty(c, "computeAddress", {
                enumerable: !0,
                get: function() {
                    return em.computeAddress
                }
            }), Object.defineProperty(c, "parseTransaction", {
                enumerable: !0,
                get: function() {
                    return em.parse
                }
            }), Object.defineProperty(c, "recoverAddress", {
                enumerable: !0,
                get: function() {
                    return em.recoverAddress
                }
            }), Object.defineProperty(c, "serializeTransaction", {
                enumerable: !0,
                get: function() {
                    return em.serialize
                }
            }), Object.defineProperty(c, "TransactionTypes", {
                enumerable: !0,
                get: function() {
                    return em.TransactionTypes
                }
            });
            var eg = x(73760);
            Object.defineProperty(c, "commify", {
                enumerable: !0,
                get: function() {
                    return eg.commify
                }
            }), Object.defineProperty(c, "formatEther", {
                enumerable: !0,
                get: function() {
                    return eg.formatEther
                }
            }), Object.defineProperty(c, "parseEther", {
                enumerable: !0,
                get: function() {
                    return eg.parseEther
                }
            }), Object.defineProperty(c, "formatUnits", {
                enumerable: !0,
                get: function() {
                    return eg.formatUnits
                }
            }), Object.defineProperty(c, "parseUnits", {
                enumerable: !0,
                get: function() {
                    return eg.parseUnits
                }
            });
            var eb = x(61678);
            Object.defineProperty(c, "verifyMessage", {
                enumerable: !0,
                get: function() {
                    return eb.verifyMessage
                }
            }), Object.defineProperty(c, "verifyTypedData", {
                enumerable: !0,
                get: function() {
                    return eb.verifyTypedData
                }
            });
            var ev = x(39318);
            Object.defineProperty(c, "_fetchData", {
                enumerable: !0,
                get: function() {
                    return ev._fetchData
                }
            }), Object.defineProperty(c, "fetchJson", {
                enumerable: !0,
                get: function() {
                    return ev.fetchJson
                }
            }), Object.defineProperty(c, "poll", {
                enumerable: !0,
                get: function() {
                    return ev.poll
                }
            });
            var ew = x(85766);
            Object.defineProperty(c, "SupportedAlgorithm", {
                enumerable: !0,
                get: function() {
                    return ew.SupportedAlgorithm
                }
            });
            var eT = x(10914);
            Object.defineProperty(c, "UnicodeNormalizationForm", {
                enumerable: !0,
                get: function() {
                    return eT.UnicodeNormalizationForm
                }
            }), Object.defineProperty(c, "Utf8ErrorReason", {
                enumerable: !0,
                get: function() {
                    return eT.Utf8ErrorReason
                }
            })
        },
        28729: function(l) {
            "use strict";
            var c = Object.prototype.hasOwnProperty,
                x = "~";

            function Events() {}

            function EE(l, c, x) {
                this.fn = l, this.context = c, this.once = x || !1
            }

            function addListener(l, c, N, U, Z) {
                if ("function" != typeof N) throw TypeError("The listener must be a function");
                var $ = new EE(N, U || l, Z),
                    Y = x ? x + c : c;
                return l._events[Y] ? l._events[Y].fn ? l._events[Y] = [l._events[Y], $] : l._events[Y].push($) : (l._events[Y] = $, l._eventsCount++), l
            }

            function clearEvent(l, c) {
                0 == --l._eventsCount ? l._events = new Events : delete l._events[c]
            }

            function EventEmitter() {
                this._events = new Events, this._eventsCount = 0
            }
            Object.create && (Events.prototype = Object.create(null), new Events().__proto__ || (x = !1)), EventEmitter.prototype.eventNames = function() {
                var l, N, U = [];
                if (0 === this._eventsCount) return U;
                for (N in l = this._events) c.call(l, N) && U.push(x ? N.slice(1) : N);
                return Object.getOwnPropertySymbols ? U.concat(Object.getOwnPropertySymbols(l)) : U
            }, EventEmitter.prototype.listeners = function(l) {
                var c = x ? x + l : l,
                    N = this._events[c];
                if (!N) return [];
                if (N.fn) return [N.fn];
                for (var U = 0, Z = N.length, $ = Array(Z); U < Z; U++) $[U] = N[U].fn;
                return $
            }, EventEmitter.prototype.listenerCount = function(l) {
                var c = x ? x + l : l,
                    N = this._events[c];
                return N ? N.fn ? 1 : N.length : 0
            }, EventEmitter.prototype.emit = function(l, c, N, U, Z, $) {
                var Y = x ? x + l : l;
                if (!this._events[Y]) return !1;
                var q, J, X = this._events[Y],
                    en = arguments.length;
                if (X.fn) {
                    switch (X.once && this.removeListener(l, X.fn, void 0, !0), en) {
                        case 1:
                            return X.fn.call(X.context), !0;
                        case 2:
                            return X.fn.call(X.context, c), !0;
                        case 3:
                            return X.fn.call(X.context, c, N), !0;
                        case 4:
                            return X.fn.call(X.context, c, N, U), !0;
                        case 5:
                            return X.fn.call(X.context, c, N, U, Z), !0;
                        case 6:
                            return X.fn.call(X.context, c, N, U, Z, $), !0
                    }
                    for (J = 1, q = Array(en - 1); J < en; J++) q[J - 1] = arguments[J];
                    X.fn.apply(X.context, q)
                } else {
                    var er, ea = X.length;
                    for (J = 0; J < ea; J++) switch (X[J].once && this.removeListener(l, X[J].fn, void 0, !0), en) {
                        case 1:
                            X[J].fn.call(X[J].context);
                            break;
                        case 2:
                            X[J].fn.call(X[J].context, c);
                            break;
                        case 3:
                            X[J].fn.call(X[J].context, c, N);
                            break;
                        case 4:
                            X[J].fn.call(X[J].context, c, N, U);
                            break;
                        default:
                            if (!q)
                                for (er = 1, q = Array(en - 1); er < en; er++) q[er - 1] = arguments[er];
                            X[J].fn.apply(X[J].context, q)
                    }
                }
                return !0
            }, EventEmitter.prototype.on = function(l, c, x) {
                return addListener(this, l, c, x, !1)
            }, EventEmitter.prototype.once = function(l, c, x) {
                return addListener(this, l, c, x, !0)
            }, EventEmitter.prototype.removeListener = function(l, c, N, U) {
                var Z = x ? x + l : l;
                if (!this._events[Z]) return this;
                if (!c) return clearEvent(this, Z), this;
                var $ = this._events[Z];
                if ($.fn) $.fn !== c || U && !$.once || N && $.context !== N || clearEvent(this, Z);
                else {
                    for (var Y = 0, q = [], J = $.length; Y < J; Y++)($[Y].fn !== c || U && !$[Y].once || N && $[Y].context !== N) && q.push($[Y]);
                    q.length ? this._events[Z] = 1 === q.length ? q[0] : q : clearEvent(this, Z)
                }
                return this
            }, EventEmitter.prototype.removeAllListeners = function(l) {
                var c;
                return l ? (c = x ? x + l : l, this._events[c] && clearEvent(this, c)) : (this._events = new Events, this._eventsCount = 0), this
            }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prefixed = x, EventEmitter.EventEmitter = EventEmitter, l.exports = EventEmitter
        },
        512: function(l) {
            "use strict";
            var c, x = "object" == typeof Reflect ? Reflect : null,
                N = x && "function" == typeof x.apply ? x.apply : function(l, c, x) {
                    return Function.prototype.apply.call(l, c, x)
                };
            c = x && "function" == typeof x.ownKeys ? x.ownKeys : Object.getOwnPropertySymbols ? function(l) {
                return Object.getOwnPropertyNames(l).concat(Object.getOwnPropertySymbols(l))
            } : function(l) {
                return Object.getOwnPropertyNames(l)
            };
            var U = Number.isNaN || function(l) {
                return l != l
            };

            function EventEmitter() {
                EventEmitter.init.call(this)
            }
            l.exports = EventEmitter, l.exports.once = function(l, c) {
                return new Promise(function(x, N) {
                    function errorListener(x) {
                        l.removeListener(c, resolver), N(x)
                    }

                    function resolver() {
                        "function" == typeof l.removeListener && l.removeListener("error", errorListener), x([].slice.call(arguments))
                    }
                    eventTargetAgnosticAddListener(l, c, resolver, {
                        once: !0
                    }), "error" !== c && "function" == typeof l.on && eventTargetAgnosticAddListener(l, "error", errorListener, {
                        once: !0
                    })
                })
            }, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._eventsCount = 0, EventEmitter.prototype._maxListeners = void 0;
            var Z = 10;

            function checkListener(l) {
                if ("function" != typeof l) throw TypeError('The "listener" argument must be of type Function. Received type ' + typeof l)
            }

            function _getMaxListeners(l) {
                return void 0 === l._maxListeners ? EventEmitter.defaultMaxListeners : l._maxListeners
            }

            function _addListener(l, c, x, N) {
                if (checkListener(x), void 0 === (Z = l._events) ? (Z = l._events = Object.create(null), l._eventsCount = 0) : (void 0 !== Z.newListener && (l.emit("newListener", c, x.listener ? x.listener : x), Z = l._events), $ = Z[c]), void 0 === $) $ = Z[c] = x, ++l._eventsCount;
                else if ("function" == typeof $ ? $ = Z[c] = N ? [x, $] : [$, x] : N ? $.unshift(x) : $.push(x), (U = _getMaxListeners(l)) > 0 && $.length > U && !$.warned) {
                    $.warned = !0;
                    var U, Z, $, Y = Error("Possible EventEmitter memory leak detected. " + $.length + " " + String(c) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    Y.name = "MaxListenersExceededWarning", Y.emitter = l, Y.type = c, Y.count = $.length, console && console.warn && console.warn(Y)
                }
                return l
            }

            function onceWrapper() {
                if (!this.fired) return (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 == arguments.length) ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }

            function _onceWrap(l, c, x) {
                var N = {
                        fired: !1,
                        wrapFn: void 0,
                        target: l,
                        type: c,
                        listener: x
                    },
                    U = onceWrapper.bind(N);
                return U.listener = x, N.wrapFn = U, U
            }

            function _listeners(l, c, x) {
                var N = l._events;
                if (void 0 === N) return [];
                var U = N[c];
                return void 0 === U ? [] : "function" == typeof U ? x ? [U.listener || U] : [U] : x ? function(l) {
                    for (var c = Array(l.length), x = 0; x < c.length; ++x) c[x] = l[x].listener || l[x];
                    return c
                }(U) : arrayClone(U, U.length)
            }

            function listenerCount(l) {
                var c = this._events;
                if (void 0 !== c) {
                    var x = c[l];
                    if ("function" == typeof x) return 1;
                    if (void 0 !== x) return x.length
                }
                return 0
            }

            function arrayClone(l, c) {
                for (var x = Array(c), N = 0; N < c; ++N) x[N] = l[N];
                return x
            }

            function eventTargetAgnosticAddListener(l, c, x, N) {
                if ("function" == typeof l.on) N.once ? l.once(c, x) : l.on(c, x);
                else if ("function" == typeof l.addEventListener) l.addEventListener(c, function wrapListener(U) {
                    N.once && l.removeEventListener(c, wrapListener), x(U)
                });
                else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof l)
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return Z
                },
                set: function(l) {
                    if ("number" != typeof l || l < 0 || U(l)) throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + l + ".");
                    Z = l
                }
            }), EventEmitter.init = function() {
                (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }, EventEmitter.prototype.setMaxListeners = function(l) {
                if ("number" != typeof l || l < 0 || U(l)) throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + l + ".");
                return this._maxListeners = l, this
            }, EventEmitter.prototype.getMaxListeners = function() {
                return _getMaxListeners(this)
            }, EventEmitter.prototype.emit = function(l) {
                for (var c = [], x = 1; x < arguments.length; x++) c.push(arguments[x]);
                var U = "error" === l,
                    Z = this._events;
                if (void 0 !== Z) U = U && void 0 === Z.error;
                else if (!U) return !1;
                if (U) {
                    if (c.length > 0 && ($ = c[0]), $ instanceof Error) throw $;
                    var $, Y = Error("Unhandled error." + ($ ? " (" + $.message + ")" : ""));
                    throw Y.context = $, Y
                }
                var q = Z[l];
                if (void 0 === q) return !1;
                if ("function" == typeof q) N(q, this, c);
                else
                    for (var J = q.length, X = arrayClone(q, J), x = 0; x < J; ++x) N(X[x], this, c);
                return !0
            }, EventEmitter.prototype.addListener = function(l, c) {
                return _addListener(this, l, c, !1)
            }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function(l, c) {
                return _addListener(this, l, c, !0)
            }, EventEmitter.prototype.once = function(l, c) {
                return checkListener(c), this.on(l, _onceWrap(this, l, c)), this
            }, EventEmitter.prototype.prependOnceListener = function(l, c) {
                return checkListener(c), this.prependListener(l, _onceWrap(this, l, c)), this
            }, EventEmitter.prototype.removeListener = function(l, c) {
                var x, N, U, Z, $;
                if (checkListener(c), void 0 === (N = this._events) || void 0 === (x = N[l])) return this;
                if (x === c || x.listener === c) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete N[l], N.removeListener && this.emit("removeListener", l, x.listener || c));
                else if ("function" != typeof x) {
                    for (U = -1, Z = x.length - 1; Z >= 0; Z--)
                        if (x[Z] === c || x[Z].listener === c) {
                            $ = x[Z].listener, U = Z;
                            break
                        }
                    if (U < 0) return this;
                    0 === U ? x.shift() : function(l, c) {
                        for (; c + 1 < l.length; c++) l[c] = l[c + 1];
                        l.pop()
                    }(x, U), 1 === x.length && (N[l] = x[0]), void 0 !== N.removeListener && this.emit("removeListener", l, $ || c)
                }
                return this
            }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.removeAllListeners = function(l) {
                var c, x, N;
                if (void 0 === (x = this._events)) return this;
                if (void 0 === x.removeListener) return 0 == arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== x[l] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete x[l]), this;
                if (0 == arguments.length) {
                    var U, Z = Object.keys(x);
                    for (N = 0; N < Z.length; ++N) "removeListener" !== (U = Z[N]) && this.removeAllListeners(U);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                }
                if ("function" == typeof(c = x[l])) this.removeListener(l, c);
                else if (void 0 !== c)
                    for (N = c.length - 1; N >= 0; N--) this.removeListener(l, c[N]);
                return this
            }, EventEmitter.prototype.listeners = function(l) {
                return _listeners(this, l, !0)
            }, EventEmitter.prototype.rawListeners = function(l) {
                return _listeners(this, l, !1)
            }, EventEmitter.listenerCount = function(l, c) {
                return "function" == typeof l.listenerCount ? l.listenerCount(c) : listenerCount.call(l, c)
            }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function() {
                return this._eventsCount > 0 ? c(this._events) : []
            }
        },
        21497: function(l) {
            function getStack(l) {
                return l.stack && l.name && l.message ? l.stack.substring(l.name.length + 3 + l.message.length).split("\n") : l.stack ? l.stack.split("\n") : void 0
            }
            l.exports = function(l, c) {
                if (!(l.stack && l.name && l.message)) return console.error(Error("stackless error")), l;
                var x, N, U = Error(c),
                    Z = (x = getStack(U).slice(1), N = getStack(l), x.filter(function(l) {
                        return !~N.indexOf(l)
                    })).join("\n");
                return U.__proto__ = l, U.stack = U.name + ": " + U.message + "\n" + Z + "\n  " + l.stack, U
            }
        },
        53010: function(l) {
            "use strict";
            l.exports = function equal(l, c) {
                if (l === c) return !0;
                if (l && c && "object" == typeof l && "object" == typeof c) {
                    if (l.constructor !== c.constructor) return !1;
                    if (Array.isArray(l)) {
                        if ((x = l.length) != c.length) return !1;
                        for (N = x; 0 != N--;)
                            if (!equal(l[N], c[N])) return !1;
                        return !0
                    }
                    if (l.constructor === RegExp) return l.source === c.source && l.flags === c.flags;
                    if (l.valueOf !== Object.prototype.valueOf) return l.valueOf() === c.valueOf();
                    if (l.toString !== Object.prototype.toString) return l.toString() === c.toString();
                    if ((x = (U = Object.keys(l)).length) !== Object.keys(c).length) return !1;
                    for (N = x; 0 != N--;)
                        if (!Object.prototype.hasOwnProperty.call(c, U[N])) return !1;
                    for (N = x; 0 != N--;) {
                        var x, N, U, Z = U[N];
                        if (!equal(l[Z], c[Z])) return !1
                    }
                    return !0
                }
                return l != l && c != c
            }
        },
        61820: function(l) {
            "use strict";
            l.exports = function(l, c) {
                for (var x = {}, N = Object.keys(l), U = Array.isArray(c), Z = 0; Z < N.length; Z++) {
                    var $ = N[Z],
                        Y = l[$];
                    (U ? -1 !== c.indexOf($) : c($, Y, l)) && (x[$] = Y)
                }
                return x
            }
        },
        65053: function(l) {
            l.exports = "object" == typeof self ? self.FormData : window.FormData
        },
        68970: function(l, c, x) {
            "use strict";

            function isArray(l) {
                return Array.isArray ? Array.isArray(l) : "[object Array]" === getTag(l)
            }
            x.d(c, {
                Z: function() {
                    return Fuse
                }
            });
            let N = 1 / 0;

            function isString(l) {
                return "string" == typeof l
            }

            function isNumber(l) {
                return "number" == typeof l
            }

            function isObject(l) {
                return "object" == typeof l
            }

            function isDefined(l) {
                return null != l
            }

            function isBlank(l) {
                return !l.trim().length
            }

            function getTag(l) {
                return null == l ? void 0 === l ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(l)
            }
            let LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = l => `Invalid value for key ${l}`,
                PATTERN_LENGTH_TOO_LARGE = l => `Pattern length exceeds max of ${l}.`,
                MISSING_KEY_PROPERTY = l => `Missing ${l} property in key`,
                INVALID_KEY_WEIGHT_VALUE = l => `Property 'weight' in key '${l}' must be a positive integer`,
                U = Object.prototype.hasOwnProperty;
            let KeyStore = class KeyStore {
                constructor(l) {
                    this._keys = [], this._keyMap = {};
                    let c = 0;
                    l.forEach(l => {
                        let x = createKey(l);
                        c += x.weight, this._keys.push(x), this._keyMap[x.id] = x, c += x.weight
                    }), this._keys.forEach(l => {
                        l.weight /= c
                    })
                }
                get(l) {
                    return this._keyMap[l]
                }
                keys() {
                    return this._keys
                }
                toJSON() {
                    return JSON.stringify(this._keys)
                }
            };

            function createKey(l) {
                let c = null,
                    x = null,
                    N = null,
                    Z = 1,
                    $ = null;
                if (isString(l) || isArray(l)) N = l, c = createKeyPath(l), x = createKeyId(l);
                else {
                    if (!U.call(l, "name")) throw Error(MISSING_KEY_PROPERTY("name"));
                    let Y = l.name;
                    if (N = Y, U.call(l, "weight") && (Z = l.weight) <= 0) throw Error(INVALID_KEY_WEIGHT_VALUE(Y));
                    c = createKeyPath(Y), x = createKeyId(Y), $ = l.getFn
                }
                return {
                    path: c,
                    id: x,
                    weight: Z,
                    src: N,
                    getFn: $
                }
            }

            function createKeyPath(l) {
                return isArray(l) ? l : l.split(".")
            }

            function createKeyId(l) {
                return isArray(l) ? l.join(".") : l
            }
            var Z = {
                isCaseSensitive: !1,
                includeScore: !1,
                keys: [],
                shouldSort: !0,
                sortFn: (l, c) => l.score === c.score ? l.idx < c.idx ? -1 : 1 : l.score < c.score ? -1 : 1,
                includeMatches: !1,
                findAllMatches: !1,
                minMatchCharLength: 1,
                location: 0,
                threshold: .6,
                distance: 100,
                useExtendedSearch: !1,
                getFn: function(l, c) {
                    let x = [],
                        U = !1,
                        deepGet = (l, c, Z) => {
                            if (isDefined(l)) {
                                if (c[Z]) {
                                    var $, Y;
                                    let q = c[Z],
                                        J = l[q];
                                    if (isDefined(J)) {
                                        if (Z === c.length - 1 && (isString(J) || isNumber(J) || !0 === ($ = J) || !1 === $ || isObject(Y = $) && null !== Y && "[object Boolean]" == getTag($))) x.push(null == J ? "" : function(l) {
                                            if ("string" == typeof l) return l;
                                            let c = l + "";
                                            return "0" == c && 1 / l == -N ? "-0" : c
                                        }(J));
                                        else if (isArray(J)) {
                                            U = !0;
                                            for (let l = 0, x = J.length; l < x; l += 1) deepGet(J[l], c, Z + 1)
                                        } else c.length && deepGet(J, c, Z + 1)
                                    }
                                } else x.push(l)
                            }
                        };
                    return deepGet(l, isString(c) ? c.split(".") : c, 0), U ? x : x[0]
                },
                ignoreLocation: !1,
                ignoreFieldNorm: !1,
                fieldNormWeight: 1
            };
            let $ = /[^ ]+/g;
            let FuseIndex = class FuseIndex {
                constructor({
                    getFn: l = Z.getFn,
                    fieldNormWeight: c = Z.fieldNormWeight
                } = {}) {
                    this.norm = function(l = 1, c = 3) {
                        let x = new Map,
                            N = Math.pow(10, c);
                        return {
                            get(c) {
                                let U = c.match($).length;
                                if (x.has(U)) return x.get(U);
                                let Z = 1 / Math.pow(U, .5 * l),
                                    Y = parseFloat(Math.round(Z * N) / N);
                                return x.set(U, Y), Y
                            },
                            clear() {
                                x.clear()
                            }
                        }
                    }(c, 3), this.getFn = l, this.isCreated = !1, this.setIndexRecords()
                }
                setSources(l = []) {
                    this.docs = l
                }
                setIndexRecords(l = []) {
                    this.records = l
                }
                setKeys(l = []) {
                    this.keys = l, this._keysMap = {}, l.forEach((l, c) => {
                        this._keysMap[l.id] = c
                    })
                }
                create() {
                    !this.isCreated && this.docs.length && (this.isCreated = !0, isString(this.docs[0]) ? this.docs.forEach((l, c) => {
                        this._addString(l, c)
                    }) : this.docs.forEach((l, c) => {
                        this._addObject(l, c)
                    }), this.norm.clear())
                }
                add(l) {
                    let c = this.size();
                    isString(l) ? this._addString(l, c) : this._addObject(l, c)
                }
                removeAt(l) {
                    this.records.splice(l, 1);
                    for (let c = l, x = this.size(); c < x; c += 1) this.records[c].i -= 1
                }
                getValueForItemAtKeyId(l, c) {
                    return l[this._keysMap[c]]
                }
                size() {
                    return this.records.length
                }
                _addString(l, c) {
                    if (!isDefined(l) || isBlank(l)) return;
                    let x = {
                        v: l,
                        i: c,
                        n: this.norm.get(l)
                    };
                    this.records.push(x)
                }
                _addObject(l, c) {
                    let x = {
                        i: c,
                        $: {}
                    };
                    this.keys.forEach((c, N) => {
                        let U = c.getFn ? c.getFn(l) : this.getFn(l, c.path);
                        if (isDefined(U)) {
                            if (isArray(U)) {
                                let l = [],
                                    c = [{
                                        nestedArrIndex: -1,
                                        value: U
                                    }];
                                for (; c.length;) {
                                    let {
                                        nestedArrIndex: x,
                                        value: N
                                    } = c.pop();
                                    if (isDefined(N)) {
                                        if (isString(N) && !isBlank(N)) {
                                            let c = {
                                                v: N,
                                                i: x,
                                                n: this.norm.get(N)
                                            };
                                            l.push(c)
                                        } else isArray(N) && N.forEach((l, x) => {
                                            c.push({
                                                nestedArrIndex: x,
                                                value: l
                                            })
                                        })
                                    }
                                }
                                x.$[N] = l
                            } else if (isString(U) && !isBlank(U)) {
                                let l = {
                                    v: U,
                                    n: this.norm.get(U)
                                };
                                x.$[N] = l
                            }
                        }
                    }), this.records.push(x)
                }
                toJSON() {
                    return {
                        keys: this.keys,
                        records: this.records
                    }
                }
            };

            function createIndex(l, c, {
                getFn: x = Z.getFn,
                fieldNormWeight: N = Z.fieldNormWeight
            } = {}) {
                let U = new FuseIndex({
                    getFn: x,
                    fieldNormWeight: N
                });
                return U.setKeys(l.map(createKey)), U.setSources(c), U.create(), U
            }

            function computeScore$1(l, {
                errors: c = 0,
                currentLocation: x = 0,
                expectedLocation: N = 0,
                distance: U = Z.distance,
                ignoreLocation: $ = Z.ignoreLocation
            } = {}) {
                let Y = c / l.length;
                if ($) return Y;
                let q = Math.abs(N - x);
                return U ? Y + q / U : q ? 1 : Y
            }
            let BitapSearch = class BitapSearch {
                constructor(l, {
                    location: c = Z.location,
                    threshold: x = Z.threshold,
                    distance: N = Z.distance,
                    includeMatches: U = Z.includeMatches,
                    findAllMatches: $ = Z.findAllMatches,
                    minMatchCharLength: Y = Z.minMatchCharLength,
                    isCaseSensitive: q = Z.isCaseSensitive,
                    ignoreLocation: J = Z.ignoreLocation
                } = {}) {
                    if (this.options = {
                            location: c,
                            threshold: x,
                            distance: N,
                            includeMatches: U,
                            findAllMatches: $,
                            minMatchCharLength: Y,
                            isCaseSensitive: q,
                            ignoreLocation: J
                        }, this.pattern = q ? l : l.toLowerCase(), this.chunks = [], !this.pattern.length) return;
                    let addChunk = (l, c) => {
                            this.chunks.push({
                                pattern: l,
                                alphabet: function(l) {
                                    let c = {};
                                    for (let x = 0, N = l.length; x < N; x += 1) {
                                        let U = l.charAt(x);
                                        c[U] = (c[U] || 0) | 1 << N - x - 1
                                    }
                                    return c
                                }(l),
                                startIndex: c
                            })
                        },
                        X = this.pattern.length;
                    if (X > 32) {
                        let l = 0,
                            c = X % 32,
                            x = X - c;
                        for (; l < x;) addChunk(this.pattern.substr(l, 32), l), l += 32;
                        if (c) {
                            let l = X - 32;
                            addChunk(this.pattern.substr(l), l)
                        }
                    } else addChunk(this.pattern, 0)
                }
                searchIn(l) {
                    let {
                        isCaseSensitive: c,
                        includeMatches: x
                    } = this.options;
                    if (c || (l = l.toLowerCase()), this.pattern === l) {
                        let c = {
                            isMatch: !0,
                            score: 0
                        };
                        return x && (c.indices = [
                            [0, l.length - 1]
                        ]), c
                    }
                    let {
                        location: N,
                        distance: U,
                        threshold: $,
                        findAllMatches: Y,
                        minMatchCharLength: q,
                        ignoreLocation: J
                    } = this.options, X = [], en = 0, er = !1;
                    this.chunks.forEach(({
                        pattern: c,
                        alphabet: ea,
                        startIndex: eo
                    }) => {
                        let {
                            isMatch: el,
                            score: ec,
                            indices: eu
                        } = function(l, c, x, {
                            location: N = Z.location,
                            distance: U = Z.distance,
                            threshold: $ = Z.threshold,
                            findAllMatches: Y = Z.findAllMatches,
                            minMatchCharLength: q = Z.minMatchCharLength,
                            includeMatches: J = Z.includeMatches,
                            ignoreLocation: X = Z.ignoreLocation
                        } = {}) {
                            let en;
                            if (c.length > 32) throw Error(PATTERN_LENGTH_TOO_LARGE(32));
                            let er = c.length,
                                ea = l.length,
                                eo = Math.max(0, Math.min(N, ea)),
                                el = $,
                                ec = eo,
                                eu = q > 1 || J,
                                ed = eu ? Array(ea) : [];
                            for (;
                                (en = l.indexOf(c, ec)) > -1;)
                                if (el = Math.min(computeScore$1(c, {
                                        currentLocation: en,
                                        expectedLocation: eo,
                                        distance: U,
                                        ignoreLocation: X
                                    }), el), ec = en + er, eu) {
                                    let l = 0;
                                    for (; l < er;) ed[en + l] = 1, l += 1
                                }
                            ec = -1;
                            let ep = [],
                                eh = 1,
                                ey = er + ea,
                                ef = 1 << er - 1;
                            for (let N = 0; N < er; N += 1) {
                                let Z = 0,
                                    $ = ey;
                                for (; Z < $;) {
                                    let l = computeScore$1(c, {
                                        errors: N,
                                        currentLocation: eo + $,
                                        expectedLocation: eo,
                                        distance: U,
                                        ignoreLocation: X
                                    });
                                    l <= el ? Z = $ : ey = $, $ = Math.floor((ey - Z) / 2 + Z)
                                }
                                ey = $;
                                let q = Math.max(1, eo - $ + 1),
                                    J = Y ? ea : Math.min(eo + $, ea) + er,
                                    en = Array(J + 2);
                                en[J + 1] = (1 << N) - 1;
                                for (let Z = J; Z >= q; Z -= 1) {
                                    let $ = Z - 1,
                                        Y = x[l.charAt($)];
                                    if (eu && (ed[$] = +!!Y), en[Z] = (en[Z + 1] << 1 | 1) & Y, N && (en[Z] |= (ep[Z + 1] | ep[Z]) << 1 | 1 | ep[Z + 1]), en[Z] & ef && (eh = computeScore$1(c, {
                                            errors: N,
                                            currentLocation: $,
                                            expectedLocation: eo,
                                            distance: U,
                                            ignoreLocation: X
                                        })) <= el) {
                                        if (el = eh, (ec = $) <= eo) break;
                                        q = Math.max(1, 2 * eo - ec)
                                    }
                                }
                                let em = computeScore$1(c, {
                                    errors: N + 1,
                                    currentLocation: eo,
                                    expectedLocation: eo,
                                    distance: U,
                                    ignoreLocation: X
                                });
                                if (em > el) break;
                                ep = en
                            }
                            let em = {
                                isMatch: ec >= 0,
                                score: Math.max(.001, eh)
                            };
                            if (eu) {
                                let l = function(l = [], c = Z.minMatchCharLength) {
                                    let x = [],
                                        N = -1,
                                        U = -1,
                                        $ = 0;
                                    for (let Z = l.length; $ < Z; $ += 1) {
                                        let Z = l[$];
                                        Z && -1 === N ? N = $ : Z || -1 === N || ((U = $ - 1) - N + 1 >= c && x.push([N, U]), N = -1)
                                    }
                                    return l[$ - 1] && $ - N >= c && x.push([N, $ - 1]), x
                                }(ed, q);
                                l.length ? J && (em.indices = l) : em.isMatch = !1
                            }
                            return em
                        }(l, c, ea, {
                            location: N + eo,
                            distance: U,
                            threshold: $,
                            findAllMatches: Y,
                            minMatchCharLength: q,
                            includeMatches: x,
                            ignoreLocation: J
                        });
                        el && (er = !0), en += ec, el && eu && (X = [...X, ...eu])
                    });
                    let ea = {
                        isMatch: er,
                        score: er ? en / this.chunks.length : 1
                    };
                    return er && x && (ea.indices = X), ea
                }
            };
            let BaseMatch = class BaseMatch {
                constructor(l) {
                    this.pattern = l
                }
                static isMultiMatch(l) {
                    return getMatch(l, this.multiRegex)
                }
                static isSingleMatch(l) {
                    return getMatch(l, this.singleRegex)
                }
                search() {}
            };

            function getMatch(l, c) {
                let x = l.match(c);
                return x ? x[1] : null
            }
            let FuzzyMatch = class FuzzyMatch extends BaseMatch {
                constructor(l, {
                    location: c = Z.location,
                    threshold: x = Z.threshold,
                    distance: N = Z.distance,
                    includeMatches: U = Z.includeMatches,
                    findAllMatches: $ = Z.findAllMatches,
                    minMatchCharLength: Y = Z.minMatchCharLength,
                    isCaseSensitive: q = Z.isCaseSensitive,
                    ignoreLocation: J = Z.ignoreLocation
                } = {}) {
                    super(l), this._bitapSearch = new BitapSearch(l, {
                        location: c,
                        threshold: x,
                        distance: N,
                        includeMatches: U,
                        findAllMatches: $,
                        minMatchCharLength: Y,
                        isCaseSensitive: q,
                        ignoreLocation: J
                    })
                }
                static get type() {
                    return "fuzzy"
                }
                static get multiRegex() {
                    return /^"(.*)"$/
                }
                static get singleRegex() {
                    return /^(.*)$/
                }
                search(l) {
                    return this._bitapSearch.searchIn(l)
                }
            };
            let IncludeMatch = class IncludeMatch extends BaseMatch {
                constructor(l) {
                    super(l)
                }
                static get type() {
                    return "include"
                }
                static get multiRegex() {
                    return /^'"(.*)"$/
                }
                static get singleRegex() {
                    return /^'(.*)$/
                }
                search(l) {
                    let c, x = 0,
                        N = [],
                        U = this.pattern.length;
                    for (;
                        (c = l.indexOf(this.pattern, x)) > -1;) x = c + U, N.push([c, x - 1]);
                    let Z = !!N.length;
                    return {
                        isMatch: Z,
                        score: Z ? 0 : 1,
                        indices: N
                    }
                }
            };
            let Y = [class extends BaseMatch {
                    constructor(l) {
                        super(l)
                    }
                    static get type() {
                        return "exact"
                    }
                    static get multiRegex() {
                        return /^="(.*)"$/
                    }
                    static get singleRegex() {
                        return /^=(.*)$/
                    }
                    search(l) {
                        let c = l === this.pattern;
                        return {
                            isMatch: c,
                            score: c ? 0 : 1,
                            indices: [0, this.pattern.length - 1]
                        }
                    }
                }, IncludeMatch, class extends BaseMatch {
                    constructor(l) {
                        super(l)
                    }
                    static get type() {
                        return "prefix-exact"
                    }
                    static get multiRegex() {
                        return /^\^"(.*)"$/
                    }
                    static get singleRegex() {
                        return /^\^(.*)$/
                    }
                    search(l) {
                        let c = l.startsWith(this.pattern);
                        return {
                            isMatch: c,
                            score: c ? 0 : 1,
                            indices: [0, this.pattern.length - 1]
                        }
                    }
                }, class extends BaseMatch {
                    constructor(l) {
                        super(l)
                    }
                    static get type() {
                        return "inverse-prefix-exact"
                    }
                    static get multiRegex() {
                        return /^!\^"(.*)"$/
                    }
                    static get singleRegex() {
                        return /^!\^(.*)$/
                    }
                    search(l) {
                        let c = !l.startsWith(this.pattern);
                        return {
                            isMatch: c,
                            score: c ? 0 : 1,
                            indices: [0, l.length - 1]
                        }
                    }
                }, class extends BaseMatch {
                    constructor(l) {
                        super(l)
                    }
                    static get type() {
                        return "inverse-suffix-exact"
                    }
                    static get multiRegex() {
                        return /^!"(.*)"\$$/
                    }
                    static get singleRegex() {
                        return /^!(.*)\$$/
                    }
                    search(l) {
                        let c = !l.endsWith(this.pattern);
                        return {
                            isMatch: c,
                            score: c ? 0 : 1,
                            indices: [0, l.length - 1]
                        }
                    }
                }, class extends BaseMatch {
                    constructor(l) {
                        super(l)
                    }
                    static get type() {
                        return "suffix-exact"
                    }
                    static get multiRegex() {
                        return /^"(.*)"\$$/
                    }
                    static get singleRegex() {
                        return /^(.*)\$$/
                    }
                    search(l) {
                        let c = l.endsWith(this.pattern);
                        return {
                            isMatch: c,
                            score: c ? 0 : 1,
                            indices: [l.length - this.pattern.length, l.length - 1]
                        }
                    }
                }, class extends BaseMatch {
                    constructor(l) {
                        super(l)
                    }
                    static get type() {
                        return "inverse-exact"
                    }
                    static get multiRegex() {
                        return /^!"(.*)"$/
                    }
                    static get singleRegex() {
                        return /^!(.*)$/
                    }
                    search(l) {
                        let c = l.indexOf(this.pattern),
                            x = -1 === c;
                        return {
                            isMatch: x,
                            score: x ? 0 : 1,
                            indices: [0, l.length - 1]
                        }
                    }
                }, FuzzyMatch],
                q = Y.length,
                J = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
                X = new Set([FuzzyMatch.type, IncludeMatch.type]),
                en = [];

            function createSearcher(l, c) {
                for (let x = 0, N = en.length; x < N; x += 1) {
                    let N = en[x];
                    if (N.condition(l, c)) return new N(l, c)
                }
                return new BitapSearch(l, c)
            }
            let er = {
                    AND: "$and",
                    OR: "$or"
                },
                ea = {
                    PATH: "$path",
                    PATTERN: "$val"
                },
                isExpression = l => !!(l[er.AND] || l[er.OR]),
                isPath = l => !!l[ea.PATH],
                isLeaf = l => !isArray(l) && isObject(l) && !isExpression(l),
                convertToExplicit = l => ({
                    [er.AND]: Object.keys(l).map(c => ({
                        [c]: l[c]
                    }))
                });

            function parse(l, c, {
                auto: x = !0
            } = {}) {
                let next = l => {
                    let N = Object.keys(l),
                        U = isPath(l);
                    if (!U && N.length > 1 && !isExpression(l)) return next(convertToExplicit(l));
                    if (isLeaf(l)) {
                        let Z = U ? l[ea.PATH] : N[0],
                            $ = U ? l[ea.PATTERN] : l[Z];
                        if (!isString($)) throw Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(Z));
                        let Y = {
                            keyId: createKeyId(Z),
                            pattern: $
                        };
                        return x && (Y.searcher = createSearcher($, c)), Y
                    }
                    let Z = {
                        children: [],
                        operator: N[0]
                    };
                    return N.forEach(c => {
                        let x = l[c];
                        isArray(x) && x.forEach(l => {
                            Z.children.push(next(l))
                        })
                    }), Z
                };
                return isExpression(l) || (l = convertToExplicit(l)), next(l)
            }

            function transformMatches(l, c) {
                let x = l.matches;
                c.matches = [], isDefined(x) && x.forEach(l => {
                    if (!isDefined(l.indices) || !l.indices.length) return;
                    let {
                        indices: x,
                        value: N
                    } = l, U = {
                        indices: x,
                        value: N
                    };
                    l.key && (U.key = l.key.src), l.idx > -1 && (U.refIndex = l.idx), c.matches.push(U)
                })
            }

            function transformScore(l, c) {
                c.score = l.score
            }
            let Fuse = class Fuse {
                constructor(l, c = {}, x) {
                    this.options = { ...Z,
                        ...c
                    }, this.options.useExtendedSearch, this._keyStore = new KeyStore(this.options.keys), this.setCollection(l, x)
                }
                setCollection(l, c) {
                    if (this._docs = l, c && !(c instanceof FuseIndex)) throw Error("Incorrect 'index' type");
                    this._myIndex = c || createIndex(this.options.keys, this._docs, {
                        getFn: this.options.getFn,
                        fieldNormWeight: this.options.fieldNormWeight
                    })
                }
                add(l) {
                    isDefined(l) && (this._docs.push(l), this._myIndex.add(l))
                }
                remove(l = () => !1) {
                    let c = [];
                    for (let x = 0, N = this._docs.length; x < N; x += 1) {
                        let U = this._docs[x];
                        l(U, x) && (this.removeAt(x), x -= 1, N -= 1, c.push(U))
                    }
                    return c
                }
                removeAt(l) {
                    this._docs.splice(l, 1), this._myIndex.removeAt(l)
                }
                getIndex() {
                    return this._myIndex
                }
                search(l, {
                    limit: c = -1
                } = {}) {
                    let {
                        includeMatches: x,
                        includeScore: N,
                        shouldSort: U,
                        sortFn: $,
                        ignoreFieldNorm: Y
                    } = this.options, q = isString(l) ? isString(this._docs[0]) ? this._searchStringList(l) : this._searchObjectList(l) : this._searchLogical(l);
                    return ! function(l, {
                            ignoreFieldNorm: c = Z.ignoreFieldNorm
                        }) {
                            l.forEach(l => {
                                let x = 1;
                                l.matches.forEach(({
                                    key: l,
                                    norm: N,
                                    score: U
                                }) => {
                                    let Z = l ? l.weight : null;
                                    x *= Math.pow(0 === U && Z ? Number.EPSILON : U, (Z || 1) * (c ? 1 : N))
                                }), l.score = x
                            })
                        }(q, {
                            ignoreFieldNorm: Y
                        }), U && q.sort($), isNumber(c) && c > -1 && (q = q.slice(0, c)),
                        function(l, c, {
                            includeMatches: x = Z.includeMatches,
                            includeScore: N = Z.includeScore
                        } = {}) {
                            let U = [];
                            return x && U.push(transformMatches), N && U.push(transformScore), l.map(l => {
                                let {
                                    idx: x
                                } = l, N = {
                                    item: c[x],
                                    refIndex: x
                                };
                                return U.length && U.forEach(c => {
                                    c(l, N)
                                }), N
                            })
                        }(q, this._docs, {
                            includeMatches: x,
                            includeScore: N
                        })
                }
                _searchStringList(l) {
                    let c = createSearcher(l, this.options),
                        {
                            records: x
                        } = this._myIndex,
                        N = [];
                    return x.forEach(({
                        v: l,
                        i: x,
                        n: U
                    }) => {
                        if (!isDefined(l)) return;
                        let {
                            isMatch: Z,
                            score: $,
                            indices: Y
                        } = c.searchIn(l);
                        Z && N.push({
                            item: l,
                            idx: x,
                            matches: [{
                                score: $,
                                value: l,
                                norm: U,
                                indices: Y
                            }]
                        })
                    }), N
                }
                _searchLogical(l) {
                    let c = parse(l, this.options),
                        evaluate = (l, c, x) => {
                            if (!l.children) {
                                let {
                                    keyId: N,
                                    searcher: U
                                } = l, Z = this._findMatches({
                                    key: this._keyStore.get(N),
                                    value: this._myIndex.getValueForItemAtKeyId(c, N),
                                    searcher: U
                                });
                                return Z && Z.length ? [{
                                    idx: x,
                                    item: c,
                                    matches: Z
                                }] : []
                            }
                            let N = [];
                            for (let U = 0, Z = l.children.length; U < Z; U += 1) {
                                let Z = l.children[U],
                                    $ = evaluate(Z, c, x);
                                if ($.length) N.push(...$);
                                else if (l.operator === er.AND) return []
                            }
                            return N
                        },
                        x = this._myIndex.records,
                        N = {},
                        U = [];
                    return x.forEach(({
                        $: l,
                        i: x
                    }) => {
                        if (isDefined(l)) {
                            let Z = evaluate(c, l, x);
                            Z.length && (N[x] || (N[x] = {
                                idx: x,
                                item: l,
                                matches: []
                            }, U.push(N[x])), Z.forEach(({
                                matches: l
                            }) => {
                                N[x].matches.push(...l)
                            }))
                        }
                    }), U
                }
                _searchObjectList(l) {
                    let c = createSearcher(l, this.options),
                        {
                            keys: x,
                            records: N
                        } = this._myIndex,
                        U = [];
                    return N.forEach(({
                        $: l,
                        i: N
                    }) => {
                        if (!isDefined(l)) return;
                        let Z = [];
                        x.forEach((x, N) => {
                            Z.push(...this._findMatches({
                                key: x,
                                value: l[N],
                                searcher: c
                            }))
                        }), Z.length && U.push({
                            idx: N,
                            item: l,
                            matches: Z
                        })
                    }), U
                }
                _findMatches({
                    key: l,
                    value: c,
                    searcher: x
                }) {
                    if (!isDefined(c)) return [];
                    let N = [];
                    if (isArray(c)) c.forEach(({
                        v: c,
                        i: U,
                        n: Z
                    }) => {
                        if (!isDefined(c)) return;
                        let {
                            isMatch: $,
                            score: Y,
                            indices: q
                        } = x.searchIn(c);
                        $ && N.push({
                            score: Y,
                            key: l,
                            value: c,
                            idx: U,
                            norm: Z,
                            indices: q
                        })
                    });
                    else {
                        let {
                            v: U,
                            n: Z
                        } = c, {
                            isMatch: $,
                            score: Y,
                            indices: q
                        } = x.searchIn(U);
                        $ && N.push({
                            score: Y,
                            key: l,
                            value: U,
                            norm: Z,
                            indices: q
                        })
                    }
                    return N
                }
            };
            Fuse.version = "6.6.2", Fuse.createIndex = createIndex, Fuse.parseIndex = function(l, {
                    getFn: c = Z.getFn,
                    fieldNormWeight: x = Z.fieldNormWeight
                } = {}) {
                    let {
                        keys: N,
                        records: U
                    } = l, $ = new FuseIndex({
                        getFn: c,
                        fieldNormWeight: x
                    });
                    return $.setKeys(N), $.setIndexRecords(U), $
                }, Fuse.config = Z, Fuse.parseQuery = parse,
                function(...l) {
                    en.push(...l)
                }(class {
                    constructor(l, {
                        isCaseSensitive: c = Z.isCaseSensitive,
                        includeMatches: x = Z.includeMatches,
                        minMatchCharLength: N = Z.minMatchCharLength,
                        ignoreLocation: U = Z.ignoreLocation,
                        findAllMatches: $ = Z.findAllMatches,
                        location: X = Z.location,
                        threshold: en = Z.threshold,
                        distance: er = Z.distance
                    } = {}) {
                        this.query = null, this.options = {
                            isCaseSensitive: c,
                            includeMatches: x,
                            minMatchCharLength: N,
                            findAllMatches: $,
                            ignoreLocation: U,
                            location: X,
                            threshold: en,
                            distance: er
                        }, this.pattern = c ? l : l.toLowerCase(), this.query = function(l, c = {}) {
                            return l.split("|").map(l => {
                                let x = l.trim().split(J).filter(l => l && !!l.trim()),
                                    N = [];
                                for (let l = 0, U = x.length; l < U; l += 1) {
                                    let U = x[l],
                                        Z = !1,
                                        $ = -1;
                                    for (; !Z && ++$ < q;) {
                                        let l = Y[$],
                                            x = l.isMultiMatch(U);
                                        x && (N.push(new l(x, c)), Z = !0)
                                    }
                                    if (!Z)
                                        for ($ = -1; ++$ < q;) {
                                            let l = Y[$],
                                                x = l.isSingleMatch(U);
                                            if (x) {
                                                N.push(new l(x, c));
                                                break
                                            }
                                        }
                                }
                                return N
                            })
                        }(this.pattern, this.options)
                    }
                    static condition(l, c) {
                        return c.useExtendedSearch
                    }
                    searchIn(l) {
                        let c = this.query;
                        if (!c) return {
                            isMatch: !1,
                            score: 1
                        };
                        let {
                            includeMatches: x,
                            isCaseSensitive: N
                        } = this.options;
                        l = N ? l : l.toLowerCase();
                        let U = 0,
                            Z = [],
                            $ = 0;
                        for (let N = 0, Y = c.length; N < Y; N += 1) {
                            let Y = c[N];
                            Z.length = 0, U = 0;
                            for (let c = 0, N = Y.length; c < N; c += 1) {
                                let N = Y[c],
                                    {
                                        isMatch: q,
                                        indices: J,
                                        score: en
                                    } = N.search(l);
                                if (q) {
                                    if (U += 1, $ += en, x) {
                                        let l = N.constructor.type;
                                        X.has(l) ? Z = [...Z, ...J] : Z.push(J)
                                    }
                                } else {
                                    $ = 0, U = 0, Z.length = 0;
                                    break
                                }
                            }
                            if (U) {
                                let l = {
                                    isMatch: !0,
                                    score: $ / U
                                };
                                return x && (l.indices = Z), l
                            }
                        }
                        return {
                            isMatch: !1,
                            score: 1
                        }
                    }
                })
        },
        55487: function(l, c, x) {
            "use strict";
            var N = x(9176),
                U = {
                    childContextTypes: !0,
                    contextType: !0,
                    contextTypes: !0,
                    defaultProps: !0,
                    displayName: !0,
                    getDefaultProps: !0,
                    getDerivedStateFromError: !0,
                    getDerivedStateFromProps: !0,
                    mixins: !0,
                    propTypes: !0,
                    type: !0
                },
                Z = {
                    name: !0,
                    length: !0,
                    prototype: !0,
                    caller: !0,
                    callee: !0,
                    arguments: !0,
                    arity: !0
                },
                $ = {
                    $$typeof: !0,
                    compare: !0,
                    defaultProps: !0,
                    displayName: !0,
                    propTypes: !0,
                    type: !0
                },
                Y = {};

            function getStatics(l) {
                return N.isMemo(l) ? $ : Y[l.$$typeof] || U
            }
            Y[N.ForwardRef] = {
                $$typeof: !0,
                render: !0,
                defaultProps: !0,
                displayName: !0,
                propTypes: !0
            }, Y[N.Memo] = $;
            var q = Object.defineProperty,
                J = Object.getOwnPropertyNames,
                X = Object.getOwnPropertySymbols,
                en = Object.getOwnPropertyDescriptor,
                er = Object.getPrototypeOf,
                ea = Object.prototype;
            l.exports = function hoistNonReactStatics(l, c, x) {
                if ("string" != typeof c) {
                    if (ea) {
                        var N = er(c);
                        N && N !== ea && hoistNonReactStatics(l, N, x)
                    }
                    var U = J(c);
                    X && (U = U.concat(X(c)));
                    for (var $ = getStatics(l), Y = getStatics(c), eo = 0; eo < U.length; ++eo) {
                        var el = U[eo];
                        if (!Z[el] && !(x && x[el]) && !(Y && Y[el]) && !($ && $[el])) {
                            var ec = en(c, el);
                            try {
                                q(l, el, ec)
                            } catch (l) {}
                        }
                    }
                }
                return l
            }
        },
        19087: function(l, c) { /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
            c.read = function(l, c, x, N, U) {
                var Z, $, Y = 8 * U - N - 1,
                    q = (1 << Y) - 1,
                    J = q >> 1,
                    X = -7,
                    en = x ? U - 1 : 0,
                    er = x ? -1 : 1,
                    ea = l[c + en];
                for (en += er, Z = ea & (1 << -X) - 1, ea >>= -X, X += Y; X > 0; Z = 256 * Z + l[c + en], en += er, X -= 8);
                for ($ = Z & (1 << -X) - 1, Z >>= -X, X += N; X > 0; $ = 256 * $ + l[c + en], en += er, X -= 8);
                if (0 === Z) Z = 1 - J;
                else {
                    if (Z === q) return $ ? NaN : (ea ? -1 : 1) * (1 / 0);
                    $ += Math.pow(2, N), Z -= J
                }
                return (ea ? -1 : 1) * $ * Math.pow(2, Z - N)
            }, c.write = function(l, c, x, N, U, Z) {
                var $, Y, q, J = 8 * Z - U - 1,
                    X = (1 << J) - 1,
                    en = X >> 1,
                    er = 23 === U ? 5960464477539062e-23 : 0,
                    ea = N ? 0 : Z - 1,
                    eo = N ? 1 : -1,
                    el = c < 0 || 0 === c && 1 / c < 0 ? 1 : 0;
                for (isNaN(c = Math.abs(c)) || c === 1 / 0 ? (Y = isNaN(c) ? 1 : 0, $ = X) : ($ = Math.floor(Math.log(c) / Math.LN2), c * (q = Math.pow(2, -$)) < 1 && ($--, q *= 2), $ + en >= 1 ? c += er / q : c += er * Math.pow(2, 1 - en), c * q >= 2 && ($++, q /= 2), $ + en >= X ? (Y = 0, $ = X) : $ + en >= 1 ? (Y = (c * q - 1) * Math.pow(2, U), $ += en) : (Y = c * Math.pow(2, en - 1) * Math.pow(2, U), $ = 0)); U >= 8; l[x + ea] = 255 & Y, ea += eo, Y /= 256, U -= 8);
                for ($ = $ << U | Y, J += U; J > 0; l[x + ea] = 255 & $, ea += eo, $ /= 256, J -= 8);
                l[x + ea - eo] |= 128 * el
            }
        },
        99780: function(l, c, x) {
            l = x.nmd(l);
            var N, U, Z, $ = "__lodash_hash_undefined__",
                Y = "[object Arguments]",
                q = "[object Array]",
                J = "[object Boolean]",
                X = "[object Date]",
                en = "[object Error]",
                er = "[object Function]",
                ea = "[object Map]",
                eo = "[object Number]",
                el = "[object Object]",
                ec = "[object Promise]",
                eu = "[object RegExp]",
                ed = "[object Set]",
                ep = "[object String]",
                eh = "[object WeakMap]",
                ey = "[object ArrayBuffer]",
                ef = "[object DataView]",
                em = /^\[object .+?Constructor\]$/,
                eg = /^(?:0|[1-9]\d*)$/,
                eb = {};
            eb["[object Float32Array]"] = eb["[object Float64Array]"] = eb["[object Int8Array]"] = eb["[object Int16Array]"] = eb["[object Int32Array]"] = eb["[object Uint8Array]"] = eb["[object Uint8ClampedArray]"] = eb["[object Uint16Array]"] = eb["[object Uint32Array]"] = !0, eb[Y] = eb[q] = eb[ey] = eb[J] = eb[ef] = eb[X] = eb[en] = eb[er] = eb[ea] = eb[eo] = eb[el] = eb[eu] = eb[ed] = eb[ep] = eb[eh] = !1;
            var ev = "object" == typeof x.g && x.g && x.g.Object === Object && x.g,
                ew = "object" == typeof self && self && self.Object === Object && self,
                eT = ev || ew || Function("return this")(),
                eM = c && !c.nodeType && c,
                eI = eM && l && !l.nodeType && l,
                ex = eI && eI.exports === eM,
                eC = ex && ev.process,
                e_ = function() {
                    try {
                        return eC && eC.binding && eC.binding("util")
                    } catch (l) {}
                }(),
                eD = e_ && e_.isTypedArray;

            function mapToArray(l) {
                var c = -1,
                    x = Array(l.size);
                return l.forEach(function(l, N) {
                    x[++c] = [N, l]
                }), x
            }

            function setToArray(l) {
                var c = -1,
                    x = Array(l.size);
                return l.forEach(function(l) {
                    x[++c] = l
                }), x
            }
            var eS = Array.prototype,
                ek = Function.prototype,
                eE = Object.prototype,
                eN = eT["__core-js_shared__"],
                eA = ek.toString,
                ej = eE.hasOwnProperty,
                eO = (N = /[^.]+$/.exec(eN && eN.keys && eN.keys.IE_PROTO || "")) ? "Symbol(src)_1." + N : "",
                eP = eE.toString,
                ez = RegExp("^" + eA.call(ej).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                eR = ex ? eT.Buffer : void 0,
                eL = eT.Symbol,
                eB = eT.Uint8Array,
                eU = eE.propertyIsEnumerable,
                eF = eS.splice,
                eW = eL ? eL.toStringTag : void 0,
                eZ = Object.getOwnPropertySymbols,
                eQ = eR ? eR.isBuffer : void 0,
                eH = (U = Object.keys, Z = Object, function(l) {
                    return U(Z(l))
                }),
                e$ = getNative(eT, "DataView"),
                eY = getNative(eT, "Map"),
                eG = getNative(eT, "Promise"),
                eV = getNative(eT, "Set"),
                eK = getNative(eT, "WeakMap"),
                eJ = getNative(Object, "create"),
                eX = toSource(e$),
                e0 = toSource(eY),
                e2 = toSource(eG),
                e1 = toSource(eV),
                e5 = toSource(eK),
                e4 = eL ? eL.prototype : void 0,
                e3 = e4 ? e4.valueOf : void 0;

            function Hash(l) {
                var c = -1,
                    x = null == l ? 0 : l.length;
                for (this.clear(); ++c < x;) {
                    var N = l[c];
                    this.set(N[0], N[1])
                }
            }

            function ListCache(l) {
                var c = -1,
                    x = null == l ? 0 : l.length;
                for (this.clear(); ++c < x;) {
                    var N = l[c];
                    this.set(N[0], N[1])
                }
            }

            function MapCache(l) {
                var c = -1,
                    x = null == l ? 0 : l.length;
                for (this.clear(); ++c < x;) {
                    var N = l[c];
                    this.set(N[0], N[1])
                }
            }

            function SetCache(l) {
                var c = -1,
                    x = null == l ? 0 : l.length;
                for (this.__data__ = new MapCache; ++c < x;) this.add(l[c])
            }

            function Stack(l) {
                var c = this.__data__ = new ListCache(l);
                this.size = c.size
            }

            function assocIndexOf(l, c) {
                for (var x = l.length; x--;)
                    if (eq(l[x][0], c)) return x;
                return -1
            }

            function baseGetTag(l) {
                return null == l ? void 0 === l ? "[object Undefined]" : "[object Null]" : eW && eW in Object(l) ? function(l) {
                    var c = ej.call(l, eW),
                        x = l[eW];
                    try {
                        l[eW] = void 0;
                        var N = !0
                    } catch (l) {}
                    var U = eP.call(l);
                    return N && (c ? l[eW] = x : delete l[eW]), U
                }(l) : eP.call(l)
            }

            function baseIsArguments(l) {
                return isObjectLike(l) && baseGetTag(l) == Y
            }

            function equalArrays(l, c, x, N, U, Z) {
                var $ = 1 & x,
                    Y = l.length,
                    q = c.length;
                if (Y != q && !($ && q > Y)) return !1;
                var J = Z.get(l);
                if (J && Z.get(c)) return J == c;
                var X = -1,
                    en = !0,
                    er = 2 & x ? new SetCache : void 0;
                for (Z.set(l, c), Z.set(c, l); ++X < Y;) {
                    var ea = l[X],
                        eo = c[X];
                    if (N) var el = $ ? N(eo, ea, X, c, l, Z) : N(ea, eo, X, l, c, Z);
                    if (void 0 !== el) {
                        if (el) continue;
                        en = !1;
                        break
                    }
                    if (er) {
                        if (! function(l, c) {
                                for (var x = -1, N = null == l ? 0 : l.length; ++x < N;)
                                    if (c(l[x], x, l)) return !0;
                                return !1
                            }(c, function(l, c) {
                                if (!er.has(c) && (ea === l || U(ea, l, x, N, Z))) return er.push(c)
                            })) {
                            en = !1;
                            break
                        }
                    } else if (!(ea === eo || U(ea, eo, x, N, Z))) {
                        en = !1;
                        break
                    }
                }
                return Z.delete(l), Z.delete(c), en
            }

            function getAllKeys(l) {
                var c;
                return c = function(l) {
                    return null != l && isLength(l.length) && !isFunction(l) ? function(l, c) {
                        var x, N = e7(l),
                            U = !N && e9(l),
                            Z = !N && !U && tt(l),
                            $ = !N && !U && !Z && tn(l),
                            Y = N || U || Z || $,
                            q = Y ? function(l, c) {
                                for (var x = -1, N = Array(l); ++x < l;) N[x] = c(x);
                                return N
                            }(l.length, String) : [],
                            J = q.length;
                        for (var X in l) ej.call(l, X) && !(Y && ("length" == X || Z && ("offset" == X || "parent" == X) || $ && ("buffer" == X || "byteLength" == X || "byteOffset" == X) || (x = null == (x = J) ? 9007199254740991 : x) && ("number" == typeof X || eg.test(X)) && X > -1 && X % 1 == 0 && X < x)) && q.push(X);
                        return q
                    }(l) : function(l) {
                        if (c = l && l.constructor, l !== ("function" == typeof c && c.prototype || eE)) return eH(l);
                        var c, x = [];
                        for (var N in Object(l)) ej.call(l, N) && "constructor" != N && x.push(N);
                        return x
                    }(l)
                }(l), e7(l) ? c : function(l, c) {
                    for (var x = -1, N = c.length, U = l.length; ++x < N;) l[U + x] = c[x];
                    return l
                }(c, e6(l))
            }

            function getMapData(l, c) {
                var x, N = l.__data__;
                return ("string" == (x = typeof c) || "number" == x || "symbol" == x || "boolean" == x ? "__proto__" !== c : null === c) ? N["string" == typeof c ? "string" : "hash"] : N.map
            }

            function getNative(l, c) {
                var x = null == l ? void 0 : l[c];
                return !(!isObject(x) || eO && eO in x) && (isFunction(x) ? ez : em).test(toSource(x)) ? x : void 0
            }
            Hash.prototype.clear = function() {
                this.__data__ = eJ ? eJ(null) : {}, this.size = 0
            }, Hash.prototype.delete = function(l) {
                var c = this.has(l) && delete this.__data__[l];
                return this.size -= c ? 1 : 0, c
            }, Hash.prototype.get = function(l) {
                var c = this.__data__;
                if (eJ) {
                    var x = c[l];
                    return x === $ ? void 0 : x
                }
                return ej.call(c, l) ? c[l] : void 0
            }, Hash.prototype.has = function(l) {
                var c = this.__data__;
                return eJ ? void 0 !== c[l] : ej.call(c, l)
            }, Hash.prototype.set = function(l, c) {
                var x = this.__data__;
                return this.size += this.has(l) ? 0 : 1, x[l] = eJ && void 0 === c ? $ : c, this
            }, ListCache.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, ListCache.prototype.delete = function(l) {
                var c = this.__data__,
                    x = assocIndexOf(c, l);
                return !(x < 0) && (x == c.length - 1 ? c.pop() : eF.call(c, x, 1), --this.size, !0)
            }, ListCache.prototype.get = function(l) {
                var c = this.__data__,
                    x = assocIndexOf(c, l);
                return x < 0 ? void 0 : c[x][1]
            }, ListCache.prototype.has = function(l) {
                return assocIndexOf(this.__data__, l) > -1
            }, ListCache.prototype.set = function(l, c) {
                var x = this.__data__,
                    N = assocIndexOf(x, l);
                return N < 0 ? (++this.size, x.push([l, c])) : x[N][1] = c, this
            }, MapCache.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Hash,
                    map: new(eY || ListCache),
                    string: new Hash
                }
            }, MapCache.prototype.delete = function(l) {
                var c = getMapData(this, l).delete(l);
                return this.size -= c ? 1 : 0, c
            }, MapCache.prototype.get = function(l) {
                return getMapData(this, l).get(l)
            }, MapCache.prototype.has = function(l) {
                return getMapData(this, l).has(l)
            }, MapCache.prototype.set = function(l, c) {
                var x = getMapData(this, l),
                    N = x.size;
                return x.set(l, c), this.size += x.size == N ? 0 : 1, this
            }, SetCache.prototype.add = SetCache.prototype.push = function(l) {
                return this.__data__.set(l, $), this
            }, SetCache.prototype.has = function(l) {
                return this.__data__.has(l)
            }, Stack.prototype.clear = function() {
                this.__data__ = new ListCache, this.size = 0
            }, Stack.prototype.delete = function(l) {
                var c = this.__data__,
                    x = c.delete(l);
                return this.size = c.size, x
            }, Stack.prototype.get = function(l) {
                return this.__data__.get(l)
            }, Stack.prototype.has = function(l) {
                return this.__data__.has(l)
            }, Stack.prototype.set = function(l, c) {
                var x = this.__data__;
                if (x instanceof ListCache) {
                    var N = x.__data__;
                    if (!eY || N.length < 199) return N.push([l, c]), this.size = ++x.size, this;
                    x = this.__data__ = new MapCache(N)
                }
                return x.set(l, c), this.size = x.size, this
            };
            var e6 = eZ ? function(l) {
                    return null == l ? [] : function(l, c) {
                        for (var x = -1, N = null == l ? 0 : l.length, U = 0, Z = []; ++x < N;) {
                            var $ = l[x];
                            c($, x, l) && (Z[U++] = $)
                        }
                        return Z
                    }(eZ(l = Object(l)), function(c) {
                        return eU.call(l, c)
                    })
                } : function() {
                    return []
                },
                e8 = baseGetTag;

            function toSource(l) {
                if (null != l) {
                    try {
                        return eA.call(l)
                    } catch (l) {}
                    try {
                        return l + ""
                    } catch (l) {}
                }
                return ""
            }

            function eq(l, c) {
                return l === c || l != l && c != c
            }(e$ && e8(new e$(new ArrayBuffer(1))) != ef || eY && e8(new eY) != ea || eG && e8(eG.resolve()) != ec || eV && e8(new eV) != ed || eK && e8(new eK) != eh) && (e8 = function(l) {
                var c = baseGetTag(l),
                    x = c == el ? l.constructor : void 0,
                    N = x ? toSource(x) : "";
                if (N) switch (N) {
                    case eX:
                        return ef;
                    case e0:
                        return ea;
                    case e2:
                        return ec;
                    case e1:
                        return ed;
                    case e5:
                        return eh
                }
                return c
            });
            var e9 = baseIsArguments(function() {
                    return arguments
                }()) ? baseIsArguments : function(l) {
                    return isObjectLike(l) && ej.call(l, "callee") && !eU.call(l, "callee")
                },
                e7 = Array.isArray,
                tt = eQ || function() {
                    return !1
                };

            function isFunction(l) {
                if (!isObject(l)) return !1;
                var c = baseGetTag(l);
                return c == er || "[object GeneratorFunction]" == c || "[object AsyncFunction]" == c || "[object Proxy]" == c
            }

            function isLength(l) {
                return "number" == typeof l && l > -1 && l % 1 == 0 && l <= 9007199254740991
            }

            function isObject(l) {
                var c = typeof l;
                return null != l && ("object" == c || "function" == c)
            }

            function isObjectLike(l) {
                return null != l && "object" == typeof l
            }
            var tn = eD ? function(l) {
                return eD(l)
            } : function(l) {
                return isObjectLike(l) && isLength(l.length) && !!eb[baseGetTag(l)]
            };
            l.exports = function(l, c) {
                return function baseIsEqual(l, c, x, N, U) {
                    return l === c || (null != l && null != c && (isObjectLike(l) || isObjectLike(c)) ? function(l, c, x, N, U, Z) {
                        var $ = e7(l),
                            er = e7(c),
                            ec = $ ? q : e8(l),
                            eh = er ? q : e8(c);
                        ec = ec == Y ? el : ec, eh = eh == Y ? el : eh;
                        var em = ec == el,
                            eg = eh == el,
                            eb = ec == eh;
                        if (eb && tt(l)) {
                            if (!tt(c)) return !1;
                            $ = !0, em = !1
                        }
                        if (eb && !em) return Z || (Z = new Stack), $ || tn(l) ? equalArrays(l, c, x, N, U, Z) : function(l, c, x, N, U, Z, $) {
                            switch (x) {
                                case ef:
                                    if (l.byteLength != c.byteLength || l.byteOffset != c.byteOffset) break;
                                    l = l.buffer, c = c.buffer;
                                case ey:
                                    if (l.byteLength != c.byteLength || !Z(new eB(l), new eB(c))) break;
                                    return !0;
                                case J:
                                case X:
                                case eo:
                                    return eq(+l, +c);
                                case en:
                                    return l.name == c.name && l.message == c.message;
                                case eu:
                                case ep:
                                    return l == c + "";
                                case ea:
                                    var Y = mapToArray;
                                case ed:
                                    var q = 1 & N;
                                    if (Y || (Y = setToArray), l.size != c.size && !q) break;
                                    var er = $.get(l);
                                    if (er) return er == c;
                                    N |= 2, $.set(l, c);
                                    var el = equalArrays(Y(l), Y(c), N, U, Z, $);
                                    return $.delete(l), el;
                                case "[object Symbol]":
                                    if (e3) return e3.call(l) == e3.call(c)
                            }
                            return !1
                        }(l, c, ec, x, N, U, Z);
                        if (!(1 & x)) {
                            var ev = em && ej.call(l, "__wrapped__"),
                                ew = eg && ej.call(c, "__wrapped__");
                            if (ev || ew) {
                                var eT = ev ? l.value() : l,
                                    eM = ew ? c.value() : c;
                                return Z || (Z = new Stack), U(eT, eM, x, N, Z)
                            }
                        }
                        return !!eb && (Z || (Z = new Stack), function(l, c, x, N, U, Z) {
                            var $ = 1 & x,
                                Y = getAllKeys(l),
                                q = Y.length;
                            if (q != getAllKeys(c).length && !$) return !1;
                            for (var J = q; J--;) {
                                var X = Y[J];
                                if (!($ ? X in c : ej.call(c, X))) return !1
                            }
                            var en = Z.get(l);
                            if (en && Z.get(c)) return en == c;
                            var er = !0;
                            Z.set(l, c), Z.set(c, l);
                            for (var ea = $; ++J < q;) {
                                var eo = l[X = Y[J]],
                                    el = c[X];
                                if (N) var ec = $ ? N(el, eo, X, c, l, Z) : N(eo, el, X, l, c, Z);
                                if (!(void 0 === ec ? eo === el || U(eo, el, x, N, Z) : ec)) {
                                    er = !1;
                                    break
                                }
                                ea || (ea = "constructor" == X)
                            }
                            if (er && !ea) {
                                var eu = l.constructor,
                                    ed = c.constructor;
                                eu != ed && "constructor" in l && "constructor" in c && !("function" == typeof eu && eu instanceof eu && "function" == typeof ed && ed instanceof ed) && (er = !1)
                            }
                            return Z.delete(l), Z.delete(c), er
                        }(l, c, x, N, U, Z))
                    }(l, c, x, N, baseIsEqual, U) : l != l && c != c)
                }(l, c)
            }
        },
        61755: function(l, c, x) {
            "use strict";
            var N = this && this.__importDefault || function(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            };
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.Base = void 0;
            let U = x(67133),
                Z = N(x(90302));
            let Base = class Base {
                print() {
                    Base.print(this)
                }
                _bufferIndexOf(l, c) {
                    for (let x = 0; x < l.length; x++)
                        if (c.equals(l[x])) return x;
                    return -1
                }
                static bufferify(l) {
                    if (!U.Buffer.isBuffer(l)) {
                        if ("object" == typeof l && l.words) return U.Buffer.from(l.toString(Z.default.enc.Hex), "hex");
                        if (Base.isHexString(l)) return U.Buffer.from(l.replace(/^0x/, ""), "hex");
                        if ("string" == typeof l) return U.Buffer.from(l);
                        if ("number" == typeof l) {
                            let c = l.toString();
                            return c.length % 2 && (c = `0${c}`), U.Buffer.from(c, "hex")
                        } else if (ArrayBuffer.isView(l)) return U.Buffer.from(l.buffer, l.byteOffset, l.byteLength)
                    }
                    return l
                }
                static isHexString(l) {
                    return "string" == typeof l && /^(0x)?[0-9A-Fa-f]*$/.test(l)
                }
                static print(l) {
                    console.log(l.toString())
                }
                bufferToHex(l, c = !0) {
                    return Base.bufferToHex(l, c)
                }
                static bufferToHex(l, c = !0) {
                    return `${c?"0x":""}${(l||U.Buffer.alloc(0)).toString("hex")}`
                }
                bufferify(l) {
                    return Base.bufferify(l)
                }
                bufferifyFn(l) {
                    return c => {
                        let x = l(c);
                        return U.Buffer.isBuffer(x) ? x : this._isHexString(x) ? U.Buffer.from(x.replace("0x", ""), "hex") : "string" == typeof x ? U.Buffer.from(x) : ArrayBuffer.isView(x) ? U.Buffer.from(x.buffer, x.byteOffset, x.byteLength) : U.Buffer.from(l(Z.default.enc.Hex.parse(c.toString("hex"))).toString(Z.default.enc.Hex), "hex")
                    }
                }
                _isHexString(l) {
                    return Base.isHexString(l)
                }
                _log2(l) {
                    return 1 === l ? 0 : 1 + this._log2(l / 2 | 0)
                }
                _zip(l, c) {
                    return l.map((l, x) => [l, c[x]])
                }
            };
            c.Base = Base, c.default = Base
        },
        5126: function(l, c, x) {
            "use strict";
            var N = this && this.__importDefault || function(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            };
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.MerkleMountainRange = void 0;
            let U = x(67133),
                Z = N(x(83303)),
                $ = N(x(61755));
            let MerkleMountainRange = class MerkleMountainRange extends $.default {
                constructor(l = Z.default, c = [], x, N, $) {
                    for (let Z of (super(), this.root = U.Buffer.alloc(0), this.size = 0, this.width = 0, this.hashes = {}, this.data = {}, c = c.map(this.bufferify), this.hashFn = this.bufferifyFn(l), this.hashLeafFn = x, this.peakBaggingFn = N, this.hashBranchFn = $, c)) this.append(Z)
                }
                append(l) {
                    l = this.bufferify(l);
                    let c = this.hashFn(l),
                        x = this.bufferToHex(c);
                    this.data[x] && this.bufferToHex(this.hashFn(this.data[x])) === x || (this.data[x] = l);
                    let N = this.hashLeaf(this.size + 1, c);
                    this.hashes[this.size + 1] = N, this.width += 1;
                    let U = this.getPeakIndexes(this.width);
                    this.size = this.getSize(this.width);
                    let Z = [];
                    for (let l = 0; l < U.length; l++) Z[l] = this._getOrCreateNode(U[l]);
                    this.root = this.peakBagging(this.width, Z)
                }
                hashLeaf(l, c) {
                    return (c = this.bufferify(c), this.hashLeafFn) ? this.bufferify(this.hashLeafFn(l, c)) : this.hashFn(U.Buffer.concat([this.bufferify(l), c]))
                }
                hashBranch(l, c, x) {
                    return this.hashBranchFn ? this.bufferify(this.hashBranchFn(l, c, x)) : this.hashFn(U.Buffer.concat([this.bufferify(l), this.bufferify(c), this.bufferify(x)]))
                }
                getPeaks() {
                    let l = this.getPeakIndexes(this.width),
                        c = [];
                    for (let x = 0; x < l.length; x++) c[x] = this.hashes[l[x]];
                    return c
                }
                getLeafIndex(l) {
                    return l % 2 == 1 ? this.getSize(l) : this.getSize(l - 1) + 1
                }
                getPeakIndexes(l) {
                    let c = this.numOfPeaks(l),
                        x = [],
                        N = 0,
                        U = 0;
                    for (let Z = 255; Z > 0 && ((l & 1 << Z - 1) == 0 || (U = U + (1 << Z) - 1, x[N++] = U, !(x.length >= c))); Z--);
                    if (N !== x.length) throw Error("invalid bit calculation");
                    return x
                }
                numOfPeaks(l) {
                    let c = l,
                        x = 0;
                    for (; c > 0;) c % 2 == 1 && x++, c >>= 1;
                    return x
                }
                peakBagging(l, c) {
                    let x = this.getSize(l);
                    if (this.numOfPeaks(l) !== c.length) throw Error("received invalid number of peaks");
                    return 0 !== l || c.length ? this.peakBaggingFn ? this.bufferify(this.peakBaggingFn(x, c)) : this.hashFn(U.Buffer.concat([this.bufferify(x), ...c.map(this.bufferify)])) : U.Buffer.alloc(0)
                }
                getSize(l) {
                    return (l << 1) - this.numOfPeaks(l)
                }
                getRoot() {
                    return this.root
                }
                getHexRoot() {
                    return this.bufferToHex(this.getRoot())
                }
                getNode(l) {
                    return this.hashes[l]
                }
                mountainHeight(l) {
                    let c = 1;
                    for (; 1 << c <= l + c;) c++;
                    return c - 1
                }
                heightAt(l) {
                    let c = l,
                        x = 0,
                        N = 0;
                    for (; c > x;) c -= (1 << N) - 1, x = (1 << (N = this.mountainHeight(c))) - 1;
                    return N - (x - c)
                }
                isLeaf(l) {
                    return 1 === this.heightAt(l)
                }
                getChildren(l) {
                    let c = l - (1 << this.heightAt(l) - 1),
                        x = l - 1;
                    if (c === x) throw Error("not a parent");
                    return [c, x]
                }
                getMerkleProof(l) {
                    if (l > this.size) throw Error("out of range");
                    if (!this.isLeaf(l)) throw Error("not a leaf");
                    let c = this.root,
                        x = this.width,
                        N = this.getPeakIndexes(this.width),
                        U = [],
                        Z = 0;
                    for (let c = 0; c < N.length; c++) U[c] = this.hashes[N[c]], N[c] >= l && 0 === Z && (Z = N[c]);
                    let $ = 0,
                        Y = 0,
                        q = this.heightAt(Z),
                        J = [];
                    for (; Z !== l;) q--, [$, Y] = this.getChildren(Z), Z = l <= $ ? $ : Y, J[q - 1] = this.hashes[l <= $ ? Y : $];
                    return {
                        root: c,
                        width: x,
                        peakBagging: U,
                        siblings: J
                    }
                }
                verify(l, c, x, N, U, Z) {
                    let $, Y;
                    N = this.bufferify(N);
                    let q = this.getSize(c);
                    if (q < x) throw Error("index is out of range");
                    if (!l.equals(this.peakBagging(c, U))) throw Error("invalid root hash from the peaks");
                    let J = 0,
                        X = this.getPeakIndexes(c);
                    for (let l = 0; l < X.length; l++)
                        if (X[l] >= x) {
                            $ = U[l], J = X[l];
                            break
                        }
                    if (!$) throw Error("target not found");
                    let en = Z.length + 1,
                        er = Array(en),
                        ea = 0,
                        eo = 0;
                    for (; en > 0 && (er[--en] = J, J !== x);)[ea, eo] = this.getChildren(J), J = x > ea ? eo : ea;
                    for (; en < er.length;) J = er[en], Y = 0 === en ? this.hashLeaf(J, this.hashFn(N)) : J - 1 === er[en - 1] ? this.hashBranch(J, Z[en - 1], Y) : this.hashBranch(J, Y, Z[en - 1]), en++;
                    if (!Y.equals($)) throw Error("hashed peak is invalid");
                    return !0
                }
                peaksToPeakMap(l, c) {
                    let x = {},
                        N = 0,
                        U = c.length;
                    for (let Z = 1; Z <= 32; Z++) N = 32 - Z, (l & 1 << Z - 1) != 0 ? x[N] = c[--U] : x[N] = 0;
                    if (0 !== U) throw Error("invalid number of peaks");
                    return x
                }
                peakMapToPeaks(l, c) {
                    let x = this.numOfPeaks(l),
                        N = Array(x),
                        U = 0;
                    for (let l = 0; l < 32; l++) 0 !== c[l] && (N[U++] = c[l]);
                    if (U !== x) throw Error("invalid number of peaks");
                    return N
                }
                peakUpdate(l, c, x) {
                    let N = {},
                        U = l + 1,
                        Z = this.getLeafIndex(U),
                        $ = this.hashLeaf(Z, x),
                        Y = 0,
                        q = 0,
                        J = !1,
                        X = !1,
                        en = !1;
                    for (let x = 1; x <= 32; x++) Y = 32 - x, en ? N[Y] = c[Y] : (J = (l & (q = 1 << x - 1)) != 0, X = (U & q) != 0, Z++, J && ($ = this.hashBranch(Z, c[Y], $)), X ? (J ? N[Y] = c[Y] : N[Y] = $, en = !0) : N[Y] = 0);
                    return N
                }
                rollUp(l, c, x, N) {
                    if (!l.equals(this.peakBagging(c, x))) throw Error("invalid root hash from the peaks");
                    let U = c,
                        Z = this.peaksToPeakMap(c, x);
                    for (let l = 0; l < N.length; l++) Z = this.peakUpdate(U, Z, N[l]), U++;
                    return this.peakBagging(U, this.peakMapToPeaks(U, Z))
                }
                _getOrCreateNode(l) {
                    if (l > this.size) throw Error("out of range");
                    if (!this.hashes[l]) {
                        let [c, x] = this.getChildren(l), N = this._getOrCreateNode(c), U = this._getOrCreateNode(x);
                        this.hashes[l] = this.hashBranch(l, N, U)
                    }
                    return this.hashes[l]
                }
            };
            c.MerkleMountainRange = MerkleMountainRange, c.default = MerkleMountainRange
        },
        71707: function(l, c, x) {
            "use strict";
            var N = this && this.__importDefault || function(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            };
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.MerkleTree = void 0;
            let U = x(67133),
                Z = N(x(78133)),
                $ = N(x(83303)),
                Y = N(x(841)),
                q = N(x(61755));
            let MerkleTree = class MerkleTree extends q.default {
                constructor(l, c = $.default, x = {}) {
                    if (super(), this.duplicateOdd = !1, this.hashLeaves = !1, this.isBitcoinTree = !1, this.leaves = [], this.layers = [], this.sortLeaves = !1, this.sortPairs = !1, this.sort = !1, this.fillDefaultHash = null, this.isBitcoinTree = !!x.isBitcoinTree, this.hashLeaves = !!x.hashLeaves, this.sortLeaves = !!x.sortLeaves, this.sortPairs = !!x.sortPairs, x.fillDefaultHash) {
                        if ("function" == typeof x.fillDefaultHash) this.fillDefaultHash = x.fillDefaultHash;
                        else if (U.Buffer.isBuffer(x.fillDefaultHash) || "string" == typeof x.fillDefaultHash) this.fillDefaultHash = (l, c) => x.fillDefaultHash;
                        else throw Error('method "fillDefaultHash" must be a function, Buffer, or string')
                    }
                    this.sort = !!x.sort, this.sort && (this.sortLeaves = !0, this.sortPairs = !0), this.duplicateOdd = !!x.duplicateOdd, this.hashFn = this.bufferifyFn(c), this.processLeaves(l)
                }
                processLeaves(l) {
                    if (this.hashLeaves && (l = l.map(this.hashFn)), this.leaves = l.map(this.bufferify), this.sortLeaves && (this.leaves = this.leaves.sort(U.Buffer.compare)), this.fillDefaultHash)
                        for (let l = 0; l < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); l++) l >= this.leaves.length && this.leaves.push(this.bufferify(this.fillDefaultHash(l, this.hashFn)));
                    this.layers = [this.leaves], this._createHashes(this.leaves)
                }
                _createHashes(l) {
                    for (; l.length > 1;) {
                        let c = this.layers.length;
                        this.layers.push([]);
                        for (let x = 0; x < l.length; x += 2) {
                            if (x + 1 === l.length && l.length % 2 == 1) {
                                let N = l[l.length - 1],
                                    $ = N;
                                if (this.isBitcoinTree) {
                                    N = U.Buffer.concat([Z.default(N), Z.default(N)]), $ = this.hashFn(N), $ = Z.default(this.hashFn($)), this.layers[c].push($);
                                    continue
                                }
                                if (this.duplicateOdd);
                                else {
                                    this.layers[c].push(l[x]);
                                    continue
                                }
                            }
                            let N = l[x],
                                $ = x + 1 === l.length ? N : l[x + 1],
                                Y = null,
                                q = null;
                            q = this.isBitcoinTree ? [Z.default(N), Z.default($)] : [N, $], this.sortPairs && q.sort(U.Buffer.compare), Y = U.Buffer.concat(q);
                            let J = this.hashFn(Y);
                            this.isBitcoinTree && (J = Z.default(this.hashFn(J))), this.layers[c].push(J)
                        }
                        l = this.layers[c]
                    }
                }
                addLeaf(l, c = !1) {
                    c && (l = this.hashFn(l)), this.processLeaves(this.leaves.concat(l))
                }
                addLeaves(l, c = !1) {
                    c && (l = l.map(this.hashFn)), this.processLeaves(this.leaves.concat(l))
                }
                getLeaves(l) {
                    return Array.isArray(l) ? (this.hashLeaves && (l = l.map(this.hashFn), this.sortLeaves && (l = l.sort(U.Buffer.compare))), this.leaves.filter(c => -1 !== this._bufferIndexOf(l, c))) : this.leaves
                }
                getLeaf(l) {
                    return l < 0 || l > this.leaves.length - 1 ? U.Buffer.from([]) : this.leaves[l]
                }
                getLeafIndex(l) {
                    l = this.bufferify(l);
                    let c = this.getLeaves();
                    for (let x = 0; x < c.length; x++) {
                        let N = c[x];
                        if (N.equals(l)) return x
                    }
                    return -1
                }
                getLeafCount() {
                    return this.leaves.length
                }
                getHexLeaves() {
                    return this.leaves.map(l => this.bufferToHex(l))
                }
                static marshalLeaves(l) {
                    return JSON.stringify(l.map(l => MerkleTree.bufferToHex(l)), null, 2)
                }
                static unmarshalLeaves(l) {
                    let c = null;
                    if ("string" == typeof l) c = JSON.parse(l);
                    else if (l instanceof Object) c = l;
                    else throw Error("Expected type of string or object");
                    if (!c) return [];
                    if (!Array.isArray(c)) throw Error("Expected JSON string to be array");
                    return c.map(MerkleTree.bufferify)
                }
                getLayers() {
                    return this.layers
                }
                getHexLayers() {
                    return this.layers.reduce((l, c) => (Array.isArray(c) ? l.push(c.map(l => this.bufferToHex(l))) : l.push(c), l), [])
                }
                getLayersFlat() {
                    let l = this.layers.reduce((l, c) => (Array.isArray(c) ? l.unshift(...c) : l.unshift(c), l), []);
                    return l.unshift(U.Buffer.from([0])), l
                }
                getHexLayersFlat() {
                    return this.getLayersFlat().map(l => this.bufferToHex(l))
                }
                getLayerCount() {
                    return this.getLayers().length
                }
                getRoot() {
                    return 0 === this.layers.length ? U.Buffer.from([]) : this.layers[this.layers.length - 1][0] || U.Buffer.from([])
                }
                getHexRoot() {
                    return this.bufferToHex(this.getRoot())
                }
                getProof(l, c) {
                    if (void 0 === l) throw Error("leaf is required");
                    l = this.bufferify(l);
                    let x = [];
                    if (!Number.isInteger(c)) {
                        c = -1;
                        for (let x = 0; x < this.leaves.length; x++) 0 === U.Buffer.compare(l, this.leaves[x]) && (c = x)
                    }
                    if (c <= -1) return [];
                    for (let l = 0; l < this.layers.length; l++) {
                        let N = this.layers[l],
                            U = c % 2,
                            Z = U ? c - 1 : this.isBitcoinTree && c === N.length - 1 && l < this.layers.length - 1 ? c : c + 1;
                        Z < N.length && x.push({
                            position: U ? "left" : "right",
                            data: N[Z]
                        }), c = c / 2 | 0
                    }
                    return x
                }
                getHexProof(l, c) {
                    return this.getProof(l, c).map(l => this.bufferToHex(l.data))
                }
                getPositionalHexProof(l, c) {
                    return this.getProof(l, c).map(l => ["left" === l.position ? 0 : 1, this.bufferToHex(l.data)])
                }
                static marshalProof(l) {
                    let c = l.map(l => "string" == typeof l ? l : U.Buffer.isBuffer(l) ? MerkleTree.bufferToHex(l) : {
                        position: l.position,
                        data: MerkleTree.bufferToHex(l.data)
                    });
                    return JSON.stringify(c, null, 2)
                }
                static unmarshalProof(l) {
                    let c = null;
                    if ("string" == typeof l) c = JSON.parse(l);
                    else if (l instanceof Object) c = l;
                    else throw Error("Expected type of string or object");
                    if (!c) return [];
                    if (!Array.isArray(c)) throw Error("Expected JSON string to be array");
                    return c.map(l => {
                        if ("string" == typeof l) return MerkleTree.bufferify(l);
                        if (l instanceof Object) return {
                            position: l.position,
                            data: MerkleTree.bufferify(l.data)
                        };
                        throw Error("Expected item to be of type string or object")
                    })
                }
                getProofIndices(l, c) {
                    let x = Math.pow(2, c),
                        N = new Set;
                    for (let c of l) {
                        let l = x + c;
                        for (; l > 1;) N.add(1 ^ l), l = l / 2 | 0
                    }
                    let U = l.map(l => x + l),
                        Z = Array.from(N).sort((l, c) => l - c).reverse();
                    N = U.concat(Z);
                    let $ = new Set,
                        Y = [];
                    for (let l of N)
                        if (!$.has(l))
                            for (Y.push(l); l > 1 && ($.add(l), $.has(1 ^ l));) l = l / 2 | 0;
                    return Y.filter(c => !l.includes(c - x))
                }
                getProofIndicesForUnevenTree(l, c) {
                    let x = Math.ceil(Math.log2(c)),
                        N = [];
                    for (let l = 0; l < x; l++) {
                        let x = c % 2 != 0;
                        x && N.push({
                            index: l,
                            leavesCount: c
                        }), c = Math.ceil(c / 2)
                    }
                    let U = [],
                        Z = l;
                    for (let l = 0; l < x; l++) {
                        let c = Z.map(l => l % 2 == 0 ? l + 1 : l - 1),
                            x = c.filter(l => !Z.includes(l)),
                            $ = N.find(({
                                index: c
                            }) => c === l);
                        $ && Z.includes($.leavesCount - 1) && (x = x.slice(0, -1)), U.push(x), Z = [...new Set(Z.map(l => l % 2 == 0 ? l / 2 : l % 2 == 0 ? (l + 1) / 2 : (l - 1) / 2))]
                    }
                    return U
                }
                getMultiProof(l, c) {
                    c || (c = l, l = this.getLayersFlat());
                    let x = this.isUnevenTree();
                    if (x && c.every(Number.isInteger)) return this.getMultiProofForUnevenTree(c);
                    if (!c.every(Number.isInteger)) {
                        let l = c;
                        this.sortPairs && (l = l.sort(U.Buffer.compare));
                        let x = l.map(l => this._bufferIndexOf(this.leaves, l)).sort((l, c) => l === c ? 0 : l > c ? 1 : -1);
                        if (!x.every(l => -1 !== l)) throw Error("Element does not exist in Merkle tree");
                        let N = [],
                            Z = [],
                            $ = [];
                        for (let l = 0; l < this.layers.length; l++) {
                            let c = this.layers[l];
                            for (let l = 0; l < x.length; l++) {
                                let U = x[l],
                                    Y = this._getPairNode(c, U);
                                N.push(c[U]), Y && Z.push(Y), $.push(U / 2 | 0)
                            }
                            x = $.filter((l, c, x) => x.indexOf(l) === c), $ = []
                        }
                        return Z.filter(l => !N.includes(l))
                    }
                    return this.getProofIndices(c, this._log2(l.length / 2 | 0)).map(c => l[c])
                }
                getMultiProofForUnevenTree(l, c) {
                    c || (c = l, l = this.getLayers());
                    let x = [],
                        N = c;
                    for (let c of l) {
                        let l = [];
                        for (let x of N) {
                            if (x % 2 == 0) {
                                let U = x + 1;
                                if (!N.includes(U) && c[U]) {
                                    l.push(c[U]);
                                    continue
                                }
                            }
                            let U = x - 1;
                            if (!N.includes(U) && c[U]) {
                                l.push(c[U]);
                                continue
                            }
                        }
                        x = x.concat(l);
                        let U = new Set;
                        for (let l of N) {
                            if (l % 2 == 0) {
                                U.add(l / 2);
                                continue
                            }
                            if (l % 2 == 0) {
                                U.add((l + 1) / 2);
                                continue
                            }
                            U.add((l - 1) / 2)
                        }
                        N = Array.from(U)
                    }
                    return x
                }
                getHexMultiProof(l, c) {
                    return this.getMultiProof(l, c).map(l => this.bufferToHex(l))
                }
                getProofFlags(l, c) {
                    let x;
                    if (!Array.isArray(l) || l.length <= 0) throw Error("Invalid Inputs!");
                    if (!(x = l.every(Number.isInteger) ? l.sort((l, c) => l === c ? 0 : l > c ? 1 : -1) : l.map(l => this._bufferIndexOf(this.leaves, l)).sort((l, c) => l === c ? 0 : l > c ? 1 : -1)).every(l => -1 !== l)) throw Error("Element does not exist in Merkle tree");
                    let N = c.map(l => this.bufferify(l)),
                        U = [],
                        Z = [];
                    for (let l = 0; l < this.layers.length; l++) {
                        let c = this.layers[l];
                        x = x.reduce((l, x) => {
                            let $ = U.includes(c[x]);
                            if (!$) {
                                let l = this._getPairNode(c, x),
                                    $ = N.includes(c[x]) || N.includes(l);
                                l && Z.push(!$), U.push(c[x]), U.push(l)
                            }
                            return l.push(x / 2 | 0), l
                        }, [])
                    }
                    return Z
                }
                verify(l, c, x) {
                    let N = this.bufferify(c);
                    if (x = this.bufferify(x), !Array.isArray(l) || !c || !x) return !1;
                    for (let c = 0; c < l.length; c++) {
                        let x = l[c],
                            $ = null,
                            Y = null;
                        if ("string" == typeof x) $ = this.bufferify(x), Y = !0;
                        else if (Array.isArray(x)) Y = 0 === x[0], $ = this.bufferify(x[1]);
                        else if (U.Buffer.isBuffer(x)) $ = x, Y = !0;
                        else if (x instanceof Object) $ = this.bufferify(x.data), Y = "left" === x.position;
                        else throw Error("Expected node to be of type string or object");
                        let q = [];
                        this.isBitcoinTree ? (q.push(Z.default(N)), q[Y ? "unshift" : "push"](Z.default($)), N = this.hashFn(U.Buffer.concat(q)), N = Z.default(this.hashFn(N))) : (this.sortPairs ? -1 === U.Buffer.compare(N, $) ? q.push(N, $) : q.push($, N) : (q.push(N), q[Y ? "unshift" : "push"]($)), N = this.hashFn(U.Buffer.concat(q)))
                    }
                    return 0 === U.Buffer.compare(N, x)
                }
                verifyMultiProof(l, c, x, N, Z) {
                    let $ = this.isUnevenTree();
                    if ($) return this.verifyMultiProofForUnevenTree(l, c, x, N, Z);
                    let Y = Math.ceil(Math.log2(N));
                    l = this.bufferify(l), x = x.map(l => this.bufferify(l)), Z = Z.map(l => this.bufferify(l));
                    let q = {};
                    for (let [l, N] of this._zip(c, x)) q[Math.pow(2, Y) + l] = N;
                    for (let [l, x] of this._zip(this.getProofIndices(c, Y), Z)) q[l] = x;
                    let J = Object.keys(q).map(l => +l).sort((l, c) => l - c);
                    J = J.slice(0, J.length - 1);
                    let X = 0;
                    for (; X < J.length;) {
                        let l = J[X];
                        if (l >= 2 && ({}).hasOwnProperty.call(q, 1 ^ l)) {
                            let c = [q[l - l % 2], q[l - l % 2 + 1]];
                            this.sortPairs && (c = c.sort(U.Buffer.compare));
                            let x = c[1] ? this.hashFn(U.Buffer.concat(c)) : c[0];
                            q[l / 2 | 0] = x, J.push(l / 2 | 0)
                        }
                        X += 1
                    }
                    return !c.length || ({}).hasOwnProperty.call(q, 1) && q[1].equals(l)
                }
                verifyMultiProofWithFlags(l, c, x, N) {
                    l = this.bufferify(l), c = c.map(this.bufferify), x = x.map(this.bufferify);
                    let Z = c.length,
                        $ = N.length,
                        Y = [],
                        q = 0,
                        J = 0,
                        X = 0;
                    for (let l = 0; l < $; l++) {
                        let $ = N[l] ? q < Z ? c[q++] : Y[J++] : x[X++],
                            en = q < Z ? c[q++] : Y[J++],
                            er = [$, en].sort(U.Buffer.compare);
                        Y[l] = this.hashFn(U.Buffer.concat(er))
                    }
                    return 0 === U.Buffer.compare(Y[$ - 1], l)
                }
                verifyMultiProofForUnevenTree(l, c, x, N, U) {
                    l = this.bufferify(l), x = x.map(l => this.bufferify(l)), U = U.map(l => this.bufferify(l));
                    let Z = this.calculateRootForUnevenTree(c, x, N, U);
                    return l.equals(Z)
                }
                getDepth() {
                    return this.getLayers().length - 1
                }
                getLayersAsObject() {
                    let l = this.getLayers().map(l => l.map(l => this.bufferToHex(l, !1))),
                        c = [];
                    for (let x = 0; x < l.length; x++) {
                        let N = [];
                        for (let U = 0; U < l[x].length; U++) {
                            let Z = {
                                [l[x][U]]: null
                            };
                            if (c.length) {
                                Z[l[x][U]] = {};
                                let N = c.shift(),
                                    $ = Object.keys(N)[0];
                                if (Z[l[x][U]][$] = N[$], c.length) {
                                    let N = c.shift(),
                                        $ = Object.keys(N)[0];
                                    Z[l[x][U]][$] = N[$]
                                }
                            }
                            N.push(Z)
                        }
                        c.push(...N)
                    }
                    return c[0]
                }
                static verify(l, c, x, N = $.default, U = {}) {
                    let Z = new MerkleTree([], N, U);
                    return Z.verify(l, c, x)
                }
                static getMultiProof(l, c) {
                    let x = new MerkleTree([]);
                    return x.getMultiProof(l, c)
                }
                resetTree() {
                    this.leaves = [], this.layers = []
                }
                _getPairNode(l, c) {
                    let x = c % 2 == 0 ? c + 1 : c - 1;
                    return x < l.length ? l[x] : null
                }
                _toTreeString() {
                    let l = this.getLayersAsObject();
                    return Y.default.asTree(l, !0)
                }
                toString() {
                    return this._toTreeString()
                }
                isUnevenTree(l) {
                    let c = (null == l ? void 0 : l.length) || this.getDepth();
                    return !this.isPowOf2(c)
                }
                isPowOf2(l) {
                    return l && !(l & l - 1)
                }
                calculateRootForUnevenTree(l, c, x, N) {
                    let Z = this._zip(l, c).sort(([l], [c]) => l - c),
                        $ = Z.map(([l]) => l),
                        Y = this.getProofIndicesForUnevenTree($, x),
                        q = 0,
                        J = [];
                    for (let l = 0; l < Y.length; l++) {
                        let c = Y[l],
                            x = q;
                        q += c.length, J[l] = this._zip(c, N.slice(x, q))
                    }
                    let X = [Z];
                    for (let l = 0; l < J.length; l++) {
                        let c = J[l].concat(X[l]).sort(([l], [c]) => l - c).map(([, l]) => l),
                            x = X[l].map(([l]) => l),
                            N = [...new Set(x.map(l => l % 2 == 0 ? l / 2 : l % 2 == 0 ? (l + 1) / 2 : (l - 1) / 2))],
                            Z = [];
                        for (let l = 0; l < N.length; l++) {
                            let x = N[l],
                                $ = c[2 * l],
                                Y = c[2 * l + 1],
                                q = Y ? this.hashFn(U.Buffer.concat([$, Y])) : $;
                            Z.push([x, q])
                        }
                        X.push(Z)
                    }
                    return X[X.length - 1][0][1]
                }
            };
            c.MerkleTree = MerkleTree, "undefined" != typeof window && (window.MerkleTree = MerkleTree), c.default = MerkleTree
        },
        41650: function(l, c, x) {
            "use strict";
            var N = this && this.__importDefault || function(l) {
                return l && l.__esModule ? l : {
                    default: l
                }
            };
            Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.MerkleTree = void 0;
            let U = N(x(71707));
            c.MerkleTree = U.default;
            var Z = x(5126);
            Object.defineProperty(c, "MerkleMountainRange", {
                enumerable: !0,
                get: function() {
                    return Z.MerkleMountainRange
                }
            }), c.default = U.default
        },
        68458: function(l, c, x) {
            var N, U, Z, $, Y, q, J, X, en, er, ea, eo, el, ec, eu;
            l.exports = (N = x(13686), x(55937), x(39589), x(40964), x(28980), U = N.lib.BlockCipher, Z = N.algo, $ = [], Y = [], q = [], J = [], X = [], en = [], er = [], ea = [], eo = [], el = [], function() {
                for (var l = [], c = 0; c < 256; c++) c < 128 ? l[c] = c << 1 : l[c] = c << 1 ^ 283;
                for (var x = 0, N = 0, c = 0; c < 256; c++) {
                    var U = N ^ N << 1 ^ N << 2 ^ N << 3 ^ N << 4;
                    U = U >>> 8 ^ 255 & U ^ 99, $[x] = U, Y[U] = x;
                    var Z = l[x],
                        ec = l[Z],
                        eu = l[ec],
                        ed = 257 * l[U] ^ 16843008 * U;
                    q[x] = ed << 24 | ed >>> 8, J[x] = ed << 16 | ed >>> 16, X[x] = ed << 8 | ed >>> 24, en[x] = ed;
                    var ed = 16843009 * eu ^ 65537 * ec ^ 257 * Z ^ 16843008 * x;
                    er[U] = ed << 24 | ed >>> 8, ea[U] = ed << 16 | ed >>> 16, eo[U] = ed << 8 | ed >>> 24, el[U] = ed, x ? (x = Z ^ l[l[l[eu ^ Z]]], N ^= l[l[N]]) : x = N = 1
                }
            }(), ec = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], eu = Z.AES = U.extend({
                _doReset: function() {
                    if (!this._nRounds || this._keyPriorReset !== this._key) {
                        for (var l = this._keyPriorReset = this._key, c = l.words, x = l.sigBytes / 4, N = ((this._nRounds = x + 6) + 1) * 4, U = this._keySchedule = [], Z = 0; Z < N; Z++)
                            if (Z < x) U[Z] = c[Z];
                            else {
                                var Y = U[Z - 1];
                                Z % x ? x > 6 && Z % x == 4 && (Y = $[Y >>> 24] << 24 | $[Y >>> 16 & 255] << 16 | $[Y >>> 8 & 255] << 8 | $[255 & Y]) : Y = ($[(Y = Y << 8 | Y >>> 24) >>> 24] << 24 | $[Y >>> 16 & 255] << 16 | $[Y >>> 8 & 255] << 8 | $[255 & Y]) ^ ec[Z / x | 0] << 24, U[Z] = U[Z - x] ^ Y
                            }
                        for (var q = this._invKeySchedule = [], J = 0; J < N; J++) {
                            var Z = N - J;
                            if (J % 4) var Y = U[Z];
                            else var Y = U[Z - 4];
                            J < 4 || Z <= 4 ? q[J] = Y : q[J] = er[$[Y >>> 24]] ^ ea[$[Y >>> 16 & 255]] ^ eo[$[Y >>> 8 & 255]] ^ el[$[255 & Y]]
                        }
                    }
                },
                encryptBlock: function(l, c) {
                    this._doCryptBlock(l, c, this._keySchedule, q, J, X, en, $)
                },
                decryptBlock: function(l, c) {
                    var x = l[c + 1];
                    l[c + 1] = l[c + 3], l[c + 3] = x, this._doCryptBlock(l, c, this._invKeySchedule, er, ea, eo, el, Y);
                    var x = l[c + 1];
                    l[c + 1] = l[c + 3], l[c + 3] = x
                },
                _doCryptBlock: function(l, c, x, N, U, Z, $, Y) {
                    for (var q = this._nRounds, J = l[c] ^ x[0], X = l[c + 1] ^ x[1], en = l[c + 2] ^ x[2], er = l[c + 3] ^ x[3], ea = 4, eo = 1; eo < q; eo++) {
                        var el = N[J >>> 24] ^ U[X >>> 16 & 255] ^ Z[en >>> 8 & 255] ^ $[255 & er] ^ x[ea++],
                            ec = N[X >>> 24] ^ U[en >>> 16 & 255] ^ Z[er >>> 8 & 255] ^ $[255 & J] ^ x[ea++],
                            eu = N[en >>> 24] ^ U[er >>> 16 & 255] ^ Z[J >>> 8 & 255] ^ $[255 & X] ^ x[ea++],
                            ed = N[er >>> 24] ^ U[J >>> 16 & 255] ^ Z[X >>> 8 & 255] ^ $[255 & en] ^ x[ea++];
                        J = el, X = ec, en = eu, er = ed
                    }
                    var el = (Y[J >>> 24] << 24 | Y[X >>> 16 & 255] << 16 | Y[en >>> 8 & 255] << 8 | Y[255 & er]) ^ x[ea++],
                        ec = (Y[X >>> 24] << 24 | Y[en >>> 16 & 255] << 16 | Y[er >>> 8 & 255] << 8 | Y[255 & J]) ^ x[ea++],
                        eu = (Y[en >>> 24] << 24 | Y[er >>> 16 & 255] << 16 | Y[J >>> 8 & 255] << 8 | Y[255 & X]) ^ x[ea++],
                        ed = (Y[er >>> 24] << 24 | Y[J >>> 16 & 255] << 16 | Y[X >>> 8 & 255] << 8 | Y[255 & en]) ^ x[ea++];
                    l[c] = el, l[c + 1] = ec, l[c + 2] = eu, l[c + 3] = ed
                },
                keySize: 8
            }), N.AES = U._createHelper(eu), N.AES)
        },
        28980: function(l, c, x) {
            var N, U, Z, $, Y, q, J, X, en, er, ea, eo, el, ec, eu, ed, ep, eh;
            l.exports = (N = x(13686), x(40964), void(N.lib.Cipher || (Z = (U = N.lib).Base, $ = U.WordArray, Y = U.BufferedBlockAlgorithm, (q = N.enc).Utf8, J = q.Base64, X = N.algo.EvpKDF, en = U.Cipher = Y.extend({
                cfg: Z.extend(),
                createEncryptor: function(l, c) {
                    return this.create(this._ENC_XFORM_MODE, l, c)
                },
                createDecryptor: function(l, c) {
                    return this.create(this._DEC_XFORM_MODE, l, c)
                },
                init: function(l, c, x) {
                    this.cfg = this.cfg.extend(x), this._xformMode = l, this._key = c, this.reset()
                },
                reset: function() {
                    Y.reset.call(this), this._doReset()
                },
                process: function(l) {
                    return this._append(l), this._process()
                },
                finalize: function(l) {
                    return l && this._append(l), this._doFinalize()
                },
                keySize: 4,
                ivSize: 4,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: function() {
                    function selectCipherStrategy(l) {
                        return "string" == typeof l ? eh : ed
                    }
                    return function(l) {
                        return {
                            encrypt: function(c, x, N) {
                                return selectCipherStrategy(x).encrypt(l, c, x, N)
                            },
                            decrypt: function(c, x, N) {
                                return selectCipherStrategy(x).decrypt(l, c, x, N)
                            }
                        }
                    }
                }()
            }), U.StreamCipher = en.extend({
                _doFinalize: function() {
                    return this._process(!0)
                },
                blockSize: 1
            }), er = N.mode = {}, ea = U.BlockCipherMode = Z.extend({
                createEncryptor: function(l, c) {
                    return this.Encryptor.create(l, c)
                },
                createDecryptor: function(l, c) {
                    return this.Decryptor.create(l, c)
                },
                init: function(l, c) {
                    this._cipher = l, this._iv = c
                }
            }), eo = er.CBC = function() {
                var l = ea.extend();

                function xorBlock(l, c, x) {
                    var N = this._iv;
                    if (N) {
                        var U = N;
                        this._iv = void 0
                    } else var U = this._prevBlock;
                    for (var Z = 0; Z < x; Z++) l[c + Z] ^= U[Z]
                }
                return l.Encryptor = l.extend({
                    processBlock: function(l, c) {
                        var x = this._cipher,
                            N = x.blockSize;
                        xorBlock.call(this, l, c, N), x.encryptBlock(l, c), this._prevBlock = l.slice(c, c + N)
                    }
                }), l.Decryptor = l.extend({
                    processBlock: function(l, c) {
                        var x = this._cipher,
                            N = x.blockSize,
                            U = l.slice(c, c + N);
                        x.decryptBlock(l, c), xorBlock.call(this, l, c, N), this._prevBlock = U
                    }
                }), l
            }(), el = (N.pad = {}).Pkcs7 = {
                pad: function(l, c) {
                    for (var x = 4 * c, N = x - l.sigBytes % x, U = N << 24 | N << 16 | N << 8 | N, Z = [], Y = 0; Y < N; Y += 4) Z.push(U);
                    var q = $.create(Z, N);
                    l.concat(q)
                },
                unpad: function(l) {
                    var c = 255 & l.words[l.sigBytes - 1 >>> 2];
                    l.sigBytes -= c
                }
            }, U.BlockCipher = en.extend({
                cfg: en.cfg.extend({
                    mode: eo,
                    padding: el
                }),
                reset: function() {
                    en.reset.call(this);
                    var l = this.cfg,
                        c = l.iv,
                        x = l.mode;
                    if (this._xformMode == this._ENC_XFORM_MODE) var N = x.createEncryptor;
                    else {
                        var N = x.createDecryptor;
                        this._minBufferSize = 1
                    }
                    this._mode && this._mode.__creator == N ? this._mode.init(this, c && c.words) : (this._mode = N.call(x, this, c && c.words), this._mode.__creator = N)
                },
                _doProcessBlock: function(l, c) {
                    this._mode.processBlock(l, c)
                },
                _doFinalize: function() {
                    var l = this.cfg.padding;
                    if (this._xformMode == this._ENC_XFORM_MODE) {
                        l.pad(this._data, this.blockSize);
                        var c = this._process(!0)
                    } else {
                        var c = this._process(!0);
                        l.unpad(c)
                    }
                    return c
                },
                blockSize: 4
            }), ec = U.CipherParams = Z.extend({
                init: function(l) {
                    this.mixIn(l)
                },
                toString: function(l) {
                    return (l || this.formatter).stringify(this)
                }
            }), eu = (N.format = {}).OpenSSL = {
                stringify: function(l) {
                    var c = l.ciphertext,
                        x = l.salt;
                    if (x) var N = $.create([1398893684, 1701076831]).concat(x).concat(c);
                    else var N = c;
                    return N.toString(J)
                },
                parse: function(l) {
                    var c = J.parse(l),
                        x = c.words;
                    if (1398893684 == x[0] && 1701076831 == x[1]) {
                        var N = $.create(x.slice(2, 4));
                        x.splice(0, 4), c.sigBytes -= 16
                    }
                    return ec.create({
                        ciphertext: c,
                        salt: N
                    })
                }
            }, ed = U.SerializableCipher = Z.extend({
                cfg: Z.extend({
                    format: eu
                }),
                encrypt: function(l, c, x, N) {
                    N = this.cfg.extend(N);
                    var U = l.createEncryptor(x, N),
                        Z = U.finalize(c),
                        $ = U.cfg;
                    return ec.create({
                        ciphertext: Z,
                        key: x,
                        iv: $.iv,
                        algorithm: l,
                        mode: $.mode,
                        padding: $.padding,
                        blockSize: l.blockSize,
                        formatter: N.format
                    })
                },
                decrypt: function(l, c, x, N) {
                    return N = this.cfg.extend(N), c = this._parse(c, N.format), l.createDecryptor(x, N).finalize(c.ciphertext)
                },
                _parse: function(l, c) {
                    return "string" == typeof l ? c.parse(l, this) : l
                }
            }), ep = (N.kdf = {}).OpenSSL = {
                execute: function(l, c, x, N) {
                    N || (N = $.random(8));
                    var U = X.create({
                            keySize: c + x
                        }).compute(l, N),
                        Z = $.create(U.words.slice(c), 4 * x);
                    return U.sigBytes = 4 * c, ec.create({
                        key: U,
                        iv: Z,
                        salt: N
                    })
                }
            }, eh = U.PasswordBasedCipher = ed.extend({
                cfg: ed.cfg.extend({
                    kdf: ep
                }),
                encrypt: function(l, c, x, N) {
                    var U = (N = this.cfg.extend(N)).kdf.execute(x, l.keySize, l.ivSize);
                    N.iv = U.iv;
                    var Z = ed.encrypt.call(this, l, c, U.key, N);
                    return Z.mixIn(U), Z
                },
                decrypt: function(l, c, x, N) {
                    N = this.cfg.extend(N), c = this._parse(c, N.format);
                    var U = N.kdf.execute(x, l.keySize, l.ivSize, c.salt);
                    return N.iv = U.iv, ed.decrypt.call(this, l, c, U.key, N)
                }
            }))))
        },
        13686: function(l, c) {
            var x, N, U, Z, $, Y, q, J, X, en, er, ea, eo;
            l.exports = eo || (x = Math, N = Object.create || function() {
                function F() {}
                return function(l) {
                    var c;
                    return F.prototype = l, c = new F, F.prototype = null, c
                }
            }(), $ = (Z = (U = {}).lib = {}).Base = {
                extend: function(l) {
                    var c = N(this);
                    return l && c.mixIn(l), c.hasOwnProperty("init") && this.init !== c.init || (c.init = function() {
                        c.$super.init.apply(this, arguments)
                    }), c.init.prototype = c, c.$super = this, c
                },
                create: function() {
                    var l = this.extend();
                    return l.init.apply(l, arguments), l
                },
                init: function() {},
                mixIn: function(l) {
                    for (var c in l) l.hasOwnProperty(c) && (this[c] = l[c]);
                    l.hasOwnProperty("toString") && (this.toString = l.toString)
                },
                clone: function() {
                    return this.init.prototype.extend(this)
                }
            }, Y = Z.WordArray = $.extend({
                init: function(l, c) {
                    l = this.words = l || [], void 0 != c ? this.sigBytes = c : this.sigBytes = 4 * l.length
                },
                toString: function(l) {
                    return (l || J).stringify(this)
                },
                concat: function(l) {
                    var c = this.words,
                        x = l.words,
                        N = this.sigBytes,
                        U = l.sigBytes;
                    if (this.clamp(), N % 4)
                        for (var Z = 0; Z < U; Z++) {
                            var $ = x[Z >>> 2] >>> 24 - Z % 4 * 8 & 255;
                            c[N + Z >>> 2] |= $ << 24 - (N + Z) % 4 * 8
                        } else
                            for (var Z = 0; Z < U; Z += 4) c[N + Z >>> 2] = x[Z >>> 2];
                    return this.sigBytes += U, this
                },
                clamp: function() {
                    var l = this.words,
                        c = this.sigBytes;
                    l[c >>> 2] &= 4294967295 << 32 - c % 4 * 8, l.length = x.ceil(c / 4)
                },
                clone: function() {
                    var l = $.clone.call(this);
                    return l.words = this.words.slice(0), l
                },
                random: function(l) {
                    for (var c, N = [], r = function(l) {
                            var l = l,
                                c = 987654321;
                            return function() {
                                var N = ((c = 36969 * (65535 & c) + (c >> 16) & 4294967295) << 16) + (l = 18e3 * (65535 & l) + (l >> 16) & 4294967295) & 4294967295;
                                return N /= 4294967296, (N += .5) * (x.random() > .5 ? 1 : -1)
                            }
                        }, U = 0; U < l; U += 4) {
                        var Z = r(4294967296 * (c || x.random()));
                        c = 987654071 * Z(), N.push(4294967296 * Z() | 0)
                    }
                    return new Y.init(N, l)
                }
            }), J = (q = U.enc = {}).Hex = {
                stringify: function(l) {
                    for (var c = l.words, x = l.sigBytes, N = [], U = 0; U < x; U++) {
                        var Z = c[U >>> 2] >>> 24 - U % 4 * 8 & 255;
                        N.push((Z >>> 4).toString(16)), N.push((15 & Z).toString(16))
                    }
                    return N.join("")
                },
                parse: function(l) {
                    for (var c = l.length, x = [], N = 0; N < c; N += 2) x[N >>> 3] |= parseInt(l.substr(N, 2), 16) << 24 - N % 8 * 4;
                    return new Y.init(x, c / 2)
                }
            }, X = q.Latin1 = {
                stringify: function(l) {
                    for (var c = l.words, x = l.sigBytes, N = [], U = 0; U < x; U++) {
                        var Z = c[U >>> 2] >>> 24 - U % 4 * 8 & 255;
                        N.push(String.fromCharCode(Z))
                    }
                    return N.join("")
                },
                parse: function(l) {
                    for (var c = l.length, x = [], N = 0; N < c; N++) x[N >>> 2] |= (255 & l.charCodeAt(N)) << 24 - N % 4 * 8;
                    return new Y.init(x, c)
                }
            }, en = q.Utf8 = {
                stringify: function(l) {
                    try {
                        return decodeURIComponent(escape(X.stringify(l)))
                    } catch (l) {
                        throw Error("Malformed UTF-8 data")
                    }
                },
                parse: function(l) {
                    return X.parse(unescape(encodeURIComponent(l)))
                }
            }, er = Z.BufferedBlockAlgorithm = $.extend({
                reset: function() {
                    this._data = new Y.init, this._nDataBytes = 0
                },
                _append: function(l) {
                    "string" == typeof l && (l = en.parse(l)), this._data.concat(l), this._nDataBytes += l.sigBytes
                },
                _process: function(l) {
                    var c = this._data,
                        N = c.words,
                        U = c.sigBytes,
                        Z = this.blockSize,
                        $ = U / (4 * Z),
                        q = ($ = l ? x.ceil($) : x.max((0 | $) - this._minBufferSize, 0)) * Z,
                        J = x.min(4 * q, U);
                    if (q) {
                        for (var X = 0; X < q; X += Z) this._doProcessBlock(N, X);
                        var en = N.splice(0, q);
                        c.sigBytes -= J
                    }
                    return new Y.init(en, J)
                },
                clone: function() {
                    var l = $.clone.call(this);
                    return l._data = this._data.clone(), l
                },
                _minBufferSize: 0
            }), Z.Hasher = er.extend({
                cfg: $.extend(),
                init: function(l) {
                    this.cfg = this.cfg.extend(l), this.reset()
                },
                reset: function() {
                    er.reset.call(this), this._doReset()
                },
                update: function(l) {
                    return this._append(l), this._process(), this
                },
                finalize: function(l) {
                    return l && this._append(l), this._doFinalize()
                },
                blockSize: 16,
                _createHelper: function(l) {
                    return function(c, x) {
                        return new l.init(x).finalize(c)
                    }
                },
                _createHmacHelper: function(l) {
                    return function(c, x) {
                        return new ea.HMAC.init(l, x).finalize(c)
                    }
                }
            }), ea = U.algo = {}, U)
        },
        55937: function(l, c, x) {
            var N, U;
            l.exports = (U = (N = x(13686)).lib.WordArray, N.enc.Base64 = {
                stringify: function(l) {
                    var c = l.words,
                        x = l.sigBytes,
                        N = this._map;
                    l.clamp();
                    for (var U = [], Z = 0; Z < x; Z += 3)
                        for (var $ = (c[Z >>> 2] >>> 24 - Z % 4 * 8 & 255) << 16 | (c[Z + 1 >>> 2] >>> 24 - (Z + 1) % 4 * 8 & 255) << 8 | c[Z + 2 >>> 2] >>> 24 - (Z + 2) % 4 * 8 & 255, Y = 0; Y < 4 && Z + .75 * Y < x; Y++) U.push(N.charAt($ >>> 6 * (3 - Y) & 63));
                    var q = N.charAt(64);
                    if (q)
                        for (; U.length % 4;) U.push(q);
                    return U.join("")
                },
                parse: function(l) {
                    var c = l.length,
                        x = this._map,
                        N = this._reverseMap;
                    if (!N) {
                        N = this._reverseMap = [];
                        for (var Z = 0; Z < x.length; Z++) N[x.charCodeAt(Z)] = Z
                    }
                    var $ = x.charAt(64);
                    if ($) {
                        var Y = l.indexOf($); - 1 !== Y && (c = Y)
                    }
                    return function(l, c, x) {
                        for (var N = [], Z = 0, $ = 0; $ < c; $++)
                            if ($ % 4) {
                                var Y = x[l.charCodeAt($ - 1)] << $ % 4 * 2,
                                    q = x[l.charCodeAt($)] >>> 6 - $ % 4 * 2;
                                N[Z >>> 2] |= (Y | q) << 24 - Z % 4 * 8, Z++
                            }
                        return U.create(N, Z)
                    }(l, c, N)
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            }, N.enc.Base64)
        },
        75454: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), function() {
                var l = N.lib.WordArray,
                    c = N.enc;

                function swapEndian(l) {
                    return l << 8 & 4278255360 | l >>> 8 & 16711935
                }
                c.Utf16 = c.Utf16BE = {
                    stringify: function(l) {
                        for (var c = l.words, x = l.sigBytes, N = [], U = 0; U < x; U += 2) {
                            var Z = c[U >>> 2] >>> 16 - U % 4 * 8 & 65535;
                            N.push(String.fromCharCode(Z))
                        }
                        return N.join("")
                    },
                    parse: function(c) {
                        for (var x = c.length, N = [], U = 0; U < x; U++) N[U >>> 1] |= c.charCodeAt(U) << 16 - U % 2 * 16;
                        return l.create(N, 2 * x)
                    }
                }, c.Utf16LE = {
                    stringify: function(l) {
                        for (var c = l.words, x = l.sigBytes, N = [], U = 0; U < x; U += 2) {
                            var Z = swapEndian(c[U >>> 2] >>> 16 - U % 4 * 8 & 65535);
                            N.push(String.fromCharCode(Z))
                        }
                        return N.join("")
                    },
                    parse: function(c) {
                        for (var x = c.length, N = [], U = 0; U < x; U++) N[U >>> 1] |= swapEndian(c.charCodeAt(U) << 16 - U % 2 * 16);
                        return l.create(N, 2 * x)
                    }
                }
            }(), N.enc.Utf16)
        },
        40964: function(l, c, x) {
            var N, U, Z, $, Y, q, J;
            l.exports = (N = x(13686), x(45666), x(24333), Z = (U = N.lib).Base, $ = U.WordArray, q = (Y = N.algo).MD5, J = Y.EvpKDF = Z.extend({
                cfg: Z.extend({
                    keySize: 4,
                    hasher: q,
                    iterations: 1
                }),
                init: function(l) {
                    this.cfg = this.cfg.extend(l)
                },
                compute: function(l, c) {
                    for (var x = this.cfg, N = x.hasher.create(), U = $.create(), Z = U.words, Y = x.keySize, q = x.iterations; Z.length < Y;) {
                        J && N.update(J);
                        var J = N.update(l).finalize(c);
                        N.reset();
                        for (var X = 1; X < q; X++) J = N.finalize(J), N.reset();
                        U.concat(J)
                    }
                    return U.sigBytes = 4 * Y, U
                }
            }), N.EvpKDF = function(l, c, x) {
                return J.create(x).compute(l, c)
            }, N.EvpKDF)
        },
        88049: function(l, c, x) {
            var N, U, Z;
            l.exports = (N = x(13686), x(28980), U = N.lib.CipherParams, Z = N.enc.Hex, N.format.Hex = {
                stringify: function(l) {
                    return l.ciphertext.toString(Z)
                },
                parse: function(l) {
                    var c = Z.parse(l);
                    return U.create({
                        ciphertext: c
                    })
                }
            }, N.format.Hex)
        },
        24333: function(l, c, x) {
            var N, U, Z;
            l.exports = void(U = (N = x(13686)).lib.Base, Z = N.enc.Utf8, N.algo.HMAC = U.extend({
                init: function(l, c) {
                    l = this._hasher = new l.init, "string" == typeof c && (c = Z.parse(c));
                    var x = l.blockSize,
                        N = 4 * x;
                    c.sigBytes > N && (c = l.finalize(c)), c.clamp();
                    for (var U = this._oKey = c.clone(), $ = this._iKey = c.clone(), Y = U.words, q = $.words, J = 0; J < x; J++) Y[J] ^= 1549556828, q[J] ^= 909522486;
                    U.sigBytes = $.sigBytes = N, this.reset()
                },
                reset: function() {
                    var l = this._hasher;
                    l.reset(), l.update(this._iKey)
                },
                update: function(l) {
                    return this._hasher.update(l), this
                },
                finalize: function(l) {
                    var c = this._hasher,
                        x = c.finalize(l);
                    return c.reset(), c.finalize(this._oKey.clone().concat(x))
                }
            }))
        },
        90302: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(68493), x(28169), x(75454), x(55937), x(39589), x(45666), x(83303), x(14689), x(43146), x(21762), x(37372), x(80211), x(24333), x(89551), x(40964), x(28980), x(78275), x(89985), x(21750), x(56910), x(87671), x(11592), x(50368), x(69497), x(95143), x(10540), x(88049), x(68458), x(55476), x(89510), x(79567), x(18272), N)
        },
        28169: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), function() {
                if ("function" == typeof ArrayBuffer) {
                    var l = N.lib.WordArray,
                        c = l.init;
                    (l.init = function(l) {
                        if (l instanceof ArrayBuffer && (l = new Uint8Array(l)), (l instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && l instanceof Uint8ClampedArray || l instanceof Int16Array || l instanceof Uint16Array || l instanceof Int32Array || l instanceof Uint32Array || l instanceof Float32Array || l instanceof Float64Array) && (l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength)), l instanceof Uint8Array) {
                            for (var x = l.byteLength, N = [], U = 0; U < x; U++) N[U >>> 2] |= l[U] << 24 - U % 4 * 8;
                            c.call(this, N, x)
                        } else c.apply(this, arguments)
                    }).prototype = l
                }
            }(), N.lib.WordArray)
        },
        39589: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), function(l) {
                var c = N.lib,
                    x = c.WordArray,
                    U = c.Hasher,
                    Z = N.algo,
                    $ = [];
                ! function() {
                    for (var c = 0; c < 64; c++) $[c] = 4294967296 * l.abs(l.sin(c + 1)) | 0
                }();
                var Y = Z.MD5 = U.extend({
                    _doReset: function() {
                        this._hash = new x.init([1732584193, 4023233417, 2562383102, 271733878])
                    },
                    _doProcessBlock: function(l, c) {
                        for (var x = 0; x < 16; x++) {
                            var N = c + x,
                                U = l[N];
                            l[N] = (U << 8 | U >>> 24) & 16711935 | (U << 24 | U >>> 8) & 4278255360
                        }
                        var Z = this._hash.words,
                            Y = l[c + 0],
                            q = l[c + 1],
                            J = l[c + 2],
                            X = l[c + 3],
                            en = l[c + 4],
                            er = l[c + 5],
                            ea = l[c + 6],
                            eo = l[c + 7],
                            el = l[c + 8],
                            ec = l[c + 9],
                            eu = l[c + 10],
                            ed = l[c + 11],
                            ep = l[c + 12],
                            eh = l[c + 13],
                            ey = l[c + 14],
                            ef = l[c + 15],
                            em = Z[0],
                            eg = Z[1],
                            eb = Z[2],
                            ev = Z[3];
                        em = FF(em, eg, eb, ev, Y, 7, $[0]), ev = FF(ev, em, eg, eb, q, 12, $[1]), eb = FF(eb, ev, em, eg, J, 17, $[2]), eg = FF(eg, eb, ev, em, X, 22, $[3]), em = FF(em, eg, eb, ev, en, 7, $[4]), ev = FF(ev, em, eg, eb, er, 12, $[5]), eb = FF(eb, ev, em, eg, ea, 17, $[6]), eg = FF(eg, eb, ev, em, eo, 22, $[7]), em = FF(em, eg, eb, ev, el, 7, $[8]), ev = FF(ev, em, eg, eb, ec, 12, $[9]), eb = FF(eb, ev, em, eg, eu, 17, $[10]), eg = FF(eg, eb, ev, em, ed, 22, $[11]), em = FF(em, eg, eb, ev, ep, 7, $[12]), ev = FF(ev, em, eg, eb, eh, 12, $[13]), eb = FF(eb, ev, em, eg, ey, 17, $[14]), eg = FF(eg, eb, ev, em, ef, 22, $[15]), em = GG(em, eg, eb, ev, q, 5, $[16]), ev = GG(ev, em, eg, eb, ea, 9, $[17]), eb = GG(eb, ev, em, eg, ed, 14, $[18]), eg = GG(eg, eb, ev, em, Y, 20, $[19]), em = GG(em, eg, eb, ev, er, 5, $[20]), ev = GG(ev, em, eg, eb, eu, 9, $[21]), eb = GG(eb, ev, em, eg, ef, 14, $[22]), eg = GG(eg, eb, ev, em, en, 20, $[23]), em = GG(em, eg, eb, ev, ec, 5, $[24]), ev = GG(ev, em, eg, eb, ey, 9, $[25]), eb = GG(eb, ev, em, eg, X, 14, $[26]), eg = GG(eg, eb, ev, em, el, 20, $[27]), em = GG(em, eg, eb, ev, eh, 5, $[28]), ev = GG(ev, em, eg, eb, J, 9, $[29]), eb = GG(eb, ev, em, eg, eo, 14, $[30]), eg = GG(eg, eb, ev, em, ep, 20, $[31]), em = HH(em, eg, eb, ev, er, 4, $[32]), ev = HH(ev, em, eg, eb, el, 11, $[33]), eb = HH(eb, ev, em, eg, ed, 16, $[34]), eg = HH(eg, eb, ev, em, ey, 23, $[35]), em = HH(em, eg, eb, ev, q, 4, $[36]), ev = HH(ev, em, eg, eb, en, 11, $[37]), eb = HH(eb, ev, em, eg, eo, 16, $[38]), eg = HH(eg, eb, ev, em, eu, 23, $[39]), em = HH(em, eg, eb, ev, eh, 4, $[40]), ev = HH(ev, em, eg, eb, Y, 11, $[41]), eb = HH(eb, ev, em, eg, X, 16, $[42]), eg = HH(eg, eb, ev, em, ea, 23, $[43]), em = HH(em, eg, eb, ev, ec, 4, $[44]), ev = HH(ev, em, eg, eb, ep, 11, $[45]), eb = HH(eb, ev, em, eg, ef, 16, $[46]), eg = HH(eg, eb, ev, em, J, 23, $[47]), em = II(em, eg, eb, ev, Y, 6, $[48]), ev = II(ev, em, eg, eb, eo, 10, $[49]), eb = II(eb, ev, em, eg, ey, 15, $[50]), eg = II(eg, eb, ev, em, er, 21, $[51]), em = II(em, eg, eb, ev, ep, 6, $[52]), ev = II(ev, em, eg, eb, X, 10, $[53]), eb = II(eb, ev, em, eg, eu, 15, $[54]), eg = II(eg, eb, ev, em, q, 21, $[55]), em = II(em, eg, eb, ev, el, 6, $[56]), ev = II(ev, em, eg, eb, ef, 10, $[57]), eb = II(eb, ev, em, eg, ea, 15, $[58]), eg = II(eg, eb, ev, em, eh, 21, $[59]), em = II(em, eg, eb, ev, en, 6, $[60]), ev = II(ev, em, eg, eb, ed, 10, $[61]), eb = II(eb, ev, em, eg, J, 15, $[62]), eg = II(eg, eb, ev, em, ec, 21, $[63]), Z[0] = Z[0] + em | 0, Z[1] = Z[1] + eg | 0, Z[2] = Z[2] + eb | 0, Z[3] = Z[3] + ev | 0
                    },
                    _doFinalize: function() {
                        var c = this._data,
                            x = c.words,
                            N = 8 * this._nDataBytes,
                            U = 8 * c.sigBytes;
                        x[U >>> 5] |= 128 << 24 - U % 32;
                        var Z = l.floor(N / 4294967296);
                        x[(U + 64 >>> 9 << 4) + 15] = (Z << 8 | Z >>> 24) & 16711935 | (Z << 24 | Z >>> 8) & 4278255360, x[(U + 64 >>> 9 << 4) + 14] = (N << 8 | N >>> 24) & 16711935 | (N << 24 | N >>> 8) & 4278255360, c.sigBytes = (x.length + 1) * 4, this._process();
                        for (var $ = this._hash, Y = $.words, q = 0; q < 4; q++) {
                            var J = Y[q];
                            Y[q] = (J << 8 | J >>> 24) & 16711935 | (J << 24 | J >>> 8) & 4278255360
                        }
                        return $
                    },
                    clone: function() {
                        var l = U.clone.call(this);
                        return l._hash = this._hash.clone(), l
                    }
                });

                function FF(l, c, x, N, U, Z, $) {
                    var Y = l + (c & x | ~c & N) + U + $;
                    return (Y << Z | Y >>> 32 - Z) + c
                }

                function GG(l, c, x, N, U, Z, $) {
                    var Y = l + (c & N | x & ~N) + U + $;
                    return (Y << Z | Y >>> 32 - Z) + c
                }

                function HH(l, c, x, N, U, Z, $) {
                    var Y = l + (c ^ x ^ N) + U + $;
                    return (Y << Z | Y >>> 32 - Z) + c
                }

                function II(l, c, x, N, U, Z, $) {
                    var Y = l + (x ^ (c | ~N)) + U + $;
                    return (Y << Z | Y >>> 32 - Z) + c
                }
                N.MD5 = U._createHelper(Y), N.HmacMD5 = U._createHmacHelper(Y)
            }(Math), N.MD5)
        },
        78275: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980), N.mode.CFB = function() {
                var l = N.lib.BlockCipherMode.extend();

                function generateKeystreamAndEncrypt(l, c, x, N) {
                    var U = this._iv;
                    if (U) {
                        var Z = U.slice(0);
                        this._iv = void 0
                    } else var Z = this._prevBlock;
                    N.encryptBlock(Z, 0);
                    for (var $ = 0; $ < x; $++) l[c + $] ^= Z[$]
                }
                return l.Encryptor = l.extend({
                    processBlock: function(l, c) {
                        var x = this._cipher,
                            N = x.blockSize;
                        generateKeystreamAndEncrypt.call(this, l, c, N, x), this._prevBlock = l.slice(c, c + N)
                    }
                }), l.Decryptor = l.extend({
                    processBlock: function(l, c) {
                        var x = this._cipher,
                            N = x.blockSize,
                            U = l.slice(c, c + N);
                        generateKeystreamAndEncrypt.call(this, l, c, N, x), this._prevBlock = U
                    }
                }), l
            }(), N.mode.CFB)
        },
        21750: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980),
                /** @preserve
                 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
                 * derived from CryptoJS.mode.CTR
                 * Jan Hruby jhruby.web@gmail.com
                 */
                N.mode.CTRGladman = function() {
                    var l = N.lib.BlockCipherMode.extend();

                    function incWord(l) {
                        if ((l >> 24 & 255) == 255) {
                            var c = l >> 16 & 255,
                                x = l >> 8 & 255,
                                N = 255 & l;
                            255 === c ? (c = 0, 255 === x ? (x = 0, 255 === N ? N = 0 : ++N) : ++x) : ++c, l = 0 + (c << 16) + (x << 8) + N
                        } else l += 16777216;
                        return l
                    }
                    var c = l.Encryptor = l.extend({
                        processBlock: function(l, c) {
                            var x, N = this._cipher,
                                U = N.blockSize,
                                Z = this._iv,
                                $ = this._counter;
                            Z && ($ = this._counter = Z.slice(0), this._iv = void 0), 0 === ((x = $)[0] = incWord(x[0])) && (x[1] = incWord(x[1]));
                            var Y = $.slice(0);
                            N.encryptBlock(Y, 0);
                            for (var q = 0; q < U; q++) l[c + q] ^= Y[q]
                        }
                    });
                    return l.Decryptor = c, l
                }(), N.mode.CTRGladman)
        },
        89985: function(l, c, x) {
            var N, U, Z;
            l.exports = (N = x(13686), x(28980), N.mode.CTR = (Z = (U = N.lib.BlockCipherMode.extend()).Encryptor = U.extend({
                processBlock: function(l, c) {
                    var x = this._cipher,
                        N = x.blockSize,
                        U = this._iv,
                        Z = this._counter;
                    U && (Z = this._counter = U.slice(0), this._iv = void 0);
                    var $ = Z.slice(0);
                    x.encryptBlock($, 0), Z[N - 1] = Z[N - 1] + 1 | 0;
                    for (var Y = 0; Y < N; Y++) l[c + Y] ^= $[Y]
                }
            }), U.Decryptor = Z, U), N.mode.CTR)
        },
        87671: function(l, c, x) {
            var N, U;
            l.exports = (N = x(13686), x(28980), N.mode.ECB = ((U = N.lib.BlockCipherMode.extend()).Encryptor = U.extend({
                processBlock: function(l, c) {
                    this._cipher.encryptBlock(l, c)
                }
            }), U.Decryptor = U.extend({
                processBlock: function(l, c) {
                    this._cipher.decryptBlock(l, c)
                }
            }), U), N.mode.ECB)
        },
        56910: function(l, c, x) {
            var N, U, Z;
            l.exports = (N = x(13686), x(28980), N.mode.OFB = (Z = (U = N.lib.BlockCipherMode.extend()).Encryptor = U.extend({
                processBlock: function(l, c) {
                    var x = this._cipher,
                        N = x.blockSize,
                        U = this._iv,
                        Z = this._keystream;
                    U && (Z = this._keystream = U.slice(0), this._iv = void 0), x.encryptBlock(Z, 0);
                    for (var $ = 0; $ < N; $++) l[c + $] ^= Z[$]
                }
            }), U.Decryptor = Z, U), N.mode.OFB)
        },
        11592: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980), N.pad.AnsiX923 = {
                pad: function(l, c) {
                    var x = l.sigBytes,
                        N = 4 * c,
                        U = N - x % N,
                        Z = x + U - 1;
                    l.clamp(), l.words[Z >>> 2] |= U << 24 - Z % 4 * 8, l.sigBytes += U
                },
                unpad: function(l) {
                    var c = 255 & l.words[l.sigBytes - 1 >>> 2];
                    l.sigBytes -= c
                }
            }, N.pad.Ansix923)
        },
        50368: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980), N.pad.Iso10126 = {
                pad: function(l, c) {
                    var x = 4 * c,
                        U = x - l.sigBytes % x;
                    l.concat(N.lib.WordArray.random(U - 1)).concat(N.lib.WordArray.create([U << 24], 1))
                },
                unpad: function(l) {
                    var c = 255 & l.words[l.sigBytes - 1 >>> 2];
                    l.sigBytes -= c
                }
            }, N.pad.Iso10126)
        },
        69497: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980), N.pad.Iso97971 = {
                pad: function(l, c) {
                    l.concat(N.lib.WordArray.create([2147483648], 1)), N.pad.ZeroPadding.pad(l, c)
                },
                unpad: function(l) {
                    N.pad.ZeroPadding.unpad(l), l.sigBytes--
                }
            }, N.pad.Iso97971)
        },
        10540: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980), N.pad.NoPadding = {
                pad: function() {},
                unpad: function() {}
            }, N.pad.NoPadding)
        },
        95143: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(28980), N.pad.ZeroPadding = {
                pad: function(l, c) {
                    var x = 4 * c;
                    l.clamp(), l.sigBytes += x - (l.sigBytes % x || x)
                },
                unpad: function(l) {
                    for (var c = l.words, x = l.sigBytes - 1; !(c[x >>> 2] >>> 24 - x % 4 * 8 & 255);) x--;
                    l.sigBytes = x + 1
                }
            }, N.pad.ZeroPadding)
        },
        89551: function(l, c, x) {
            var N, U, Z, $, Y, q, J, X;
            l.exports = (N = x(13686), x(45666), x(24333), Z = (U = N.lib).Base, $ = U.WordArray, q = (Y = N.algo).SHA1, J = Y.HMAC, X = Y.PBKDF2 = Z.extend({
                cfg: Z.extend({
                    keySize: 4,
                    hasher: q,
                    iterations: 1
                }),
                init: function(l) {
                    this.cfg = this.cfg.extend(l)
                },
                compute: function(l, c) {
                    for (var x = this.cfg, N = J.create(x.hasher, l), U = $.create(), Z = $.create([1]), Y = U.words, q = Z.words, X = x.keySize, en = x.iterations; Y.length < X;) {
                        var er = N.update(c).finalize(Z);
                        N.reset();
                        for (var ea = er.words, eo = ea.length, el = er, ec = 1; ec < en; ec++) {
                            el = N.finalize(el), N.reset();
                            for (var eu = el.words, ed = 0; ed < eo; ed++) ea[ed] ^= eu[ed]
                        }
                        U.concat(er), q[0]++
                    }
                    return U.sigBytes = 4 * X, U
                }
            }), N.PBKDF2 = function(l, c, x) {
                return X.create(x).compute(l, c)
            }, N.PBKDF2)
        },
        18272: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(55937), x(39589), x(40964), x(28980), function() {
                var l = N.lib.StreamCipher,
                    c = N.algo,
                    x = [],
                    U = [],
                    Z = [],
                    $ = c.RabbitLegacy = l.extend({
                        _doReset: function() {
                            var l = this._key.words,
                                c = this.cfg.iv,
                                x = this._X = [l[0], l[3] << 16 | l[2] >>> 16, l[1], l[0] << 16 | l[3] >>> 16, l[2], l[1] << 16 | l[0] >>> 16, l[3], l[2] << 16 | l[1] >>> 16],
                                N = this._C = [l[2] << 16 | l[2] >>> 16, 4294901760 & l[0] | 65535 & l[1], l[3] << 16 | l[3] >>> 16, 4294901760 & l[1] | 65535 & l[2], l[0] << 16 | l[0] >>> 16, 4294901760 & l[2] | 65535 & l[3], l[1] << 16 | l[1] >>> 16, 4294901760 & l[3] | 65535 & l[0]];
                            this._b = 0;
                            for (var U = 0; U < 4; U++) nextState.call(this);
                            for (var U = 0; U < 8; U++) N[U] ^= x[U + 4 & 7];
                            if (c) {
                                var Z = c.words,
                                    $ = Z[0],
                                    Y = Z[1],
                                    q = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360,
                                    J = (Y << 8 | Y >>> 24) & 16711935 | (Y << 24 | Y >>> 8) & 4278255360,
                                    X = q >>> 16 | 4294901760 & J,
                                    en = J << 16 | 65535 & q;
                                N[0] ^= q, N[1] ^= X, N[2] ^= J, N[3] ^= en, N[4] ^= q, N[5] ^= X, N[6] ^= J, N[7] ^= en;
                                for (var U = 0; U < 4; U++) nextState.call(this)
                            }
                        },
                        _doProcessBlock: function(l, c) {
                            var N = this._X;
                            nextState.call(this), x[0] = N[0] ^ N[5] >>> 16 ^ N[3] << 16, x[1] = N[2] ^ N[7] >>> 16 ^ N[5] << 16, x[2] = N[4] ^ N[1] >>> 16 ^ N[7] << 16, x[3] = N[6] ^ N[3] >>> 16 ^ N[1] << 16;
                            for (var U = 0; U < 4; U++) x[U] = (x[U] << 8 | x[U] >>> 24) & 16711935 | (x[U] << 24 | x[U] >>> 8) & 4278255360, l[c + U] ^= x[U]
                        },
                        blockSize: 4,
                        ivSize: 2
                    });

                function nextState() {
                    for (var l = this._X, c = this._C, x = 0; x < 8; x++) U[x] = c[x];
                    c[0] = c[0] + 1295307597 + this._b | 0, c[1] = c[1] + 3545052371 + (c[0] >>> 0 < U[0] >>> 0 ? 1 : 0) | 0, c[2] = c[2] + 886263092 + (c[1] >>> 0 < U[1] >>> 0 ? 1 : 0) | 0, c[3] = c[3] + 1295307597 + (c[2] >>> 0 < U[2] >>> 0 ? 1 : 0) | 0, c[4] = c[4] + 3545052371 + (c[3] >>> 0 < U[3] >>> 0 ? 1 : 0) | 0, c[5] = c[5] + 886263092 + (c[4] >>> 0 < U[4] >>> 0 ? 1 : 0) | 0, c[6] = c[6] + 1295307597 + (c[5] >>> 0 < U[5] >>> 0 ? 1 : 0) | 0, c[7] = c[7] + 3545052371 + (c[6] >>> 0 < U[6] >>> 0 ? 1 : 0) | 0, this._b = c[7] >>> 0 < U[7] >>> 0 ? 1 : 0;
                    for (var x = 0; x < 8; x++) {
                        var N = l[x] + c[x],
                            $ = 65535 & N,
                            Y = N >>> 16,
                            q = (($ * $ >>> 17) + $ * Y >>> 15) + Y * Y,
                            J = ((4294901760 & N) * N | 0) + ((65535 & N) * N | 0);
                        Z[x] = q ^ J
                    }
                    l[0] = Z[0] + (Z[7] << 16 | Z[7] >>> 16) + (Z[6] << 16 | Z[6] >>> 16) | 0, l[1] = Z[1] + (Z[0] << 8 | Z[0] >>> 24) + Z[7] | 0, l[2] = Z[2] + (Z[1] << 16 | Z[1] >>> 16) + (Z[0] << 16 | Z[0] >>> 16) | 0, l[3] = Z[3] + (Z[2] << 8 | Z[2] >>> 24) + Z[1] | 0, l[4] = Z[4] + (Z[3] << 16 | Z[3] >>> 16) + (Z[2] << 16 | Z[2] >>> 16) | 0, l[5] = Z[5] + (Z[4] << 8 | Z[4] >>> 24) + Z[3] | 0, l[6] = Z[6] + (Z[5] << 16 | Z[5] >>> 16) + (Z[4] << 16 | Z[4] >>> 16) | 0, l[7] = Z[7] + (Z[6] << 8 | Z[6] >>> 24) + Z[5] | 0
                }
                N.RabbitLegacy = l._createHelper($)
            }(), N.RabbitLegacy)
        },
        79567: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(55937), x(39589), x(40964), x(28980), function() {
                var l = N.lib.StreamCipher,
                    c = N.algo,
                    x = [],
                    U = [],
                    Z = [],
                    $ = c.Rabbit = l.extend({
                        _doReset: function() {
                            for (var l = this._key.words, c = this.cfg.iv, x = 0; x < 4; x++) l[x] = (l[x] << 8 | l[x] >>> 24) & 16711935 | (l[x] << 24 | l[x] >>> 8) & 4278255360;
                            var N = this._X = [l[0], l[3] << 16 | l[2] >>> 16, l[1], l[0] << 16 | l[3] >>> 16, l[2], l[1] << 16 | l[0] >>> 16, l[3], l[2] << 16 | l[1] >>> 16],
                                U = this._C = [l[2] << 16 | l[2] >>> 16, 4294901760 & l[0] | 65535 & l[1], l[3] << 16 | l[3] >>> 16, 4294901760 & l[1] | 65535 & l[2], l[0] << 16 | l[0] >>> 16, 4294901760 & l[2] | 65535 & l[3], l[1] << 16 | l[1] >>> 16, 4294901760 & l[3] | 65535 & l[0]];
                            this._b = 0;
                            for (var x = 0; x < 4; x++) nextState.call(this);
                            for (var x = 0; x < 8; x++) U[x] ^= N[x + 4 & 7];
                            if (c) {
                                var Z = c.words,
                                    $ = Z[0],
                                    Y = Z[1],
                                    q = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360,
                                    J = (Y << 8 | Y >>> 24) & 16711935 | (Y << 24 | Y >>> 8) & 4278255360,
                                    X = q >>> 16 | 4294901760 & J,
                                    en = J << 16 | 65535 & q;
                                U[0] ^= q, U[1] ^= X, U[2] ^= J, U[3] ^= en, U[4] ^= q, U[5] ^= X, U[6] ^= J, U[7] ^= en;
                                for (var x = 0; x < 4; x++) nextState.call(this)
                            }
                        },
                        _doProcessBlock: function(l, c) {
                            var N = this._X;
                            nextState.call(this), x[0] = N[0] ^ N[5] >>> 16 ^ N[3] << 16, x[1] = N[2] ^ N[7] >>> 16 ^ N[5] << 16, x[2] = N[4] ^ N[1] >>> 16 ^ N[7] << 16, x[3] = N[6] ^ N[3] >>> 16 ^ N[1] << 16;
                            for (var U = 0; U < 4; U++) x[U] = (x[U] << 8 | x[U] >>> 24) & 16711935 | (x[U] << 24 | x[U] >>> 8) & 4278255360, l[c + U] ^= x[U]
                        },
                        blockSize: 4,
                        ivSize: 2
                    });

                function nextState() {
                    for (var l = this._X, c = this._C, x = 0; x < 8; x++) U[x] = c[x];
                    c[0] = c[0] + 1295307597 + this._b | 0, c[1] = c[1] + 3545052371 + (c[0] >>> 0 < U[0] >>> 0 ? 1 : 0) | 0, c[2] = c[2] + 886263092 + (c[1] >>> 0 < U[1] >>> 0 ? 1 : 0) | 0, c[3] = c[3] + 1295307597 + (c[2] >>> 0 < U[2] >>> 0 ? 1 : 0) | 0, c[4] = c[4] + 3545052371 + (c[3] >>> 0 < U[3] >>> 0 ? 1 : 0) | 0, c[5] = c[5] + 886263092 + (c[4] >>> 0 < U[4] >>> 0 ? 1 : 0) | 0, c[6] = c[6] + 1295307597 + (c[5] >>> 0 < U[5] >>> 0 ? 1 : 0) | 0, c[7] = c[7] + 3545052371 + (c[6] >>> 0 < U[6] >>> 0 ? 1 : 0) | 0, this._b = c[7] >>> 0 < U[7] >>> 0 ? 1 : 0;
                    for (var x = 0; x < 8; x++) {
                        var N = l[x] + c[x],
                            $ = 65535 & N,
                            Y = N >>> 16,
                            q = (($ * $ >>> 17) + $ * Y >>> 15) + Y * Y,
                            J = ((4294901760 & N) * N | 0) + ((65535 & N) * N | 0);
                        Z[x] = q ^ J
                    }
                    l[0] = Z[0] + (Z[7] << 16 | Z[7] >>> 16) + (Z[6] << 16 | Z[6] >>> 16) | 0, l[1] = Z[1] + (Z[0] << 8 | Z[0] >>> 24) + Z[7] | 0, l[2] = Z[2] + (Z[1] << 16 | Z[1] >>> 16) + (Z[0] << 16 | Z[0] >>> 16) | 0, l[3] = Z[3] + (Z[2] << 8 | Z[2] >>> 24) + Z[1] | 0, l[4] = Z[4] + (Z[3] << 16 | Z[3] >>> 16) + (Z[2] << 16 | Z[2] >>> 16) | 0, l[5] = Z[5] + (Z[4] << 8 | Z[4] >>> 24) + Z[3] | 0, l[6] = Z[6] + (Z[5] << 16 | Z[5] >>> 16) + (Z[4] << 16 | Z[4] >>> 16) | 0, l[7] = Z[7] + (Z[6] << 8 | Z[6] >>> 24) + Z[5] | 0
                }
                N.Rabbit = l._createHelper($)
            }(), N.Rabbit)
        },
        89510: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(55937), x(39589), x(40964), x(28980), function() {
                var l = N.lib.StreamCipher,
                    c = N.algo,
                    x = c.RC4 = l.extend({
                        _doReset: function() {
                            for (var l = this._key, c = l.words, x = l.sigBytes, N = this._S = [], U = 0; U < 256; U++) N[U] = U;
                            for (var U = 0, Z = 0; U < 256; U++) {
                                var $ = U % x,
                                    Y = c[$ >>> 2] >>> 24 - $ % 4 * 8 & 255;
                                Z = (Z + N[U] + Y) % 256;
                                var q = N[U];
                                N[U] = N[Z], N[Z] = q
                            }
                            this._i = this._j = 0
                        },
                        _doProcessBlock: function(l, c) {
                            l[c] ^= generateKeystreamWord.call(this)
                        },
                        keySize: 8,
                        ivSize: 0
                    });

                function generateKeystreamWord() {
                    for (var l = this._S, c = this._i, x = this._j, N = 0, U = 0; U < 4; U++) {
                        x = (x + l[c = (c + 1) % 256]) % 256;
                        var Z = l[c];
                        l[c] = l[x], l[x] = Z, N |= l[(l[c] + l[x]) % 256] << 24 - 8 * U
                    }
                    return this._i = c, this._j = x, N
                }
                N.RC4 = l._createHelper(x);
                var U = c.RC4Drop = x.extend({
                    cfg: x.cfg.extend({
                        drop: 192
                    }),
                    _doReset: function() {
                        x._doReset.call(this);
                        for (var l = this.cfg.drop; l > 0; l--) generateKeystreamWord.call(this)
                    }
                });
                N.RC4Drop = l._createHelper(U)
            }(), N.RC4)
        },
        80211: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), function(l) {
                var c = N.lib,
                    x = c.WordArray,
                    U = c.Hasher,
                    Z = N.algo,
                    $ = x.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                    Y = x.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                    q = x.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                    J = x.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                    X = x.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                    en = x.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                    er = Z.RIPEMD160 = U.extend({
                        _doReset: function() {
                            this._hash = x.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                        },
                        _doProcessBlock: function(l, c) {
                            for (var x, N, U, Z, er, ea, eo, el, ec, eu, ed, ep, eh, ey, ef, em, eg, eb, ev, ew, eT, eM, eI, ex, eC, e_, eD, eS, ek, eE, eN, eA, ej, eO, eP, ez, eR, eL, eB, eU, eF, eW = 0; eW < 16; eW++) {
                                var eZ = c + eW,
                                    eQ = l[eZ];
                                l[eZ] = (eQ << 8 | eQ >>> 24) & 16711935 | (eQ << 24 | eQ >>> 8) & 4278255360
                            }
                            var eH = this._hash.words,
                                e$ = X.words,
                                eY = en.words,
                                eG = $.words,
                                eV = Y.words,
                                eK = q.words,
                                eJ = J.words;
                            ez = eN = eH[0], eR = eA = eH[1], eL = ej = eH[2], eB = eO = eH[3], eU = eP = eH[4];
                            for (var eW = 0; eW < 80; eW += 1) eF = eN + l[c + eG[eW]] | 0, eW < 16 ? eF += (eA ^ ej ^ eO) + e$[0] : eW < 32 ? eF += ((Z = eA) & ej | ~Z & eO) + e$[1] : eW < 48 ? eF += ((eA | ~ej) ^ eO) + e$[2] : eW < 64 ? eF += (eu = eA, ed = ej, (eu & (ep = eO) | ed & ~ep) + e$[3]) : eF += (eA ^ (ej | ~eO)) + e$[4], eF |= 0, eF = (eF = rotl(eF, eK[eW])) + eP | 0, eN = eP, eP = eO, eO = rotl(ej, 10), ej = eA, eA = eF, eF = ez + l[c + eV[eW]] | 0, eW < 16 ? eF += (eR ^ (eL | ~eB)) + eY[0] : eW < 32 ? eF += (ev = eR, ew = eL, (ev & (eT = eB) | ew & ~eT) + eY[1]) : eW < 48 ? eF += ((eR | ~eL) ^ eB) + eY[2] : eW < 64 ? eF += ((eC = eR) & eL | ~eC & eB) + eY[3] : eF += (eR ^ eL ^ eB) + eY[4], eF |= 0, eF = (eF = rotl(eF, eJ[eW])) + eU | 0, ez = eU, eU = eB, eB = rotl(eL, 10), eL = eR, eR = eF;
                            eF = eH[1] + ej + eB | 0, eH[1] = eH[2] + eO + eU | 0, eH[2] = eH[3] + eP + ez | 0, eH[3] = eH[4] + eN + eR | 0, eH[4] = eH[0] + eA + eL | 0, eH[0] = eF
                        },
                        _doFinalize: function() {
                            var l = this._data,
                                c = l.words,
                                x = 8 * this._nDataBytes,
                                N = 8 * l.sigBytes;
                            c[N >>> 5] |= 128 << 24 - N % 32, c[(N + 64 >>> 9 << 4) + 14] = (x << 8 | x >>> 24) & 16711935 | (x << 24 | x >>> 8) & 4278255360, l.sigBytes = (c.length + 1) * 4, this._process();
                            for (var U = this._hash, Z = U.words, $ = 0; $ < 5; $++) {
                                var Y = Z[$];
                                Z[$] = (Y << 8 | Y >>> 24) & 16711935 | (Y << 24 | Y >>> 8) & 4278255360
                            }
                            return U
                        },
                        clone: function() {
                            var l = U.clone.call(this);
                            return l._hash = this._hash.clone(), l
                        }
                    });

                function rotl(l, c) {
                    return l << c | l >>> 32 - c
                }
                N.RIPEMD160 = U._createHelper(er), N.HmacRIPEMD160 = U._createHmacHelper(er)
            }(Math), N.RIPEMD160)
        },
        45666: function(l, c, x) {
            var N, U, Z, $, Y, q, J;
            l.exports = (Z = (U = (N = x(13686)).lib).WordArray, $ = U.Hasher, Y = N.algo, q = [], J = Y.SHA1 = $.extend({
                _doReset: function() {
                    this._hash = new Z.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                },
                _doProcessBlock: function(l, c) {
                    for (var x = this._hash.words, N = x[0], U = x[1], Z = x[2], $ = x[3], Y = x[4], J = 0; J < 80; J++) {
                        if (J < 16) q[J] = 0 | l[c + J];
                        else {
                            var X = q[J - 3] ^ q[J - 8] ^ q[J - 14] ^ q[J - 16];
                            q[J] = X << 1 | X >>> 31
                        }
                        var en = (N << 5 | N >>> 27) + Y + q[J];
                        J < 20 ? en += (U & Z | ~U & $) + 1518500249 : J < 40 ? en += (U ^ Z ^ $) + 1859775393 : J < 60 ? en += (U & Z | U & $ | Z & $) - 1894007588 : en += (U ^ Z ^ $) - 899497514, Y = $, $ = Z, Z = U << 30 | U >>> 2, U = N, N = en
                    }
                    x[0] = x[0] + N | 0, x[1] = x[1] + U | 0, x[2] = x[2] + Z | 0, x[3] = x[3] + $ | 0, x[4] = x[4] + Y | 0
                },
                _doFinalize: function() {
                    var l = this._data,
                        c = l.words,
                        x = 8 * this._nDataBytes,
                        N = 8 * l.sigBytes;
                    return c[N >>> 5] |= 128 << 24 - N % 32, c[(N + 64 >>> 9 << 4) + 14] = Math.floor(x / 4294967296), c[(N + 64 >>> 9 << 4) + 15] = x, l.sigBytes = 4 * c.length, this._process(), this._hash
                },
                clone: function() {
                    var l = $.clone.call(this);
                    return l._hash = this._hash.clone(), l
                }
            }), N.SHA1 = $._createHelper(J), N.HmacSHA1 = $._createHmacHelper(J), N.SHA1)
        },
        14689: function(l, c, x) {
            var N, U, Z, $, Y;
            l.exports = (N = x(13686), x(83303), U = N.lib.WordArray, $ = (Z = N.algo).SHA256, Y = Z.SHA224 = $.extend({
                _doReset: function() {
                    this._hash = new U.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                },
                _doFinalize: function() {
                    var l = $._doFinalize.call(this);
                    return l.sigBytes -= 4, l
                }
            }), N.SHA224 = $._createHelper(Y), N.HmacSHA224 = $._createHmacHelper(Y), N.SHA224)
        },
        83303: function(l, c, x) {
            var N, U, Z, $, Y, q, J, X, en, er;
            l.exports = (N = x(13686), U = Math, $ = (Z = N.lib).WordArray, Y = Z.Hasher, q = N.algo, J = [], X = [], function() {
                function getFractionalBits(l) {
                    return (l - (0 | l)) * 4294967296 | 0
                }
                for (var l = 2, c = 0; c < 64;)(function(l) {
                    for (var c = U.sqrt(l), x = 2; x <= c; x++)
                        if (!(l % x)) return !1;
                    return !0
                })(l) && (c < 8 && (J[c] = getFractionalBits(U.pow(l, .5))), X[c] = getFractionalBits(U.pow(l, 1 / 3)), c++), l++
            }(), en = [], er = q.SHA256 = Y.extend({
                _doReset: function() {
                    this._hash = new $.init(J.slice(0))
                },
                _doProcessBlock: function(l, c) {
                    for (var x = this._hash.words, N = x[0], U = x[1], Z = x[2], $ = x[3], Y = x[4], q = x[5], J = x[6], er = x[7], ea = 0; ea < 64; ea++) {
                        if (ea < 16) en[ea] = 0 | l[c + ea];
                        else {
                            var eo = en[ea - 15],
                                el = (eo << 25 | eo >>> 7) ^ (eo << 14 | eo >>> 18) ^ eo >>> 3,
                                ec = en[ea - 2],
                                eu = (ec << 15 | ec >>> 17) ^ (ec << 13 | ec >>> 19) ^ ec >>> 10;
                            en[ea] = el + en[ea - 7] + eu + en[ea - 16]
                        }
                        var ed = Y & q ^ ~Y & J,
                            ep = N & U ^ N & Z ^ U & Z,
                            eh = (N << 30 | N >>> 2) ^ (N << 19 | N >>> 13) ^ (N << 10 | N >>> 22),
                            ey = er + ((Y << 26 | Y >>> 6) ^ (Y << 21 | Y >>> 11) ^ (Y << 7 | Y >>> 25)) + ed + X[ea] + en[ea],
                            ef = eh + ep;
                        er = J, J = q, q = Y, Y = $ + ey | 0, $ = Z, Z = U, U = N, N = ey + ef | 0
                    }
                    x[0] = x[0] + N | 0, x[1] = x[1] + U | 0, x[2] = x[2] + Z | 0, x[3] = x[3] + $ | 0, x[4] = x[4] + Y | 0, x[5] = x[5] + q | 0, x[6] = x[6] + J | 0, x[7] = x[7] + er | 0
                },
                _doFinalize: function() {
                    var l = this._data,
                        c = l.words,
                        x = 8 * this._nDataBytes,
                        N = 8 * l.sigBytes;
                    return c[N >>> 5] |= 128 << 24 - N % 32, c[(N + 64 >>> 9 << 4) + 14] = U.floor(x / 4294967296), c[(N + 64 >>> 9 << 4) + 15] = x, l.sigBytes = 4 * c.length, this._process(), this._hash
                },
                clone: function() {
                    var l = Y.clone.call(this);
                    return l._hash = this._hash.clone(), l
                }
            }), N.SHA256 = Y._createHelper(er), N.HmacSHA256 = Y._createHmacHelper(er), N.SHA256)
        },
        37372: function(l, c, x) {
            var N, U, Z, $, Y, q, J, X, en, er, ea, eo;
            l.exports = (N = x(13686), x(68493), U = Math, $ = (Z = N.lib).WordArray, Y = Z.Hasher, q = N.x64.Word, J = N.algo, X = [], en = [], er = [], function() {
                for (var l = 1, c = 0, x = 0; x < 24; x++) {
                    X[l + 5 * c] = (x + 1) * (x + 2) / 2 % 64;
                    var N = c % 5,
                        U = (2 * l + 3 * c) % 5;
                    l = N, c = U
                }
                for (var l = 0; l < 5; l++)
                    for (var c = 0; c < 5; c++) en[l + 5 * c] = c + (2 * l + 3 * c) % 5 * 5;
                for (var Z = 1, $ = 0; $ < 24; $++) {
                    for (var Y = 0, J = 0, ea = 0; ea < 7; ea++) {
                        if (1 & Z) {
                            var eo = (1 << ea) - 1;
                            eo < 32 ? J ^= 1 << eo : Y ^= 1 << eo - 32
                        }
                        128 & Z ? Z = Z << 1 ^ 113 : Z <<= 1
                    }
                    er[$] = q.create(Y, J)
                }
            }(), ea = [], function() {
                for (var l = 0; l < 25; l++) ea[l] = q.create()
            }(), eo = J.SHA3 = Y.extend({
                cfg: Y.cfg.extend({
                    outputLength: 512
                }),
                _doReset: function() {
                    for (var l = this._state = [], c = 0; c < 25; c++) l[c] = new q.init;
                    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                },
                _doProcessBlock: function(l, c) {
                    for (var x = this._state, N = this.blockSize / 2, U = 0; U < N; U++) {
                        var Z = l[c + 2 * U],
                            $ = l[c + 2 * U + 1];
                        Z = (Z << 8 | Z >>> 24) & 16711935 | (Z << 24 | Z >>> 8) & 4278255360, $ = ($ << 8 | $ >>> 24) & 16711935 | ($ << 24 | $ >>> 8) & 4278255360;
                        var Y = x[U];
                        Y.high ^= $, Y.low ^= Z
                    }
                    for (var q = 0; q < 24; q++) {
                        for (var J = 0; J < 5; J++) {
                            for (var eo = 0, el = 0, ec = 0; ec < 5; ec++) {
                                var Y = x[J + 5 * ec];
                                eo ^= Y.high, el ^= Y.low
                            }
                            var eu = ea[J];
                            eu.high = eo, eu.low = el
                        }
                        for (var J = 0; J < 5; J++)
                            for (var ed = ea[(J + 4) % 5], ep = ea[(J + 1) % 5], eh = ep.high, ey = ep.low, eo = ed.high ^ (eh << 1 | ey >>> 31), el = ed.low ^ (ey << 1 | eh >>> 31), ec = 0; ec < 5; ec++) {
                                var Y = x[J + 5 * ec];
                                Y.high ^= eo, Y.low ^= el
                            }
                        for (var ef = 1; ef < 25; ef++) {
                            var Y = x[ef],
                                em = Y.high,
                                eg = Y.low,
                                eb = X[ef];
                            if (eb < 32) var eo = em << eb | eg >>> 32 - eb,
                                el = eg << eb | em >>> 32 - eb;
                            else var eo = eg << eb - 32 | em >>> 64 - eb,
                                el = em << eb - 32 | eg >>> 64 - eb;
                            var ev = ea[en[ef]];
                            ev.high = eo, ev.low = el
                        }
                        var ew = ea[0],
                            eT = x[0];
                        ew.high = eT.high, ew.low = eT.low;
                        for (var J = 0; J < 5; J++)
                            for (var ec = 0; ec < 5; ec++) {
                                var ef = J + 5 * ec,
                                    Y = x[ef],
                                    eM = ea[ef],
                                    eI = ea[(J + 1) % 5 + 5 * ec],
                                    ex = ea[(J + 2) % 5 + 5 * ec];
                                Y.high = eM.high ^ ~eI.high & ex.high, Y.low = eM.low ^ ~eI.low & ex.low
                            }
                        var Y = x[0],
                            eC = er[q];
                        Y.high ^= eC.high, Y.low ^= eC.low
                    }
                },
                _doFinalize: function() {
                    var l = this._data,
                        c = l.words;
                    this._nDataBytes;
                    var x = 8 * l.sigBytes,
                        N = 32 * this.blockSize;
                    c[x >>> 5] |= 1 << 24 - x % 32, c[(U.ceil((x + 1) / N) * N >>> 5) - 1] |= 128, l.sigBytes = 4 * c.length, this._process();
                    for (var Z = this._state, Y = this.cfg.outputLength / 8, q = Y / 8, J = [], X = 0; X < q; X++) {
                        var en = Z[X],
                            er = en.high,
                            ea = en.low;
                        er = (er << 8 | er >>> 24) & 16711935 | (er << 24 | er >>> 8) & 4278255360, ea = (ea << 8 | ea >>> 24) & 16711935 | (ea << 24 | ea >>> 8) & 4278255360, J.push(ea), J.push(er)
                    }
                    return new $.init(J, Y)
                },
                clone: function() {
                    for (var l = Y.clone.call(this), c = l._state = this._state.slice(0), x = 0; x < 25; x++) c[x] = c[x].clone();
                    return l
                }
            }), N.SHA3 = Y._createHelper(eo), N.HmacSHA3 = Y._createHmacHelper(eo), N.SHA3)
        },
        21762: function(l, c, x) {
            var N, U, Z, $, Y, q, J;
            l.exports = (N = x(13686), x(68493), x(43146), Z = (U = N.x64).Word, $ = U.WordArray, q = (Y = N.algo).SHA512, J = Y.SHA384 = q.extend({
                _doReset: function() {
                    this._hash = new $.init([new Z.init(3418070365, 3238371032), new Z.init(1654270250, 914150663), new Z.init(2438529370, 812702999), new Z.init(355462360, 4144912697), new Z.init(1731405415, 4290775857), new Z.init(2394180231, 1750603025), new Z.init(3675008525, 1694076839), new Z.init(1203062813, 3204075428)])
                },
                _doFinalize: function() {
                    var l = q._doFinalize.call(this);
                    return l.sigBytes -= 16, l
                }
            }), N.SHA384 = q._createHelper(J), N.HmacSHA384 = q._createHmacHelper(J), N.SHA384)
        },
        43146: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(68493), function() {
                var l = N.lib.Hasher,
                    c = N.x64,
                    x = c.Word,
                    U = c.WordArray,
                    Z = N.algo;

                function X64Word_create() {
                    return x.create.apply(x, arguments)
                }
                var $ = [X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591)],
                    Y = [];
                ! function() {
                    for (var l = 0; l < 80; l++) Y[l] = X64Word_create()
                }();
                var q = Z.SHA512 = l.extend({
                    _doReset: function() {
                        this._hash = new U.init([new x.init(1779033703, 4089235720), new x.init(3144134277, 2227873595), new x.init(1013904242, 4271175723), new x.init(2773480762, 1595750129), new x.init(1359893119, 2917565137), new x.init(2600822924, 725511199), new x.init(528734635, 4215389547), new x.init(1541459225, 327033209)])
                    },
                    _doProcessBlock: function(l, c) {
                        for (var x = this._hash.words, N = x[0], U = x[1], Z = x[2], q = x[3], J = x[4], X = x[5], en = x[6], er = x[7], ea = N.high, eo = N.low, el = U.high, ec = U.low, eu = Z.high, ed = Z.low, ep = q.high, eh = q.low, ey = J.high, ef = J.low, em = X.high, eg = X.low, eb = en.high, ev = en.low, ew = er.high, eT = er.low, eM = ea, eI = eo, ex = el, eC = ec, e_ = eu, eD = ed, eS = ep, ek = eh, eE = ey, eN = ef, eA = em, ej = eg, eO = eb, eP = ev, ez = ew, eR = eT, eL = 0; eL < 80; eL++) {
                            var eB = Y[eL];
                            if (eL < 16) var eU = eB.high = 0 | l[c + 2 * eL],
                                eF = eB.low = 0 | l[c + 2 * eL + 1];
                            else {
                                var eW = Y[eL - 15],
                                    eZ = eW.high,
                                    eQ = eW.low,
                                    eH = (eZ >>> 1 | eQ << 31) ^ (eZ >>> 8 | eQ << 24) ^ eZ >>> 7,
                                    e$ = (eQ >>> 1 | eZ << 31) ^ (eQ >>> 8 | eZ << 24) ^ (eQ >>> 7 | eZ << 25),
                                    eY = Y[eL - 2],
                                    eG = eY.high,
                                    eV = eY.low,
                                    eK = (eG >>> 19 | eV << 13) ^ (eG << 3 | eV >>> 29) ^ eG >>> 6,
                                    eJ = (eV >>> 19 | eG << 13) ^ (eV << 3 | eG >>> 29) ^ (eV >>> 6 | eG << 26),
                                    eX = Y[eL - 7],
                                    e0 = eX.high,
                                    e2 = eX.low,
                                    e1 = Y[eL - 16],
                                    e5 = e1.high,
                                    e4 = e1.low,
                                    eF = e$ + e2,
                                    eU = eH + e0 + (eF >>> 0 < e$ >>> 0 ? 1 : 0),
                                    eF = eF + eJ,
                                    eU = eU + eK + (eF >>> 0 < eJ >>> 0 ? 1 : 0),
                                    eF = eF + e4,
                                    eU = eU + e5 + (eF >>> 0 < e4 >>> 0 ? 1 : 0);
                                eB.high = eU, eB.low = eF
                            }
                            var e3 = eE & eA ^ ~eE & eO,
                                e6 = eN & ej ^ ~eN & eP,
                                e8 = eM & ex ^ eM & e_ ^ ex & e_,
                                e9 = eI & eC ^ eI & eD ^ eC & eD,
                                e7 = (eM >>> 28 | eI << 4) ^ (eM << 30 | eI >>> 2) ^ (eM << 25 | eI >>> 7),
                                tt = (eI >>> 28 | eM << 4) ^ (eI << 30 | eM >>> 2) ^ (eI << 25 | eM >>> 7),
                                tn = (eE >>> 14 | eN << 18) ^ (eE >>> 18 | eN << 14) ^ (eE << 23 | eN >>> 9),
                                tr = (eN >>> 14 | eE << 18) ^ (eN >>> 18 | eE << 14) ^ (eN << 23 | eE >>> 9),
                                ta = $[eL],
                                to = ta.high,
                                tl = ta.low,
                                tc = eR + tr,
                                tu = ez + tn + (tc >>> 0 < eR >>> 0 ? 1 : 0),
                                tc = tc + e6,
                                tu = tu + e3 + (tc >>> 0 < e6 >>> 0 ? 1 : 0),
                                tc = tc + tl,
                                tu = tu + to + (tc >>> 0 < tl >>> 0 ? 1 : 0),
                                tc = tc + eF,
                                tu = tu + eU + (tc >>> 0 < eF >>> 0 ? 1 : 0),
                                td = tt + e9,
                                tp = e7 + e8 + (td >>> 0 < tt >>> 0 ? 1 : 0);
                            ez = eO, eR = eP, eO = eA, eP = ej, eA = eE, ej = eN, eE = eS + tu + ((eN = ek + tc | 0) >>> 0 < ek >>> 0 ? 1 : 0) | 0, eS = e_, ek = eD, e_ = ex, eD = eC, ex = eM, eC = eI, eM = tu + tp + ((eI = tc + td | 0) >>> 0 < tc >>> 0 ? 1 : 0) | 0
                        }
                        eo = N.low = eo + eI, N.high = ea + eM + (eo >>> 0 < eI >>> 0 ? 1 : 0), ec = U.low = ec + eC, U.high = el + ex + (ec >>> 0 < eC >>> 0 ? 1 : 0), ed = Z.low = ed + eD, Z.high = eu + e_ + (ed >>> 0 < eD >>> 0 ? 1 : 0), eh = q.low = eh + ek, q.high = ep + eS + (eh >>> 0 < ek >>> 0 ? 1 : 0), ef = J.low = ef + eN, J.high = ey + eE + (ef >>> 0 < eN >>> 0 ? 1 : 0), eg = X.low = eg + ej, X.high = em + eA + (eg >>> 0 < ej >>> 0 ? 1 : 0), ev = en.low = ev + eP, en.high = eb + eO + (ev >>> 0 < eP >>> 0 ? 1 : 0), eT = er.low = eT + eR, er.high = ew + ez + (eT >>> 0 < eR >>> 0 ? 1 : 0)
                    },
                    _doFinalize: function() {
                        var l = this._data,
                            c = l.words,
                            x = 8 * this._nDataBytes,
                            N = 8 * l.sigBytes;
                        return c[N >>> 5] |= 128 << 24 - N % 32, c[(N + 128 >>> 10 << 5) + 30] = Math.floor(x / 4294967296), c[(N + 128 >>> 10 << 5) + 31] = x, l.sigBytes = 4 * c.length, this._process(), this._hash.toX32()
                    },
                    clone: function() {
                        var c = l.clone.call(this);
                        return c._hash = this._hash.clone(), c
                    },
                    blockSize: 32
                });
                N.SHA512 = l._createHelper(q), N.HmacSHA512 = l._createHmacHelper(q)
            }(), N.SHA512)
        },
        55476: function(l, c, x) {
            var N;
            l.exports = (N = x(13686), x(55937), x(39589), x(40964), x(28980), function() {
                var l = N.lib,
                    c = l.WordArray,
                    x = l.BlockCipher,
                    U = N.algo,
                    Z = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                    $ = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                    Y = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                    q = [{
                        0: 8421888,
                        268435456: 32768,
                        536870912: 8421378,
                        805306368: 2,
                        1073741824: 512,
                        1342177280: 8421890,
                        1610612736: 8389122,
                        1879048192: 8388608,
                        2147483648: 514,
                        2415919104: 8389120,
                        2684354560: 33280,
                        2952790016: 8421376,
                        3221225472: 32770,
                        3489660928: 8388610,
                        3758096384: 0,
                        4026531840: 33282,
                        134217728: 0,
                        402653184: 8421890,
                        671088640: 33282,
                        939524096: 32768,
                        1207959552: 8421888,
                        1476395008: 512,
                        1744830464: 8421378,
                        2013265920: 2,
                        2281701376: 8389120,
                        2550136832: 33280,
                        2818572288: 8421376,
                        3087007744: 8389122,
                        3355443200: 8388610,
                        3623878656: 32770,
                        3892314112: 514,
                        4160749568: 8388608,
                        1: 32768,
                        268435457: 2,
                        536870913: 8421888,
                        805306369: 8388608,
                        1073741825: 8421378,
                        1342177281: 33280,
                        1610612737: 512,
                        1879048193: 8389122,
                        2147483649: 8421890,
                        2415919105: 8421376,
                        2684354561: 8388610,
                        2952790017: 33282,
                        3221225473: 514,
                        3489660929: 8389120,
                        3758096385: 32770,
                        4026531841: 0,
                        134217729: 8421890,
                        402653185: 8421376,
                        671088641: 8388608,
                        939524097: 512,
                        1207959553: 32768,
                        1476395009: 8388610,
                        1744830465: 2,
                        2013265921: 33282,
                        2281701377: 32770,
                        2550136833: 8389122,
                        2818572289: 514,
                        3087007745: 8421888,
                        3355443201: 8389120,
                        3623878657: 0,
                        3892314113: 33280,
                        4160749569: 8421378
                    }, {
                        0: 1074282512,
                        16777216: 16384,
                        33554432: 524288,
                        50331648: 1074266128,
                        67108864: 1073741840,
                        83886080: 1074282496,
                        100663296: 1073758208,
                        117440512: 16,
                        134217728: 540672,
                        150994944: 1073758224,
                        167772160: 1073741824,
                        184549376: 540688,
                        201326592: 524304,
                        218103808: 0,
                        234881024: 16400,
                        251658240: 1074266112,
                        8388608: 1073758208,
                        25165824: 540688,
                        41943040: 16,
                        58720256: 1073758224,
                        75497472: 1074282512,
                        92274688: 1073741824,
                        109051904: 524288,
                        125829120: 1074266128,
                        142606336: 524304,
                        159383552: 0,
                        176160768: 16384,
                        192937984: 1074266112,
                        209715200: 1073741840,
                        226492416: 540672,
                        243269632: 1074282496,
                        260046848: 16400,
                        268435456: 0,
                        285212672: 1074266128,
                        301989888: 1073758224,
                        318767104: 1074282496,
                        335544320: 1074266112,
                        352321536: 16,
                        369098752: 540688,
                        385875968: 16384,
                        402653184: 16400,
                        419430400: 524288,
                        436207616: 524304,
                        452984832: 1073741840,
                        469762048: 540672,
                        486539264: 1073758208,
                        503316480: 1073741824,
                        520093696: 1074282512,
                        276824064: 540688,
                        293601280: 524288,
                        310378496: 1074266112,
                        327155712: 16384,
                        343932928: 1073758208,
                        360710144: 1074282512,
                        377487360: 16,
                        394264576: 1073741824,
                        411041792: 1074282496,
                        427819008: 1073741840,
                        444596224: 1073758224,
                        461373440: 524304,
                        478150656: 0,
                        494927872: 16400,
                        511705088: 1074266128,
                        528482304: 540672
                    }, {
                        0: 260,
                        1048576: 0,
                        2097152: 67109120,
                        3145728: 65796,
                        4194304: 65540,
                        5242880: 67108868,
                        6291456: 67174660,
                        7340032: 67174400,
                        8388608: 67108864,
                        9437184: 67174656,
                        10485760: 65792,
                        11534336: 67174404,
                        12582912: 67109124,
                        13631488: 65536,
                        14680064: 4,
                        15728640: 256,
                        524288: 67174656,
                        1572864: 67174404,
                        2621440: 0,
                        3670016: 67109120,
                        4718592: 67108868,
                        5767168: 65536,
                        6815744: 65540,
                        7864320: 260,
                        8912896: 4,
                        9961472: 256,
                        11010048: 67174400,
                        12058624: 65796,
                        13107200: 65792,
                        14155776: 67109124,
                        15204352: 67174660,
                        16252928: 67108864,
                        16777216: 67174656,
                        17825792: 65540,
                        18874368: 65536,
                        19922944: 67109120,
                        20971520: 256,
                        22020096: 67174660,
                        23068672: 67108868,
                        24117248: 0,
                        25165824: 67109124,
                        26214400: 67108864,
                        27262976: 4,
                        28311552: 65792,
                        29360128: 67174400,
                        30408704: 260,
                        31457280: 65796,
                        32505856: 67174404,
                        17301504: 67108864,
                        18350080: 260,
                        19398656: 67174656,
                        20447232: 0,
                        21495808: 65540,
                        22544384: 67109120,
                        23592960: 256,
                        24641536: 67174404,
                        25690112: 65536,
                        26738688: 67174660,
                        27787264: 65796,
                        28835840: 67108868,
                        29884416: 67109124,
                        30932992: 67174400,
                        31981568: 4,
                        33030144: 65792
                    }, {
                        0: 2151682048,
                        65536: 2147487808,
                        131072: 4198464,
                        196608: 2151677952,
                        262144: 0,
                        327680: 4198400,
                        393216: 2147483712,
                        458752: 4194368,
                        524288: 2147483648,
                        589824: 4194304,
                        655360: 64,
                        720896: 2147487744,
                        786432: 2151678016,
                        851968: 4160,
                        917504: 4096,
                        983040: 2151682112,
                        32768: 2147487808,
                        98304: 64,
                        163840: 2151678016,
                        229376: 2147487744,
                        294912: 4198400,
                        360448: 2151682112,
                        425984: 0,
                        491520: 2151677952,
                        557056: 4096,
                        622592: 2151682048,
                        688128: 4194304,
                        753664: 4160,
                        819200: 2147483648,
                        884736: 4194368,
                        950272: 4198464,
                        1015808: 2147483712,
                        1048576: 4194368,
                        1114112: 4198400,
                        1179648: 2147483712,
                        1245184: 0,
                        1310720: 4160,
                        1376256: 2151678016,
                        1441792: 2151682048,
                        1507328: 2147487808,
                        1572864: 2151682112,
                        1638400: 2147483648,
                        1703936: 2151677952,
                        1769472: 4198464,
                        1835008: 2147487744,
                        1900544: 4194304,
                        1966080: 64,
                        2031616: 4096,
                        1081344: 2151677952,
                        1146880: 2151682112,
                        1212416: 0,
                        1277952: 4198400,
                        1343488: 4194368,
                        1409024: 2147483648,
                        1474560: 2147487808,
                        1540096: 64,
                        1605632: 2147483712,
                        1671168: 4096,
                        1736704: 2147487744,
                        1802240: 2151678016,
                        1867776: 4160,
                        1933312: 2151682048,
                        1998848: 4194304,
                        2064384: 4198464
                    }, {
                        0: 128,
                        4096: 17039360,
                        8192: 262144,
                        12288: 536870912,
                        16384: 537133184,
                        20480: 16777344,
                        24576: 553648256,
                        28672: 262272,
                        32768: 16777216,
                        36864: 537133056,
                        40960: 536871040,
                        45056: 553910400,
                        49152: 553910272,
                        53248: 0,
                        57344: 17039488,
                        61440: 553648128,
                        2048: 17039488,
                        6144: 553648256,
                        10240: 128,
                        14336: 17039360,
                        18432: 262144,
                        22528: 537133184,
                        26624: 553910272,
                        30720: 536870912,
                        34816: 537133056,
                        38912: 0,
                        43008: 553910400,
                        47104: 16777344,
                        51200: 536871040,
                        55296: 553648128,
                        59392: 16777216,
                        63488: 262272,
                        65536: 262144,
                        69632: 128,
                        73728: 536870912,
                        77824: 553648256,
                        81920: 16777344,
                        86016: 553910272,
                        90112: 537133184,
                        94208: 16777216,
                        98304: 553910400,
                        102400: 553648128,
                        106496: 17039360,
                        110592: 537133056,
                        114688: 262272,
                        118784: 536871040,
                        122880: 0,
                        126976: 17039488,
                        67584: 553648256,
                        71680: 16777216,
                        75776: 17039360,
                        79872: 537133184,
                        83968: 536870912,
                        88064: 17039488,
                        92160: 128,
                        96256: 553910272,
                        100352: 262272,
                        104448: 553910400,
                        108544: 0,
                        112640: 553648128,
                        116736: 16777344,
                        120832: 262144,
                        124928: 537133056,
                        129024: 536871040
                    }, {
                        0: 268435464,
                        256: 8192,
                        512: 270532608,
                        768: 270540808,
                        1024: 268443648,
                        1280: 2097152,
                        1536: 2097160,
                        1792: 268435456,
                        2048: 0,
                        2304: 268443656,
                        2560: 2105344,
                        2816: 8,
                        3072: 270532616,
                        3328: 2105352,
                        3584: 8200,
                        3840: 270540800,
                        128: 270532608,
                        384: 270540808,
                        640: 8,
                        896: 2097152,
                        1152: 2105352,
                        1408: 268435464,
                        1664: 268443648,
                        1920: 8200,
                        2176: 2097160,
                        2432: 8192,
                        2688: 268443656,
                        2944: 270532616,
                        3200: 0,
                        3456: 270540800,
                        3712: 2105344,
                        3968: 268435456,
                        4096: 268443648,
                        4352: 270532616,
                        4608: 270540808,
                        4864: 8200,
                        5120: 2097152,
                        5376: 268435456,
                        5632: 268435464,
                        5888: 2105344,
                        6144: 2105352,
                        6400: 0,
                        6656: 8,
                        6912: 270532608,
                        7168: 8192,
                        7424: 268443656,
                        7680: 270540800,
                        7936: 2097160,
                        4224: 8,
                        4480: 2105344,
                        4736: 2097152,
                        4992: 268435464,
                        5248: 268443648,
                        5504: 8200,
                        5760: 270540808,
                        6016: 270532608,
                        6272: 270540800,
                        6528: 270532616,
                        6784: 8192,
                        7040: 2105352,
                        7296: 2097160,
                        7552: 0,
                        7808: 268435456,
                        8064: 268443656
                    }, {
                        0: 1048576,
                        16: 33555457,
                        32: 1024,
                        48: 1049601,
                        64: 34604033,
                        80: 0,
                        96: 1,
                        112: 34603009,
                        128: 33555456,
                        144: 1048577,
                        160: 33554433,
                        176: 34604032,
                        192: 34603008,
                        208: 1025,
                        224: 1049600,
                        240: 33554432,
                        8: 34603009,
                        24: 0,
                        40: 33555457,
                        56: 34604032,
                        72: 1048576,
                        88: 33554433,
                        104: 33554432,
                        120: 1025,
                        136: 1049601,
                        152: 33555456,
                        168: 34603008,
                        184: 1048577,
                        200: 1024,
                        216: 34604033,
                        232: 1,
                        248: 1049600,
                        256: 33554432,
                        272: 1048576,
                        288: 33555457,
                        304: 34603009,
                        320: 1048577,
                        336: 33555456,
                        352: 34604032,
                        368: 1049601,
                        384: 1025,
                        400: 34604033,
                        416: 1049600,
                        432: 1,
                        448: 0,
                        464: 34603008,
                        480: 33554433,
                        496: 1024,
                        264: 1049600,
                        280: 33555457,
                        296: 34603009,
                        312: 1,
                        328: 33554432,
                        344: 1048576,
                        360: 1025,
                        376: 34604032,
                        392: 33554433,
                        408: 34603008,
                        424: 0,
                        440: 34604033,
                        456: 1049601,
                        472: 1024,
                        488: 33555456,
                        504: 1048577
                    }, {
                        0: 134219808,
                        1: 131072,
                        2: 134217728,
                        3: 32,
                        4: 131104,
                        5: 134350880,
                        6: 134350848,
                        7: 2048,
                        8: 134348800,
                        9: 134219776,
                        10: 133120,
                        11: 134348832,
                        12: 2080,
                        13: 0,
                        14: 134217760,
                        15: 133152,
                        2147483648: 2048,
                        2147483649: 134350880,
                        2147483650: 134219808,
                        2147483651: 134217728,
                        2147483652: 134348800,
                        2147483653: 133120,
                        2147483654: 133152,
                        2147483655: 32,
                        2147483656: 134217760,
                        2147483657: 2080,
                        2147483658: 131104,
                        2147483659: 134350848,
                        2147483660: 0,
                        2147483661: 134348832,
                        2147483662: 134219776,
                        2147483663: 131072,
                        16: 133152,
                        17: 134350848,
                        18: 32,
                        19: 2048,
                        20: 134219776,
                        21: 134217760,
                        22: 134348832,
                        23: 131072,
                        24: 0,
                        25: 131104,
                        26: 134348800,
                        27: 134219808,
                        28: 134350880,
                        29: 133120,
                        30: 2080,
                        31: 134217728,
                        2147483664: 131072,
                        2147483665: 2048,
                        2147483666: 134348832,
                        2147483667: 133152,
                        2147483668: 32,
                        2147483669: 134348800,
                        2147483670: 134217728,
                        2147483671: 134219808,
                        2147483672: 134350880,
                        2147483673: 134217760,
                        2147483674: 134219776,
                        2147483675: 0,
                        2147483676: 133120,
                        2147483677: 2080,
                        2147483678: 131104,
                        2147483679: 134350848
                    }],
                    J = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                    X = U.DES = x.extend({
                        _doReset: function() {
                            for (var l = this._key.words, c = [], x = 0; x < 56; x++) {
                                var N = Z[x] - 1;
                                c[x] = l[N >>> 5] >>> 31 - N % 32 & 1
                            }
                            for (var U = this._subKeys = [], q = 0; q < 16; q++) {
                                for (var J = U[q] = [], X = Y[q], x = 0; x < 24; x++) J[x / 6 | 0] |= c[($[x] - 1 + X) % 28] << 31 - x % 6, J[4 + (x / 6 | 0)] |= c[28 + ($[x + 24] - 1 + X) % 28] << 31 - x % 6;
                                J[0] = J[0] << 1 | J[0] >>> 31;
                                for (var x = 1; x < 7; x++) J[x] = J[x] >>> (x - 1) * 4 + 3;
                                J[7] = J[7] << 5 | J[7] >>> 27
                            }
                            for (var en = this._invSubKeys = [], x = 0; x < 16; x++) en[x] = U[15 - x]
                        },
                        encryptBlock: function(l, c) {
                            this._doCryptBlock(l, c, this._subKeys)
                        },
                        decryptBlock: function(l, c) {
                            this._doCryptBlock(l, c, this._invSubKeys)
                        },
                        _doCryptBlock: function(l, c, x) {
                            this._lBlock = l[c], this._rBlock = l[c + 1], exchangeLR.call(this, 4, 252645135), exchangeLR.call(this, 16, 65535), exchangeRL.call(this, 2, 858993459), exchangeRL.call(this, 8, 16711935), exchangeLR.call(this, 1, 1431655765);
                            for (var N = 0; N < 16; N++) {
                                for (var U = x[N], Z = this._lBlock, $ = this._rBlock, Y = 0, X = 0; X < 8; X++) Y |= q[X][(($ ^ U[X]) & J[X]) >>> 0];
                                this._lBlock = $, this._rBlock = Z ^ Y
                            }
                            var en = this._lBlock;
                            this._lBlock = this._rBlock, this._rBlock = en, exchangeLR.call(this, 1, 1431655765), exchangeRL.call(this, 8, 16711935), exchangeRL.call(this, 2, 858993459), exchangeLR.call(this, 16, 65535), exchangeLR.call(this, 4, 252645135), l[c] = this._lBlock, l[c + 1] = this._rBlock
                        },
                        keySize: 2,
                        ivSize: 2,
                        blockSize: 2
                    });

                function exchangeLR(l, c) {
                    var x = (this._lBlock >>> l ^ this._rBlock) & c;
                    this._rBlock ^= x, this._lBlock ^= x << l
                }

                function exchangeRL(l, c) {
                    var x = (this._rBlock >>> l ^ this._lBlock) & c;
                    this._lBlock ^= x, this._rBlock ^= x << l
                }
                N.DES = x._createHelper(X);
                var en = U.TripleDES = x.extend({
                    _doReset: function() {
                        var l = this._key.words;
                        this._des1 = X.createEncryptor(c.create(l.slice(0, 2))), this._des2 = X.createEncryptor(c.create(l.slice(2, 4))), this._des3 = X.createEncryptor(c.create(l.slice(4, 6)))
                    },
                    encryptBlock: function(l, c) {
                        this._des1.encryptBlock(l, c), this._des2.decryptBlock(l, c), this._des3.encryptBlock(l, c)
                    },
                    decryptBlock: function(l, c) {
                        this._des3.decryptBlock(l, c), this._des2.encryptBlock(l, c), this._des1.decryptBlock(l, c)
                    },
                    keySize: 6,
                    ivSize: 2,
                    blockSize: 2
                });
                N.TripleDES = x._createHelper(en)
            }(), N.TripleDES)
        },
        68493: function(l, c, x) {
            var N, U, Z, $, Y;
            l.exports = (Z = (U = (N = x(13686)).lib).Base, $ = U.WordArray, (Y = N.x64 = {}).Word = Z.extend({
                init: function(l, c) {
                    this.high = l, this.low = c
                }
            }), Y.WordArray = Z.extend({
                init: function(l, c) {
                    l = this.words = l || [], void 0 != c ? this.sigBytes = c : this.sigBytes = 8 * l.length
                },
                toX32: function() {
                    for (var l = this.words, c = l.length, x = [], N = 0; N < c; N++) {
                        var U = l[N];
                        x.push(U.high), x.push(U.low)
                    }
                    return $.create(x, this.sigBytes)
                },
                clone: function() {
                    for (var l = Z.clone.call(this), c = l.words = this.words.slice(0), x = c.length, N = 0; N < x; N++) c[N] = c[N].clone();
                    return l
                }
            }), N)
        },
        34713: function(l) {
            "use strict";

            function Mime() {
                this._types = Object.create(null), this._extensions = Object.create(null);
                for (let l = 0; l < arguments.length; l++) this.define(arguments[l]);
                this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this)
            }
            Mime.prototype.define = function(l, c) {
                for (let x in l) {
                    let N = l[x].map(function(l) {
                        return l.toLowerCase()
                    });
                    x = x.toLowerCase();
                    for (let l = 0; l < N.length; l++) {
                        let U = N[l];
                        if ("*" !== U[0]) {
                            if (!c && U in this._types) throw Error('Attempt to change mapping for "' + U + '" extension from "' + this._types[U] + '" to "' + x + '". Pass `force=true` to allow this, otherwise remove "' + U + '" from the list of extensions for "' + x + '".');
                            this._types[U] = x
                        }
                    }
                    if (c || !this._extensions[x]) {
                        let l = N[0];
                        this._extensions[x] = "*" !== l[0] ? l : l.substr(1)
                    }
                }
            }, Mime.prototype.getType = function(l) {
                let c = (l = String(l)).replace(/^.*[/\\]/, "").toLowerCase(),
                    x = c.replace(/^.*\./, "").toLowerCase(),
                    N = c.length < l.length;
                return (x.length < c.length - 1 || !N) && this._types[x] || null
            }, Mime.prototype.getExtension = function(l) {
                return (l = /^\s*([^;\s]*)/.test(l) && RegExp.$1) && this._extensions[l.toLowerCase()] || null
            }, l.exports = Mime
        },
        58499: function(l, c, x) {
            "use strict";
            let N = x(34713);
            l.exports = new N(x(78223))
        },
        78223: function(l) {
            l.exports = {
                "application/andrew-inset": ["ez"],
                "application/applixware": ["aw"],
                "application/atom+xml": ["atom"],
                "application/atomcat+xml": ["atomcat"],
                "application/atomdeleted+xml": ["atomdeleted"],
                "application/atomsvc+xml": ["atomsvc"],
                "application/atsc-dwd+xml": ["dwd"],
                "application/atsc-held+xml": ["held"],
                "application/atsc-rsat+xml": ["rsat"],
                "application/bdoc": ["bdoc"],
                "application/calendar+xml": ["xcs"],
                "application/ccxml+xml": ["ccxml"],
                "application/cdfx+xml": ["cdfx"],
                "application/cdmi-capability": ["cdmia"],
                "application/cdmi-container": ["cdmic"],
                "application/cdmi-domain": ["cdmid"],
                "application/cdmi-object": ["cdmio"],
                "application/cdmi-queue": ["cdmiq"],
                "application/cu-seeme": ["cu"],
                "application/dash+xml": ["mpd"],
                "application/davmount+xml": ["davmount"],
                "application/docbook+xml": ["dbk"],
                "application/dssc+der": ["dssc"],
                "application/dssc+xml": ["xdssc"],
                "application/ecmascript": ["es", "ecma"],
                "application/emma+xml": ["emma"],
                "application/emotionml+xml": ["emotionml"],
                "application/epub+zip": ["epub"],
                "application/exi": ["exi"],
                "application/express": ["exp"],
                "application/fdt+xml": ["fdt"],
                "application/font-tdpfr": ["pfr"],
                "application/geo+json": ["geojson"],
                "application/gml+xml": ["gml"],
                "application/gpx+xml": ["gpx"],
                "application/gxf": ["gxf"],
                "application/gzip": ["gz"],
                "application/hjson": ["hjson"],
                "application/hyperstudio": ["stk"],
                "application/inkml+xml": ["ink", "inkml"],
                "application/ipfix": ["ipfix"],
                "application/its+xml": ["its"],
                "application/java-archive": ["jar", "war", "ear"],
                "application/java-serialized-object": ["ser"],
                "application/java-vm": ["class"],
                "application/javascript": ["js", "mjs"],
                "application/json": ["json", "map"],
                "application/json5": ["json5"],
                "application/jsonml+json": ["jsonml"],
                "application/ld+json": ["jsonld"],
                "application/lgr+xml": ["lgr"],
                "application/lost+xml": ["lostxml"],
                "application/mac-binhex40": ["hqx"],
                "application/mac-compactpro": ["cpt"],
                "application/mads+xml": ["mads"],
                "application/manifest+json": ["webmanifest"],
                "application/marc": ["mrc"],
                "application/marcxml+xml": ["mrcx"],
                "application/mathematica": ["ma", "nb", "mb"],
                "application/mathml+xml": ["mathml"],
                "application/mbox": ["mbox"],
                "application/mediaservercontrol+xml": ["mscml"],
                "application/metalink+xml": ["metalink"],
                "application/metalink4+xml": ["meta4"],
                "application/mets+xml": ["mets"],
                "application/mmt-aei+xml": ["maei"],
                "application/mmt-usd+xml": ["musd"],
                "application/mods+xml": ["mods"],
                "application/mp21": ["m21", "mp21"],
                "application/mp4": ["mp4s", "m4p"],
                "application/msword": ["doc", "dot"],
                "application/mxf": ["mxf"],
                "application/n-quads": ["nq"],
                "application/n-triples": ["nt"],
                "application/node": ["cjs"],
                "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
                "application/oda": ["oda"],
                "application/oebps-package+xml": ["opf"],
                "application/ogg": ["ogx"],
                "application/omdoc+xml": ["omdoc"],
                "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
                "application/oxps": ["oxps"],
                "application/p2p-overlay+xml": ["relo"],
                "application/patch-ops-error+xml": ["xer"],
                "application/pdf": ["pdf"],
                "application/pgp-encrypted": ["pgp"],
                "application/pgp-signature": ["asc", "sig"],
                "application/pics-rules": ["prf"],
                "application/pkcs10": ["p10"],
                "application/pkcs7-mime": ["p7m", "p7c"],
                "application/pkcs7-signature": ["p7s"],
                "application/pkcs8": ["p8"],
                "application/pkix-attr-cert": ["ac"],
                "application/pkix-cert": ["cer"],
                "application/pkix-crl": ["crl"],
                "application/pkix-pkipath": ["pkipath"],
                "application/pkixcmp": ["pki"],
                "application/pls+xml": ["pls"],
                "application/postscript": ["ai", "eps", "ps"],
                "application/provenance+xml": ["provx"],
                "application/pskc+xml": ["pskcxml"],
                "application/raml+yaml": ["raml"],
                "application/rdf+xml": ["rdf", "owl"],
                "application/reginfo+xml": ["rif"],
                "application/relax-ng-compact-syntax": ["rnc"],
                "application/resource-lists+xml": ["rl"],
                "application/resource-lists-diff+xml": ["rld"],
                "application/rls-services+xml": ["rs"],
                "application/route-apd+xml": ["rapd"],
                "application/route-s-tsid+xml": ["sls"],
                "application/route-usd+xml": ["rusd"],
                "application/rpki-ghostbusters": ["gbr"],
                "application/rpki-manifest": ["mft"],
                "application/rpki-roa": ["roa"],
                "application/rsd+xml": ["rsd"],
                "application/rss+xml": ["rss"],
                "application/rtf": ["rtf"],
                "application/sbml+xml": ["sbml"],
                "application/scvp-cv-request": ["scq"],
                "application/scvp-cv-response": ["scs"],
                "application/scvp-vp-request": ["spq"],
                "application/scvp-vp-response": ["spp"],
                "application/sdp": ["sdp"],
                "application/senml+xml": ["senmlx"],
                "application/sensml+xml": ["sensmlx"],
                "application/set-payment-initiation": ["setpay"],
                "application/set-registration-initiation": ["setreg"],
                "application/shf+xml": ["shf"],
                "application/sieve": ["siv", "sieve"],
                "application/smil+xml": ["smi", "smil"],
                "application/sparql-query": ["rq"],
                "application/sparql-results+xml": ["srx"],
                "application/srgs": ["gram"],
                "application/srgs+xml": ["grxml"],
                "application/sru+xml": ["sru"],
                "application/ssdl+xml": ["ssdl"],
                "application/ssml+xml": ["ssml"],
                "application/swid+xml": ["swidtag"],
                "application/tei+xml": ["tei", "teicorpus"],
                "application/thraud+xml": ["tfi"],
                "application/timestamped-data": ["tsd"],
                "application/toml": ["toml"],
                "application/trig": ["trig"],
                "application/ttml+xml": ["ttml"],
                "application/ubjson": ["ubj"],
                "application/urc-ressheet+xml": ["rsheet"],
                "application/urc-targetdesc+xml": ["td"],
                "application/voicexml+xml": ["vxml"],
                "application/wasm": ["wasm"],
                "application/widget": ["wgt"],
                "application/winhlp": ["hlp"],
                "application/wsdl+xml": ["wsdl"],
                "application/wspolicy+xml": ["wspolicy"],
                "application/xaml+xml": ["xaml"],
                "application/xcap-att+xml": ["xav"],
                "application/xcap-caps+xml": ["xca"],
                "application/xcap-diff+xml": ["xdf"],
                "application/xcap-el+xml": ["xel"],
                "application/xcap-ns+xml": ["xns"],
                "application/xenc+xml": ["xenc"],
                "application/xhtml+xml": ["xhtml", "xht"],
                "application/xliff+xml": ["xlf"],
                "application/xml": ["xml", "xsl", "xsd", "rng"],
                "application/xml-dtd": ["dtd"],
                "application/xop+xml": ["xop"],
                "application/xproc+xml": ["xpl"],
                "application/xslt+xml": ["*xsl", "xslt"],
                "application/xspf+xml": ["xspf"],
                "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
                "application/yang": ["yang"],
                "application/yin+xml": ["yin"],
                "application/zip": ["zip"],
                "audio/3gpp": ["*3gpp"],
                "audio/adpcm": ["adp"],
                "audio/amr": ["amr"],
                "audio/basic": ["au", "snd"],
                "audio/midi": ["mid", "midi", "kar", "rmi"],
                "audio/mobile-xmf": ["mxmf"],
                "audio/mp3": ["*mp3"],
                "audio/mp4": ["m4a", "mp4a"],
                "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
                "audio/ogg": ["oga", "ogg", "spx", "opus"],
                "audio/s3m": ["s3m"],
                "audio/silk": ["sil"],
                "audio/wav": ["wav"],
                "audio/wave": ["*wav"],
                "audio/webm": ["weba"],
                "audio/xm": ["xm"],
                "font/collection": ["ttc"],
                "font/otf": ["otf"],
                "font/ttf": ["ttf"],
                "font/woff": ["woff"],
                "font/woff2": ["woff2"],
                "image/aces": ["exr"],
                "image/apng": ["apng"],
                "image/avif": ["avif"],
                "image/bmp": ["bmp"],
                "image/cgm": ["cgm"],
                "image/dicom-rle": ["drle"],
                "image/emf": ["emf"],
                "image/fits": ["fits"],
                "image/g3fax": ["g3"],
                "image/gif": ["gif"],
                "image/heic": ["heic"],
                "image/heic-sequence": ["heics"],
                "image/heif": ["heif"],
                "image/heif-sequence": ["heifs"],
                "image/hej2k": ["hej2"],
                "image/hsj2": ["hsj2"],
                "image/ief": ["ief"],
                "image/jls": ["jls"],
                "image/jp2": ["jp2", "jpg2"],
                "image/jpeg": ["jpeg", "jpg", "jpe"],
                "image/jph": ["jph"],
                "image/jphc": ["jhc"],
                "image/jpm": ["jpm"],
                "image/jpx": ["jpx", "jpf"],
                "image/jxr": ["jxr"],
                "image/jxra": ["jxra"],
                "image/jxrs": ["jxrs"],
                "image/jxs": ["jxs"],
                "image/jxsc": ["jxsc"],
                "image/jxsi": ["jxsi"],
                "image/jxss": ["jxss"],
                "image/ktx": ["ktx"],
                "image/ktx2": ["ktx2"],
                "image/png": ["png"],
                "image/sgi": ["sgi"],
                "image/svg+xml": ["svg", "svgz"],
                "image/t38": ["t38"],
                "image/tiff": ["tif", "tiff"],
                "image/tiff-fx": ["tfx"],
                "image/webp": ["webp"],
                "image/wmf": ["wmf"],
                "message/disposition-notification": ["disposition-notification"],
                "message/global": ["u8msg"],
                "message/global-delivery-status": ["u8dsn"],
                "message/global-disposition-notification": ["u8mdn"],
                "message/global-headers": ["u8hdr"],
                "message/rfc822": ["eml", "mime"],
                "model/3mf": ["3mf"],
                "model/gltf+json": ["gltf"],
                "model/gltf-binary": ["glb"],
                "model/iges": ["igs", "iges"],
                "model/mesh": ["msh", "mesh", "silo"],
                "model/mtl": ["mtl"],
                "model/obj": ["obj"],
                "model/step+xml": ["stpx"],
                "model/step+zip": ["stpz"],
                "model/step-xml+zip": ["stpxz"],
                "model/stl": ["stl"],
                "model/vrml": ["wrl", "vrml"],
                "model/x3d+binary": ["*x3db", "x3dbz"],
                "model/x3d+fastinfoset": ["x3db"],
                "model/x3d+vrml": ["*x3dv", "x3dvz"],
                "model/x3d+xml": ["x3d", "x3dz"],
                "model/x3d-vrml": ["x3dv"],
                "text/cache-manifest": ["appcache", "manifest"],
                "text/calendar": ["ics", "ifb"],
                "text/coffeescript": ["coffee", "litcoffee"],
                "text/css": ["css"],
                "text/csv": ["csv"],
                "text/html": ["html", "htm", "shtml"],
                "text/jade": ["jade"],
                "text/jsx": ["jsx"],
                "text/less": ["less"],
                "text/markdown": ["markdown", "md"],
                "text/mathml": ["mml"],
                "text/mdx": ["mdx"],
                "text/n3": ["n3"],
                "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
                "text/richtext": ["rtx"],
                "text/rtf": ["*rtf"],
                "text/sgml": ["sgml", "sgm"],
                "text/shex": ["shex"],
                "text/slim": ["slim", "slm"],
                "text/spdx": ["spdx"],
                "text/stylus": ["stylus", "styl"],
                "text/tab-separated-values": ["tsv"],
                "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
                "text/turtle": ["ttl"],
                "text/uri-list": ["uri", "uris", "urls"],
                "text/vcard": ["vcard"],
                "text/vtt": ["vtt"],
                "text/xml": ["*xml"],
                "text/yaml": ["yaml", "yml"],
                "video/3gpp": ["3gp", "3gpp"],
                "video/3gpp2": ["3g2"],
                "video/h261": ["h261"],
                "video/h263": ["h263"],
                "video/h264": ["h264"],
                "video/iso.segment": ["m4s"],
                "video/jpeg": ["jpgv"],
                "video/jpm": ["*jpm", "jpgm"],
                "video/mj2": ["mj2", "mjp2"],
                "video/mp2t": ["ts"],
                "video/mp4": ["mp4", "mp4v", "mpg4"],
                "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
                "video/ogg": ["ogv"],
                "video/quicktime": ["qt", "mov"],
                "video/webm": ["webm"]
            }
        },
        2105: function(l, c, x) {
            "use strict";
            let {
                encodeText: N
            } = x(40533);
            l.exports = class {
                constructor(l, c, x, U) {
                    this.name = l, this.code = c, this.codeBuf = N(this.code), this.alphabet = U, this.codec = x(U)
                }
                encode(l) {
                    return this.codec.encode(l)
                }
                decode(l) {
                    for (let c of l)
                        if (this.alphabet && 0 > this.alphabet.indexOf(c)) throw Error(`invalid character '${c}' in '${l}'`);
                    return this.codec.decode(l)
                }
            }
        },
        58599: function(l, c, x) {
            "use strict";
            let N = x(27081),
                U = x(2105),
                {
                    rfc4648: Z
                } = x(63213),
                {
                    decodeText: $,
                    encodeText: Y
                } = x(40533),
                q = [
                    ["identity", "\x00", () => ({
                        encode: $,
                        decode: Y
                    }), ""],
                    ["base2", "0", Z(1), "01"],
                    ["base8", "7", Z(3), "01234567"],
                    ["base10", "9", N, "0123456789"],
                    ["base16", "f", Z(4), "0123456789abcdef"],
                    ["base16upper", "F", Z(4), "0123456789ABCDEF"],
                    ["base32hex", "v", Z(5), "0123456789abcdefghijklmnopqrstuv"],
                    ["base32hexupper", "V", Z(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
                    ["base32hexpad", "t", Z(5), "0123456789abcdefghijklmnopqrstuv="],
                    ["base32hexpadupper", "T", Z(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
                    ["base32", "b", Z(5), "abcdefghijklmnopqrstuvwxyz234567"],
                    ["base32upper", "B", Z(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
                    ["base32pad", "c", Z(5), "abcdefghijklmnopqrstuvwxyz234567="],
                    ["base32padupper", "C", Z(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
                    ["base32z", "h", Z(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
                    ["base36", "k", N, "0123456789abcdefghijklmnopqrstuvwxyz"],
                    ["base36upper", "K", N, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
                    ["base58btc", "z", N, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
                    ["base58flickr", "Z", N, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
                    ["base64", "m", Z(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
                    ["base64pad", "M", Z(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
                    ["base64url", "u", Z(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
                    ["base64urlpad", "U", Z(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
                ],
                J = q.reduce((l, c) => (l[c[0]] = new U(c[0], c[1], c[2], c[3]), l), {}),
                X = q.reduce((l, c) => (l[c[1]] = J[c[0]], l), {});
            l.exports = {
                names: J,
                codes: X
            }
        },
        34313: function(l, c, x) {
            "use strict";
            let N = x(58599),
                {
                    encodeText: U,
                    decodeText: Z,
                    concat: $
                } = x(40533);

            function encoding(l) {
                if (Object.prototype.hasOwnProperty.call(N.names, l)) return N.names[l];
                if (Object.prototype.hasOwnProperty.call(N.codes, l)) return N.codes[l];
                throw Error(`Unsupported encoding: ${l}`)
            }(c = l.exports = function(l, c) {
                if (!c) throw Error("requires an encoded Uint8Array");
                let {
                    name: x,
                    codeBuf: N
                } = encoding(l);
                return function(l, c) {
                    let x = encoding(l);
                    x.decode(Z(c))
                }(x, c), $([N, c], N.length + c.length)
            }).encode = function(l, c) {
                let x = encoding(l),
                    N = U(x.encode(c));
                return $([x.codeBuf, N], x.codeBuf.length + N.length)
            }, c.decode = function(l) {
                l instanceof Uint8Array && (l = Z(l));
                let c = l[0];
                ["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(c) && (l = l.toLowerCase());
                let x = encoding(l[0]);
                return x.decode(l.substring(1))
            }, c.isEncoded = function(l) {
                if (l instanceof Uint8Array && (l = Z(l)), "[object String]" !== Object.prototype.toString.call(l)) return !1;
                try {
                    let c = encoding(l[0]);
                    return c.name
                } catch (l) {
                    return !1
                }
            }, c.encoding = encoding, c.encodingFromData = function(l) {
                return l instanceof Uint8Array && (l = Z(l)), encoding(l[0])
            };
            let Y = Object.freeze(N.names),
                q = Object.freeze(N.codes);
            c.names = Y, c.codes = q
        },
        63213: function(l) {
            "use strict";
            let decode = (l, c, x) => {
                    let N = {};
                    for (let l = 0; l < c.length; ++l) N[c[l]] = l;
                    let U = l.length;
                    for (;
                        "=" === l[U - 1];) --U;
                    let Z = new Uint8Array(U * x / 8 | 0),
                        $ = 0,
                        Y = 0,
                        q = 0;
                    for (let c = 0; c < U; ++c) {
                        let U = N[l[c]];
                        if (void 0 === U) throw SyntaxError("Invalid character " + l[c]);
                        Y = Y << x | U, ($ += x) >= 8 && ($ -= 8, Z[q++] = 255 & Y >> $)
                    }
                    if ($ >= x || 255 & Y << 8 - $) throw SyntaxError("Unexpected end of data");
                    return Z
                },
                encode = (l, c, x) => {
                    let N = "=" === c[c.length - 1],
                        U = (1 << x) - 1,
                        Z = "",
                        $ = 0,
                        Y = 0;
                    for (let N = 0; N < l.length; ++N)
                        for (Y = Y << 8 | l[N], $ += 8; $ > x;) $ -= x, Z += c[U & Y >> $];
                    if ($ && (Z += c[U & Y << x - $]), N)
                        for (; Z.length * x & 7;) Z += "=";
                    return Z
                };
            l.exports = {
                rfc4648: l => c => ({
                    encode: x => encode(x, c, l),
                    decode: x => decode(x, c, l)
                })
            }
        },
        40533: function(l) {
            "use strict";
            let c = new TextDecoder,
                x = new TextEncoder;
            l.exports = {
                decodeText: l => c.decode(l),
                encodeText: l => x.encode(l),
                concat: function(l, c) {
                    let x = new Uint8Array(c),
                        N = 0;
                    for (let c of l) x.set(c, N), N += c.length;
                    return x
                }
            }
        },
        78270: function(l) {
            "use strict";
            let c = Object.freeze({
                identity: 0,
                cidv1: 1,
                cidv2: 2,
                cidv3: 3,
                ip4: 4,
                tcp: 6,
                sha1: 17,
                "sha2-256": 18,
                "sha2-512": 19,
                "sha3-512": 20,
                "sha3-384": 21,
                "sha3-256": 22,
                "sha3-224": 23,
                "shake-128": 24,
                "shake-256": 25,
                "keccak-224": 26,
                "keccak-256": 27,
                "keccak-384": 28,
                "keccak-512": 29,
                blake3: 30,
                dccp: 33,
                "murmur3-128": 34,
                "murmur3-32": 35,
                ip6: 41,
                ip6zone: 42,
                path: 47,
                multicodec: 48,
                multihash: 49,
                multiaddr: 50,
                multibase: 51,
                dns: 53,
                dns4: 54,
                dns6: 55,
                dnsaddr: 56,
                protobuf: 80,
                cbor: 81,
                raw: 85,
                "dbl-sha2-256": 86,
                rlp: 96,
                bencode: 99,
                "dag-pb": 112,
                "dag-cbor": 113,
                "libp2p-key": 114,
                "git-raw": 120,
                "torrent-info": 123,
                "torrent-file": 124,
                "leofcoin-block": 129,
                "leofcoin-tx": 130,
                "leofcoin-pr": 131,
                sctp: 132,
                "dag-jose": 133,
                "dag-cose": 134,
                "eth-block": 144,
                "eth-block-list": 145,
                "eth-tx-trie": 146,
                "eth-tx": 147,
                "eth-tx-receipt-trie": 148,
                "eth-tx-receipt": 149,
                "eth-state-trie": 150,
                "eth-account-snapshot": 151,
                "eth-storage-trie": 152,
                "eth-receipt-log-trie": 153,
                "eth-reciept-log": 154,
                "bitcoin-block": 176,
                "bitcoin-tx": 177,
                "bitcoin-witness-commitment": 178,
                "zcash-block": 192,
                "zcash-tx": 193,
                "caip-50": 202,
                streamid: 206,
                "stellar-block": 208,
                "stellar-tx": 209,
                md4: 212,
                md5: 213,
                bmt: 214,
                "decred-block": 224,
                "decred-tx": 225,
                "ipld-ns": 226,
                "ipfs-ns": 227,
                "swarm-ns": 228,
                "ipns-ns": 229,
                zeronet: 230,
                "secp256k1-pub": 231,
                "bls12_381-g1-pub": 234,
                "bls12_381-g2-pub": 235,
                "x25519-pub": 236,
                "ed25519-pub": 237,
                "bls12_381-g1g2-pub": 238,
                "dash-block": 240,
                "dash-tx": 241,
                "swarm-manifest": 250,
                "swarm-feed": 251,
                udp: 273,
                "p2p-webrtc-star": 275,
                "p2p-webrtc-direct": 276,
                "p2p-stardust": 277,
                "p2p-circuit": 290,
                "dag-json": 297,
                udt: 301,
                utp: 302,
                unix: 400,
                thread: 406,
                p2p: 421,
                ipfs: 421,
                https: 443,
                onion: 444,
                onion3: 445,
                garlic64: 446,
                garlic32: 447,
                tls: 448,
                noise: 454,
                quic: 460,
                ws: 477,
                wss: 478,
                "p2p-websocket-star": 479,
                http: 480,
                "swhid-1-snp": 496,
                json: 512,
                messagepack: 513,
                "libp2p-peer-record": 769,
                "libp2p-relay-rsvp": 770,
                "car-index-sorted": 1024,
                "sha2-256-trunc254-padded": 4114,
                "ripemd-128": 4178,
                "ripemd-160": 4179,
                "ripemd-256": 4180,
                "ripemd-320": 4181,
                x11: 4352,
                "p256-pub": 4608,
                "p384-pub": 4609,
                "p521-pub": 4610,
                "ed448-pub": 4611,
                "x448-pub": 4612,
                "ed25519-priv": 4864,
                "secp256k1-priv": 4865,
                "x25519-priv": 4866,
                kangarootwelve: 7425,
                "sm3-256": 21325,
                "blake2b-8": 45569,
                "blake2b-16": 45570,
                "blake2b-24": 45571,
                "blake2b-32": 45572,
                "blake2b-40": 45573,
                "blake2b-48": 45574,
                "blake2b-56": 45575,
                "blake2b-64": 45576,
                "blake2b-72": 45577,
                "blake2b-80": 45578,
                "blake2b-88": 45579,
                "blake2b-96": 45580,
                "blake2b-104": 45581,
                "blake2b-112": 45582,
                "blake2b-120": 45583,
                "blake2b-128": 45584,
                "blake2b-136": 45585,
                "blake2b-144": 45586,
                "blake2b-152": 45587,
                "blake2b-160": 45588,
                "blake2b-168": 45589,
                "blake2b-176": 45590,
                "blake2b-184": 45591,
                "blake2b-192": 45592,
                "blake2b-200": 45593,
                "blake2b-208": 45594,
                "blake2b-216": 45595,
                "blake2b-224": 45596,
                "blake2b-232": 45597,
                "blake2b-240": 45598,
                "blake2b-248": 45599,
                "blake2b-256": 45600,
                "blake2b-264": 45601,
                "blake2b-272": 45602,
                "blake2b-280": 45603,
                "blake2b-288": 45604,
                "blake2b-296": 45605,
                "blake2b-304": 45606,
                "blake2b-312": 45607,
                "blake2b-320": 45608,
                "blake2b-328": 45609,
                "blake2b-336": 45610,
                "blake2b-344": 45611,
                "blake2b-352": 45612,
                "blake2b-360": 45613,
                "blake2b-368": 45614,
                "blake2b-376": 45615,
                "blake2b-384": 45616,
                "blake2b-392": 45617,
                "blake2b-400": 45618,
                "blake2b-408": 45619,
                "blake2b-416": 45620,
                "blake2b-424": 45621,
                "blake2b-432": 45622,
                "blake2b-440": 45623,
                "blake2b-448": 45624,
                "blake2b-456": 45625,
                "blake2b-464": 45626,
                "blake2b-472": 45627,
                "blake2b-480": 45628,
                "blake2b-488": 45629,
                "blake2b-496": 45630,
                "blake2b-504": 45631,
                "blake2b-512": 45632,
                "blake2s-8": 45633,
                "blake2s-16": 45634,
                "blake2s-24": 45635,
                "blake2s-32": 45636,
                "blake2s-40": 45637,
                "blake2s-48": 45638,
                "blake2s-56": 45639,
                "blake2s-64": 45640,
                "blake2s-72": 45641,
                "blake2s-80": 45642,
                "blake2s-88": 45643,
                "blake2s-96": 45644,
                "blake2s-104": 45645,
                "blake2s-112": 45646,
                "blake2s-120": 45647,
                "blake2s-128": 45648,
                "blake2s-136": 45649,
                "blake2s-144": 45650,
                "blake2s-152": 45651,
                "blake2s-160": 45652,
                "blake2s-168": 45653,
                "blake2s-176": 45654,
                "blake2s-184": 45655,
                "blake2s-192": 45656,
                "blake2s-200": 45657,
                "blake2s-208": 45658,
                "blake2s-216": 45659,
                "blake2s-224": 45660,
                "blake2s-232": 45661,
                "blake2s-240": 45662,
                "blake2s-248": 45663,
                "blake2s-256": 45664,
                "skein256-8": 45825,
                "skein256-16": 45826,
                "skein256-24": 45827,
                "skein256-32": 45828,
                "skein256-40": 45829,
                "skein256-48": 45830,
                "skein256-56": 45831,
                "skein256-64": 45832,
                "skein256-72": 45833,
                "skein256-80": 45834,
                "skein256-88": 45835,
                "skein256-96": 45836,
                "skein256-104": 45837,
                "skein256-112": 45838,
                "skein256-120": 45839,
                "skein256-128": 45840,
                "skein256-136": 45841,
                "skein256-144": 45842,
                "skein256-152": 45843,
                "skein256-160": 45844,
                "skein256-168": 45845,
                "skein256-176": 45846,
                "skein256-184": 45847,
                "skein256-192": 45848,
                "skein256-200": 45849,
                "skein256-208": 45850,
                "skein256-216": 45851,
                "skein256-224": 45852,
                "skein256-232": 45853,
                "skein256-240": 45854,
                "skein256-248": 45855,
                "skein256-256": 45856,
                "skein512-8": 45857,
                "skein512-16": 45858,
                "skein512-24": 45859,
                "skein512-32": 45860,
                "skein512-40": 45861,
                "skein512-48": 45862,
                "skein512-56": 45863,
                "skein512-64": 45864,
                "skein512-72": 45865,
                "skein512-80": 45866,
                "skein512-88": 45867,
                "skein512-96": 45868,
                "skein512-104": 45869,
                "skein512-112": 45870,
                "skein512-120": 45871,
                "skein512-128": 45872,
                "skein512-136": 45873,
                "skein512-144": 45874,
                "skein512-152": 45875,
                "skein512-160": 45876,
                "skein512-168": 45877,
                "skein512-176": 45878,
                "skein512-184": 45879,
                "skein512-192": 45880,
                "skein512-200": 45881,
                "skein512-208": 45882,
                "skein512-216": 45883,
                "skein512-224": 45884,
                "skein512-232": 45885,
                "skein512-240": 45886,
                "skein512-248": 45887,
                "skein512-256": 45888,
                "skein512-264": 45889,
                "skein512-272": 45890,
                "skein512-280": 45891,
                "skein512-288": 45892,
                "skein512-296": 45893,
                "skein512-304": 45894,
                "skein512-312": 45895,
                "skein512-320": 45896,
                "skein512-328": 45897,
                "skein512-336": 45898,
                "skein512-344": 45899,
                "skein512-352": 45900,
                "skein512-360": 45901,
                "skein512-368": 45902,
                "skein512-376": 45903,
                "skein512-384": 45904,
                "skein512-392": 45905,
                "skein512-400": 45906,
                "skein512-408": 45907,
                "skein512-416": 45908,
                "skein512-424": 45909,
                "skein512-432": 45910,
                "skein512-440": 45911,
                "skein512-448": 45912,
                "skein512-456": 45913,
                "skein512-464": 45914,
                "skein512-472": 45915,
                "skein512-480": 45916,
                "skein512-488": 45917,
                "skein512-496": 45918,
                "skein512-504": 45919,
                "skein512-512": 45920,
                "skein1024-8": 45921,
                "skein1024-16": 45922,
                "skein1024-24": 45923,
                "skein1024-32": 45924,
                "skein1024-40": 45925,
                "skein1024-48": 45926,
                "skein1024-56": 45927,
                "skein1024-64": 45928,
                "skein1024-72": 45929,
                "skein1024-80": 45930,
                "skein1024-88": 45931,
                "skein1024-96": 45932,
                "skein1024-104": 45933,
                "skein1024-112": 45934,
                "skein1024-120": 45935,
                "skein1024-128": 45936,
                "skein1024-136": 45937,
                "skein1024-144": 45938,
                "skein1024-152": 45939,
                "skein1024-160": 45940,
                "skein1024-168": 45941,
                "skein1024-176": 45942,
                "skein1024-184": 45943,
                "skein1024-192": 45944,
                "skein1024-200": 45945,
                "skein1024-208": 45946,
                "skein1024-216": 45947,
                "skein1024-224": 45948,
                "skein1024-232": 45949,
                "skein1024-240": 45950,
                "skein1024-248": 45951,
                "skein1024-256": 45952,
                "skein1024-264": 45953,
                "skein1024-272": 45954,
                "skein1024-280": 45955,
                "skein1024-288": 45956,
                "skein1024-296": 45957,
                "skein1024-304": 45958,
                "skein1024-312": 45959,
                "skein1024-320": 45960,
                "skein1024-328": 45961,
                "skein1024-336": 45962,
                "skein1024-344": 45963,
                "skein1024-352": 45964,
                "skein1024-360": 45965,
                "skein1024-368": 45966,
                "skein1024-376": 45967,
                "skein1024-384": 45968,
                "skein1024-392": 45969,
                "skein1024-400": 45970,
                "skein1024-408": 45971,
                "skein1024-416": 45972,
                "skein1024-424": 45973,
                "skein1024-432": 45974,
                "skein1024-440": 45975,
                "skein1024-448": 45976,
                "skein1024-456": 45977,
                "skein1024-464": 45978,
                "skein1024-472": 45979,
                "skein1024-480": 45980,
                "skein1024-488": 45981,
                "skein1024-496": 45982,
                "skein1024-504": 45983,
                "skein1024-512": 45984,
                "skein1024-520": 45985,
                "skein1024-528": 45986,
                "skein1024-536": 45987,
                "skein1024-544": 45988,
                "skein1024-552": 45989,
                "skein1024-560": 45990,
                "skein1024-568": 45991,
                "skein1024-576": 45992,
                "skein1024-584": 45993,
                "skein1024-592": 45994,
                "skein1024-600": 45995,
                "skein1024-608": 45996,
                "skein1024-616": 45997,
                "skein1024-624": 45998,
                "skein1024-632": 45999,
                "skein1024-640": 46e3,
                "skein1024-648": 46001,
                "skein1024-656": 46002,
                "skein1024-664": 46003,
                "skein1024-672": 46004,
                "skein1024-680": 46005,
                "skein1024-688": 46006,
                "skein1024-696": 46007,
                "skein1024-704": 46008,
                "skein1024-712": 46009,
                "skein1024-720": 46010,
                "skein1024-728": 46011,
                "skein1024-736": 46012,
                "skein1024-744": 46013,
                "skein1024-752": 46014,
                "skein1024-760": 46015,
                "skein1024-768": 46016,
                "skein1024-776": 46017,
                "skein1024-784": 46018,
                "skein1024-792": 46019,
                "skein1024-800": 46020,
                "skein1024-808": 46021,
                "skein1024-816": 46022,
                "skein1024-824": 46023,
                "skein1024-832": 46024,
                "skein1024-840": 46025,
                "skein1024-848": 46026,
                "skein1024-856": 46027,
                "skein1024-864": 46028,
                "skein1024-872": 46029,
                "skein1024-880": 46030,
                "skein1024-888": 46031,
                "skein1024-896": 46032,
                "skein1024-904": 46033,
                "skein1024-912": 46034,
                "skein1024-920": 46035,
                "skein1024-928": 46036,
                "skein1024-936": 46037,
                "skein1024-944": 46038,
                "skein1024-952": 46039,
                "skein1024-960": 46040,
                "skein1024-968": 46041,
                "skein1024-976": 46042,
                "skein1024-984": 46043,
                "skein1024-992": 46044,
                "skein1024-1000": 46045,
                "skein1024-1008": 46046,
                "skein1024-1016": 46047,
                "skein1024-1024": 46048,
                "poseidon-bls12_381-a2-fc1": 46081,
                "poseidon-bls12_381-a2-fc1-sc": 46082,
                "zeroxcert-imprint-256": 52753,
                "fil-commitment-unsealed": 61697,
                "fil-commitment-sealed": 61698,
                "holochain-adr-v0": 8417572,
                "holochain-adr-v1": 8483108,
                "holochain-key-v0": 9728292,
                "holochain-key-v1": 9793828,
                "holochain-sig-v0": 10645796,
                "holochain-sig-v1": 10711332,
                "skynet-ns": 11639056,
                "arweave-ns": 11704592
            });
            l.exports = {
                baseTable: c
            }
        },
        97284: function(l, c, x) {
            "use strict";
            let N = x(28965),
                {
                    concat: U
                } = x(72281),
                Z = x(42471),
                {
                    nameToVarint: $,
                    constantToCode: Y,
                    nameToCode: q,
                    codeToName: J
                } = x(60819);

            function getNameFromData(l) {
                let c = N.decode(l),
                    x = J[c];
                if (void 0 === x) throw Error(`Code "${c}" not found`);
                return x
            }

            function getCodeFromName(l) {
                let c = q[l];
                if (void 0 === c) throw Error(`Codec "${l}" not found`);
                return c
            }

            function getCodeFromData(l) {
                return N.decode(l)
            }

            function getVarintFromName(l) {
                let c = $[l];
                if (void 0 === c) throw Error(`Codec "${l}" not found`);
                return c
            }

            function getVarintFromCode(l) {
                return Z.varintEncode(l)
            }
            l.exports = {
                addPrefix: function(l, c) {
                    let x;
                    if (l instanceof Uint8Array) x = Z.varintUint8ArrayEncode(l);
                    else if ($[l]) x = $[l];
                    else throw Error("multicodec not recognized");
                    return U([x, c], x.length + c.length)
                },
                rmPrefix: function(l) {
                    return N.decode(l), l.slice(N.decode.bytes)
                },
                getNameFromData,
                getNameFromCode: function(l) {
                    return J[l]
                },
                getCodeFromName,
                getCodeFromData,
                getVarintFromName,
                getVarintFromCode,
                getCodec: function(l) {
                    return getNameFromData(l)
                },
                getName: function(l) {
                    return J[l]
                },
                getNumber: function(l) {
                    return getCodeFromName(l)
                },
                getCode: function(l) {
                    return getCodeFromData(l)
                },
                getCodeVarint: function(l) {
                    return getVarintFromName(l)
                },
                getVarint: function(l) {
                    return Array.from(getVarintFromCode(l))
                },
                ...Y,
                nameToVarint: $,
                nameToCode: q,
                codeToName: J
            }
        },
        60819: function(l, c, x) {
            "use strict";
            let {
                baseTable: N
            } = x(78270), U = x(42471).varintEncode, Z = {}, $ = {}, Y = {};
            for (let l in N) {
                let c = N[l];
                Z[l] = U(c);
                let x = l.toUpperCase().replace(/-/g, "_");
                $[x] = c, Y[c] || (Y[c] = l)
            }
            Object.freeze(Z), Object.freeze($), Object.freeze(Y);
            let q = Object.freeze(N);
            l.exports = {
                nameToVarint: Z,
                constantToCode: $,
                nameToCode: q,
                codeToName: Y
            }
        },
        42471: function(l, c, x) {
            "use strict";
            let N = x(28965),
                {
                    toString: U
                } = x(21361),
                {
                    fromString: Z
                } = x(34901);

            function uint8ArrayToNumber(l) {
                return parseInt(U(l, "base16"), 16)
            }
            l.exports = {
                numberToUint8Array: function(l) {
                    let c = l.toString(16);
                    return c.length % 2 == 1 && (c = "0" + c), Z(c, "base16")
                },
                uint8ArrayToNumber,
                varintUint8ArrayEncode: function(l) {
                    return Uint8Array.from(N.encode(uint8ArrayToNumber(l)))
                },
                varintEncode: function(l) {
                    return Uint8Array.from(N.encode(l))
                }
            }
        },
        10668: function(l) {
            l.exports = read;

            function read(l, c) {
                var x, N = 0,
                    c = c || 0,
                    U = 0,
                    Z = c,
                    $ = l.length;
                do {
                    if (Z >= $) throw read.bytes = 0, RangeError("Could not decode varint");
                    x = l[Z++], N += U < 28 ? (127 & x) << U : (127 & x) * Math.pow(2, U), U += 7
                } while (x >= 128);
                return read.bytes = Z - c, N
            }
        },
        92093: function(l) {
            l.exports = encode;

            function encode(l, c, x) {
                c = c || [];
                for (var N = x = x || 0; l >= 2147483648;) c[x++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[x++] = 255 & l | 128, l >>>= 7;
                return c[x] = 0 | l, encode.bytes = x - N + 1, c
            }
        },
        97475: function(l, c, x) {
            l.exports = {
                encode: x(92093),
                decode: x(10668),
                encodingLength: x(12577)
            }
        },
        12577: function(l) {
            l.exports = function(l) {
                return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
            }
        },
        17121: function(l) {
            "use strict";
            let c = Object.freeze({
                identity: 0,
                sha1: 17,
                "sha2-256": 18,
                "sha2-512": 19,
                "sha3-512": 20,
                "sha3-384": 21,
                "sha3-256": 22,
                "sha3-224": 23,
                "shake-128": 24,
                "shake-256": 25,
                "keccak-224": 26,
                "keccak-256": 27,
                "keccak-384": 28,
                "keccak-512": 29,
                blake3: 30,
                "murmur3-128": 34,
                "murmur3-32": 35,
                "dbl-sha2-256": 86,
                md4: 212,
                md5: 213,
                bmt: 214,
                "sha2-256-trunc254-padded": 4114,
                "ripemd-128": 4178,
                "ripemd-160": 4179,
                "ripemd-256": 4180,
                "ripemd-320": 4181,
                x11: 4352,
                kangarootwelve: 7425,
                "sm3-256": 21325,
                "blake2b-8": 45569,
                "blake2b-16": 45570,
                "blake2b-24": 45571,
                "blake2b-32": 45572,
                "blake2b-40": 45573,
                "blake2b-48": 45574,
                "blake2b-56": 45575,
                "blake2b-64": 45576,
                "blake2b-72": 45577,
                "blake2b-80": 45578,
                "blake2b-88": 45579,
                "blake2b-96": 45580,
                "blake2b-104": 45581,
                "blake2b-112": 45582,
                "blake2b-120": 45583,
                "blake2b-128": 45584,
                "blake2b-136": 45585,
                "blake2b-144": 45586,
                "blake2b-152": 45587,
                "blake2b-160": 45588,
                "blake2b-168": 45589,
                "blake2b-176": 45590,
                "blake2b-184": 45591,
                "blake2b-192": 45592,
                "blake2b-200": 45593,
                "blake2b-208": 45594,
                "blake2b-216": 45595,
                "blake2b-224": 45596,
                "blake2b-232": 45597,
                "blake2b-240": 45598,
                "blake2b-248": 45599,
                "blake2b-256": 45600,
                "blake2b-264": 45601,
                "blake2b-272": 45602,
                "blake2b-280": 45603,
                "blake2b-288": 45604,
                "blake2b-296": 45605,
                "blake2b-304": 45606,
                "blake2b-312": 45607,
                "blake2b-320": 45608,
                "blake2b-328": 45609,
                "blake2b-336": 45610,
                "blake2b-344": 45611,
                "blake2b-352": 45612,
                "blake2b-360": 45613,
                "blake2b-368": 45614,
                "blake2b-376": 45615,
                "blake2b-384": 45616,
                "blake2b-392": 45617,
                "blake2b-400": 45618,
                "blake2b-408": 45619,
                "blake2b-416": 45620,
                "blake2b-424": 45621,
                "blake2b-432": 45622,
                "blake2b-440": 45623,
                "blake2b-448": 45624,
                "blake2b-456": 45625,
                "blake2b-464": 45626,
                "blake2b-472": 45627,
                "blake2b-480": 45628,
                "blake2b-488": 45629,
                "blake2b-496": 45630,
                "blake2b-504": 45631,
                "blake2b-512": 45632,
                "blake2s-8": 45633,
                "blake2s-16": 45634,
                "blake2s-24": 45635,
                "blake2s-32": 45636,
                "blake2s-40": 45637,
                "blake2s-48": 45638,
                "blake2s-56": 45639,
                "blake2s-64": 45640,
                "blake2s-72": 45641,
                "blake2s-80": 45642,
                "blake2s-88": 45643,
                "blake2s-96": 45644,
                "blake2s-104": 45645,
                "blake2s-112": 45646,
                "blake2s-120": 45647,
                "blake2s-128": 45648,
                "blake2s-136": 45649,
                "blake2s-144": 45650,
                "blake2s-152": 45651,
                "blake2s-160": 45652,
                "blake2s-168": 45653,
                "blake2s-176": 45654,
                "blake2s-184": 45655,
                "blake2s-192": 45656,
                "blake2s-200": 45657,
                "blake2s-208": 45658,
                "blake2s-216": 45659,
                "blake2s-224": 45660,
                "blake2s-232": 45661,
                "blake2s-240": 45662,
                "blake2s-248": 45663,
                "blake2s-256": 45664,
                "skein256-8": 45825,
                "skein256-16": 45826,
                "skein256-24": 45827,
                "skein256-32": 45828,
                "skein256-40": 45829,
                "skein256-48": 45830,
                "skein256-56": 45831,
                "skein256-64": 45832,
                "skein256-72": 45833,
                "skein256-80": 45834,
                "skein256-88": 45835,
                "skein256-96": 45836,
                "skein256-104": 45837,
                "skein256-112": 45838,
                "skein256-120": 45839,
                "skein256-128": 45840,
                "skein256-136": 45841,
                "skein256-144": 45842,
                "skein256-152": 45843,
                "skein256-160": 45844,
                "skein256-168": 45845,
                "skein256-176": 45846,
                "skein256-184": 45847,
                "skein256-192": 45848,
                "skein256-200": 45849,
                "skein256-208": 45850,
                "skein256-216": 45851,
                "skein256-224": 45852,
                "skein256-232": 45853,
                "skein256-240": 45854,
                "skein256-248": 45855,
                "skein256-256": 45856,
                "skein512-8": 45857,
                "skein512-16": 45858,
                "skein512-24": 45859,
                "skein512-32": 45860,
                "skein512-40": 45861,
                "skein512-48": 45862,
                "skein512-56": 45863,
                "skein512-64": 45864,
                "skein512-72": 45865,
                "skein512-80": 45866,
                "skein512-88": 45867,
                "skein512-96": 45868,
                "skein512-104": 45869,
                "skein512-112": 45870,
                "skein512-120": 45871,
                "skein512-128": 45872,
                "skein512-136": 45873,
                "skein512-144": 45874,
                "skein512-152": 45875,
                "skein512-160": 45876,
                "skein512-168": 45877,
                "skein512-176": 45878,
                "skein512-184": 45879,
                "skein512-192": 45880,
                "skein512-200": 45881,
                "skein512-208": 45882,
                "skein512-216": 45883,
                "skein512-224": 45884,
                "skein512-232": 45885,
                "skein512-240": 45886,
                "skein512-248": 45887,
                "skein512-256": 45888,
                "skein512-264": 45889,
                "skein512-272": 45890,
                "skein512-280": 45891,
                "skein512-288": 45892,
                "skein512-296": 45893,
                "skein512-304": 45894,
                "skein512-312": 45895,
                "skein512-320": 45896,
                "skein512-328": 45897,
                "skein512-336": 45898,
                "skein512-344": 45899,
                "skein512-352": 45900,
                "skein512-360": 45901,
                "skein512-368": 45902,
                "skein512-376": 45903,
                "skein512-384": 45904,
                "skein512-392": 45905,
                "skein512-400": 45906,
                "skein512-408": 45907,
                "skein512-416": 45908,
                "skein512-424": 45909,
                "skein512-432": 45910,
                "skein512-440": 45911,
                "skein512-448": 45912,
                "skein512-456": 45913,
                "skein512-464": 45914,
                "skein512-472": 45915,
                "skein512-480": 45916,
                "skein512-488": 45917,
                "skein512-496": 45918,
                "skein512-504": 45919,
                "skein512-512": 45920,
                "skein1024-8": 45921,
                "skein1024-16": 45922,
                "skein1024-24": 45923,
                "skein1024-32": 45924,
                "skein1024-40": 45925,
                "skein1024-48": 45926,
                "skein1024-56": 45927,
                "skein1024-64": 45928,
                "skein1024-72": 45929,
                "skein1024-80": 45930,
                "skein1024-88": 45931,
                "skein1024-96": 45932,
                "skein1024-104": 45933,
                "skein1024-112": 45934,
                "skein1024-120": 45935,
                "skein1024-128": 45936,
                "skein1024-136": 45937,
                "skein1024-144": 45938,
                "skein1024-152": 45939,
                "skein1024-160": 45940,
                "skein1024-168": 45941,
                "skein1024-176": 45942,
                "skein1024-184": 45943,
                "skein1024-192": 45944,
                "skein1024-200": 45945,
                "skein1024-208": 45946,
                "skein1024-216": 45947,
                "skein1024-224": 45948,
                "skein1024-232": 45949,
                "skein1024-240": 45950,
                "skein1024-248": 45951,
                "skein1024-256": 45952,
                "skein1024-264": 45953,
                "skein1024-272": 45954,
                "skein1024-280": 45955,
                "skein1024-288": 45956,
                "skein1024-296": 45957,
                "skein1024-304": 45958,
                "skein1024-312": 45959,
                "skein1024-320": 45960,
                "skein1024-328": 45961,
                "skein1024-336": 45962,
                "skein1024-344": 45963,
                "skein1024-352": 45964,
                "skein1024-360": 45965,
                "skein1024-368": 45966,
                "skein1024-376": 45967,
                "skein1024-384": 45968,
                "skein1024-392": 45969,
                "skein1024-400": 45970,
                "skein1024-408": 45971,
                "skein1024-416": 45972,
                "skein1024-424": 45973,
                "skein1024-432": 45974,
                "skein1024-440": 45975,
                "skein1024-448": 45976,
                "skein1024-456": 45977,
                "skein1024-464": 45978,
                "skein1024-472": 45979,
                "skein1024-480": 45980,
                "skein1024-488": 45981,
                "skein1024-496": 45982,
                "skein1024-504": 45983,
                "skein1024-512": 45984,
                "skein1024-520": 45985,
                "skein1024-528": 45986,
                "skein1024-536": 45987,
                "skein1024-544": 45988,
                "skein1024-552": 45989,
                "skein1024-560": 45990,
                "skein1024-568": 45991,
                "skein1024-576": 45992,
                "skein1024-584": 45993,
                "skein1024-592": 45994,
                "skein1024-600": 45995,
                "skein1024-608": 45996,
                "skein1024-616": 45997,
                "skein1024-624": 45998,
                "skein1024-632": 45999,
                "skein1024-640": 46e3,
                "skein1024-648": 46001,
                "skein1024-656": 46002,
                "skein1024-664": 46003,
                "skein1024-672": 46004,
                "skein1024-680": 46005,
                "skein1024-688": 46006,
                "skein1024-696": 46007,
                "skein1024-704": 46008,
                "skein1024-712": 46009,
                "skein1024-720": 46010,
                "skein1024-728": 46011,
                "skein1024-736": 46012,
                "skein1024-744": 46013,
                "skein1024-752": 46014,
                "skein1024-760": 46015,
                "skein1024-768": 46016,
                "skein1024-776": 46017,
                "skein1024-784": 46018,
                "skein1024-792": 46019,
                "skein1024-800": 46020,
                "skein1024-808": 46021,
                "skein1024-816": 46022,
                "skein1024-824": 46023,
                "skein1024-832": 46024,
                "skein1024-840": 46025,
                "skein1024-848": 46026,
                "skein1024-856": 46027,
                "skein1024-864": 46028,
                "skein1024-872": 46029,
                "skein1024-880": 46030,
                "skein1024-888": 46031,
                "skein1024-896": 46032,
                "skein1024-904": 46033,
                "skein1024-912": 46034,
                "skein1024-920": 46035,
                "skein1024-928": 46036,
                "skein1024-936": 46037,
                "skein1024-944": 46038,
                "skein1024-952": 46039,
                "skein1024-960": 46040,
                "skein1024-968": 46041,
                "skein1024-976": 46042,
                "skein1024-984": 46043,
                "skein1024-992": 46044,
                "skein1024-1000": 46045,
                "skein1024-1008": 46046,
                "skein1024-1016": 46047,
                "skein1024-1024": 46048,
                "poseidon-bls12_381-a2-fc1": 46081,
                "poseidon-bls12_381-a2-fc1-sc": 46082
            });
            l.exports = {
                names: c
            }
        },
        20400: function(l, c, x) {
            "use strict";
            let N = x(34313),
                U = x(97475),
                {
                    names: Z
                } = x(17121),
                {
                    toString: $
                } = x(21361),
                {
                    fromString: Y
                } = x(34901),
                {
                    concat: q
                } = x(72281),
                J = {};
            for (let l in Z) J[Z[l]] = l;

            function decode(l) {
                if (!(l instanceof Uint8Array)) throw Error("multihash must be a Uint8Array");
                if (l.length < 2) throw Error("multihash too short. must be > 2 bytes.");
                let c = U.decode(l);
                if (!isValidCode(c)) throw Error(`multihash unknown function code: 0x${c.toString(16)}`);
                l = l.slice(U.decode.bytes);
                let x = U.decode(l);
                if (x < 0) throw Error(`multihash invalid length: ${x}`);
                if ((l = l.slice(U.decode.bytes)).length !== x) throw Error(`multihash length inconsistent: 0x${$(l,"base16")}`);
                return {
                    code: c,
                    name: J[c],
                    length: x,
                    digest: l
                }
            }

            function coerceCode(l) {
                let c = l;
                if ("string" == typeof l) {
                    if (void 0 === Z[l]) throw Error(`Unrecognized hash function named: ${l}`);
                    c = Z[l]
                }
                if ("number" != typeof c) throw Error(`Hash function code should be a number. Got: ${c}`);
                if (void 0 === J[c] && !isAppCode(c)) throw Error(`Unrecognized function code: ${c}`);
                return c
            }

            function isAppCode(l) {
                return l > 0 && l < 16
            }

            function isValidCode(l) {
                return !!isAppCode(l) || !!J[l]
            }
            Object.freeze(J), l.exports = {
                names: Z,
                codes: J,
                toHexString: function(l) {
                    if (!(l instanceof Uint8Array)) throw Error("must be passed a Uint8Array");
                    return $(l, "base16")
                },
                fromHexString: function(l) {
                    return Y(l, "base16")
                },
                toB58String: function(l) {
                    if (!(l instanceof Uint8Array)) throw Error("must be passed a Uint8Array");
                    return $(N.encode("base58btc", l)).slice(1)
                },
                fromB58String: function(l) {
                    let c = l instanceof Uint8Array ? $(l) : l;
                    return N.decode("z" + c)
                },
                decode,
                encode: function(l, c, x) {
                    if (!l || void 0 === c) throw Error("multihash encode requires at least two args: digest, code");
                    let N = coerceCode(c);
                    if (!(l instanceof Uint8Array)) throw Error("digest should be a Uint8Array");
                    if (null == x && (x = l.length), x && l.length !== x) throw Error("digest length should be equal to specified length.");
                    let Z = U.encode(N),
                        $ = U.encode(x);
                    return q([Z, $, l], Z.length + $.length + l.length)
                },
                coerceCode,
                isAppCode,
                validate: function(l) {
                    decode(l)
                },
                prefix: function(l) {
                    return decode(l), l.subarray(0, 2)
                },
                isValidCode
            }
        },
        31935: function(l) {
            "use strict";
            let c = self.fetch.bind(self);
            l.exports = c, l.exports.default = l.exports
        },
        75298: function(l, c, x) {
            let N = x(47363),
                U = x(37621),
                Z = x(46028),
                $ = x(12330);

            function renderCanvas(l, c, x, Z, $) {
                let Y = [].slice.call(arguments, 1),
                    q = Y.length,
                    J = "function" == typeof Y[q - 1];
                if (!J && !N()) throw Error("Callback required as last argument");
                if (J) {
                    if (q < 2) throw Error("Too few arguments provided");
                    2 === q ? ($ = x, x = c, c = Z = void 0) : 3 === q && (c.getContext && void 0 === $ ? ($ = Z, Z = void 0) : ($ = Z, Z = x, x = c, c = void 0))
                } else {
                    if (q < 1) throw Error("Too few arguments provided");
                    return 1 === q ? (x = c, c = Z = void 0) : 2 !== q || c.getContext || (Z = x, x = c, c = void 0), new Promise(function(N, $) {
                        try {
                            let $ = U.create(x, Z);
                            N(l($, c, Z))
                        } catch (l) {
                            $(l)
                        }
                    })
                }
                try {
                    let N = U.create(x, Z);
                    $(null, l(N, c, Z))
                } catch (l) {
                    $(l)
                }
            }
            c.create = U.create, c.toCanvas = renderCanvas.bind(null, Z.render), c.toDataURL = renderCanvas.bind(null, Z.renderToDataURL), c.toString = renderCanvas.bind(null, function(l, c, x) {
                return $.render(l, x)
            })
        },
        47363: function(l) {
            l.exports = function() {
                return "function" == typeof Promise && Promise.prototype && Promise.prototype.then
            }
        },
        8177: function(l, c, x) {
            let N = x(13400).getSymbolSize;
            c.getRowColCoords = function(l) {
                if (1 === l) return [];
                let c = Math.floor(l / 7) + 2,
                    x = N(l),
                    U = 145 === x ? 26 : 2 * Math.ceil((x - 13) / (2 * c - 2)),
                    Z = [x - 7];
                for (let l = 1; l < c - 1; l++) Z[l] = Z[l - 1] - U;
                return Z.push(6), Z.reverse()
            }, c.getPositions = function(l) {
                let x = [],
                    N = c.getRowColCoords(l),
                    U = N.length;
                for (let l = 0; l < U; l++)
                    for (let c = 0; c < U; c++)(0 !== l || 0 !== c) && (0 !== l || c !== U - 1) && (l !== U - 1 || 0 !== c) && x.push([N[l], N[c]]);
                return x
            }
        },
        77654: function(l, c, x) {
            let N = x(37662),
                U = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

            function AlphanumericData(l) {
                this.mode = N.ALPHANUMERIC, this.data = l
            }
            AlphanumericData.getBitsLength = function(l) {
                return 11 * Math.floor(l / 2) + 6 * (l % 2)
            }, AlphanumericData.prototype.getLength = function() {
                return this.data.length
            }, AlphanumericData.prototype.getBitsLength = function() {
                return AlphanumericData.getBitsLength(this.data.length)
            }, AlphanumericData.prototype.write = function(l) {
                let c;
                for (c = 0; c + 2 <= this.data.length; c += 2) {
                    let x = 45 * U.indexOf(this.data[c]);
                    x += U.indexOf(this.data[c + 1]), l.put(x, 11)
                }
                this.data.length % 2 && l.put(U.indexOf(this.data[c]), 6)
            }, l.exports = AlphanumericData
        },
        41904: function(l) {
            function BitBuffer() {
                this.buffer = [], this.length = 0
            }
            BitBuffer.prototype = {
                get: function(l) {
                    let c = Math.floor(l / 8);
                    return (this.buffer[c] >>> 7 - l % 8 & 1) == 1
                },
                put: function(l, c) {
                    for (let x = 0; x < c; x++) this.putBit((l >>> c - x - 1 & 1) == 1)
                },
                getLengthInBits: function() {
                    return this.length
                },
                putBit: function(l) {
                    let c = Math.floor(this.length / 8);
                    this.buffer.length <= c && this.buffer.push(0), l && (this.buffer[c] |= 128 >>> this.length % 8), this.length++
                }
            }, l.exports = BitBuffer
        },
        21091: function(l) {
            function BitMatrix(l) {
                if (!l || l < 1) throw Error("BitMatrix size must be defined and greater than 0");
                this.size = l, this.data = new Uint8Array(l * l), this.reservedBit = new Uint8Array(l * l)
            }
            BitMatrix.prototype.set = function(l, c, x, N) {
                let U = l * this.size + c;
                this.data[U] = x, N && (this.reservedBit[U] = !0)
            }, BitMatrix.prototype.get = function(l, c) {
                return this.data[l * this.size + c]
            }, BitMatrix.prototype.xor = function(l, c, x) {
                this.data[l * this.size + c] ^= x
            }, BitMatrix.prototype.isReserved = function(l, c) {
                return this.reservedBit[l * this.size + c]
            }, l.exports = BitMatrix
        },
        90690: function(l, c, x) {
            let N = x(53216),
                U = x(37662);

            function ByteData(l) {
                this.mode = U.BYTE, "string" == typeof l && (l = N(l)), this.data = new Uint8Array(l)
            }
            ByteData.getBitsLength = function(l) {
                return 8 * l
            }, ByteData.prototype.getLength = function() {
                return this.data.length
            }, ByteData.prototype.getBitsLength = function() {
                return ByteData.getBitsLength(this.data.length)
            }, ByteData.prototype.write = function(l) {
                for (let c = 0, x = this.data.length; c < x; c++) l.put(this.data[c], 8)
            }, l.exports = ByteData
        },
        37039: function(l, c, x) {
            let N = x(9406),
                U = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81],
                Z = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
            c.getBlocksCount = function(l, c) {
                switch (c) {
                    case N.L:
                        return U[(l - 1) * 4 + 0];
                    case N.M:
                        return U[(l - 1) * 4 + 1];
                    case N.Q:
                        return U[(l - 1) * 4 + 2];
                    case N.H:
                        return U[(l - 1) * 4 + 3];
                    default:
                        return
                }
            }, c.getTotalCodewordsCount = function(l, c) {
                switch (c) {
                    case N.L:
                        return Z[(l - 1) * 4 + 0];
                    case N.M:
                        return Z[(l - 1) * 4 + 1];
                    case N.Q:
                        return Z[(l - 1) * 4 + 2];
                    case N.H:
                        return Z[(l - 1) * 4 + 3];
                    default:
                        return
                }
            }
        },
        9406: function(l, c) {
            c.L = {
                bit: 1
            }, c.M = {
                bit: 0
            }, c.Q = {
                bit: 3
            }, c.H = {
                bit: 2
            }, c.isValid = function(l) {
                return l && void 0 !== l.bit && l.bit >= 0 && l.bit < 4
            }, c.from = function(l, x) {
                if (c.isValid(l)) return l;
                try {
                    return function(l) {
                        if ("string" != typeof l) throw Error("Param is not a string");
                        let x = l.toLowerCase();
                        switch (x) {
                            case "l":
                            case "low":
                                return c.L;
                            case "m":
                            case "medium":
                                return c.M;
                            case "q":
                            case "quartile":
                                return c.Q;
                            case "h":
                            case "high":
                                return c.H;
                            default:
                                throw Error("Unknown EC Level: " + l)
                        }
                    }(l)
                } catch (l) {
                    return x
                }
            }
        },
        78241: function(l, c, x) {
            let N = x(13400).getSymbolSize;
            c.getPositions = function(l) {
                let c = N(l);
                return [
                    [0, 0],
                    [c - 7, 0],
                    [0, c - 7]
                ]
            }
        },
        50237: function(l, c, x) {
            let N = x(13400),
                U = N.getBCHDigit(1335);
            c.getEncodedBits = function(l, c) {
                let x = l.bit << 3 | c,
                    Z = x << 10;
                for (; N.getBCHDigit(Z) - U >= 0;) Z ^= 1335 << N.getBCHDigit(Z) - U;
                return (x << 10 | Z) ^ 21522
            }
        },
        51309: function(l, c) {
            let x = new Uint8Array(512),
                N = new Uint8Array(256);
            ! function() {
                let l = 1;
                for (let c = 0; c < 255; c++) x[c] = l, N[l] = c, 256 & (l <<= 1) && (l ^= 285);
                for (let l = 255; l < 512; l++) x[l] = x[l - 255]
            }(), c.log = function(l) {
                if (l < 1) throw Error("log(" + l + ")");
                return N[l]
            }, c.exp = function(l) {
                return x[l]
            }, c.mul = function(l, c) {
                return 0 === l || 0 === c ? 0 : x[N[l] + N[c]]
            }
        },
        69592: function(l, c, x) {
            let N = x(37662),
                U = x(13400);

            function KanjiData(l) {
                this.mode = N.KANJI, this.data = l
            }
            KanjiData.getBitsLength = function(l) {
                return 13 * l
            }, KanjiData.prototype.getLength = function() {
                return this.data.length
            }, KanjiData.prototype.getBitsLength = function() {
                return KanjiData.getBitsLength(this.data.length)
            }, KanjiData.prototype.write = function(l) {
                let c;
                for (c = 0; c < this.data.length; c++) {
                    let x = U.toSJIS(this.data[c]);
                    if (x >= 33088 && x <= 40956) x -= 33088;
                    else if (x >= 57408 && x <= 60351) x -= 49472;
                    else throw Error("Invalid SJIS character: " + this.data[c] + "\nMake sure your charset is UTF-8");
                    x = (x >>> 8 & 255) * 192 + (255 & x), l.put(x, 13)
                }
            }, l.exports = KanjiData
        },
        62486: function(l, c) {
            c.Patterns = {
                PATTERN000: 0,
                PATTERN001: 1,
                PATTERN010: 2,
                PATTERN011: 3,
                PATTERN100: 4,
                PATTERN101: 5,
                PATTERN110: 6,
                PATTERN111: 7
            };
            let x = {
                N1: 3,
                N2: 3,
                N3: 40,
                N4: 10
            };
            c.isValid = function(l) {
                return null != l && "" !== l && !isNaN(l) && l >= 0 && l <= 7
            }, c.from = function(l) {
                return c.isValid(l) ? parseInt(l, 10) : void 0
            }, c.getPenaltyN1 = function(l) {
                let c = l.size,
                    N = 0,
                    U = 0,
                    Z = 0,
                    $ = null,
                    Y = null;
                for (let q = 0; q < c; q++) {
                    U = Z = 0, $ = Y = null;
                    for (let J = 0; J < c; J++) {
                        let c = l.get(q, J);
                        c === $ ? U++ : (U >= 5 && (N += x.N1 + (U - 5)), $ = c, U = 1), (c = l.get(J, q)) === Y ? Z++ : (Z >= 5 && (N += x.N1 + (Z - 5)), Y = c, Z = 1)
                    }
                    U >= 5 && (N += x.N1 + (U - 5)), Z >= 5 && (N += x.N1 + (Z - 5))
                }
                return N
            }, c.getPenaltyN2 = function(l) {
                let c = l.size,
                    N = 0;
                for (let x = 0; x < c - 1; x++)
                    for (let U = 0; U < c - 1; U++) {
                        let c = l.get(x, U) + l.get(x, U + 1) + l.get(x + 1, U) + l.get(x + 1, U + 1);
                        (4 === c || 0 === c) && N++
                    }
                return N * x.N2
            }, c.getPenaltyN3 = function(l) {
                let c = l.size,
                    N = 0,
                    U = 0,
                    Z = 0;
                for (let x = 0; x < c; x++) {
                    U = Z = 0;
                    for (let $ = 0; $ < c; $++) U = U << 1 & 2047 | l.get(x, $), $ >= 10 && (1488 === U || 93 === U) && N++, Z = Z << 1 & 2047 | l.get($, x), $ >= 10 && (1488 === Z || 93 === Z) && N++
                }
                return N * x.N3
            }, c.getPenaltyN4 = function(l) {
                let c = 0,
                    N = l.data.length;
                for (let x = 0; x < N; x++) c += l.data[x];
                let U = Math.abs(Math.ceil(100 * c / N / 5) - 10);
                return U * x.N4
            }, c.applyMask = function(l, x) {
                let N = x.size;
                for (let U = 0; U < N; U++)
                    for (let Z = 0; Z < N; Z++) x.isReserved(Z, U) || x.xor(Z, U, function(l, x, N) {
                        switch (l) {
                            case c.Patterns.PATTERN000:
                                return (x + N) % 2 == 0;
                            case c.Patterns.PATTERN001:
                                return x % 2 == 0;
                            case c.Patterns.PATTERN010:
                                return N % 3 == 0;
                            case c.Patterns.PATTERN011:
                                return (x + N) % 3 == 0;
                            case c.Patterns.PATTERN100:
                                return (Math.floor(x / 2) + Math.floor(N / 3)) % 2 == 0;
                            case c.Patterns.PATTERN101:
                                return x * N % 2 + x * N % 3 == 0;
                            case c.Patterns.PATTERN110:
                                return (x * N % 2 + x * N % 3) % 2 == 0;
                            case c.Patterns.PATTERN111:
                                return (x * N % 3 + (x + N) % 2) % 2 == 0;
                            default:
                                throw Error("bad maskPattern:" + l)
                        }
                    }(l, Z, U))
            }, c.getBestMask = function(l, x) {
                let N = Object.keys(c.Patterns).length,
                    U = 0,
                    Z = 1 / 0;
                for (let $ = 0; $ < N; $++) {
                    x($), c.applyMask($, l);
                    let N = c.getPenaltyN1(l) + c.getPenaltyN2(l) + c.getPenaltyN3(l) + c.getPenaltyN4(l);
                    c.applyMask($, l), N < Z && (Z = N, U = $)
                }
                return U
            }
        },
        37662: function(l, c, x) {
            let N = x(64956),
                U = x(66579);
            c.NUMERIC = {
                id: "Numeric",
                bit: 1,
                ccBits: [10, 12, 14]
            }, c.ALPHANUMERIC = {
                id: "Alphanumeric",
                bit: 2,
                ccBits: [9, 11, 13]
            }, c.BYTE = {
                id: "Byte",
                bit: 4,
                ccBits: [8, 16, 16]
            }, c.KANJI = {
                id: "Kanji",
                bit: 8,
                ccBits: [8, 10, 12]
            }, c.MIXED = {
                bit: -1
            }, c.getCharCountIndicator = function(l, c) {
                if (!l.ccBits) throw Error("Invalid mode: " + l);
                if (!N.isValid(c)) throw Error("Invalid version: " + c);
                return c >= 1 && c < 10 ? l.ccBits[0] : c < 27 ? l.ccBits[1] : l.ccBits[2]
            }, c.getBestModeForData = function(l) {
                return U.testNumeric(l) ? c.NUMERIC : U.testAlphanumeric(l) ? c.ALPHANUMERIC : U.testKanji(l) ? c.KANJI : c.BYTE
            }, c.toString = function(l) {
                if (l && l.id) return l.id;
                throw Error("Invalid mode")
            }, c.isValid = function(l) {
                return l && l.bit && l.ccBits
            }, c.from = function(l, x) {
                if (c.isValid(l)) return l;
                try {
                    return function(l) {
                        if ("string" != typeof l) throw Error("Param is not a string");
                        let x = l.toLowerCase();
                        switch (x) {
                            case "numeric":
                                return c.NUMERIC;
                            case "alphanumeric":
                                return c.ALPHANUMERIC;
                            case "kanji":
                                return c.KANJI;
                            case "byte":
                                return c.BYTE;
                            default:
                                throw Error("Unknown mode: " + l)
                        }
                    }(l)
                } catch (l) {
                    return x
                }
            }
        },
        10894: function(l, c, x) {
            let N = x(37662);

            function NumericData(l) {
                this.mode = N.NUMERIC, this.data = l.toString()
            }
            NumericData.getBitsLength = function(l) {
                return 10 * Math.floor(l / 3) + (l % 3 ? l % 3 * 3 + 1 : 0)
            }, NumericData.prototype.getLength = function() {
                return this.data.length
            }, NumericData.prototype.getBitsLength = function() {
                return NumericData.getBitsLength(this.data.length)
            }, NumericData.prototype.write = function(l) {
                let c, x;
                for (c = 0; c + 3 <= this.data.length; c += 3) x = parseInt(this.data.substr(c, 3), 10), l.put(x, 10);
                let N = this.data.length - c;
                N > 0 && (x = parseInt(this.data.substr(c), 10), l.put(x, 3 * N + 1))
            }, l.exports = NumericData
        },
        25153: function(l, c, x) {
            let N = x(51309);
            c.mul = function(l, c) {
                let x = new Uint8Array(l.length + c.length - 1);
                for (let U = 0; U < l.length; U++)
                    for (let Z = 0; Z < c.length; Z++) x[U + Z] ^= N.mul(l[U], c[Z]);
                return x
            }, c.mod = function(l, c) {
                let x = new Uint8Array(l);
                for (; x.length - c.length >= 0;) {
                    let l = x[0];
                    for (let U = 0; U < c.length; U++) x[U] ^= N.mul(c[U], l);
                    let U = 0;
                    for (; U < x.length && 0 === x[U];) U++;
                    x = x.slice(U)
                }
                return x
            }, c.generateECPolynomial = function(l) {
                let x = new Uint8Array([1]);
                for (let U = 0; U < l; U++) x = c.mul(x, new Uint8Array([1, N.exp(U)]));
                return x
            }
        },
        37621: function(l, c, x) {
            let N = x(13400),
                U = x(9406),
                Z = x(41904),
                $ = x(21091),
                Y = x(8177),
                q = x(78241),
                J = x(62486),
                X = x(37039),
                en = x(9936),
                er = x(48670),
                ea = x(50237),
                eo = x(37662),
                el = x(25082);

            function setupFormatInfo(l, c, x) {
                let N, U;
                let Z = l.size,
                    $ = ea.getEncodedBits(c, x);
                for (N = 0; N < 15; N++) U = ($ >> N & 1) == 1, N < 6 ? l.set(N, 8, U, !0) : N < 8 ? l.set(N + 1, 8, U, !0) : l.set(Z - 15 + N, 8, U, !0), N < 8 ? l.set(8, Z - N - 1, U, !0) : N < 9 ? l.set(8, 15 - N - 1 + 1, U, !0) : l.set(8, 15 - N - 1, U, !0);
                l.set(Z - 8, 8, 1, !0)
            }
            c.create = function(l, c) {
                let x, ea;
                if (void 0 === l || "" === l) throw Error("No input text");
                let ec = U.M;
                return void 0 !== c && (ec = U.from(c.errorCorrectionLevel, U.M), x = er.from(c.version), ea = J.from(c.maskPattern), c.toSJISFunc && N.setToSJISFunction(c.toSJISFunc)),
                    function(l, c, x, U) {
                        let ea;
                        if (Array.isArray(l)) ea = el.fromArray(l);
                        else if ("string" == typeof l) {
                            let N = c;
                            if (!N) {
                                let c = el.rawSplit(l);
                                N = er.getBestVersionForData(c, x)
                            }
                            ea = el.fromString(l, N || 40)
                        } else throw Error("Invalid data");
                        let ec = er.getBestVersionForData(ea, x);
                        if (!ec) throw Error("The amount of data is too big to be stored in a QR Code");
                        if (c) {
                            if (c < ec) throw Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + ec + ".\n")
                        } else c = ec;
                        let eu = function(l, c, x) {
                                let U = new Z;
                                x.forEach(function(c) {
                                    U.put(c.mode.bit, 4), U.put(c.getLength(), eo.getCharCountIndicator(c.mode, l)), c.write(U)
                                });
                                let $ = N.getSymbolTotalCodewords(l),
                                    Y = X.getTotalCodewordsCount(l, c),
                                    q = ($ - Y) * 8;
                                for (U.getLengthInBits() + 4 <= q && U.put(0, 4); U.getLengthInBits() % 8 != 0;) U.putBit(0);
                                let J = (q - U.getLengthInBits()) / 8;
                                for (let l = 0; l < J; l++) U.put(l % 2 ? 17 : 236, 8);
                                return function(l, c, x) {
                                    let U, Z;
                                    let $ = N.getSymbolTotalCodewords(c),
                                        Y = X.getTotalCodewordsCount(c, x),
                                        q = $ - Y,
                                        J = X.getBlocksCount(c, x),
                                        er = $ % J,
                                        ea = J - er,
                                        eo = Math.floor($ / J),
                                        el = Math.floor(q / J),
                                        ec = el + 1,
                                        eu = eo - el,
                                        ed = new en(eu),
                                        ep = 0,
                                        eh = Array(J),
                                        ey = Array(J),
                                        ef = 0,
                                        em = new Uint8Array(l.buffer);
                                    for (let l = 0; l < J; l++) {
                                        let c = l < ea ? el : ec;
                                        eh[l] = em.slice(ep, ep + c), ey[l] = ed.encode(eh[l]), ep += c, ef = Math.max(ef, c)
                                    }
                                    let eg = new Uint8Array($),
                                        eb = 0;
                                    for (U = 0; U < ef; U++)
                                        for (Z = 0; Z < J; Z++) U < eh[Z].length && (eg[eb++] = eh[Z][U]);
                                    for (U = 0; U < eu; U++)
                                        for (Z = 0; Z < J; Z++) eg[eb++] = ey[Z][U];
                                    return eg
                                }(U, l, c)
                            }(c, x, ea),
                            ed = N.getSymbolSize(c),
                            ep = new $(ed);
                        return function(l, c) {
                                let x = l.size,
                                    N = q.getPositions(c);
                                for (let c = 0; c < N.length; c++) {
                                    let U = N[c][0],
                                        Z = N[c][1];
                                    for (let c = -1; c <= 7; c++)
                                        if (!(U + c <= -1) && !(x <= U + c))
                                            for (let N = -1; N <= 7; N++) Z + N <= -1 || x <= Z + N || (c >= 0 && c <= 6 && (0 === N || 6 === N) || N >= 0 && N <= 6 && (0 === c || 6 === c) || c >= 2 && c <= 4 && N >= 2 && N <= 4 ? l.set(U + c, Z + N, !0, !0) : l.set(U + c, Z + N, !1, !0))
                                }
                            }(ep, c),
                            function(l) {
                                let c = l.size;
                                for (let x = 8; x < c - 8; x++) {
                                    let c = x % 2 == 0;
                                    l.set(x, 6, c, !0), l.set(6, x, c, !0)
                                }
                            }(ep),
                            function(l, c) {
                                let x = Y.getPositions(c);
                                for (let c = 0; c < x.length; c++) {
                                    let N = x[c][0],
                                        U = x[c][1];
                                    for (let c = -2; c <= 2; c++)
                                        for (let x = -2; x <= 2; x++) - 2 === c || 2 === c || -2 === x || 2 === x || 0 === c && 0 === x ? l.set(N + c, U + x, !0, !0) : l.set(N + c, U + x, !1, !0)
                                }
                            }(ep, c), setupFormatInfo(ep, x, 0), c >= 7 && function(l, c) {
                                let x, N, U;
                                let Z = l.size,
                                    $ = er.getEncodedBits(c);
                                for (let c = 0; c < 18; c++) x = Math.floor(c / 3), N = c % 3 + Z - 8 - 3, U = ($ >> c & 1) == 1, l.set(x, N, U, !0), l.set(N, x, U, !0)
                            }(ep, c),
                            function(l, c) {
                                let x = l.size,
                                    N = -1,
                                    U = x - 1,
                                    Z = 7,
                                    $ = 0;
                                for (let Y = x - 1; Y > 0; Y -= 2)
                                    for (6 === Y && Y--;;) {
                                        for (let x = 0; x < 2; x++)
                                            if (!l.isReserved(U, Y - x)) {
                                                let N = !1;
                                                $ < c.length && (N = (c[$] >>> Z & 1) == 1), l.set(U, Y - x, N), -1 == --Z && ($++, Z = 7)
                                            }
                                        if ((U += N) < 0 || x <= U) {
                                            U -= N, N = -N;
                                            break
                                        }
                                    }
                            }(ep, eu), isNaN(U) && (U = J.getBestMask(ep, setupFormatInfo.bind(null, ep, x))), J.applyMask(U, ep), setupFormatInfo(ep, x, U), {
                                modules: ep,
                                version: c,
                                errorCorrectionLevel: x,
                                maskPattern: U,
                                segments: ea
                            }
                    }(l, x, ec, ea)
            }
        },
        9936: function(l, c, x) {
            let N = x(25153);

            function ReedSolomonEncoder(l) {
                this.genPoly = void 0, this.degree = l, this.degree && this.initialize(this.degree)
            }
            ReedSolomonEncoder.prototype.initialize = function(l) {
                this.degree = l, this.genPoly = N.generateECPolynomial(this.degree)
            }, ReedSolomonEncoder.prototype.encode = function(l) {
                if (!this.genPoly) throw Error("Encoder not initialized");
                let c = new Uint8Array(l.length + this.degree);
                c.set(l);
                let x = N.mod(c, this.genPoly),
                    U = this.degree - x.length;
                if (U > 0) {
                    let l = new Uint8Array(this.degree);
                    return l.set(x, U), l
                }
                return x
            }, l.exports = ReedSolomonEncoder
        },
        66579: function(l, c) {
            let x = "[0-9]+",
                N = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
            N = N.replace(/u/g, "\\u");
            let U = "(?:(?![A-Z0-9 $%*+\\-./:]|" + N + ")(?:.|[\r\n]))+";
            c.KANJI = RegExp(N, "g"), c.BYTE_KANJI = RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"), c.BYTE = RegExp(U, "g"), c.NUMERIC = RegExp(x, "g"), c.ALPHANUMERIC = RegExp("[A-Z $%*+\\-./:]+", "g");
            let Z = RegExp("^" + N + "$"),
                $ = RegExp("^" + x + "$"),
                Y = RegExp("^[A-Z0-9 $%*+\\-./:]+$");
            c.testKanji = function(l) {
                return Z.test(l)
            }, c.testNumeric = function(l) {
                return $.test(l)
            }, c.testAlphanumeric = function(l) {
                return Y.test(l)
            }
        },
        25082: function(l, c, x) {
            let N = x(37662),
                U = x(10894),
                Z = x(77654),
                $ = x(90690),
                Y = x(69592),
                q = x(66579),
                J = x(13400),
                X = x(78343);

            function getStringByteLength(l) {
                return unescape(encodeURIComponent(l)).length
            }

            function getSegments(l, c, x) {
                let N;
                let U = [];
                for (; null !== (N = l.exec(x));) U.push({
                    data: N[0],
                    index: N.index,
                    mode: c,
                    length: N[0].length
                });
                return U
            }

            function getSegmentsFromString(l) {
                let c, x;
                let U = getSegments(q.NUMERIC, N.NUMERIC, l),
                    Z = getSegments(q.ALPHANUMERIC, N.ALPHANUMERIC, l);
                J.isKanjiModeEnabled() ? (c = getSegments(q.BYTE, N.BYTE, l), x = getSegments(q.KANJI, N.KANJI, l)) : (c = getSegments(q.BYTE_KANJI, N.BYTE, l), x = []);
                let $ = U.concat(Z, c, x);
                return $.sort(function(l, c) {
                    return l.index - c.index
                }).map(function(l) {
                    return {
                        data: l.data,
                        mode: l.mode,
                        length: l.length
                    }
                })
            }

            function getSegmentBitsLength(l, c) {
                switch (c) {
                    case N.NUMERIC:
                        return U.getBitsLength(l);
                    case N.ALPHANUMERIC:
                        return Z.getBitsLength(l);
                    case N.KANJI:
                        return Y.getBitsLength(l);
                    case N.BYTE:
                        return $.getBitsLength(l)
                }
            }

            function buildSingleSegment(l, c) {
                let x;
                let q = N.getBestModeForData(l);
                if ((x = N.from(c, q)) !== N.BYTE && x.bit < q.bit) throw Error('"' + l + '" cannot be encoded with mode ' + N.toString(x) + ".\n Suggested mode is: " + N.toString(q));
                switch (x !== N.KANJI || J.isKanjiModeEnabled() || (x = N.BYTE), x) {
                    case N.NUMERIC:
                        return new U(l);
                    case N.ALPHANUMERIC:
                        return new Z(l);
                    case N.KANJI:
                        return new Y(l);
                    case N.BYTE:
                        return new $(l)
                }
            }
            c.fromArray = function(l) {
                return l.reduce(function(l, c) {
                    return "string" == typeof c ? l.push(buildSingleSegment(c, null)) : c.data && l.push(buildSingleSegment(c.data, c.mode)), l
                }, [])
            }, c.fromString = function(l, x) {
                let U = getSegmentsFromString(l, J.isKanjiModeEnabled()),
                    Z = function(l) {
                        let c = [];
                        for (let x = 0; x < l.length; x++) {
                            let U = l[x];
                            switch (U.mode) {
                                case N.NUMERIC:
                                    c.push([U, {
                                        data: U.data,
                                        mode: N.ALPHANUMERIC,
                                        length: U.length
                                    }, {
                                        data: U.data,
                                        mode: N.BYTE,
                                        length: U.length
                                    }]);
                                    break;
                                case N.ALPHANUMERIC:
                                    c.push([U, {
                                        data: U.data,
                                        mode: N.BYTE,
                                        length: U.length
                                    }]);
                                    break;
                                case N.KANJI:
                                    c.push([U, {
                                        data: U.data,
                                        mode: N.BYTE,
                                        length: getStringByteLength(U.data)
                                    }]);
                                    break;
                                case N.BYTE:
                                    c.push([{
                                        data: U.data,
                                        mode: N.BYTE,
                                        length: getStringByteLength(U.data)
                                    }])
                            }
                        }
                        return c
                    }(U),
                    $ = function(l, c) {
                        let x = {},
                            U = {
                                start: {}
                            },
                            Z = ["start"];
                        for (let $ = 0; $ < l.length; $++) {
                            let Y = l[$],
                                q = [];
                            for (let l = 0; l < Y.length; l++) {
                                let J = Y[l],
                                    X = "" + $ + l;
                                q.push(X), x[X] = {
                                    node: J,
                                    lastCount: 0
                                }, U[X] = {};
                                for (let l = 0; l < Z.length; l++) {
                                    let $ = Z[l];
                                    x[$] && x[$].node.mode === J.mode ? (U[$][X] = getSegmentBitsLength(x[$].lastCount + J.length, J.mode) - getSegmentBitsLength(x[$].lastCount, J.mode), x[$].lastCount += J.length) : (x[$] && (x[$].lastCount = J.length), U[$][X] = getSegmentBitsLength(J.length, J.mode) + 4 + N.getCharCountIndicator(J.mode, c))
                                }
                            }
                            Z = q
                        }
                        for (let l = 0; l < Z.length; l++) U[Z[l]].end = 0;
                        return {
                            map: U,
                            table: x
                        }
                    }(Z, x),
                    Y = X.find_path($.map, "start", "end"),
                    q = [];
                for (let l = 1; l < Y.length - 1; l++) q.push($.table[Y[l]].node);
                return c.fromArray(q.reduce(function(l, c) {
                    let x = l.length - 1 >= 0 ? l[l.length - 1] : null;
                    return x && x.mode === c.mode ? l[l.length - 1].data += c.data : l.push(c), l
                }, []))
            }, c.rawSplit = function(l) {
                return c.fromArray(getSegmentsFromString(l, J.isKanjiModeEnabled()))
            }
        },
        13400: function(l, c) {
            let x;
            let N = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
            c.getSymbolSize = function(l) {
                if (!l) throw Error('"version" cannot be null or undefined');
                if (l < 1 || l > 40) throw Error('"version" should be in range from 1 to 40');
                return 4 * l + 17
            }, c.getSymbolTotalCodewords = function(l) {
                return N[l]
            }, c.getBCHDigit = function(l) {
                let c = 0;
                for (; 0 !== l;) c++, l >>>= 1;
                return c
            }, c.setToSJISFunction = function(l) {
                if ("function" != typeof l) throw Error('"toSJISFunc" is not a valid function.');
                x = l
            }, c.isKanjiModeEnabled = function() {
                return void 0 !== x
            }, c.toSJIS = function(l) {
                return x(l)
            }
        },
        64956: function(l, c) {
            c.isValid = function(l) {
                return !isNaN(l) && l >= 1 && l <= 40
            }
        },
        48670: function(l, c, x) {
            let N = x(13400),
                U = x(37039),
                Z = x(9406),
                $ = x(37662),
                Y = x(64956),
                q = N.getBCHDigit(7973);

            function getReservedBitsCount(l, c) {
                return $.getCharCountIndicator(l, c) + 4
            }
            c.from = function(l, c) {
                return Y.isValid(l) ? parseInt(l, 10) : c
            }, c.getCapacity = function(l, c, x) {
                if (!Y.isValid(l)) throw Error("Invalid QR Code version");
                void 0 === x && (x = $.BYTE);
                let Z = N.getSymbolTotalCodewords(l),
                    q = U.getTotalCodewordsCount(l, c),
                    J = (Z - q) * 8;
                if (x === $.MIXED) return J;
                let X = J - getReservedBitsCount(x, l);
                switch (x) {
                    case $.NUMERIC:
                        return Math.floor(X / 10 * 3);
                    case $.ALPHANUMERIC:
                        return Math.floor(X / 11 * 2);
                    case $.KANJI:
                        return Math.floor(X / 13);
                    case $.BYTE:
                    default:
                        return Math.floor(X / 8)
                }
            }, c.getBestVersionForData = function(l, x) {
                let N;
                let U = Z.from(x, Z.M);
                if (Array.isArray(l)) {
                    if (l.length > 1) return function(l, x) {
                        for (let N = 1; N <= 40; N++) {
                            let U = function(l, c) {
                                let x = 0;
                                return l.forEach(function(l) {
                                    let N = getReservedBitsCount(l.mode, c);
                                    x += N + l.getBitsLength()
                                }), x
                            }(l, N);
                            if (U <= c.getCapacity(N, x, $.MIXED)) return N
                        }
                    }(l, U);
                    if (0 === l.length) return 1;
                    N = l[0]
                } else N = l;
                return function(l, x, N) {
                    for (let U = 1; U <= 40; U++)
                        if (x <= c.getCapacity(U, N, l)) return U
                }(N.mode, N.getLength(), U)
            }, c.getEncodedBits = function(l) {
                if (!Y.isValid(l) || l < 7) throw Error("Invalid QR Code version");
                let c = l << 12;
                for (; N.getBCHDigit(c) - q >= 0;) c ^= 7973 << N.getBCHDigit(c) - q;
                return l << 12 | c
            }
        },
        46028: function(l, c, x) {
            let N = x(10544);
            c.render = function(l, c, x) {
                var U;
                let Z = x,
                    $ = c;
                void 0 !== Z || c && c.getContext || (Z = c, c = void 0), c || ($ = function() {
                    try {
                        return document.createElement("canvas")
                    } catch (l) {
                        throw Error("You need to specify a canvas element")
                    }
                }()), Z = N.getOptions(Z);
                let Y = N.getImageWidth(l.modules.size, Z),
                    q = $.getContext("2d"),
                    J = q.createImageData(Y, Y);
                return N.qrToImageData(J.data, l, Z), U = $, q.clearRect(0, 0, U.width, U.height), U.style || (U.style = {}), U.height = Y, U.width = Y, U.style.height = Y + "px", U.style.width = Y + "px", q.putImageData(J, 0, 0), $
            }, c.renderToDataURL = function(l, x, N) {
                let U = N;
                void 0 !== U || x && x.getContext || (U = x, x = void 0), U || (U = {});
                let Z = c.render(l, x, U),
                    $ = U.type || "image/png",
                    Y = U.rendererOpts || {};
                return Z.toDataURL($, Y.quality)
            }
        },
        12330: function(l, c, x) {
            let N = x(10544);

            function getColorAttrib(l, c) {
                let x = l.a / 255,
                    N = c + '="' + l.hex + '"';
                return x < 1 ? N + " " + c + '-opacity="' + x.toFixed(2).slice(1) + '"' : N
            }

            function svgCmd(l, c, x) {
                let N = l + c;
                return void 0 !== x && (N += " " + x), N
            }
            c.render = function(l, c, x) {
                let U = N.getOptions(c),
                    Z = l.modules.size,
                    $ = l.modules.data,
                    Y = Z + 2 * U.margin,
                    q = U.color.light.a ? "<path " + getColorAttrib(U.color.light, "fill") + ' d="M0 0h' + Y + "v" + Y + 'H0z"/>' : "",
                    J = "<path " + getColorAttrib(U.color.dark, "stroke") + ' d="' + function(l, c, x) {
                        let N = "",
                            U = 0,
                            Z = !1,
                            $ = 0;
                        for (let Y = 0; Y < l.length; Y++) {
                            let q = Math.floor(Y % c),
                                J = Math.floor(Y / c);
                            q || Z || (Z = !0), l[Y] ? ($++, Y > 0 && q > 0 && l[Y - 1] || (N += Z ? svgCmd("M", q + x, .5 + J + x) : svgCmd("m", U, 0), U = 0, Z = !1), q + 1 < c && l[Y + 1] || (N += svgCmd("h", $), $ = 0)) : U++
                        }
                        return N
                    }($, Z, U.margin) + '"/>',
                    X = U.width ? 'width="' + U.width + '" height="' + U.width + '" ' : "",
                    en = '<svg xmlns="http://www.w3.org/2000/svg" ' + X + ('viewBox="0 0 ' + Y) + " " + Y + '" shape-rendering="crispEdges">' + q + J + "</svg>\n";
                return "function" == typeof x && x(null, en), en
            }
        },
        10544: function(l, c) {
            function hex2rgba(l) {
                if ("number" == typeof l && (l = l.toString()), "string" != typeof l) throw Error("Color should be defined as hex string");
                let c = l.slice().replace("#", "").split("");
                if (c.length < 3 || 5 === c.length || c.length > 8) throw Error("Invalid hex color: " + l);
                (3 === c.length || 4 === c.length) && (c = Array.prototype.concat.apply([], c.map(function(l) {
                    return [l, l]
                }))), 6 === c.length && c.push("F", "F");
                let x = parseInt(c.join(""), 16);
                return {
                    r: x >> 24 & 255,
                    g: x >> 16 & 255,
                    b: x >> 8 & 255,
                    a: 255 & x,
                    hex: "#" + c.slice(0, 6).join("")
                }
            }
            c.getOptions = function(l) {
                l || (l = {}), l.color || (l.color = {});
                let c = void 0 === l.margin || null === l.margin || l.margin < 0 ? 4 : l.margin,
                    x = l.width && l.width >= 21 ? l.width : void 0,
                    N = l.scale || 4;
                return {
                    width: x,
                    scale: x ? 4 : N,
                    margin: c,
                    color: {
                        dark: hex2rgba(l.color.dark || "#000000ff"),
                        light: hex2rgba(l.color.light || "#ffffffff")
                    },
                    type: l.type,
                    rendererOpts: l.rendererOpts || {}
                }
            }, c.getScale = function(l, c) {
                return c.width && c.width >= l + 2 * c.margin ? c.width / (l + 2 * c.margin) : c.scale
            }, c.getImageWidth = function(l, x) {
                let N = c.getScale(l, x);
                return Math.floor((l + 2 * x.margin) * N)
            }, c.qrToImageData = function(l, x, N) {
                let U = x.modules.size,
                    Z = x.modules.data,
                    $ = c.getScale(U, N),
                    Y = Math.floor((U + 2 * N.margin) * $),
                    q = N.margin * $,
                    J = [N.color.light, N.color.dark];
                for (let c = 0; c < Y; c++)
                    for (let x = 0; x < Y; x++) {
                        let X = (c * Y + x) * 4,
                            en = N.color.light;
                        if (c >= q && x >= q && c < Y - q && x < Y - q) {
                            let l = Math.floor((c - q) / $),
                                N = Math.floor((x - q) / $);
                            en = J[Z[l * U + N] ? 1 : 0]
                        }
                        l[X++] = en.r, l[X++] = en.g, l[X++] = en.b, l[X] = en.a
                    }
            }
        },
        89291: function(l, c, x) {
            "use strict";
            let N = x(67116),
                U = x(58005),
                Z = x(34470),
                $ = x(61820),
                isNullOrUndefined = l => null == l,
                Y = Symbol("encodeFragmentIdentifier");

            function validateArrayFormatSeparator(l) {
                if ("string" != typeof l || 1 !== l.length) throw TypeError("arrayFormatSeparator must be single character string")
            }

            function encode(l, c) {
                return c.encode ? c.strict ? N(l) : encodeURIComponent(l) : l
            }

            function decode(l, c) {
                return c.decode ? U(l) : l
            }

            function removeHash(l) {
                let c = l.indexOf("#");
                return -1 !== c && (l = l.slice(0, c)), l
            }

            function extract(l) {
                l = removeHash(l);
                let c = l.indexOf("?");
                return -1 === c ? "" : l.slice(c + 1)
            }

            function parseValue(l, c) {
                return c.parseNumbers && !Number.isNaN(Number(l)) && "string" == typeof l && "" !== l.trim() ? l = Number(l) : c.parseBooleans && null !== l && ("true" === l.toLowerCase() || "false" === l.toLowerCase()) && (l = "true" === l.toLowerCase()), l
            }

            function parse(l, c) {
                validateArrayFormatSeparator((c = Object.assign({
                    decode: !0,
                    sort: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ",",
                    parseNumbers: !1,
                    parseBooleans: !1
                }, c)).arrayFormatSeparator);
                let x = function(l) {
                        let c;
                        switch (l.arrayFormat) {
                            case "index":
                                return (l, x, N) => {
                                    if (c = /\[(\d*)\]$/.exec(l), l = l.replace(/\[\d*\]$/, ""), !c) {
                                        N[l] = x;
                                        return
                                    }
                                    void 0 === N[l] && (N[l] = {}), N[l][c[1]] = x
                                };
                            case "bracket":
                                return (l, x, N) => {
                                    if (c = /(\[\])$/.exec(l), l = l.replace(/\[\]$/, ""), !c) {
                                        N[l] = x;
                                        return
                                    }
                                    if (void 0 === N[l]) {
                                        N[l] = [x];
                                        return
                                    }
                                    N[l] = [].concat(N[l], x)
                                };
                            case "colon-list-separator":
                                return (l, x, N) => {
                                    if (c = /(:list)$/.exec(l), l = l.replace(/:list$/, ""), !c) {
                                        N[l] = x;
                                        return
                                    }
                                    if (void 0 === N[l]) {
                                        N[l] = [x];
                                        return
                                    }
                                    N[l] = [].concat(N[l], x)
                                };
                            case "comma":
                            case "separator":
                                return (c, x, N) => {
                                    let U = "string" == typeof x && x.includes(l.arrayFormatSeparator),
                                        Z = "string" == typeof x && !U && decode(x, l).includes(l.arrayFormatSeparator);
                                    x = Z ? decode(x, l) : x;
                                    let $ = U || Z ? x.split(l.arrayFormatSeparator).map(c => decode(c, l)) : null === x ? x : decode(x, l);
                                    N[c] = $
                                };
                            case "bracket-separator":
                                return (c, x, N) => {
                                    let U = /(\[\])$/.test(c);
                                    if (c = c.replace(/\[\]$/, ""), !U) {
                                        N[c] = x ? decode(x, l) : x;
                                        return
                                    }
                                    let Z = null === x ? [] : x.split(l.arrayFormatSeparator).map(c => decode(c, l));
                                    if (void 0 === N[c]) {
                                        N[c] = Z;
                                        return
                                    }
                                    N[c] = [].concat(N[c], Z)
                                };
                            default:
                                return (l, c, x) => {
                                    if (void 0 === x[l]) {
                                        x[l] = c;
                                        return
                                    }
                                    x[l] = [].concat(x[l], c)
                                }
                        }
                    }(c),
                    N = Object.create(null);
                if ("string" != typeof l || !(l = l.trim().replace(/^[?#&]/, ""))) return N;
                for (let U of l.split("&")) {
                    if ("" === U) continue;
                    let [l, $] = Z(c.decode ? U.replace(/\+/g, " ") : U, "=");
                    $ = void 0 === $ ? null : ["comma", "separator", "bracket-separator"].includes(c.arrayFormat) ? $ : decode($, c), x(decode(l, c), $, N)
                }
                for (let l of Object.keys(N)) {
                    let x = N[l];
                    if ("object" == typeof x && null !== x)
                        for (let l of Object.keys(x)) x[l] = parseValue(x[l], c);
                    else N[l] = parseValue(x, c)
                }
                return !1 === c.sort ? N : (!0 === c.sort ? Object.keys(N).sort() : Object.keys(N).sort(c.sort)).reduce((l, c) => {
                    let x = N[c];
                    return x && "object" == typeof x && !Array.isArray(x) ? l[c] = function keysSorter(l) {
                        return Array.isArray(l) ? l.sort() : "object" == typeof l ? keysSorter(Object.keys(l)).sort((l, c) => Number(l) - Number(c)).map(c => l[c]) : l
                    }(x) : l[c] = x, l
                }, Object.create(null))
            }
            c.extract = extract, c.parse = parse, c.stringify = (l, c) => {
                if (!l) return "";
                validateArrayFormatSeparator((c = Object.assign({
                    encode: !0,
                    strict: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ","
                }, c)).arrayFormatSeparator);
                let shouldFilter = x => c.skipNull && isNullOrUndefined(l[x]) || c.skipEmptyString && "" === l[x],
                    x = function(l) {
                        switch (l.arrayFormat) {
                            case "index":
                                return c => (x, N) => {
                                    let U = x.length;
                                    return void 0 === N || l.skipNull && null === N || l.skipEmptyString && "" === N ? x : null === N ? [...x, [encode(c, l), "[", U, "]"].join("")] : [...x, [encode(c, l), "[", encode(U, l), "]=", encode(N, l)].join("")]
                                };
                            case "bracket":
                                return c => (x, N) => void 0 === N || l.skipNull && null === N || l.skipEmptyString && "" === N ? x : null === N ? [...x, [encode(c, l), "[]"].join("")] : [...x, [encode(c, l), "[]=", encode(N, l)].join("")];
                            case "colon-list-separator":
                                return c => (x, N) => void 0 === N || l.skipNull && null === N || l.skipEmptyString && "" === N ? x : null === N ? [...x, [encode(c, l), ":list="].join("")] : [...x, [encode(c, l), ":list=", encode(N, l)].join("")];
                            case "comma":
                            case "separator":
                            case "bracket-separator":
                                {
                                    let c = "bracket-separator" === l.arrayFormat ? "[]=" : "=";
                                    return x => (N, U) => void 0 === U || l.skipNull && null === U || l.skipEmptyString && "" === U ? N : (U = null === U ? "" : U, 0 === N.length) ? [
                                        [encode(x, l), c, encode(U, l)].join("")
                                    ] : [
                                        [N, encode(U, l)].join(l.arrayFormatSeparator)
                                    ]
                                }
                            default:
                                return c => (x, N) => void 0 === N || l.skipNull && null === N || l.skipEmptyString && "" === N ? x : null === N ? [...x, encode(c, l)] : [...x, [encode(c, l), "=", encode(N, l)].join("")]
                        }
                    }(c),
                    N = {};
                for (let c of Object.keys(l)) shouldFilter(c) || (N[c] = l[c]);
                let U = Object.keys(N);
                return !1 !== c.sort && U.sort(c.sort), U.map(N => {
                    let U = l[N];
                    return void 0 === U ? "" : null === U ? encode(N, c) : Array.isArray(U) ? 0 === U.length && "bracket-separator" === c.arrayFormat ? encode(N, c) + "[]" : U.reduce(x(N), []).join("&") : encode(N, c) + "=" + encode(U, c)
                }).filter(l => l.length > 0).join("&")
            }, c.parseUrl = (l, c) => {
                c = Object.assign({
                    decode: !0
                }, c);
                let [x, N] = Z(l, "#");
                return Object.assign({
                    url: x.split("?")[0] || "",
                    query: parse(extract(l), c)
                }, c && c.parseFragmentIdentifier && N ? {
                    fragmentIdentifier: decode(N, c)
                } : {})
            }, c.stringifyUrl = (l, x) => {
                x = Object.assign({
                    encode: !0,
                    strict: !0,
                    [Y]: !0
                }, x);
                let N = removeHash(l.url).split("?")[0] || "",
                    U = c.extract(l.url),
                    Z = c.parse(U, {
                        sort: !1
                    }),
                    $ = Object.assign(Z, l.query),
                    q = c.stringify($, x);
                q && (q = `?${q}`);
                let J = function(l) {
                    let c = "",
                        x = l.indexOf("#");
                    return -1 !== x && (c = l.slice(x)), c
                }(l.url);
                return l.fragmentIdentifier && (J = `#${x[Y]?encode(l.fragmentIdentifier,x):l.fragmentIdentifier}`), `${N}${q}${J}`
            }, c.pick = (l, x, N) => {
                N = Object.assign({
                    parseFragmentIdentifier: !0,
                    [Y]: !1
                }, N);
                let {
                    url: U,
                    query: Z,
                    fragmentIdentifier: q
                } = c.parseUrl(l, N);
                return c.stringifyUrl({
                    url: U,
                    query: $(Z, x),
                    fragmentIdentifier: q
                }, N)
            }, c.exclude = (l, x, N) => {
                let U = Array.isArray(x) ? l => !x.includes(l) : (l, c) => !x(l, c);
                return c.pick(l, U, N)
            }
        },
        45503: function(l) {
            "use strict";

            function tryStringify(l) {
                try {
                    return JSON.stringify(l)
                } catch (l) {
                    return '"[Circular]"'
                }
            }
            l.exports = function(l, c, x) {
                var N = x && x.stringify || tryStringify;
                if ("object" == typeof l && null !== l) {
                    var U = c.length + 1;
                    if (1 === U) return l;
                    var Z = Array(U);
                    Z[0] = N(l);
                    for (var $ = 1; $ < U; $++) Z[$] = N(c[$]);
                    return Z.join(" ")
                }
                if ("string" != typeof l) return l;
                var Y = c.length;
                if (0 === Y) return l;
                for (var q = "", J = 0, X = -1, en = l && l.length || 0, er = 0; er < en;) {
                    if (37 === l.charCodeAt(er) && er + 1 < en) {
                        switch (X = X > -1 ? X : 0, l.charCodeAt(er + 1)) {
                            case 100:
                            case 102:
                                if (J >= Y || null == c[J]) break;
                                X < er && (q += l.slice(X, er)), q += Number(c[J]), X = er + 2, er++;
                                break;
                            case 105:
                                if (J >= Y || null == c[J]) break;
                                X < er && (q += l.slice(X, er)), q += Math.floor(Number(c[J])), X = er + 2, er++;
                                break;
                            case 79:
                            case 111:
                            case 106:
                                if (J >= Y || void 0 === c[J]) break;
                                X < er && (q += l.slice(X, er));
                                var ea = typeof c[J];
                                if ("string" === ea) {
                                    q += "'" + c[J] + "'", X = er + 2, er++;
                                    break
                                }
                                if ("function" === ea) {
                                    q += c[J].name || "<anonymous>", X = er + 2, er++;
                                    break
                                }
                                q += N(c[J]), X = er + 2, er++;
                                break;
                            case 115:
                                if (J >= Y) break;
                                X < er && (q += l.slice(X, er)), q += String(c[J]), X = er + 2, er++;
                                break;
                            case 37:
                                X < er && (q += l.slice(X, er)), q += "%", X = er + 2, er++, J--
                        }++J
                    }++er
                }
                return -1 === X ? l : (X < en && (q += l.slice(X)), q)
            }
        },
        8236: function(l, c) {
            "use strict";
            /** @license React v16.13.1
             * react-is.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var x = "function" == typeof Symbol && Symbol.for,
                N = x ? Symbol.for("react.element") : 60103,
                U = x ? Symbol.for("react.portal") : 60106,
                Z = x ? Symbol.for("react.fragment") : 60107,
                $ = x ? Symbol.for("react.strict_mode") : 60108,
                Y = x ? Symbol.for("react.profiler") : 60114,
                q = x ? Symbol.for("react.provider") : 60109,
                J = x ? Symbol.for("react.context") : 60110,
                X = x ? Symbol.for("react.async_mode") : 60111,
                en = x ? Symbol.for("react.concurrent_mode") : 60111,
                er = x ? Symbol.for("react.forward_ref") : 60112,
                ea = x ? Symbol.for("react.suspense") : 60113,
                eo = x ? Symbol.for("react.suspense_list") : 60120,
                el = x ? Symbol.for("react.memo") : 60115,
                ec = x ? Symbol.for("react.lazy") : 60116,
                eu = x ? Symbol.for("react.block") : 60121,
                ed = x ? Symbol.for("react.fundamental") : 60117,
                ep = x ? Symbol.for("react.responder") : 60118,
                eh = x ? Symbol.for("react.scope") : 60119;

            function z(l) {
                if ("object" == typeof l && null !== l) {
                    var c = l.$$typeof;
                    switch (c) {
                        case N:
                            switch (l = l.type) {
                                case X:
                                case en:
                                case Z:
                                case Y:
                                case $:
                                case ea:
                                    return l;
                                default:
                                    switch (l = l && l.$$typeof) {
                                        case J:
                                        case er:
                                        case ec:
                                        case el:
                                        case q:
                                            return l;
                                        default:
                                            return c
                                    }
                            }
                        case U:
                            return c
                    }
                }
            }

            function A(l) {
                return z(l) === en
            }
            c.AsyncMode = X, c.ConcurrentMode = en, c.ContextConsumer = J, c.ContextProvider = q, c.Element = N, c.ForwardRef = er, c.Fragment = Z, c.Lazy = ec, c.Memo = el, c.Portal = U, c.Profiler = Y, c.StrictMode = $, c.Suspense = ea, c.isAsyncMode = function(l) {
                return A(l) || z(l) === X
            }, c.isConcurrentMode = A, c.isContextConsumer = function(l) {
                return z(l) === J
            }, c.isContextProvider = function(l) {
                return z(l) === q
            }, c.isElement = function(l) {
                return "object" == typeof l && null !== l && l.$$typeof === N
            }, c.isForwardRef = function(l) {
                return z(l) === er
            }, c.isFragment = function(l) {
                return z(l) === Z
            }, c.isLazy = function(l) {
                return z(l) === ec
            }, c.isMemo = function(l) {
                return z(l) === el
            }, c.isPortal = function(l) {
                return z(l) === U
            }, c.isProfiler = function(l) {
                return z(l) === Y
            }, c.isStrictMode = function(l) {
                return z(l) === $
            }, c.isSuspense = function(l) {
                return z(l) === ea
            }, c.isValidElementType = function(l) {
                return "string" == typeof l || "function" == typeof l || l === Z || l === en || l === Y || l === $ || l === ea || l === eo || "object" == typeof l && null !== l && (l.$$typeof === ec || l.$$typeof === el || l.$$typeof === q || l.$$typeof === J || l.$$typeof === er || l.$$typeof === ed || l.$$typeof === ep || l.$$typeof === eh || l.$$typeof === eu)
            }, c.typeOf = z
        },
        9176: function(l, c, x) {
            "use strict";
            l.exports = x(8236)
        },
        29150: function(l) {
            "use strict";
            ! function(c) {
                function SHA256(l) {
                    let c = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                        x = 1779033703,
                        N = 3144134277,
                        U = 1013904242,
                        Z = 2773480762,
                        $ = 1359893119,
                        Y = 2600822924,
                        q = 528734635,
                        J = 1541459225,
                        X = new Uint32Array(64);

                    function blocks(l) {
                        let en = 0,
                            er = l.length;
                        for (; er >= 64;) {
                            let ea = x,
                                eo = N,
                                el = U,
                                ec = Z,
                                eu = $,
                                ed = Y,
                                ep = q,
                                eh = J,
                                ey, ef, em, eg, eb;
                            for (ef = 0; ef < 16; ef++) em = en + 4 * ef, X[ef] = (255 & l[em]) << 24 | (255 & l[em + 1]) << 16 | (255 & l[em + 2]) << 8 | 255 & l[em + 3];
                            for (ef = 16; ef < 64; ef++) eg = ((ey = X[ef - 2]) >>> 17 | ey << 15) ^ (ey >>> 19 | ey << 13) ^ ey >>> 10, eb = ((ey = X[ef - 15]) >>> 7 | ey << 25) ^ (ey >>> 18 | ey << 14) ^ ey >>> 3, X[ef] = (eg + X[ef - 7] | 0) + (eb + X[ef - 16] | 0) | 0;
                            for (ef = 0; ef < 64; ef++) eg = (((eu >>> 6 | eu << 26) ^ (eu >>> 11 | eu << 21) ^ (eu >>> 25 | eu << 7)) + (eu & ed ^ ~eu & ep) | 0) + (eh + (c[ef] + X[ef] | 0) | 0) | 0, eb = ((ea >>> 2 | ea << 30) ^ (ea >>> 13 | ea << 19) ^ (ea >>> 22 | ea << 10)) + (ea & eo ^ ea & el ^ eo & el) | 0, eh = ep, ep = ed, ed = eu, eu = ec + eg | 0, ec = el, el = eo, eo = ea, ea = eg + eb | 0;
                            x = x + ea | 0, N = N + eo | 0, U = U + el | 0, Z = Z + ec | 0, $ = $ + eu | 0, Y = Y + ed | 0, q = q + ep | 0, J = J + eh | 0, en += 64, er -= 64
                        }
                    }
                    blocks(l);
                    let en, er = l.length % 64,
                        ea = l.length / 536870912 | 0,
                        eo = l.length << 3,
                        el = er < 56 ? 56 : 120,
                        ec = l.slice(l.length - er, l.length);
                    for (ec.push(128), en = er + 1; en < el; en++) ec.push(0);
                    return ec.push(ea >>> 24 & 255), ec.push(ea >>> 16 & 255), ec.push(ea >>> 8 & 255), ec.push(ea >>> 0 & 255), ec.push(eo >>> 24 & 255), ec.push(eo >>> 16 & 255), ec.push(eo >>> 8 & 255), ec.push(eo >>> 0 & 255), blocks(ec), [x >>> 24 & 255, x >>> 16 & 255, x >>> 8 & 255, x >>> 0 & 255, N >>> 24 & 255, N >>> 16 & 255, N >>> 8 & 255, N >>> 0 & 255, U >>> 24 & 255, U >>> 16 & 255, U >>> 8 & 255, U >>> 0 & 255, Z >>> 24 & 255, Z >>> 16 & 255, Z >>> 8 & 255, Z >>> 0 & 255, $ >>> 24 & 255, $ >>> 16 & 255, $ >>> 8 & 255, $ >>> 0 & 255, Y >>> 24 & 255, Y >>> 16 & 255, Y >>> 8 & 255, Y >>> 0 & 255, q >>> 24 & 255, q >>> 16 & 255, q >>> 8 & 255, q >>> 0 & 255, J >>> 24 & 255, J >>> 16 & 255, J >>> 8 & 255, J >>> 0 & 255]
                }

                function PBKDF2_HMAC_SHA256_OneIter(l, c, x) {
                    let N;
                    l = l.length <= 64 ? l : SHA256(l);
                    let U = 64 + c.length + 4,
                        Z = Array(U),
                        $ = Array(64),
                        Y = [];
                    for (N = 0; N < 64; N++) Z[N] = 54;
                    for (N = 0; N < l.length; N++) Z[N] ^= l[N];
                    for (N = 0; N < c.length; N++) Z[64 + N] = c[N];
                    for (N = U - 4; N < U; N++) Z[N] = 0;
                    for (N = 0; N < 64; N++) $[N] = 92;
                    for (N = 0; N < l.length; N++) $[N] ^= l[N];

                    function incrementCounter() {
                        for (let l = U - 1; l >= U - 4; l--) {
                            if (Z[l]++, Z[l] <= 255) return;
                            Z[l] = 0
                        }
                    }
                    for (; x >= 32;) incrementCounter(), Y = Y.concat(SHA256($.concat(SHA256(Z)))), x -= 32;
                    return x > 0 && (incrementCounter(), Y = Y.concat(SHA256($.concat(SHA256(Z))).slice(0, x))), Y
                }

                function blockmix_salsa8(l, c, x, N, U) {
                    let Z;
                    for (arraycopy(l, (2 * x - 1) * 16, U, 0, 16), Z = 0; Z < 2 * x; Z++) blockxor(l, 16 * Z, U, 16),
                        function(l, c) {
                            arraycopy(l, 0, c, 0, 16);
                            for (let l = 8; l > 0; l -= 2) c[4] ^= R(c[0] + c[12], 7), c[8] ^= R(c[4] + c[0], 9), c[12] ^= R(c[8] + c[4], 13), c[0] ^= R(c[12] + c[8], 18), c[9] ^= R(c[5] + c[1], 7), c[13] ^= R(c[9] + c[5], 9), c[1] ^= R(c[13] + c[9], 13), c[5] ^= R(c[1] + c[13], 18), c[14] ^= R(c[10] + c[6], 7), c[2] ^= R(c[14] + c[10], 9), c[6] ^= R(c[2] + c[14], 13), c[10] ^= R(c[6] + c[2], 18), c[3] ^= R(c[15] + c[11], 7), c[7] ^= R(c[3] + c[15], 9), c[11] ^= R(c[7] + c[3], 13), c[15] ^= R(c[11] + c[7], 18), c[1] ^= R(c[0] + c[3], 7), c[2] ^= R(c[1] + c[0], 9), c[3] ^= R(c[2] + c[1], 13), c[0] ^= R(c[3] + c[2], 18), c[6] ^= R(c[5] + c[4], 7), c[7] ^= R(c[6] + c[5], 9), c[4] ^= R(c[7] + c[6], 13), c[5] ^= R(c[4] + c[7], 18), c[11] ^= R(c[10] + c[9], 7), c[8] ^= R(c[11] + c[10], 9), c[9] ^= R(c[8] + c[11], 13), c[10] ^= R(c[9] + c[8], 18), c[12] ^= R(c[15] + c[14], 7), c[13] ^= R(c[12] + c[15], 9), c[14] ^= R(c[13] + c[12], 13), c[15] ^= R(c[14] + c[13], 18);
                            for (let x = 0; x < 16; ++x) l[x] += c[x]
                        }(U, N), arraycopy(U, 0, l, c + 16 * Z, 16);
                    for (Z = 0; Z < x; Z++) arraycopy(l, c + 32 * Z, l, 16 * Z, 16);
                    for (Z = 0; Z < x; Z++) arraycopy(l, c + (2 * Z + 1) * 16, l, (Z + x) * 16, 16)
                }

                function R(l, c) {
                    return l << c | l >>> 32 - c
                }

                function blockxor(l, c, x, N) {
                    for (let U = 0; U < N; U++) x[U] ^= l[c + U]
                }

                function arraycopy(l, c, x, N, U) {
                    for (; U--;) x[N++] = l[c++]
                }

                function checkBufferish(l) {
                    if (!l || "number" != typeof l.length) return !1;
                    for (let c = 0; c < l.length; c++) {
                        let x = l[c];
                        if ("number" != typeof x || x % 1 || x < 0 || x >= 256) return !1
                    }
                    return !0
                }

                function ensureInteger(l, c) {
                    if ("number" != typeof l || l % 1) throw Error("invalid " + c);
                    return l
                }

                function _scrypt(l, c, x, N, U, Z, $) {
                    let Y;
                    if (x = ensureInteger(x, "N"), N = ensureInteger(N, "r"), U = ensureInteger(U, "p"), Z = ensureInteger(Z, "dkLen"), 0 === x || (x & x - 1) != 0) throw Error("N must be power of 2");
                    if (x > 2147483647 / 128 / N) throw Error("N too large");
                    if (N > 2147483647 / 128 / U) throw Error("r too large");
                    if (!checkBufferish(l)) throw Error("password must be an array or buffer");
                    if (l = Array.prototype.slice.call(l), !checkBufferish(c)) throw Error("salt must be an array or buffer");
                    c = Array.prototype.slice.call(c);
                    let q = PBKDF2_HMAC_SHA256_OneIter(l, c, 128 * U * N),
                        J = new Uint32Array(32 * U * N);
                    for (let l = 0; l < J.length; l++) {
                        let c = 4 * l;
                        J[l] = (255 & q[c + 3]) << 24 | (255 & q[c + 2]) << 16 | (255 & q[c + 1]) << 8 | (255 & q[c + 0]) << 0
                    }
                    let X = new Uint32Array(64 * N),
                        en = new Uint32Array(32 * N * x),
                        er = 32 * N,
                        ea = new Uint32Array(16),
                        eo = new Uint32Array(16),
                        el = U * x * 2,
                        ec = 0,
                        eu = null,
                        ed = !1,
                        ep = 0,
                        eh = 0,
                        ey, ef = $ ? parseInt(1e3 / N) : 4294967295,
                        em = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
                        incrementalSMix = function() {
                            let c;
                            if (ed) return $(Error("cancelled"), ec / el);
                            switch (ep) {
                                case 0:
                                    arraycopy(J, Y = 32 * eh * N, X, 0, er), ep = 1, ey = 0;
                                case 1:
                                    (c = x - ey) > ef && (c = ef);
                                    for (let l = 0; l < c; l++) arraycopy(X, 0, en, (ey + l) * er, er), blockmix_salsa8(X, er, N, ea, eo);
                                    if (ey += c, ec += c, $) {
                                        let l = parseInt(1e3 * ec / el);
                                        if (l !== eu) {
                                            if (ed = $(null, ec / el)) break;
                                            eu = l
                                        }
                                    }
                                    if (ey < x) break;
                                    ey = 0, ep = 2;
                                case 2:
                                    (c = x - ey) > ef && (c = ef);
                                    for (let l = 0; l < c; l++) {
                                        let l = (2 * N - 1) * 16,
                                            c = X[l] & x - 1;
                                        blockxor(en, c * er, X, er), blockmix_salsa8(X, er, N, ea, eo)
                                    }
                                    if (ey += c, ec += c, $) {
                                        let l = parseInt(1e3 * ec / el);
                                        if (l !== eu) {
                                            if (ed = $(null, ec / el)) break;
                                            eu = l
                                        }
                                    }
                                    if (ey < x) break;
                                    if (arraycopy(X, 0, J, Y, er), ++eh < U) {
                                        ep = 0;
                                        break
                                    }
                                    q = [];
                                    for (let l = 0; l < J.length; l++) q.push(J[l] >> 0 & 255), q.push(J[l] >> 8 & 255), q.push(J[l] >> 16 & 255), q.push(J[l] >> 24 & 255);
                                    let eg = PBKDF2_HMAC_SHA256_OneIter(l, q, Z);
                                    return $ && $(null, 1, eg), eg
                            }
                            $ && em(incrementalSMix)
                        };
                    if (!$)
                        for (;;) {
                            let l = incrementalSMix();
                            if (void 0 != l) return l
                        }
                    incrementalSMix()
                }
                l.exports = {
                    scrypt: function(l, c, x, N, U, Z, $) {
                        return new Promise(function(Y, q) {
                            let J = 0;
                            $ && $(0), _scrypt(l, c, x, N, U, Z, function(l, c, x) {
                                if (l) q(l);
                                else if (x) $ && 1 !== J && $(1), Y(new Uint8Array(x));
                                else if ($ && c !== J) return J = c, $(c)
                            })
                        })
                    },
                    syncScrypt: function(l, c, x, N, U, Z) {
                        return new Uint8Array(_scrypt(l, c, x, N, U, Z))
                    }
                }
            }(0)
        },
        34470: function(l) {
            "use strict";
            l.exports = (l, c) => {
                if (!("string" == typeof l && "string" == typeof c)) throw TypeError("Expected the arguments to be of type `string`");
                if ("" === c) return [l];
                let x = l.indexOf(c);
                return -1 === x ? [l] : [l.slice(0, x), l.slice(x + c.length)]
            }
        },
        67116: function(l) {
            "use strict";
            l.exports = l => encodeURIComponent(l).replace(/[!'()*]/g, l => `%${l.charCodeAt(0).toString(16).toUpperCase()}`)
        },
        25809: function(l) {
            l.exports = function() {
                var l = document.getSelection();
                if (!l.rangeCount) return function() {};
                for (var c = document.activeElement, x = [], N = 0; N < l.rangeCount; N++) x.push(l.getRangeAt(N));
                switch (c.tagName.toUpperCase()) {
                    case "INPUT":
                    case "TEXTAREA":
                        c.blur();
                        break;
                    default:
                        c = null
                }
                return l.removeAllRanges(),
                    function() {
                        "Caret" === l.type && l.removeAllRanges(), l.rangeCount || x.forEach(function(c) {
                            l.addRange(c)
                        }), c && c.focus()
                    }
            }
        },
        841: function(l) {
            l.exports = function() {
                function growBranch(l, c, x, N, U, Z, $) {
                    var Y, q, J, X = "",
                        en = 0,
                        er = N.slice(0);
                    if (er.push([c, x]) && N.length > 0 && (N.forEach(function(l, x) {
                            x > 0 && (X += (l[1] ? " " : "") + "  "), J || l[0] !== c || (J = !0)
                        }), X += (Y = x ? "" : "", l ? Y += " " : Y += "", Y + l), U && ("object" != typeof c || c instanceof Date) && (X += ": " + c), J && (X += " (circular ref.)"), $(X)), !J && "object" == typeof c) {
                        var ea = function(l, c) {
                            var x = [];
                            for (var N in l) l.hasOwnProperty(N) && (!c || "function" != typeof l[N]) && x.push(N);
                            return x
                        }(c, Z);
                        ea.forEach(function(l) {
                            q = ++en === ea.length, growBranch(l, c[l], q, er, U, Z, $)
                        })
                    }
                }
                var l = {};
                return l.asLines = function(l, c, x, N) {
                    growBranch(".", l, !1, [], c, "function" != typeof x && x, N || x)
                }, l.asTree = function(l, c, x) {
                    var N = "";
                    return growBranch(".", l, !1, [], c, x, function(l) {
                        N += l + "\n"
                    }), N
                }, l
            }()
        },
        81853: function(l, c, x) {
            "use strict";
            /**
             * @license React
             * use-sync-external-store-shim.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
            var N = x(2265),
                U = "function" == typeof Object.is ? Object.is : function(l, c) {
                    return l === c && (0 !== l || 1 / l == 1 / c) || l != l && c != c
                },
                Z = N.useState,
                $ = N.useEffect,
                Y = N.useLayoutEffect,
                q = N.useDebugValue;

            function r(l) {
                var c = l.getSnapshot;
                l = l.value;
                try {
                    var x = c();
                    return !U(l, x)
                } catch (l) {
                    return !0
                }
            }
            var J = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function(l, c) {
                return c()
            } : function(l, c) {
                var x = c(),
                    N = Z({
                        inst: {
                            value: x,
                            getSnapshot: c
                        }
                    }),
                    U = N[0].inst,
                    J = N[1];
                return Y(function() {
                    U.value = x, U.getSnapshot = c, r(U) && J({
                        inst: U
                    })
                }, [l, x, c]), $(function() {
                    return r(U) && J({
                        inst: U
                    }), l(function() {
                        r(U) && J({
                            inst: U
                        })
                    })
                }, [l]), q(x), x
            };
            c.useSyncExternalStore = void 0 !== N.useSyncExternalStore ? N.useSyncExternalStore : J
        },
        26272: function(l, c, x) {
            "use strict";
            l.exports = x(81853)
        },
        51872: function(l, c, x) {
            "use strict";
            let N;
            x.d(c, {
                Z: function() {
                    return esm_browser_v4
                }
            });
            let U = "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto);
            var Z = {
                randomUUID: U
            };
            let $ = new Uint8Array(16),
                Y = [];
            for (let l = 0; l < 256; ++l) Y.push((l + 256).toString(16).slice(1));
            var esm_browser_v4 = function(l, c, x) {
                if (Z.randomUUID && !c && !l) return Z.randomUUID();
                l = l || {};
                let U = l.random || (l.rng || function() {
                    if (!N && !(N = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto))) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                    return N($)
                })();
                if (U[6] = 15 & U[6] | 64, U[8] = 63 & U[8] | 128, c) {
                    x = x || 0;
                    for (let l = 0; l < 16; ++l) c[x + l] = U[l];
                    return c
                }
                return function(l, c = 0) {
                    return Y[l[c + 0]] + Y[l[c + 1]] + Y[l[c + 2]] + Y[l[c + 3]] + "-" + Y[l[c + 4]] + Y[l[c + 5]] + "-" + Y[l[c + 6]] + Y[l[c + 7]] + "-" + Y[l[c + 8]] + Y[l[c + 9]] + "-" + Y[l[c + 10]] + Y[l[c + 11]] + Y[l[c + 12]] + Y[l[c + 13]] + Y[l[c + 14]] + Y[l[c + 15]]
                }(U)
            }
        },
        22212: function(l) {
            l.exports = read;

            function read(l, c) {
                var x, N = 0,
                    c = c || 0,
                    U = 0,
                    Z = c,
                    $ = l.length;
                do {
                    if (Z >= $ || U > 49) throw read.bytes = 0, RangeError("Could not decode varint");
                    x = l[Z++], N += U < 28 ? (127 & x) << U : (127 & x) * Math.pow(2, U), U += 7
                } while (x >= 128);
                return read.bytes = Z - c, N
            }
        },
        4834: function(l) {
            l.exports = encode;

            function encode(l, c, x) {
                if (Number.MAX_SAFE_INTEGER && l > Number.MAX_SAFE_INTEGER) throw encode.bytes = 0, RangeError("Could not encode varint");
                c = c || [];
                for (var N = x = x || 0; l >= 2147483648;) c[x++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[x++] = 255 & l | 128, l >>>= 7;
                return c[x] = 0 | l, encode.bytes = x - N + 1, c
            }
        },
        28965: function(l, c, x) {
            l.exports = {
                encode: x(4834),
                decode: x(22212),
                encodingLength: x(30403)
            }
        },
        30403: function(l) {
            l.exports = function(l) {
                return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
            }
        },
        90440: function(l, c, x) {
            "use strict";
            let N = x(45503);
            l.exports = pino;
            let U = function() {
                function defd(l) {
                    return void 0 !== l && l
                }
                try {
                    if ("undefined" != typeof globalThis) return globalThis;
                    return Object.defineProperty(Object.prototype, "globalThis", {
                        get: function() {
                            return delete Object.prototype.globalThis, this.globalThis = this
                        },
                        configurable: !0
                    }), globalThis
                } catch (l) {
                    return defd(self) || defd(window) || defd(this) || {}
                }
            }().console || {};

            function pino(l) {
                var c;
                (l = l || {}).browser = l.browser || {};
                let x = l.browser.transmit;
                if (x && "function" != typeof x.send) throw Error("pino: transmit option must have a send function");
                let N = l.browser.write || U;
                l.browser.write && (l.browser.asObject = !0);
                let Z = l.serializers || {},
                    $ = function(l, c) {
                        if (Array.isArray(l)) {
                            let c = l.filter(function(l) {
                                return "!stdSerializers.err" !== l
                            });
                            return c
                        }
                        return !0 === l && Object.keys(c)
                    }(l.browser.serialize, Z),
                    Y = l.browser.serialize;
                Array.isArray(l.browser.serialize) && l.browser.serialize.indexOf("!stdSerializers.err") > -1 && (Y = !1), "function" == typeof N && (N.error = N.fatal = N.warn = N.info = N.debug = N.trace = N), !1 === l.enabled && (l.level = "silent");
                let q = l.level || "info",
                    J = Object.create(N);
                J.log || (J.log = noop), Object.defineProperty(J, "levelVal", {
                    get: function() {
                        return "silent" === this.level ? 1 / 0 : this.levels.values[this.level]
                    }
                }), Object.defineProperty(J, "level", {
                    get: function() {
                        return this._level
                    },
                    set: function(l) {
                        if ("silent" !== l && !this.levels.values[l]) throw Error("unknown level " + l);
                        this._level = l, set(X, J, "error", "log"), set(X, J, "fatal", "error"), set(X, J, "warn", "error"), set(X, J, "info", "log"), set(X, J, "debug", "log"), set(X, J, "trace", "log")
                    }
                });
                let X = {
                    transmit: x,
                    serialize: $,
                    asObject: l.browser.asObject,
                    levels: ["error", "fatal", "warn", "info", "debug", "trace"],
                    timestamp: "function" == typeof(c = l).timestamp ? c.timestamp : !1 === c.timestamp ? nullTime : epochTime
                };
                return J.levels = pino.levels, J.level = q, J.setMaxListeners = J.getMaxListeners = J.emit = J.addListener = J.on = J.prependListener = J.once = J.prependOnceListener = J.removeListener = J.removeAllListeners = J.listeners = J.listenerCount = J.eventNames = J.write = J.flush = noop, J.serializers = Z, J._serialize = $, J._stdErrSerialize = Y, J.child = function(c, N) {
                    if (!c) throw Error("missing bindings for child Pino");
                    N = N || {}, $ && c.serializers && (N.serializers = c.serializers);
                    let U = N.serializers;
                    if ($ && U) {
                        var Y = Object.assign({}, Z, U),
                            q = !0 === l.browser.serialize ? Object.keys(Y) : $;
                        delete c.serializers, applySerializers([c], q, Y, this._stdErrSerialize)
                    }

                    function Child(l) {
                        this._childLevel = (0 | l._childLevel) + 1, this.error = bind(l, c, "error"), this.fatal = bind(l, c, "fatal"), this.warn = bind(l, c, "warn"), this.info = bind(l, c, "info"), this.debug = bind(l, c, "debug"), this.trace = bind(l, c, "trace"), Y && (this.serializers = Y, this._serialize = q), x && (this._logEvent = createLogEventShape([].concat(l._logEvent.bindings, c)))
                    }
                    return Child.prototype = this, new Child(this)
                }, x && (J._logEvent = createLogEventShape()), J
            }

            function set(l, c, x, Z) {
                let $ = Object.getPrototypeOf(c);
                c[x] = c.levelVal > c.levels.values[x] ? noop : $[x] ? $[x] : U[x] || U[Z] || noop,
                    function(l, c, x) {
                        if (l.transmit || c[x] !== noop) {
                            var Z;
                            c[x] = (Z = c[x], function() {
                                let $ = l.timestamp(),
                                    Y = Array(arguments.length),
                                    q = Object.getPrototypeOf && Object.getPrototypeOf(this) === U ? U : this;
                                for (var J = 0; J < Y.length; J++) Y[J] = arguments[J];
                                if (l.serialize && !l.asObject && applySerializers(Y, this._serialize, this.serializers, this._stdErrSerialize), l.asObject ? Z.call(q, function(l, c, x, U) {
                                        l._serialize && applySerializers(x, l._serialize, l.serializers, l._stdErrSerialize);
                                        let Z = x.slice(),
                                            $ = Z[0],
                                            Y = {};
                                        U && (Y.time = U), Y.level = pino.levels.values[c];
                                        let q = (0 | l._childLevel) + 1;
                                        if (q < 1 && (q = 1), null !== $ && "object" == typeof $) {
                                            for (; q-- && "object" == typeof Z[0];) Object.assign(Y, Z.shift());
                                            $ = Z.length ? N(Z.shift(), Z) : void 0
                                        } else "string" == typeof $ && ($ = N(Z.shift(), Z));
                                        return void 0 !== $ && (Y.msg = $), Y
                                    }(this, x, Y, $)) : Z.apply(q, Y), l.transmit) {
                                    let N = l.transmit.level || c.level,
                                        U = pino.levels.values[N],
                                        Z = pino.levels.values[x];
                                    if (Z < U) return;
                                    (function(l, c, x) {
                                        let N = c.send,
                                            U = c.ts,
                                            Z = c.methodLevel,
                                            $ = c.methodValue,
                                            Y = c.val,
                                            q = l._logEvent.bindings;
                                        applySerializers(x, l._serialize || Object.keys(l.serializers), l.serializers, void 0 === l._stdErrSerialize || l._stdErrSerialize), l._logEvent.ts = U, l._logEvent.messages = x.filter(function(l) {
                                            return -1 === q.indexOf(l)
                                        }), l._logEvent.level.label = Z, l._logEvent.level.value = $, N(Z, l._logEvent, Y), l._logEvent = createLogEventShape(q)
                                    })(this, {
                                        ts: $,
                                        methodLevel: x,
                                        methodValue: Z,
                                        transmitLevel: N,
                                        transmitValue: pino.levels.values[l.transmit.level || c.level],
                                        send: l.transmit.send,
                                        val: c.levelVal
                                    }, Y)
                                }
                            })
                        }
                    }(l, c, x)
            }

            function applySerializers(l, c, x, N) {
                for (let U in l)
                    if (N && l[U] instanceof Error) l[U] = pino.stdSerializers.err(l[U]);
                    else if ("object" == typeof l[U] && !Array.isArray(l[U]))
                    for (let N in l[U]) c && c.indexOf(N) > -1 && N in x && (l[U][N] = x[N](l[U][N]))
            }

            function bind(l, c, x) {
                return function() {
                    let N = Array(1 + arguments.length);
                    N[0] = c;
                    for (var U = 1; U < N.length; U++) N[U] = arguments[U - 1];
                    return l[x].apply(this, N)
                }
            }

            function createLogEventShape(l) {
                return {
                    ts: 0,
                    messages: [],
                    bindings: l || [],
                    level: {
                        label: "",
                        value: 0
                    }
                }
            }

            function mock() {
                return {}
            }

            function passthrough(l) {
                return l
            }

            function noop() {}

            function nullTime() {
                return !1
            }

            function epochTime() {
                return Date.now()
            }
            pino.levels = {
                values: {
                    fatal: 60,
                    error: 50,
                    warn: 40,
                    info: 30,
                    debug: 20,
                    trace: 10
                },
                labels: {
                    10: "trace",
                    20: "debug",
                    30: "info",
                    40: "warn",
                    50: "error",
                    60: "fatal"
                }
            }, pino.stdSerializers = {
                mapHttpRequest: mock,
                mapHttpResponse: mock,
                wrapRequestSerializer: passthrough,
                wrapResponseSerializer: passthrough,
                wrapErrorSerializer: passthrough,
                req: mock,
                res: mock,
                err: function(l) {
                    let c = {
                        type: l.constructor.name,
                        msg: l.message,
                        stack: l.stack
                    };
                    for (let x in l) void 0 === c[x] && (c[x] = l[x]);
                    return c
                }
            }, pino.stdTimeFunctions = Object.assign({}, {
                nullTime,
                epochTime,
                unixTime: function() {
                    return Math.round(Date.now() / 1e3)
                },
                isoTime: function() {
                    return new Date(Date.now()).toISOString()
                }
            })
        },
        28712: function(l, c, x) {
            "use strict";
            x.d(c, {
                Dx: function() {
                    return eL
                },
                VY: function() {
                    return eR
                },
                aV: function() {
                    return ez
                },
                dk: function() {
                    return eB
                },
                fC: function() {
                    return $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9
                },
                h_: function() {
                    return $5d3850c4d0b4e6c7$export$602eac185826482c
                },
                jm: function() {
                    return ej
                },
                p8: function() {
                    return ey
                },
                x8: function() {
                    return eU
                },
                xz: function() {
                    return eP
                }
            });
            var N = x(13428),
                U = x(2265),
                Z = x(85744),
                $ = x(42210),
                Y = x(56989),
                q = x(20966),
                J = x(73763),
                X = x(79249),
                en = x(52759),
                er = x(52730),
                ea = x(85606),
                eo = x(9381),
                el = x(31244),
                ec = x(32098),
                eu = x(85859),
                ed = x(67256);
            let ep = "Dialog",
                [eh, ey] = (0, Y.b)(ep),
                [ef, em] = eh(ep),
                eg = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDialog: x,
                        ...Y
                    } = l, q = em("DialogTrigger", x), J = (0, $.e)(c, q.triggerRef);
                    return (0, U.createElement)(eo.WV.button, (0, N.Z)({
                        type: "button",
                        "aria-haspopup": "dialog",
                        "aria-expanded": q.open,
                        "aria-controls": q.contentId,
                        "data-state": $5d3850c4d0b4e6c7$var$getState(q.open)
                    }, Y, {
                        ref: J,
                        onClick: (0, Z.M)(l.onClick, q.onOpenToggle)
                    }))
                }),
                eb = "DialogPortal",
                [ev, ew] = eh(eb, {
                    forceMount: void 0
                }),
                eT = "DialogOverlay",
                eM = (0, U.forwardRef)((l, c) => {
                    let x = ew(eT, l.__scopeDialog),
                        {
                            forceMount: Z = x.forceMount,
                            ...$
                        } = l,
                        Y = em(eT, l.__scopeDialog);
                    return Y.modal ? (0, U.createElement)(ea.z, {
                        present: Z || Y.open
                    }, (0, U.createElement)(eI, (0, N.Z)({}, $, {
                        ref: c
                    }))) : null
                }),
                eI = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDialog: x,
                        ...Z
                    } = l, $ = em(eT, x);
                    return (0, U.createElement)(ec.Z, {
                        as: ed.g7,
                        allowPinchZoom: !0,
                        shards: [$.contentRef]
                    }, (0, U.createElement)(eo.WV.div, (0, N.Z)({
                        "data-state": $5d3850c4d0b4e6c7$var$getState($.open)
                    }, Z, {
                        ref: c,
                        style: {
                            pointerEvents: "auto",
                            ...Z.style
                        }
                    })))
                }),
                ex = "DialogContent",
                eC = (0, U.forwardRef)((l, c) => {
                    let x = ew(ex, l.__scopeDialog),
                        {
                            forceMount: Z = x.forceMount,
                            ...$
                        } = l,
                        Y = em(ex, l.__scopeDialog);
                    return (0, U.createElement)(ea.z, {
                        present: Z || Y.open
                    }, Y.modal ? (0, U.createElement)(e_, (0, N.Z)({}, $, {
                        ref: c
                    })) : (0, U.createElement)(eD, (0, N.Z)({}, $, {
                        ref: c
                    })))
                }),
                e_ = (0, U.forwardRef)((l, c) => {
                    let x = em(ex, l.__scopeDialog),
                        Y = (0, U.useRef)(null),
                        q = (0, $.e)(c, x.contentRef, Y);
                    return (0, U.useEffect)(() => {
                        let l = Y.current;
                        if (l) return (0, eu.Ry)(l)
                    }, []), (0, U.createElement)(eS, (0, N.Z)({}, l, {
                        ref: q,
                        trapFocus: x.open,
                        disableOutsidePointerEvents: !0,
                        onCloseAutoFocus: (0, Z.M)(l.onCloseAutoFocus, l => {
                            var c;
                            l.preventDefault(), null === (c = x.triggerRef.current) || void 0 === c || c.focus()
                        }),
                        onPointerDownOutside: (0, Z.M)(l.onPointerDownOutside, l => {
                            let c = l.detail.originalEvent,
                                x = 0 === c.button && !0 === c.ctrlKey,
                                N = 2 === c.button || x;
                            N && l.preventDefault()
                        }),
                        onFocusOutside: (0, Z.M)(l.onFocusOutside, l => l.preventDefault())
                    }))
                }),
                eD = (0, U.forwardRef)((l, c) => {
                    let x = em(ex, l.__scopeDialog),
                        Z = (0, U.useRef)(!1),
                        $ = (0, U.useRef)(!1);
                    return (0, U.createElement)(eS, (0, N.Z)({}, l, {
                        ref: c,
                        trapFocus: !1,
                        disableOutsidePointerEvents: !1,
                        onCloseAutoFocus: c => {
                            var N, U;
                            null === (N = l.onCloseAutoFocus) || void 0 === N || N.call(l, c), c.defaultPrevented || (Z.current || null === (U = x.triggerRef.current) || void 0 === U || U.focus(), c.preventDefault()), Z.current = !1, $.current = !1
                        },
                        onInteractOutside: c => {
                            var N, U;
                            null === (N = l.onInteractOutside) || void 0 === N || N.call(l, c), c.defaultPrevented || (Z.current = !0, "pointerdown" !== c.detail.originalEvent.type || ($.current = !0));
                            let Y = c.target,
                                q = null === (U = x.triggerRef.current) || void 0 === U ? void 0 : U.contains(Y);
                            q && c.preventDefault(), "focusin" === c.detail.originalEvent.type && $.current && c.preventDefault()
                        }
                    }))
                }),
                eS = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDialog: x,
                        trapFocus: Z,
                        onOpenAutoFocus: Y,
                        onCloseAutoFocus: q,
                        ...J
                    } = l, er = em(ex, x), ea = (0, U.useRef)(null), eo = (0, $.e)(c, ea);
                    return (0, el.EW)(), (0, U.createElement)(U.Fragment, null, (0, U.createElement)(en.M, {
                        asChild: !0,
                        loop: !0,
                        trapped: Z,
                        onMountAutoFocus: Y,
                        onUnmountAutoFocus: q
                    }, (0, U.createElement)(X.XB, (0, N.Z)({
                        role: "dialog",
                        id: er.contentId,
                        "aria-describedby": er.descriptionId,
                        "aria-labelledby": er.titleId,
                        "data-state": $5d3850c4d0b4e6c7$var$getState(er.open)
                    }, J, {
                        ref: eo,
                        onDismiss: () => er.onOpenChange(!1)
                    }))), !1)
                }),
                ek = "DialogTitle",
                eE = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDialog: x,
                        ...Z
                    } = l, $ = em(ek, x);
                    return (0, U.createElement)(eo.WV.h2, (0, N.Z)({
                        id: $.titleId
                    }, Z, {
                        ref: c
                    }))
                }),
                eN = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDialog: x,
                        ...Z
                    } = l, $ = em("DialogDescription", x);
                    return (0, U.createElement)(eo.WV.p, (0, N.Z)({
                        id: $.descriptionId
                    }, Z, {
                        ref: c
                    }))
                }),
                eA = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDialog: x,
                        ...$
                    } = l, Y = em("DialogClose", x);
                    return (0, U.createElement)(eo.WV.button, (0, N.Z)({
                        type: "button"
                    }, $, {
                        ref: c,
                        onClick: (0, Z.M)(l.onClick, () => Y.onOpenChange(!1))
                    }))
                });

            function $5d3850c4d0b4e6c7$var$getState(l) {
                return l ? "open" : "closed"
            }
            let [ej, eO] = (0, Y.k)("DialogTitleWarning", {
                contentName: ex,
                titleName: ek,
                docsSlug: "dialog"
            }), $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = l => {
                let {
                    __scopeDialog: c,
                    children: x,
                    open: N,
                    defaultOpen: Z,
                    onOpenChange: $,
                    modal: Y = !0
                } = l, X = (0, U.useRef)(null), en = (0, U.useRef)(null), [er = !1, ea] = (0, J.T)({
                    prop: N,
                    defaultProp: Z,
                    onChange: $
                });
                return (0, U.createElement)(ef, {
                    scope: c,
                    triggerRef: X,
                    contentRef: en,
                    contentId: (0, q.M)(),
                    titleId: (0, q.M)(),
                    descriptionId: (0, q.M)(),
                    open: er,
                    onOpenChange: ea,
                    onOpenToggle: (0, U.useCallback)(() => ea(l => !l), [ea]),
                    modal: Y
                }, x)
            }, eP = eg, $5d3850c4d0b4e6c7$export$602eac185826482c = l => {
                let {
                    __scopeDialog: c,
                    forceMount: x,
                    children: N,
                    container: Z
                } = l, $ = em(eb, c);
                return (0, U.createElement)(ev, {
                    scope: c,
                    forceMount: x
                }, U.Children.map(N, l => (0, U.createElement)(ea.z, {
                    present: x || $.open
                }, (0, U.createElement)(er.h, {
                    asChild: !0,
                    container: Z
                }, l))))
            }, ez = eM, eR = eC, eL = eE, eB = eN, eU = eA
        },
        23291: function(l, c, x) {
            "use strict";
            x.d(c, {
                oC: function() {
                    return tE
                },
                VY: function() {
                    return t_
                },
                ZA: function() {
                    return tD
                },
                ck: function() {
                    return tk
                },
                wU: function() {
                    return tj
                },
                __: function() {
                    return tS
                },
                Uv: function() {
                    return $d08ef79370b62062$export$602eac185826482c
                },
                Ee: function() {
                    return tN
                },
                Rk: function() {
                    return tA
                },
                fC: function() {
                    return $d08ef79370b62062$export$be92b6f5f03c0fe9
                },
                Z0: function() {
                    return tO
                },
                Tr: function() {
                    return $d08ef79370b62062$export$d7a01e11500dfb6f
                },
                tu: function() {
                    return tz
                },
                fF: function() {
                    return tP
                },
                xz: function() {
                    return tC
                }
            });
            var N = x(13428),
                U = x(2265),
                Z = x(85744),
                $ = x(42210),
                Y = x(56989),
                q = x(73763),
                J = x(9381),
                X = x(27733),
                en = x(65400),
                er = x(79249),
                ea = x(31244),
                eo = x(52759),
                el = x(20966),
                ec = x(83995),
                eu = x(52730),
                ed = x(85606),
                ep = x(44356),
                eh = x(67256),
                ey = x(16459),
                ef = x(85859),
                em = x(32098);
            let eg = ["Enter", " "],
                eb = ["ArrowUp", "PageDown", "End"],
                ev = ["ArrowDown", "PageUp", "Home", ...eb],
                ew = {
                    ltr: [...eg, "ArrowRight"],
                    rtl: [...eg, "ArrowLeft"]
                },
                eT = {
                    ltr: ["ArrowLeft"],
                    rtl: ["ArrowRight"]
                },
                eM = "Menu",
                [eI, ex, eC] = (0, X.B)(eM),
                [e_, eD] = (0, Y.b)(eM, [eC, ec.D7, ep.Pc]),
                eS = (0, ec.D7)(),
                ek = (0, ep.Pc)(),
                [eE, eN] = e_(eM),
                [eA, ej] = e_(eM),
                eO = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        ...Z
                    } = l, $ = eS(x);
                    return (0, U.createElement)(ec.ee, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                eP = "MenuPortal",
                [ez, eR] = e_(eP, {
                    forceMount: void 0
                }),
                eL = "MenuContent",
                [eB, eU] = e_(eL),
                eF = (0, U.forwardRef)((l, c) => {
                    let x = eR(eL, l.__scopeMenu),
                        {
                            forceMount: Z = x.forceMount,
                            ...$
                        } = l,
                        Y = eN(eL, l.__scopeMenu),
                        q = ej(eL, l.__scopeMenu);
                    return (0, U.createElement)(eI.Provider, {
                        scope: l.__scopeMenu
                    }, (0, U.createElement)(ed.z, {
                        present: Z || Y.open
                    }, (0, U.createElement)(eI.Slot, {
                        scope: l.__scopeMenu
                    }, q.modal ? (0, U.createElement)(eW, (0, N.Z)({}, $, {
                        ref: c
                    })) : (0, U.createElement)(eZ, (0, N.Z)({}, $, {
                        ref: c
                    })))))
                }),
                eW = (0, U.forwardRef)((l, c) => {
                    let x = eN(eL, l.__scopeMenu),
                        Y = (0, U.useRef)(null),
                        q = (0, $.e)(c, Y);
                    return (0, U.useEffect)(() => {
                        let l = Y.current;
                        if (l) return (0, ef.Ry)(l)
                    }, []), (0, U.createElement)(eQ, (0, N.Z)({}, l, {
                        ref: q,
                        trapFocus: x.open,
                        disableOutsidePointerEvents: x.open,
                        disableOutsideScroll: !0,
                        onFocusOutside: (0, Z.M)(l.onFocusOutside, l => l.preventDefault(), {
                            checkForDefaultPrevented: !1
                        }),
                        onDismiss: () => x.onOpenChange(!1)
                    }))
                }),
                eZ = (0, U.forwardRef)((l, c) => {
                    let x = eN(eL, l.__scopeMenu);
                    return (0, U.createElement)(eQ, (0, N.Z)({}, l, {
                        ref: c,
                        trapFocus: !1,
                        disableOutsidePointerEvents: !1,
                        disableOutsideScroll: !1,
                        onDismiss: () => x.onOpenChange(!1)
                    }))
                }),
                eQ = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        loop: Y = !1,
                        trapFocus: q,
                        onOpenAutoFocus: J,
                        onCloseAutoFocus: X,
                        disableOutsidePointerEvents: en,
                        onEntryFocus: el,
                        onEscapeKeyDown: eu,
                        onPointerDownOutside: ed,
                        onFocusOutside: ey,
                        onInteractOutside: ef,
                        onDismiss: eg,
                        disableOutsideScroll: ew,
                        ...eT
                    } = l, eM = eN(eL, x), eI = ej(eL, x), eC = eS(x), e_ = ek(x), eD = ex(x), [eE, eA] = (0, U.useState)(null), eO = (0, U.useRef)(null), eP = (0, $.e)(c, eO, eM.onContentChange), ez = (0, U.useRef)(0), eR = (0, U.useRef)(""), eU = (0, U.useRef)(0), eF = (0, U.useRef)(null), eW = (0, U.useRef)("right"), eZ = (0, U.useRef)(0), eQ = ew ? em.Z : U.Fragment, eH = ew ? {
                        as: eh.g7,
                        allowPinchZoom: !0
                    } : void 0, handleTypeaheadSearch = l => {
                        var c, x;
                        let N = eR.current + l,
                            U = eD().filter(l => !l.disabled),
                            Z = document.activeElement,
                            $ = null === (c = U.find(l => l.ref.current === Z)) || void 0 === c ? void 0 : c.textValue,
                            Y = U.map(l => l.textValue),
                            q = function(l, c, x) {
                                var N;
                                let U = c.length > 1 && Array.from(c).every(l => l === c[0]),
                                    Z = U ? c[0] : c,
                                    $ = x ? l.indexOf(x) : -1,
                                    Y = (N = Math.max($, 0), l.map((c, x) => l[(N + x) % l.length])),
                                    q = 1 === Z.length;
                                q && (Y = Y.filter(l => l !== x));
                                let J = Y.find(l => l.toLowerCase().startsWith(Z.toLowerCase()));
                                return J !== x ? J : void 0
                            }(Y, N, $),
                            J = null === (x = U.find(l => l.textValue === q)) || void 0 === x ? void 0 : x.ref.current;
                        ! function updateSearch(l) {
                            eR.current = l, window.clearTimeout(ez.current), "" !== l && (ez.current = window.setTimeout(() => updateSearch(""), 1e3))
                        }(N), J && setTimeout(() => J.focus())
                    };
                    (0, U.useEffect)(() => () => window.clearTimeout(ez.current), []), (0, ea.EW)();
                    let e$ = (0, U.useCallback)(l => {
                        var c, x;
                        let N = eW.current === (null === (c = eF.current) || void 0 === c ? void 0 : c.side);
                        return N && function(l, c) {
                            if (!c) return !1;
                            let x = {
                                x: l.clientX,
                                y: l.clientY
                            };
                            return function(l, c) {
                                let {
                                    x: x,
                                    y: N
                                } = l, U = !1;
                                for (let l = 0, Z = c.length - 1; l < c.length; Z = l++) {
                                    let $ = c[l].x,
                                        Y = c[l].y,
                                        q = c[Z].x,
                                        J = c[Z].y,
                                        X = Y > N != J > N && x < (q - $) * (N - Y) / (J - Y) + $;
                                    X && (U = !U)
                                }
                                return U
                            }(x, c)
                        }(l, null === (x = eF.current) || void 0 === x ? void 0 : x.area)
                    }, []);
                    return (0, U.createElement)(eB, {
                        scope: x,
                        searchRef: eR,
                        onItemEnter: (0, U.useCallback)(l => {
                            e$(l) && l.preventDefault()
                        }, [e$]),
                        onItemLeave: (0, U.useCallback)(l => {
                            var c;
                            e$(l) || (null === (c = eO.current) || void 0 === c || c.focus(), eA(null))
                        }, [e$]),
                        onTriggerLeave: (0, U.useCallback)(l => {
                            e$(l) && l.preventDefault()
                        }, [e$]),
                        pointerGraceTimerRef: eU,
                        onPointerGraceIntentChange: (0, U.useCallback)(l => {
                            eF.current = l
                        }, [])
                    }, (0, U.createElement)(eQ, eH, (0, U.createElement)(eo.M, {
                        asChild: !0,
                        trapped: q,
                        onMountAutoFocus: (0, Z.M)(J, l => {
                            var c;
                            l.preventDefault(), null === (c = eO.current) || void 0 === c || c.focus()
                        }),
                        onUnmountAutoFocus: X
                    }, (0, U.createElement)(er.XB, {
                        asChild: !0,
                        disableOutsidePointerEvents: en,
                        onEscapeKeyDown: eu,
                        onPointerDownOutside: ed,
                        onFocusOutside: ey,
                        onInteractOutside: ef,
                        onDismiss: eg
                    }, (0, U.createElement)(ep.fC, (0, N.Z)({
                        asChild: !0
                    }, e_, {
                        dir: eI.dir,
                        orientation: "vertical",
                        loop: Y,
                        currentTabStopId: eE,
                        onCurrentTabStopIdChange: eA,
                        onEntryFocus: (0, Z.M)(el, l => {
                            eI.isUsingKeyboardRef.current || l.preventDefault()
                        })
                    }), (0, U.createElement)(ec.VY, (0, N.Z)({
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": $6cc32821e9371a1c$var$getOpenState(eM.open),
                        "data-radix-menu-content": "",
                        dir: eI.dir
                    }, eC, eT, {
                        ref: eP,
                        style: {
                            outline: "none",
                            ...eT.style
                        },
                        onKeyDown: (0, Z.M)(eT.onKeyDown, l => {
                            let c = l.target,
                                x = c.closest("[data-radix-menu-content]") === l.currentTarget,
                                N = l.ctrlKey || l.altKey || l.metaKey,
                                U = 1 === l.key.length;
                            x && ("Tab" === l.key && l.preventDefault(), !N && U && handleTypeaheadSearch(l.key));
                            let Z = eO.current;
                            if (l.target !== Z || !ev.includes(l.key)) return;
                            l.preventDefault();
                            let $ = eD().filter(l => !l.disabled),
                                Y = $.map(l => l.ref.current);
                            eb.includes(l.key) && Y.reverse(),
                                function(l) {
                                    let c = document.activeElement;
                                    for (let x of l)
                                        if (x === c || (x.focus(), document.activeElement !== c)) return
                                }(Y)
                        }),
                        onBlur: (0, Z.M)(l.onBlur, l => {
                            l.currentTarget.contains(l.target) || (window.clearTimeout(ez.current), eR.current = "")
                        }),
                        onPointerMove: (0, Z.M)(l.onPointerMove, $6cc32821e9371a1c$var$whenMouse(l => {
                            let c = l.target,
                                x = eZ.current !== l.clientX;
                            if (l.currentTarget.contains(c) && x) {
                                let c = l.clientX > eZ.current ? "right" : "left";
                                eW.current = c, eZ.current = l.clientX
                            }
                        }))
                    })))))))
                }),
                eH = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        ...Z
                    } = l;
                    return (0, U.createElement)(J.WV.div, (0, N.Z)({
                        role: "group"
                    }, Z, {
                        ref: c
                    }))
                }),
                e$ = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        ...Z
                    } = l;
                    return (0, U.createElement)(J.WV.div, (0, N.Z)({}, Z, {
                        ref: c
                    }))
                }),
                eY = "MenuItem",
                eG = "menu.itemSelect",
                eV = (0, U.forwardRef)((l, c) => {
                    let {
                        disabled: x = !1,
                        onSelect: Y,
                        ...q
                    } = l, X = (0, U.useRef)(null), en = ej(eY, l.__scopeMenu), er = eU(eY, l.__scopeMenu), ea = (0, $.e)(c, X), eo = (0, U.useRef)(!1);
                    return (0, U.createElement)(eK, (0, N.Z)({}, q, {
                        ref: ea,
                        disabled: x,
                        onClick: (0, Z.M)(l.onClick, () => {
                            let l = X.current;
                            if (!x && l) {
                                let c = new CustomEvent(eG, {
                                    bubbles: !0,
                                    cancelable: !0
                                });
                                l.addEventListener(eG, l => null == Y ? void 0 : Y(l), {
                                    once: !0
                                }), (0, J.jH)(l, c), c.defaultPrevented ? eo.current = !1 : en.onClose()
                            }
                        }),
                        onPointerDown: c => {
                            var x;
                            null === (x = l.onPointerDown) || void 0 === x || x.call(l, c), eo.current = !0
                        },
                        onPointerUp: (0, Z.M)(l.onPointerUp, l => {
                            var c;
                            eo.current || null === (c = l.currentTarget) || void 0 === c || c.click()
                        }),
                        onKeyDown: (0, Z.M)(l.onKeyDown, l => {
                            let c = "" !== er.searchRef.current;
                            !x && (!c || " " !== l.key) && eg.includes(l.key) && (l.currentTarget.click(), l.preventDefault())
                        })
                    }))
                }),
                eK = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        disabled: Y = !1,
                        textValue: q,
                        ...X
                    } = l, en = eU(eY, x), er = ek(x), ea = (0, U.useRef)(null), eo = (0, $.e)(c, ea), [el, ec] = (0, U.useState)(!1), [eu, ed] = (0, U.useState)("");
                    return (0, U.useEffect)(() => {
                        let l = ea.current;
                        if (l) {
                            var c;
                            ed((null !== (c = l.textContent) && void 0 !== c ? c : "").trim())
                        }
                    }, [X.children]), (0, U.createElement)(eI.ItemSlot, {
                        scope: x,
                        disabled: Y,
                        textValue: null != q ? q : eu
                    }, (0, U.createElement)(ep.ck, (0, N.Z)({
                        asChild: !0
                    }, er, {
                        focusable: !Y
                    }), (0, U.createElement)(J.WV.div, (0, N.Z)({
                        role: "menuitem",
                        "data-highlighted": el ? "" : void 0,
                        "aria-disabled": Y || void 0,
                        "data-disabled": Y ? "" : void 0
                    }, X, {
                        ref: eo,
                        onPointerMove: (0, Z.M)(l.onPointerMove, $6cc32821e9371a1c$var$whenMouse(l => {
                            if (Y) en.onItemLeave(l);
                            else if (en.onItemEnter(l), !l.defaultPrevented) {
                                let c = l.currentTarget;
                                c.focus()
                            }
                        })),
                        onPointerLeave: (0, Z.M)(l.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(l => en.onItemLeave(l))),
                        onFocus: (0, Z.M)(l.onFocus, () => ec(!0)),
                        onBlur: (0, Z.M)(l.onBlur, () => ec(!1))
                    }))))
                }),
                eJ = (0, U.forwardRef)((l, c) => {
                    let {
                        checked: x = !1,
                        onCheckedChange: $,
                        ...Y
                    } = l;
                    return (0, U.createElement)(e4, {
                        scope: l.__scopeMenu,
                        checked: x
                    }, (0, U.createElement)(eV, (0, N.Z)({
                        role: "menuitemcheckbox",
                        "aria-checked": $6cc32821e9371a1c$var$isIndeterminate(x) ? "mixed" : x
                    }, Y, {
                        ref: c,
                        "data-state": $6cc32821e9371a1c$var$getCheckedState(x),
                        onSelect: (0, Z.M)(Y.onSelect, () => null == $ ? void 0 : $(!!$6cc32821e9371a1c$var$isIndeterminate(x) || !x), {
                            checkForDefaultPrevented: !1
                        })
                    })))
                }),
                [eX, e0] = e_("MenuRadioGroup", {
                    value: void 0,
                    onValueChange: () => {}
                }),
                e2 = (0, U.forwardRef)((l, c) => {
                    let {
                        value: x,
                        onValueChange: Z,
                        ...$
                    } = l, Y = (0, ey.W)(Z);
                    return (0, U.createElement)(eX, {
                        scope: l.__scopeMenu,
                        value: x,
                        onValueChange: Y
                    }, (0, U.createElement)(eH, (0, N.Z)({}, $, {
                        ref: c
                    })))
                }),
                e1 = (0, U.forwardRef)((l, c) => {
                    let {
                        value: x,
                        ...$
                    } = l, Y = e0("MenuRadioItem", l.__scopeMenu), q = x === Y.value;
                    return (0, U.createElement)(e4, {
                        scope: l.__scopeMenu,
                        checked: q
                    }, (0, U.createElement)(eV, (0, N.Z)({
                        role: "menuitemradio",
                        "aria-checked": q
                    }, $, {
                        ref: c,
                        "data-state": $6cc32821e9371a1c$var$getCheckedState(q),
                        onSelect: (0, Z.M)($.onSelect, () => {
                            var l;
                            return null === (l = Y.onValueChange) || void 0 === l ? void 0 : l.call(Y, x)
                        }, {
                            checkForDefaultPrevented: !1
                        })
                    })))
                }),
                e5 = "MenuItemIndicator",
                [e4, e3] = e_(e5, {
                    checked: !1
                }),
                e6 = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        forceMount: Z,
                        ...$
                    } = l, Y = e3(e5, x);
                    return (0, U.createElement)(ed.z, {
                        present: Z || $6cc32821e9371a1c$var$isIndeterminate(Y.checked) || !0 === Y.checked
                    }, (0, U.createElement)(J.WV.span, (0, N.Z)({}, $, {
                        ref: c,
                        "data-state": $6cc32821e9371a1c$var$getCheckedState(Y.checked)
                    })))
                }),
                e8 = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeMenu: x,
                        ...Z
                    } = l;
                    return (0, U.createElement)(J.WV.div, (0, N.Z)({
                        role: "separator",
                        "aria-orientation": "horizontal"
                    }, Z, {
                        ref: c
                    }))
                }),
                e9 = ((l, c) => {
                    let {
                        __scopeMenu: x,
                        ...Z
                    } = l, $ = eS(x);
                    return (0, U.createElement)(ec.Eh, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }, "MenuSub"),
                [e7, tt] = e_(e9),
                tn = "MenuSubTrigger",
                tr = (0, U.forwardRef)((l, c) => {
                    let x = eN(tn, l.__scopeMenu),
                        Y = ej(tn, l.__scopeMenu),
                        q = tt(tn, l.__scopeMenu),
                        J = eU(tn, l.__scopeMenu),
                        X = (0, U.useRef)(null),
                        {
                            pointerGraceTimerRef: en,
                            onPointerGraceIntentChange: er
                        } = J,
                        ea = {
                            __scopeMenu: l.__scopeMenu
                        },
                        eo = (0, U.useCallback)(() => {
                            X.current && window.clearTimeout(X.current), X.current = null
                        }, []);
                    return (0, U.useEffect)(() => eo, [eo]), (0, U.useEffect)(() => {
                        let l = en.current;
                        return () => {
                            window.clearTimeout(l), er(null)
                        }
                    }, [en, er]), (0, U.createElement)(eO, (0, N.Z)({
                        asChild: !0
                    }, ea), (0, U.createElement)(eK, (0, N.Z)({
                        id: q.triggerId,
                        "aria-haspopup": "menu",
                        "aria-expanded": x.open,
                        "aria-controls": q.contentId,
                        "data-state": $6cc32821e9371a1c$var$getOpenState(x.open)
                    }, l, {
                        ref: (0, $.F)(c, q.onTriggerChange),
                        onClick: c => {
                            var N;
                            null === (N = l.onClick) || void 0 === N || N.call(l, c), l.disabled || c.defaultPrevented || (c.currentTarget.focus(), x.open || x.onOpenChange(!0))
                        },
                        onPointerMove: (0, Z.M)(l.onPointerMove, $6cc32821e9371a1c$var$whenMouse(c => {
                            J.onItemEnter(c), c.defaultPrevented || l.disabled || x.open || X.current || (J.onPointerGraceIntentChange(null), X.current = window.setTimeout(() => {
                                x.onOpenChange(!0), eo()
                            }, 100))
                        })),
                        onPointerLeave: (0, Z.M)(l.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(l => {
                            var c, N;
                            eo();
                            let U = null === (c = x.content) || void 0 === c ? void 0 : c.getBoundingClientRect();
                            if (U) {
                                let c = null === (N = x.content) || void 0 === N ? void 0 : N.dataset.side,
                                    Z = "right" === c,
                                    $ = U[Z ? "left" : "right"],
                                    Y = U[Z ? "right" : "left"];
                                J.onPointerGraceIntentChange({
                                    area: [{
                                        x: l.clientX + (Z ? -5 : 5),
                                        y: l.clientY
                                    }, {
                                        x: $,
                                        y: U.top
                                    }, {
                                        x: Y,
                                        y: U.top
                                    }, {
                                        x: Y,
                                        y: U.bottom
                                    }, {
                                        x: $,
                                        y: U.bottom
                                    }],
                                    side: c
                                }), window.clearTimeout(en.current), en.current = window.setTimeout(() => J.onPointerGraceIntentChange(null), 300)
                            } else {
                                if (J.onTriggerLeave(l), l.defaultPrevented) return;
                                J.onPointerGraceIntentChange(null)
                            }
                        })),
                        onKeyDown: (0, Z.M)(l.onKeyDown, c => {
                            let N = "" !== J.searchRef.current;
                            if (!l.disabled && (!N || " " !== c.key) && ew[Y.dir].includes(c.key)) {
                                var U;
                                x.onOpenChange(!0), null === (U = x.content) || void 0 === U || U.focus(), c.preventDefault()
                            }
                        })
                    })))
                }),
                ta = (0, U.forwardRef)((l, c) => {
                    let x = eR(eL, l.__scopeMenu),
                        {
                            forceMount: Y = x.forceMount,
                            ...q
                        } = l,
                        J = eN(eL, l.__scopeMenu),
                        X = ej(eL, l.__scopeMenu),
                        en = tt("MenuSubContent", l.__scopeMenu),
                        er = (0, U.useRef)(null),
                        ea = (0, $.e)(c, er);
                    return (0, U.createElement)(eI.Provider, {
                        scope: l.__scopeMenu
                    }, (0, U.createElement)(ed.z, {
                        present: Y || J.open
                    }, (0, U.createElement)(eI.Slot, {
                        scope: l.__scopeMenu
                    }, (0, U.createElement)(eQ, (0, N.Z)({
                        id: en.contentId,
                        "aria-labelledby": en.triggerId
                    }, q, {
                        ref: ea,
                        align: "start",
                        side: "rtl" === X.dir ? "left" : "right",
                        disableOutsidePointerEvents: !1,
                        disableOutsideScroll: !1,
                        trapFocus: !1,
                        onOpenAutoFocus: l => {
                            var c;
                            X.isUsingKeyboardRef.current && (null === (c = er.current) || void 0 === c || c.focus()), l.preventDefault()
                        },
                        onCloseAutoFocus: l => l.preventDefault(),
                        onFocusOutside: (0, Z.M)(l.onFocusOutside, l => {
                            l.target !== en.trigger && J.onOpenChange(!1)
                        }),
                        onEscapeKeyDown: (0, Z.M)(l.onEscapeKeyDown, l => {
                            X.onClose(), l.preventDefault()
                        }),
                        onKeyDown: (0, Z.M)(l.onKeyDown, l => {
                            let c = l.currentTarget.contains(l.target),
                                x = eT[X.dir].includes(l.key);
                            if (c && x) {
                                var N;
                                J.onOpenChange(!1), null === (N = en.trigger) || void 0 === N || N.focus(), l.preventDefault()
                            }
                        })
                    })))))
                });

            function $6cc32821e9371a1c$var$getOpenState(l) {
                return l ? "open" : "closed"
            }

            function $6cc32821e9371a1c$var$isIndeterminate(l) {
                return "indeterminate" === l
            }

            function $6cc32821e9371a1c$var$getCheckedState(l) {
                return $6cc32821e9371a1c$var$isIndeterminate(l) ? "indeterminate" : l ? "checked" : "unchecked"
            }

            function $6cc32821e9371a1c$var$whenMouse(l) {
                return c => "mouse" === c.pointerType ? l(c) : void 0
            }
            let $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = l => {
                    let {
                        __scopeMenu: c,
                        open: x = !1,
                        children: N,
                        dir: Z,
                        onOpenChange: $,
                        modal: Y = !0
                    } = l, q = eS(c), [J, X] = (0, U.useState)(null), er = (0, U.useRef)(!1), ea = (0, ey.W)($), eo = (0, en.gm)(Z);
                    return (0, U.useEffect)(() => {
                        let handleKeyDown = () => {
                                er.current = !0, document.addEventListener("pointerdown", handlePointer, {
                                    capture: !0,
                                    once: !0
                                }), document.addEventListener("pointermove", handlePointer, {
                                    capture: !0,
                                    once: !0
                                })
                            },
                            handlePointer = () => er.current = !1;
                        return document.addEventListener("keydown", handleKeyDown, {
                            capture: !0
                        }), () => {
                            document.removeEventListener("keydown", handleKeyDown, {
                                capture: !0
                            }), document.removeEventListener("pointerdown", handlePointer, {
                                capture: !0
                            }), document.removeEventListener("pointermove", handlePointer, {
                                capture: !0
                            })
                        }
                    }, []), (0, U.createElement)(ec.fC, q, (0, U.createElement)(eE, {
                        scope: c,
                        open: x,
                        onOpenChange: ea,
                        content: J,
                        onContentChange: X
                    }, (0, U.createElement)(eA, {
                        scope: c,
                        onClose: (0, U.useCallback)(() => ea(!1), [ea]),
                        isUsingKeyboardRef: er,
                        dir: eo,
                        modal: Y
                    }, N)))
                },
                $6cc32821e9371a1c$export$602eac185826482c = l => {
                    let {
                        __scopeMenu: c,
                        forceMount: x,
                        children: N,
                        container: Z
                    } = l, $ = eN(eP, c);
                    return (0, U.createElement)(ez, {
                        scope: c,
                        forceMount: x
                    }, (0, U.createElement)(ed.z, {
                        present: x || $.open
                    }, (0, U.createElement)(eu.h, {
                        asChild: !0,
                        container: Z
                    }, N)))
                },
                $6cc32821e9371a1c$export$d7a01e11500dfb6f = l => {
                    let {
                        __scopeMenu: c,
                        children: x,
                        open: N = !1,
                        onOpenChange: Z
                    } = l, $ = eN(e9, c), Y = eS(c), [q, J] = (0, U.useState)(null), [X, en] = (0, U.useState)(null), er = (0, ey.W)(Z);
                    return (0, U.useEffect)(() => (!1 === $.open && er(!1), () => er(!1)), [$.open, er]), (0, U.createElement)(ec.fC, Y, (0, U.createElement)(eE, {
                        scope: c,
                        open: N,
                        onOpenChange: er,
                        content: X,
                        onContentChange: en
                    }, (0, U.createElement)(e7, {
                        scope: c,
                        contentId: (0, el.M)(),
                        triggerId: (0, el.M)(),
                        trigger: q,
                        onTriggerChange: J
                    }, x)))
                },
                to = "DropdownMenu",
                [tl, tc] = (0, Y.b)(to, [eD]),
                tu = eD(),
                [td, tp] = tl(to),
                th = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        disabled: Y = !1,
                        ...q
                    } = l, X = tp("DropdownMenuTrigger", x), en = tu(x);
                    return (0, U.createElement)(eO, (0, N.Z)({
                        asChild: !0
                    }, en), (0, U.createElement)(J.WV.button, (0, N.Z)({
                        type: "button",
                        id: X.triggerId,
                        "aria-haspopup": "menu",
                        "aria-expanded": X.open,
                        "aria-controls": X.open ? X.contentId : void 0,
                        "data-state": X.open ? "open" : "closed",
                        "data-disabled": Y ? "" : void 0,
                        disabled: Y
                    }, q, {
                        ref: (0, $.F)(c, X.triggerRef),
                        onPointerDown: (0, Z.M)(l.onPointerDown, l => {
                            Y || 0 !== l.button || !1 !== l.ctrlKey || (X.onOpenToggle(), X.open || l.preventDefault())
                        }),
                        onKeyDown: (0, Z.M)(l.onKeyDown, l => {
                            !Y && (["Enter", " "].includes(l.key) && X.onOpenToggle(), "ArrowDown" === l.key && X.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(l.key) && l.preventDefault())
                        })
                    })))
                }),
                ty = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...$
                    } = l, Y = tp("DropdownMenuContent", x), q = tu(x), J = (0, U.useRef)(!1);
                    return (0, U.createElement)(eF, (0, N.Z)({
                        id: Y.contentId,
                        "aria-labelledby": Y.triggerId
                    }, q, $, {
                        ref: c,
                        onCloseAutoFocus: (0, Z.M)(l.onCloseAutoFocus, l => {
                            var c;
                            J.current || null === (c = Y.triggerRef.current) || void 0 === c || c.focus(), J.current = !1, l.preventDefault()
                        }),
                        onInteractOutside: (0, Z.M)(l.onInteractOutside, l => {
                            let c = l.detail.originalEvent,
                                x = 0 === c.button && !0 === c.ctrlKey,
                                N = 2 === c.button || x;
                            (!Y.modal || N) && (J.current = !0)
                        }),
                        style: { ...l.style,
                            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
                            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
                            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
                            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
                            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
                        }
                    }))
                }),
                tf = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(eH, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tm = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(e$, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tg = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(eV, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tb = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(eJ, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tv = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(e2, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tw = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(e1, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tT = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(e6, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tM = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(e8, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tI = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(tr, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                }),
                tx = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeDropdownMenu: x,
                        ...Z
                    } = l, $ = tu(x);
                    return (0, U.createElement)(ta, (0, N.Z)({}, $, Z, {
                        ref: c,
                        style: { ...l.style,
                            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
                            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
                            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
                            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
                            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
                        }
                    }))
                }),
                $d08ef79370b62062$export$be92b6f5f03c0fe9 = l => {
                    let {
                        __scopeDropdownMenu: c,
                        children: x,
                        dir: Z,
                        open: $,
                        defaultOpen: Y,
                        onOpenChange: J,
                        modal: X = !0
                    } = l, en = tu(c), er = (0, U.useRef)(null), [ea = !1, eo] = (0, q.T)({
                        prop: $,
                        defaultProp: Y,
                        onChange: J
                    });
                    return (0, U.createElement)(td, {
                        scope: c,
                        triggerId: (0, el.M)(),
                        triggerRef: er,
                        contentId: (0, el.M)(),
                        open: ea,
                        onOpenChange: eo,
                        onOpenToggle: (0, U.useCallback)(() => eo(l => !l), [eo]),
                        modal: X
                    }, (0, U.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, (0, N.Z)({}, en, {
                        open: ea,
                        onOpenChange: eo,
                        dir: Z,
                        modal: X
                    }), x))
                },
                tC = th,
                $d08ef79370b62062$export$602eac185826482c = l => {
                    let {
                        __scopeDropdownMenu: c,
                        ...x
                    } = l, Z = tu(c);
                    return (0, U.createElement)($6cc32821e9371a1c$export$602eac185826482c, (0, N.Z)({}, Z, x))
                },
                t_ = ty,
                tD = tf,
                tS = tm,
                tk = tg,
                tE = tb,
                tN = tv,
                tA = tw,
                tj = tT,
                tO = tM,
                $d08ef79370b62062$export$d7a01e11500dfb6f = l => {
                    let {
                        __scopeDropdownMenu: c,
                        children: x,
                        open: Z,
                        onOpenChange: $,
                        defaultOpen: Y
                    } = l, J = tu(c), [X = !1, en] = (0, q.T)({
                        prop: Z,
                        defaultProp: Y,
                        onChange: $
                    });
                    return (0, U.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, (0, N.Z)({}, J, {
                        open: X,
                        onOpenChange: en
                    }), x)
                },
                tP = tI,
                tz = tx
        },
        65050: function(l, c, x) {
            "use strict";
            x.d(c, {
                Eh: function() {
                    return eN
                },
                VY: function() {
                    return eE
                },
                fC: function() {
                    return $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9
                },
                h_: function() {
                    return $cb5cc270b50c6fcd$export$602eac185826482c
                },
                xz: function() {
                    return ek
                }
            });
            var N = x(13428),
                U = x(2265),
                Z = x(85744),
                $ = x(42210),
                Y = x(56989),
                q = x(79249),
                J = x(31244),
                X = x(52759),
                en = x(20966),
                er = x(83995),
                ea = x(52730),
                eo = x(85606),
                el = x(9381),
                ec = x(67256),
                eu = x(73763),
                ed = x(85859),
                ep = x(32098);
            let eh = "Popover",
                [ey, ef] = (0, Y.b)(eh, [er.D7]),
                em = (0, er.D7)(),
                [eg, eb] = ey(eh),
                ev = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopePopover: x,
                        ...Y
                    } = l, q = eb("PopoverTrigger", x), J = em(x), X = (0, $.e)(c, q.triggerRef), en = (0, U.createElement)(el.WV.button, (0, N.Z)({
                        type: "button",
                        "aria-haspopup": "dialog",
                        "aria-expanded": q.open,
                        "aria-controls": q.contentId,
                        "data-state": $cb5cc270b50c6fcd$var$getState(q.open)
                    }, Y, {
                        ref: X,
                        onClick: (0, Z.M)(l.onClick, q.onOpenToggle)
                    }));
                    return q.hasCustomAnchor ? en : (0, U.createElement)(er.ee, (0, N.Z)({
                        asChild: !0
                    }, J), en)
                }),
                ew = "PopoverPortal",
                [eT, eM] = ey(ew, {
                    forceMount: void 0
                }),
                eI = "PopoverContent",
                ex = (0, U.forwardRef)((l, c) => {
                    let x = eM(eI, l.__scopePopover),
                        {
                            forceMount: Z = x.forceMount,
                            ...$
                        } = l,
                        Y = eb(eI, l.__scopePopover);
                    return (0, U.createElement)(eo.z, {
                        present: Z || Y.open
                    }, Y.modal ? (0, U.createElement)(eC, (0, N.Z)({}, $, {
                        ref: c
                    })) : (0, U.createElement)(e_, (0, N.Z)({}, $, {
                        ref: c
                    })))
                }),
                eC = (0, U.forwardRef)((l, c) => {
                    let x = eb(eI, l.__scopePopover),
                        Y = (0, U.useRef)(null),
                        q = (0, $.e)(c, Y),
                        J = (0, U.useRef)(!1);
                    return (0, U.useEffect)(() => {
                        let l = Y.current;
                        if (l) return (0, ed.Ry)(l)
                    }, []), (0, U.createElement)(ep.Z, {
                        as: ec.g7,
                        allowPinchZoom: !0
                    }, (0, U.createElement)(eD, (0, N.Z)({}, l, {
                        ref: q,
                        trapFocus: x.open,
                        disableOutsidePointerEvents: !0,
                        onCloseAutoFocus: (0, Z.M)(l.onCloseAutoFocus, l => {
                            var c;
                            l.preventDefault(), J.current || null === (c = x.triggerRef.current) || void 0 === c || c.focus()
                        }),
                        onPointerDownOutside: (0, Z.M)(l.onPointerDownOutside, l => {
                            let c = l.detail.originalEvent,
                                x = 0 === c.button && !0 === c.ctrlKey,
                                N = 2 === c.button || x;
                            J.current = N
                        }, {
                            checkForDefaultPrevented: !1
                        }),
                        onFocusOutside: (0, Z.M)(l.onFocusOutside, l => l.preventDefault(), {
                            checkForDefaultPrevented: !1
                        })
                    })))
                }),
                e_ = (0, U.forwardRef)((l, c) => {
                    let x = eb(eI, l.__scopePopover),
                        Z = (0, U.useRef)(!1),
                        $ = (0, U.useRef)(!1);
                    return (0, U.createElement)(eD, (0, N.Z)({}, l, {
                        ref: c,
                        trapFocus: !1,
                        disableOutsidePointerEvents: !1,
                        onCloseAutoFocus: c => {
                            var N, U;
                            null === (N = l.onCloseAutoFocus) || void 0 === N || N.call(l, c), c.defaultPrevented || (Z.current || null === (U = x.triggerRef.current) || void 0 === U || U.focus(), c.preventDefault()), Z.current = !1, $.current = !1
                        },
                        onInteractOutside: c => {
                            var N, U;
                            null === (N = l.onInteractOutside) || void 0 === N || N.call(l, c), c.defaultPrevented || (Z.current = !0, "pointerdown" !== c.detail.originalEvent.type || ($.current = !0));
                            let Y = c.target,
                                q = null === (U = x.triggerRef.current) || void 0 === U ? void 0 : U.contains(Y);
                            q && c.preventDefault(), "focusin" === c.detail.originalEvent.type && $.current && c.preventDefault()
                        }
                    }))
                }),
                eD = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopePopover: x,
                        trapFocus: Z,
                        onOpenAutoFocus: $,
                        onCloseAutoFocus: Y,
                        disableOutsidePointerEvents: en,
                        onEscapeKeyDown: ea,
                        onPointerDownOutside: eo,
                        onFocusOutside: el,
                        onInteractOutside: ec,
                        ...eu
                    } = l, ed = eb(eI, x), ep = em(x);
                    return (0, J.EW)(), (0, U.createElement)(X.M, {
                        asChild: !0,
                        loop: !0,
                        trapped: Z,
                        onMountAutoFocus: $,
                        onUnmountAutoFocus: Y
                    }, (0, U.createElement)(q.XB, {
                        asChild: !0,
                        disableOutsidePointerEvents: en,
                        onInteractOutside: ec,
                        onEscapeKeyDown: ea,
                        onPointerDownOutside: eo,
                        onFocusOutside: el,
                        onDismiss: () => ed.onOpenChange(!1)
                    }, (0, U.createElement)(er.VY, (0, N.Z)({
                        "data-state": $cb5cc270b50c6fcd$var$getState(ed.open),
                        role: "dialog",
                        id: ed.contentId
                    }, ep, eu, {
                        ref: c,
                        style: { ...eu.style,
                            "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                            "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                            "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                            "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                            "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                        }
                    }))))
                }),
                eS = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopePopover: x,
                        ...Z
                    } = l, $ = em(x);
                    return (0, U.createElement)(er.Eh, (0, N.Z)({}, $, Z, {
                        ref: c
                    }))
                });

            function $cb5cc270b50c6fcd$var$getState(l) {
                return l ? "open" : "closed"
            }
            let $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = l => {
                    let {
                        __scopePopover: c,
                        children: x,
                        open: N,
                        defaultOpen: Z,
                        onOpenChange: $,
                        modal: Y = !1
                    } = l, q = em(c), J = (0, U.useRef)(null), [X, ea] = (0, U.useState)(!1), [eo = !1, el] = (0, eu.T)({
                        prop: N,
                        defaultProp: Z,
                        onChange: $
                    });
                    return (0, U.createElement)(er.fC, q, (0, U.createElement)(eg, {
                        scope: c,
                        contentId: (0, en.M)(),
                        triggerRef: J,
                        open: eo,
                        onOpenChange: el,
                        onOpenToggle: (0, U.useCallback)(() => el(l => !l), [el]),
                        hasCustomAnchor: X,
                        onCustomAnchorAdd: (0, U.useCallback)(() => ea(!0), []),
                        onCustomAnchorRemove: (0, U.useCallback)(() => ea(!1), []),
                        modal: Y
                    }, x))
                },
                ek = ev,
                $cb5cc270b50c6fcd$export$602eac185826482c = l => {
                    let {
                        __scopePopover: c,
                        forceMount: x,
                        children: N,
                        container: Z
                    } = l, $ = eb(ew, c);
                    return (0, U.createElement)(eT, {
                        scope: c,
                        forceMount: x
                    }, (0, U.createElement)(eo.z, {
                        present: x || $.open
                    }, (0, U.createElement)(ea.h, {
                        asChild: !0,
                        container: Z
                    }, N)))
                },
                eE = ex,
                eN = eS
        },
        34522: function(l, c, x) {
            "use strict";
            x.d(c, {
                VY: function() {
                    return ev
                },
                aV: function() {
                    return eg
                },
                fC: function() {
                    return em
                },
                xz: function() {
                    return eb
                }
            });
            var N = x(13428),
                U = x(2265),
                Z = x(85744),
                $ = x(56989),
                Y = x(44356),
                q = x(85606),
                J = x(9381),
                X = x(65400),
                en = x(73763),
                er = x(20966);
            let ea = "Tabs",
                [eo, el] = (0, $.b)(ea, [Y.Pc]),
                ec = (0, Y.Pc)(),
                [eu, ed] = eo(ea),
                ep = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeTabs: x,
                        value: Z,
                        onValueChange: $,
                        defaultValue: Y,
                        orientation: q = "horizontal",
                        dir: ea,
                        activationMode: eo = "automatic",
                        ...el
                    } = l, ec = (0, X.gm)(ea), [ed, ep] = (0, en.T)({
                        prop: Z,
                        onChange: $,
                        defaultProp: Y
                    });
                    return (0, U.createElement)(eu, {
                        scope: x,
                        baseId: (0, er.M)(),
                        value: ed,
                        onValueChange: ep,
                        orientation: q,
                        dir: ec,
                        activationMode: eo
                    }, (0, U.createElement)(J.WV.div, (0, N.Z)({
                        dir: ec,
                        "data-orientation": q
                    }, el, {
                        ref: c
                    })))
                }),
                eh = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeTabs: x,
                        loop: Z = !0,
                        ...$
                    } = l, q = ed("TabsList", x), X = ec(x);
                    return (0, U.createElement)(Y.fC, (0, N.Z)({
                        asChild: !0
                    }, X, {
                        orientation: q.orientation,
                        dir: q.dir,
                        loop: Z
                    }), (0, U.createElement)(J.WV.div, (0, N.Z)({
                        role: "tablist",
                        "aria-orientation": q.orientation
                    }, $, {
                        ref: c
                    })))
                }),
                ey = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeTabs: x,
                        value: $,
                        disabled: q = !1,
                        ...X
                    } = l, en = ed("TabsTrigger", x), er = ec(x), ea = $69cb30bb0017df05$var$makeTriggerId(en.baseId, $), eo = $69cb30bb0017df05$var$makeContentId(en.baseId, $), el = $ === en.value;
                    return (0, U.createElement)(Y.ck, (0, N.Z)({
                        asChild: !0
                    }, er, {
                        focusable: !q,
                        active: el
                    }), (0, U.createElement)(J.WV.button, (0, N.Z)({
                        type: "button",
                        role: "tab",
                        "aria-selected": el,
                        "aria-controls": eo,
                        "data-state": el ? "active" : "inactive",
                        "data-disabled": q ? "" : void 0,
                        disabled: q,
                        id: ea
                    }, X, {
                        ref: c,
                        onMouseDown: (0, Z.M)(l.onMouseDown, l => {
                            q || 0 !== l.button || !1 !== l.ctrlKey ? l.preventDefault() : en.onValueChange($)
                        }),
                        onKeyDown: (0, Z.M)(l.onKeyDown, l => {
                            [" ", "Enter"].includes(l.key) && en.onValueChange($)
                        }),
                        onFocus: (0, Z.M)(l.onFocus, () => {
                            let l = "manual" !== en.activationMode;
                            el || q || !l || en.onValueChange($)
                        })
                    })))
                }),
                ef = (0, U.forwardRef)((l, c) => {
                    let {
                        __scopeTabs: x,
                        value: Z,
                        forceMount: $,
                        children: Y,
                        ...X
                    } = l, en = ed("TabsContent", x), er = $69cb30bb0017df05$var$makeTriggerId(en.baseId, Z), ea = $69cb30bb0017df05$var$makeContentId(en.baseId, Z), eo = Z === en.value, el = (0, U.useRef)(eo);
                    return (0, U.useEffect)(() => {
                        let l = requestAnimationFrame(() => el.current = !1);
                        return () => cancelAnimationFrame(l)
                    }, []), (0, U.createElement)(q.z, {
                        present: $ || eo
                    }, ({
                        present: x
                    }) => (0, U.createElement)(J.WV.div, (0, N.Z)({
                        "data-state": eo ? "active" : "inactive",
                        "data-orientation": en.orientation,
                        role: "tabpanel",
                        "aria-labelledby": er,
                        hidden: !x,
                        id: ea,
                        tabIndex: 0
                    }, X, {
                        ref: c,
                        style: { ...l.style,
                            animationDuration: el.current ? "0s" : void 0
                        }
                    }), x && Y))
                });

            function $69cb30bb0017df05$var$makeTriggerId(l, c) {
                return `${l}-trigger-${c}`
            }

            function $69cb30bb0017df05$var$makeContentId(l, c) {
                return `${l}-content-${c}`
            }
            let em = ep,
                eg = eh,
                eb = ey,
                ev = ef
        },
        88202: function(l, c, x) {
            "use strict";
            x.d(c, {
                j: function() {
                    return Z
                }
            });
            var N = x(29492),
                U = x(46504);
            let FocusManager = class FocusManager extends N.l {
                constructor() {
                    super(), this.setup = l => {
                        if (!U.sk && window.addEventListener) {
                            let listener = () => l();
                            return window.addEventListener("visibilitychange", listener, !1), window.addEventListener("focus", listener, !1), () => {
                                window.removeEventListener("visibilitychange", listener), window.removeEventListener("focus", listener)
                            }
                        }
                    }
                }
                onSubscribe() {
                    this.cleanup || this.setEventListener(this.setup)
                }
                onUnsubscribe() {
                    if (!this.hasListeners()) {
                        var l;
                        null == (l = this.cleanup) || l.call(this), this.cleanup = void 0
                    }
                }
                setEventListener(l) {
                    var c;
                    this.setup = l, null == (c = this.cleanup) || c.call(this), this.cleanup = l(l => {
                        "boolean" == typeof l ? this.setFocused(l) : this.onFocus()
                    })
                }
                setFocused(l) {
                    let c = this.focused !== l;
                    c && (this.focused = l, this.onFocus())
                }
                onFocus() {
                    this.listeners.forEach(({
                        listener: l
                    }) => {
                        l()
                    })
                }
                isFocused() {
                    return "boolean" == typeof this.focused ? this.focused : "undefined" == typeof document || [void 0, "visible", "prerender"].includes(document.visibilityState)
                }
            };
            let Z = new FocusManager
        },
        58810: function(l, c, x) {
            "use strict";
            x.d(c, {
                _: function() {
                    return N
                }
            });
            let N = console
        },
        20172: function(l, c, x) {
            "use strict";
            x.d(c, {
                R: function() {
                    return getDefaultState
                },
                m: function() {
                    return Mutation
                }
            });
            var N = x(58810),
                U = x(17156),
                Z = x(11909),
                $ = x(43238);
            let Mutation = class Mutation extends Z.F {
                constructor(l) {
                    super(), this.defaultOptions = l.defaultOptions, this.mutationId = l.mutationId, this.mutationCache = l.mutationCache, this.logger = l.logger || N._, this.observers = [], this.state = l.state || getDefaultState(), this.setOptions(l.options), this.scheduleGc()
                }
                setOptions(l) {
                    this.options = { ...this.defaultOptions,
                        ...l
                    }, this.updateCacheTime(this.options.cacheTime)
                }
                get meta() {
                    return this.options.meta
                }
                setState(l) {
                    this.dispatch({
                        type: "setState",
                        state: l
                    })
                }
                addObserver(l) {
                    this.observers.includes(l) || (this.observers.push(l), this.clearGcTimeout(), this.mutationCache.notify({
                        type: "observerAdded",
                        mutation: this,
                        observer: l
                    }))
                }
                removeObserver(l) {
                    this.observers = this.observers.filter(c => c !== l), this.scheduleGc(), this.mutationCache.notify({
                        type: "observerRemoved",
                        mutation: this,
                        observer: l
                    })
                }
                optionalRemove() {
                    this.observers.length || ("loading" === this.state.status ? this.scheduleGc() : this.mutationCache.remove(this))
                }
                continue () {
                    var l, c;
                    return null != (l = null == (c = this.retryer) ? void 0 : c.continue()) ? l : this.execute()
                }
                async execute() {
                    var l, c, x, N, U, Z, Y, q, J, X, en, er, ea, eo, el, ec, eu, ed, ep, eh;
                    let ey = "loading" === this.state.status;
                    try {
                        if (!ey) {
                            this.dispatch({
                                type: "loading",
                                variables: this.options.variables
                            }), await (null == (J = (X = this.mutationCache.config).onMutate) ? void 0 : J.call(X, this.state.variables, this));
                            let l = await (null == (en = (er = this.options).onMutate) ? void 0 : en.call(er, this.state.variables));
                            l !== this.state.context && this.dispatch({
                                type: "loading",
                                context: l,
                                variables: this.state.variables
                            })
                        }
                        let ea = await (() => {
                            var l;
                            return this.retryer = (0, $.Mz)({
                                fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
                                onFail: (l, c) => {
                                    this.dispatch({
                                        type: "failed",
                                        failureCount: l,
                                        error: c
                                    })
                                },
                                onPause: () => {
                                    this.dispatch({
                                        type: "pause"
                                    })
                                },
                                onContinue: () => {
                                    this.dispatch({
                                        type: "continue"
                                    })
                                },
                                retry: null != (l = this.options.retry) ? l : 0,
                                retryDelay: this.options.retryDelay,
                                networkMode: this.options.networkMode
                            }), this.retryer.promise
                        })();
                        return await (null == (l = (c = this.mutationCache.config).onSuccess) ? void 0 : l.call(c, ea, this.state.variables, this.state.context, this)), await (null == (x = (N = this.options).onSuccess) ? void 0 : x.call(N, ea, this.state.variables, this.state.context)), await (null == (U = (Z = this.mutationCache.config).onSettled) ? void 0 : U.call(Z, ea, null, this.state.variables, this.state.context, this)), await (null == (Y = (q = this.options).onSettled) ? void 0 : Y.call(q, ea, null, this.state.variables, this.state.context)), this.dispatch({
                            type: "success",
                            data: ea
                        }), ea
                    } catch (l) {
                        try {
                            throw await (null == (ea = (eo = this.mutationCache.config).onError) ? void 0 : ea.call(eo, l, this.state.variables, this.state.context, this)), await (null == (el = (ec = this.options).onError) ? void 0 : el.call(ec, l, this.state.variables, this.state.context)), await (null == (eu = (ed = this.mutationCache.config).onSettled) ? void 0 : eu.call(ed, void 0, l, this.state.variables, this.state.context, this)), await (null == (ep = (eh = this.options).onSettled) ? void 0 : ep.call(eh, void 0, l, this.state.variables, this.state.context)), l
                        } finally {
                            this.dispatch({
                                type: "error",
                                error: l
                            })
                        }
                    }
                }
                dispatch(l) {
                    this.state = (c => {
                        switch (l.type) {
                            case "failed":
                                return { ...c,
                                    failureCount: l.failureCount,
                                    failureReason: l.error
                                };
                            case "pause":
                                return { ...c,
                                    isPaused: !0
                                };
                            case "continue":
                                return { ...c,
                                    isPaused: !1
                                };
                            case "loading":
                                return { ...c,
                                    context: l.context,
                                    data: void 0,
                                    failureCount: 0,
                                    failureReason: null,
                                    error: null,
                                    isPaused: !(0, $.Kw)(this.options.networkMode),
                                    status: "loading",
                                    variables: l.variables
                                };
                            case "success":
                                return { ...c,
                                    data: l.data,
                                    failureCount: 0,
                                    failureReason: null,
                                    error: null,
                                    status: "success",
                                    isPaused: !1
                                };
                            case "error":
                                return { ...c,
                                    data: void 0,
                                    error: l.error,
                                    failureCount: c.failureCount + 1,
                                    failureReason: l.error,
                                    isPaused: !1,
                                    status: "error"
                                };
                            case "setState":
                                return { ...c,
                                    ...l.state
                                }
                        }
                    })(this.state), U.V.batch(() => {
                        this.observers.forEach(c => {
                            c.onMutationUpdate(l)
                        }), this.mutationCache.notify({
                            mutation: this,
                            type: "updated",
                            action: l
                        })
                    })
                }
            };

            function getDefaultState() {
                return {
                    context: void 0,
                    data: void 0,
                    error: null,
                    failureCount: 0,
                    failureReason: null,
                    isPaused: !1,
                    status: "idle",
                    variables: void 0
                }
            }
        },
        490: function(l, c, x) {
            "use strict";
            x.d(c, {
                X: function() {
                    return MutationObserver
                }
            });
            var N = x(20172),
                U = x(17156),
                Z = x(29492),
                $ = x(46504);
            let MutationObserver = class MutationObserver extends Z.l {
                constructor(l, c) {
                    super(), this.client = l, this.setOptions(c), this.bindMethods(), this.updateResult()
                }
                bindMethods() {
                    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this)
                }
                setOptions(l) {
                    var c;
                    let x = this.options;
                    this.options = this.client.defaultMutationOptions(l), (0, $.VS)(x, this.options) || this.client.getMutationCache().notify({
                        type: "observerOptionsUpdated",
                        mutation: this.currentMutation,
                        observer: this
                    }), null == (c = this.currentMutation) || c.setOptions(this.options)
                }
                onUnsubscribe() {
                    if (!this.hasListeners()) {
                        var l;
                        null == (l = this.currentMutation) || l.removeObserver(this)
                    }
                }
                onMutationUpdate(l) {
                    this.updateResult();
                    let c = {
                        listeners: !0
                    };
                    "success" === l.type ? c.onSuccess = !0 : "error" === l.type && (c.onError = !0), this.notify(c)
                }
                getCurrentResult() {
                    return this.currentResult
                }
                reset() {
                    this.currentMutation = void 0, this.updateResult(), this.notify({
                        listeners: !0
                    })
                }
                mutate(l, c) {
                    return this.mutateOptions = c, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,
                        variables: void 0 !== l ? l : this.options.variables
                    }), this.currentMutation.addObserver(this), this.currentMutation.execute()
                }
                updateResult() {
                    let l = this.currentMutation ? this.currentMutation.state : (0, N.R)(),
                        c = { ...l,
                            isLoading: "loading" === l.status,
                            isSuccess: "success" === l.status,
                            isError: "error" === l.status,
                            isIdle: "idle" === l.status,
                            mutate: this.mutate,
                            reset: this.reset
                        };
                    this.currentResult = c
                }
                notify(l) {
                    U.V.batch(() => {
                        if (this.mutateOptions && this.hasListeners()) {
                            var c, x, N, U, Z, $, Y, q;
                            l.onSuccess ? (null == (c = (x = this.mutateOptions).onSuccess) || c.call(x, this.currentResult.data, this.currentResult.variables, this.currentResult.context), null == (N = (U = this.mutateOptions).onSettled) || N.call(U, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context)) : l.onError && (null == (Z = ($ = this.mutateOptions).onError) || Z.call($, this.currentResult.error, this.currentResult.variables, this.currentResult.context), null == (Y = (q = this.mutateOptions).onSettled) || Y.call(q, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context))
                        }
                        l.listeners && this.listeners.forEach(({
                            listener: l
                        }) => {
                            l(this.currentResult)
                        })
                    })
                }
            }
        },
        17156: function(l, c, x) {
            "use strict";
            x.d(c, {
                V: function() {
                    return U
                }
            });
            var N = x(46504);
            let U = function() {
                let l = [],
                    c = 0,
                    notifyFn = l => {
                        l()
                    },
                    batchNotifyFn = l => {
                        l()
                    },
                    schedule = x => {
                        c ? l.push(x) : (0, N.A4)(() => {
                            notifyFn(x)
                        })
                    },
                    flush = () => {
                        let c = l;
                        l = [], c.length && (0, N.A4)(() => {
                            batchNotifyFn(() => {
                                c.forEach(l => {
                                    notifyFn(l)
                                })
                            })
                        })
                    };
                return {
                    batch: l => {
                        let x;
                        c++;
                        try {
                            x = l()
                        } finally {
                            --c || flush()
                        }
                        return x
                    },
                    batchCalls: l => (...c) => {
                        schedule(() => {
                            l(...c)
                        })
                    },
                    schedule,
                    setNotifyFunction: l => {
                        notifyFn = l
                    },
                    setBatchNotifyFunction: l => {
                        batchNotifyFn = l
                    }
                }
            }()
        },
        23864: function(l, c, x) {
            "use strict";
            x.d(c, {
                N: function() {
                    return $
                }
            });
            var N = x(29492),
                U = x(46504);
            let Z = ["online", "offline"];
            let OnlineManager = class OnlineManager extends N.l {
                constructor() {
                    super(), this.setup = l => {
                        if (!U.sk && window.addEventListener) {
                            let listener = () => l();
                            return Z.forEach(l => {
                                window.addEventListener(l, listener, !1)
                            }), () => {
                                Z.forEach(l => {
                                    window.removeEventListener(l, listener)
                                })
                            }
                        }
                    }
                }
                onSubscribe() {
                    this.cleanup || this.setEventListener(this.setup)
                }
                onUnsubscribe() {
                    if (!this.hasListeners()) {
                        var l;
                        null == (l = this.cleanup) || l.call(this), this.cleanup = void 0
                    }
                }
                setEventListener(l) {
                    var c;
                    this.setup = l, null == (c = this.cleanup) || c.call(this), this.cleanup = l(l => {
                        "boolean" == typeof l ? this.setOnline(l) : this.onOnline()
                    })
                }
                setOnline(l) {
                    let c = this.online !== l;
                    c && (this.online = l, this.onOnline())
                }
                onOnline() {
                    this.listeners.forEach(({
                        listener: l
                    }) => {
                        l()
                    })
                }
                isOnline() {
                    return "boolean" == typeof this.online ? this.online : "undefined" == typeof navigator || void 0 === navigator.onLine || navigator.onLine
                }
            };
            let $ = new OnlineManager
        },
        90127: function(l, c, x) {
            "use strict";
            x.d(c, {
                z: function() {
                    return QueryObserver
                }
            });
            var N = x(46504),
                U = x(17156),
                Z = x(88202),
                $ = x(29492),
                Y = x(43238);
            let QueryObserver = class QueryObserver extends $.l {
                constructor(l, c) {
                    super(), this.client = l, this.options = c, this.trackedProps = new Set, this.selectError = null, this.bindMethods(), this.setOptions(c)
                }
                bindMethods() {
                    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this)
                }
                onSubscribe() {
                    1 === this.listeners.size && (this.currentQuery.addObserver(this), shouldFetchOnMount(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers())
                }
                onUnsubscribe() {
                    this.hasListeners() || this.destroy()
                }
                shouldFetchOnReconnect() {
                    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect)
                }
                shouldFetchOnWindowFocus() {
                    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus)
                }
                destroy() {
                    this.listeners = new Set, this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this)
                }
                setOptions(l, c) {
                    let x = this.options,
                        U = this.currentQuery;
                    if (this.options = this.client.defaultQueryOptions(l), (0, N.VS)(x, this.options) || this.client.getQueryCache().notify({
                            type: "observerOptionsUpdated",
                            query: this.currentQuery,
                            observer: this
                        }), void 0 !== this.options.enabled && "boolean" != typeof this.options.enabled) throw Error("Expected enabled to be a boolean");
                    this.options.queryKey || (this.options.queryKey = x.queryKey), this.updateQuery();
                    let Z = this.hasListeners();
                    Z && shouldFetchOptionally(this.currentQuery, U, this.options, x) && this.executeFetch(), this.updateResult(c), Z && (this.currentQuery !== U || this.options.enabled !== x.enabled || this.options.staleTime !== x.staleTime) && this.updateStaleTimeout();
                    let $ = this.computeRefetchInterval();
                    Z && (this.currentQuery !== U || this.options.enabled !== x.enabled || $ !== this.currentRefetchInterval) && this.updateRefetchInterval($)
                }
                getOptimisticResult(l) {
                    let c = this.client.getQueryCache().build(this.client, l),
                        x = this.createResult(c, l);
                    return l.keepPreviousData || (void 0 !== l.placeholderData ? !x.isPlaceholderData : (0, N.VS)(this.getCurrentResult(), x)) || (this.currentResult = x, this.currentResultOptions = this.options, this.currentResultState = this.currentQuery.state), x
                }
                getCurrentResult() {
                    return this.currentResult
                }
                trackResult(l) {
                    let c = {};
                    return Object.keys(l).forEach(x => {
                        Object.defineProperty(c, x, {
                            configurable: !1,
                            enumerable: !0,
                            get: () => (this.trackedProps.add(x), l[x])
                        })
                    }), c
                }
                getCurrentQuery() {
                    return this.currentQuery
                }
                remove() {
                    this.client.getQueryCache().remove(this.currentQuery)
                }
                refetch({
                    refetchPage: l,
                    ...c
                } = {}) {
                    return this.fetch({ ...c,
                        meta: {
                            refetchPage: l
                        }
                    })
                }
                fetchOptimistic(l) {
                    let c = this.client.defaultQueryOptions(l),
                        x = this.client.getQueryCache().build(this.client, c);
                    return x.isFetchingOptimistic = !0, x.fetch().then(() => this.createResult(x, c))
                }
                fetch(l) {
                    var c;
                    return this.executeFetch({ ...l,
                        cancelRefetch: null == (c = l.cancelRefetch) || c
                    }).then(() => (this.updateResult(), this.currentResult))
                }
                executeFetch(l) {
                    this.updateQuery();
                    let c = this.currentQuery.fetch(this.options, l);
                    return null != l && l.throwOnError || (c = c.catch(N.ZT)), c
                }
                updateStaleTimeout() {
                    if (this.clearStaleTimeout(), N.sk || this.currentResult.isStale || !(0, N.PN)(this.options.staleTime)) return;
                    let l = (0, N.Kp)(this.currentResult.dataUpdatedAt, this.options.staleTime);
                    this.staleTimeoutId = setTimeout(() => {
                        this.currentResult.isStale || this.updateResult()
                    }, l + 1)
                }
                computeRefetchInterval() {
                    var l;
                    return "function" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : null != (l = this.options.refetchInterval) && l
                }
                updateRefetchInterval(l) {
                    this.clearRefetchInterval(), this.currentRefetchInterval = l, !N.sk && !1 !== this.options.enabled && (0, N.PN)(this.currentRefetchInterval) && 0 !== this.currentRefetchInterval && (this.refetchIntervalId = setInterval(() => {
                        (this.options.refetchIntervalInBackground || Z.j.isFocused()) && this.executeFetch()
                    }, this.currentRefetchInterval))
                }
                updateTimers() {
                    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval())
                }
                clearStaleTimeout() {
                    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0)
                }
                clearRefetchInterval() {
                    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0)
                }
                createResult(l, c) {
                    let x;
                    let U = this.currentQuery,
                        Z = this.options,
                        $ = this.currentResult,
                        q = this.currentResultState,
                        J = this.currentResultOptions,
                        X = l !== U,
                        en = X ? l.state : this.currentQueryInitialState,
                        er = X ? this.currentResult : this.previousQueryResult,
                        {
                            state: ea
                        } = l,
                        {
                            dataUpdatedAt: eo,
                            error: el,
                            errorUpdatedAt: ec,
                            fetchStatus: eu,
                            status: ed
                        } = ea,
                        ep = !1,
                        eh = !1;
                    if (c._optimisticResults) {
                        let x = this.hasListeners(),
                            N = !x && shouldFetchOnMount(l, c),
                            $ = x && shouldFetchOptionally(l, U, c, Z);
                        (N || $) && (eu = (0, Y.Kw)(l.options.networkMode) ? "fetching" : "paused", eo || (ed = "loading")), "isRestoring" === c._optimisticResults && (eu = "idle")
                    }
                    if (c.keepPreviousData && !ea.dataUpdatedAt && null != er && er.isSuccess && "error" !== ed) x = er.data, eo = er.dataUpdatedAt, ed = er.status, ep = !0;
                    else if (c.select && void 0 !== ea.data) {
                        if ($ && ea.data === (null == q ? void 0 : q.data) && c.select === this.selectFn) x = this.selectResult;
                        else try {
                            this.selectFn = c.select, x = c.select(ea.data), x = (0, N.oE)(null == $ ? void 0 : $.data, x, c), this.selectResult = x, this.selectError = null
                        } catch (l) {
                            this.selectError = l
                        }
                    } else x = ea.data;
                    if (void 0 !== c.placeholderData && void 0 === x && "loading" === ed) {
                        let l;
                        if (null != $ && $.isPlaceholderData && c.placeholderData === (null == J ? void 0 : J.placeholderData)) l = $.data;
                        else if (l = "function" == typeof c.placeholderData ? c.placeholderData() : c.placeholderData, c.select && void 0 !== l) try {
                            l = c.select(l), this.selectError = null
                        } catch (l) {
                            this.selectError = l
                        }
                        void 0 !== l && (ed = "success", x = (0, N.oE)(null == $ ? void 0 : $.data, l, c), eh = !0)
                    }
                    this.selectError && (el = this.selectError, x = this.selectResult, ec = Date.now(), ed = "error");
                    let ey = "fetching" === eu,
                        ef = "loading" === ed,
                        em = "error" === ed,
                        eg = {
                            status: ed,
                            fetchStatus: eu,
                            isLoading: ef,
                            isSuccess: "success" === ed,
                            isError: em,
                            isInitialLoading: ef && ey,
                            data: x,
                            dataUpdatedAt: eo,
                            error: el,
                            errorUpdatedAt: ec,
                            failureCount: ea.fetchFailureCount,
                            failureReason: ea.fetchFailureReason,
                            errorUpdateCount: ea.errorUpdateCount,
                            isFetched: ea.dataUpdateCount > 0 || ea.errorUpdateCount > 0,
                            isFetchedAfterMount: ea.dataUpdateCount > en.dataUpdateCount || ea.errorUpdateCount > en.errorUpdateCount,
                            isFetching: ey,
                            isRefetching: ey && !ef,
                            isLoadingError: em && 0 === ea.dataUpdatedAt,
                            isPaused: "paused" === eu,
                            isPlaceholderData: eh,
                            isPreviousData: ep,
                            isRefetchError: em && 0 !== ea.dataUpdatedAt,
                            isStale: isStale(l, c),
                            refetch: this.refetch,
                            remove: this.remove
                        };
                    return eg
                }
                updateResult(l) {
                    let c = this.currentResult,
                        x = this.createResult(this.currentQuery, this.options);
                    if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, (0, N.VS)(x, c)) return;
                    this.currentResult = x;
                    let U = {
                        cache: !0
                    };
                    (null == l ? void 0 : l.listeners) !== !1 && (() => {
                        if (!c) return !0;
                        let {
                            notifyOnChangeProps: l
                        } = this.options, x = "function" == typeof l ? l() : l;
                        if ("all" === x || !x && !this.trackedProps.size) return !0;
                        let N = new Set(null != x ? x : this.trackedProps);
                        return this.options.useErrorBoundary && N.add("error"), Object.keys(this.currentResult).some(l => {
                            let x = this.currentResult[l] !== c[l];
                            return x && N.has(l)
                        })
                    })() && (U.listeners = !0), this.notify({ ...U,
                        ...l
                    })
                }
                updateQuery() {
                    let l = this.client.getQueryCache().build(this.client, this.options);
                    if (l === this.currentQuery) return;
                    let c = this.currentQuery;
                    this.currentQuery = l, this.currentQueryInitialState = l.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (null == c || c.removeObserver(this), l.addObserver(this))
                }
                onQueryUpdate(l) {
                    let c = {};
                    "success" === l.type ? c.onSuccess = !l.manual : "error" !== l.type || (0, Y.DV)(l.error) || (c.onError = !0), this.updateResult(c), this.hasListeners() && this.updateTimers()
                }
                notify(l) {
                    U.V.batch(() => {
                        var c, x, N, U, Z, $, Y, q;
                        l.onSuccess ? (null == (c = (x = this.options).onSuccess) || c.call(x, this.currentResult.data), null == (N = (U = this.options).onSettled) || N.call(U, this.currentResult.data, null)) : l.onError && (null == (Z = ($ = this.options).onError) || Z.call($, this.currentResult.error), null == (Y = (q = this.options).onSettled) || Y.call(q, void 0, this.currentResult.error)), l.listeners && this.listeners.forEach(({
                            listener: l
                        }) => {
                            l(this.currentResult)
                        }), l.cache && this.client.getQueryCache().notify({
                            query: this.currentQuery,
                            type: "observerResultsUpdated"
                        })
                    })
                }
            };

            function shouldFetchOnMount(l, c) {
                return !1 !== c.enabled && !l.state.dataUpdatedAt && !("error" === l.state.status && !1 === c.retryOnMount) || l.state.dataUpdatedAt > 0 && shouldFetchOn(l, c, c.refetchOnMount)
            }

            function shouldFetchOn(l, c, x) {
                if (!1 !== c.enabled) {
                    let N = "function" == typeof x ? x(l) : x;
                    return "always" === N || !1 !== N && isStale(l, c)
                }
                return !1
            }

            function shouldFetchOptionally(l, c, x, N) {
                return !1 !== x.enabled && (l !== c || !1 === N.enabled) && (!x.suspense || "error" !== l.state.status) && isStale(l, x)
            }

            function isStale(l, c) {
                return l.isStaleByTime(c.staleTime)
            }
        },
        11909: function(l, c, x) {
            "use strict";
            x.d(c, {
                F: function() {
                    return Removable
                }
            });
            var N = x(46504);
            let Removable = class Removable {
                destroy() {
                    this.clearGcTimeout()
                }
                scheduleGc() {
                    this.clearGcTimeout(), (0, N.PN)(this.cacheTime) && (this.gcTimeout = setTimeout(() => {
                        this.optionalRemove()
                    }, this.cacheTime))
                }
                updateCacheTime(l) {
                    this.cacheTime = Math.max(this.cacheTime || 0, null != l ? l : N.sk ? 1 / 0 : 3e5)
                }
                clearGcTimeout() {
                    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0)
                }
            }
        },
        43238: function(l, c, x) {
            "use strict";
            x.d(c, {
                DV: function() {
                    return isCancelledError
                },
                Kw: function() {
                    return canFetch
                },
                Mz: function() {
                    return createRetryer
                }
            });
            var N = x(88202),
                U = x(23864),
                Z = x(46504);

            function defaultRetryDelay(l) {
                return Math.min(1e3 * 2 ** l, 3e4)
            }

            function canFetch(l) {
                return (null != l ? l : "online") !== "online" || U.N.isOnline()
            }
            let CancelledError = class CancelledError {
                constructor(l) {
                    this.revert = null == l ? void 0 : l.revert, this.silent = null == l ? void 0 : l.silent
                }
            };

            function isCancelledError(l) {
                return l instanceof CancelledError
            }

            function createRetryer(l) {
                let c, x, $, Y = !1,
                    q = 0,
                    J = !1,
                    X = new Promise((l, c) => {
                        x = l, $ = c
                    }),
                    shouldPause = () => !N.j.isFocused() || "always" !== l.networkMode && !U.N.isOnline(),
                    resolve = N => {
                        J || (J = !0, null == l.onSuccess || l.onSuccess(N), null == c || c(), x(N))
                    },
                    reject = x => {
                        J || (J = !0, null == l.onError || l.onError(x), null == c || c(), $(x))
                    },
                    pause = () => new Promise(x => {
                        c = l => {
                            let c = J || !shouldPause();
                            return c && x(l), c
                        }, null == l.onPause || l.onPause()
                    }).then(() => {
                        c = void 0, J || null == l.onContinue || l.onContinue()
                    }),
                    run = () => {
                        let c;
                        if (!J) {
                            try {
                                c = l.fn()
                            } catch (l) {
                                c = Promise.reject(l)
                            }
                            Promise.resolve(c).then(resolve).catch(c => {
                                var x, N;
                                if (J) return;
                                let U = null != (x = l.retry) ? x : 3,
                                    $ = null != (N = l.retryDelay) ? N : defaultRetryDelay,
                                    X = "function" == typeof $ ? $(q, c) : $,
                                    en = !0 === U || "number" == typeof U && q < U || "function" == typeof U && U(q, c);
                                if (Y || !en) {
                                    reject(c);
                                    return
                                }
                                q++, null == l.onFail || l.onFail(q, c), (0, Z.Gh)(X).then(() => {
                                    if (shouldPause()) return pause()
                                }).then(() => {
                                    Y ? reject(c) : run()
                                })
                            })
                        }
                    };
                return canFetch(l.networkMode) ? run() : pause().then(run), {
                    promise: X,
                    cancel: c => {
                        J || (reject(new CancelledError(c)), null == l.abort || l.abort())
                    },
                    continue: () => {
                        let l = null == c ? void 0 : c();
                        return l ? X : Promise.resolve()
                    },
                    cancelRetry: () => {
                        Y = !0
                    },
                    continueRetry: () => {
                        Y = !1
                    }
                }
            }
        },
        29492: function(l, c, x) {
            "use strict";
            x.d(c, {
                l: function() {
                    return Subscribable
                }
            });
            let Subscribable = class Subscribable {
                constructor() {
                    this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
                }
                subscribe(l) {
                    let c = {
                        listener: l
                    };
                    return this.listeners.add(c), this.onSubscribe(), () => {
                        this.listeners.delete(c), this.onUnsubscribe()
                    }
                }
                hasListeners() {
                    return this.listeners.size > 0
                }
                onSubscribe() {}
                onUnsubscribe() {}
            }
        },
        46504: function(l, c, x) {
            "use strict";
            x.d(c, {
                A4: function() {
                    return scheduleMicrotask
                },
                G9: function() {
                    return getAbortController
                },
                Gh: function() {
                    return sleep
                },
                I6: function() {
                    return parseFilterArgs
                },
                Kp: function() {
                    return timeUntilStale
                },
                PN: function() {
                    return isValidTimeout
                },
                Rm: function() {
                    return hashQueryKeyByOptions
                },
                SE: function() {
                    return functionalUpdate
                },
                VS: function() {
                    return shallowEqualObjects
                },
                X7: function() {
                    return matchMutation
                },
                ZT: function() {
                    return noop
                },
                _v: function() {
                    return parseQueryArgs
                },
                _x: function() {
                    return matchQuery
                },
                lV: function() {
                    return parseMutationArgs
                },
                oE: function() {
                    return replaceData
                },
                sk: function() {
                    return N
                },
                to: function() {
                    return partialMatchKey
                },
                yF: function() {
                    return hashQueryKey
                }
            });
            let N = "undefined" == typeof window || "Deno" in window;

            function noop() {}

            function functionalUpdate(l, c) {
                return "function" == typeof l ? l(c) : l
            }

            function isValidTimeout(l) {
                return "number" == typeof l && l >= 0 && l !== 1 / 0
            }

            function timeUntilStale(l, c) {
                return Math.max(l + (c || 0) - Date.now(), 0)
            }

            function parseQueryArgs(l, c, x) {
                return isQueryKey(l) ? "function" == typeof c ? { ...x,
                    queryKey: l,
                    queryFn: c
                } : { ...c,
                    queryKey: l
                } : l
            }

            function parseMutationArgs(l, c, x) {
                return isQueryKey(l) ? "function" == typeof c ? { ...x,
                    mutationKey: l,
                    mutationFn: c
                } : { ...c,
                    mutationKey: l
                } : "function" == typeof l ? { ...c,
                    mutationFn: l
                } : { ...l
                }
            }

            function parseFilterArgs(l, c, x) {
                return isQueryKey(l) ? [{ ...c,
                    queryKey: l
                }, x] : [l || {}, c]
            }

            function matchQuery(l, c) {
                let {
                    type: x = "all",
                    exact: N,
                    fetchStatus: U,
                    predicate: Z,
                    queryKey: $,
                    stale: Y
                } = l;
                if (isQueryKey($)) {
                    if (N) {
                        if (c.queryHash !== hashQueryKeyByOptions($, c.options)) return !1
                    } else {
                        if (!partialDeepEqual(c.queryKey, $)) return !1
                    }
                }
                if ("all" !== x) {
                    let l = c.isActive();
                    if ("active" === x && !l || "inactive" === x && l) return !1
                }
                return ("boolean" != typeof Y || c.isStale() === Y) && (void 0 === U || U === c.state.fetchStatus) && (!Z || !!Z(c))
            }

            function matchMutation(l, c) {
                let {
                    exact: x,
                    fetching: N,
                    predicate: U,
                    mutationKey: Z
                } = l;
                if (isQueryKey(Z)) {
                    if (!c.options.mutationKey) return !1;
                    if (x) {
                        if (hashQueryKey(c.options.mutationKey) !== hashQueryKey(Z)) return !1
                    } else {
                        if (!partialDeepEqual(c.options.mutationKey, Z)) return !1
                    }
                }
                return ("boolean" != typeof N || "loading" === c.state.status === N) && (!U || !!U(c))
            }

            function hashQueryKeyByOptions(l, c) {
                let x = (null == c ? void 0 : c.queryKeyHashFn) || hashQueryKey;
                return x(l)
            }

            function hashQueryKey(l) {
                return JSON.stringify(l, (l, c) => isPlainObject(c) ? Object.keys(c).sort().reduce((l, x) => (l[x] = c[x], l), {}) : c)
            }

            function partialMatchKey(l, c) {
                return partialDeepEqual(l, c)
            }

            function partialDeepEqual(l, c) {
                return l === c || typeof l == typeof c && !!l && !!c && "object" == typeof l && "object" == typeof c && !Object.keys(c).some(x => !partialDeepEqual(l[x], c[x]))
            }

            function shallowEqualObjects(l, c) {
                if (l && !c || c && !l) return !1;
                for (let x in l)
                    if (l[x] !== c[x]) return !1;
                return !0
            }

            function isPlainArray(l) {
                return Array.isArray(l) && l.length === Object.keys(l).length
            }

            function isPlainObject(l) {
                if (!hasObjectPrototype(l)) return !1;
                let c = l.constructor;
                if (void 0 === c) return !0;
                let x = c.prototype;
                return !!(hasObjectPrototype(x) && x.hasOwnProperty("isPrototypeOf"))
            }

            function hasObjectPrototype(l) {
                return "[object Object]" === Object.prototype.toString.call(l)
            }

            function isQueryKey(l) {
                return Array.isArray(l)
            }

            function sleep(l) {
                return new Promise(c => {
                    setTimeout(c, l)
                })
            }

            function scheduleMicrotask(l) {
                sleep(0).then(l)
            }

            function getAbortController() {
                if ("function" == typeof AbortController) return new AbortController
            }

            function replaceData(l, c, x) {
                return null != x.isDataEqual && x.isDataEqual(l, c) ? l : "function" == typeof x.structuralSharing ? x.structuralSharing(l, c) : !1 !== x.structuralSharing ? function replaceEqualDeep(l, c) {
                    if (l === c) return l;
                    let x = isPlainArray(l) && isPlainArray(c);
                    if (x || isPlainObject(l) && isPlainObject(c)) {
                        let N = x ? l.length : Object.keys(l).length,
                            U = x ? c : Object.keys(c),
                            Z = U.length,
                            $ = x ? [] : {},
                            Y = 0;
                        for (let N = 0; N < Z; N++) {
                            let Z = x ? N : U[N];
                            $[Z] = replaceEqualDeep(l[Z], c[Z]), $[Z] === l[Z] && Y++
                        }
                        return N === Z && Y === N ? l : $
                    }
                    return c
                }(l, c) : c
            }
        },
        5060: function(l, c, x) {
            "use strict";
            x.d(c, {
                NL: function() {
                    return useQueryClient
                },
                aH: function() {
                    return QueryClientProvider
                }
            });
            var N = x(2265);
            let U = N.createContext(void 0),
                Z = N.createContext(!1);

            function getQueryClientContext(l, c) {
                return l || (c && "undefined" != typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = U), window.ReactQueryClientContext) : U)
            }
            let useQueryClient = ({
                    context: l
                } = {}) => {
                    let c = N.useContext(getQueryClientContext(l, N.useContext(Z)));
                    if (!c) throw Error("No QueryClient set, use QueryClientProvider to set one");
                    return c
                },
                QueryClientProvider = ({
                    client: l,
                    children: c,
                    context: x,
                    contextSharing: U = !1
                }) => {
                    N.useEffect(() => (l.mount(), () => {
                        l.unmount()
                    }), [l]);
                    let $ = getQueryClientContext(x, U);
                    return N.createElement(Z.Provider, {
                        value: !x && U
                    }, N.createElement($.Provider, {
                        value: l
                    }, c))
                }
        },
        43979: function(l, c, x) {
            "use strict";
            x.d(c, {
                D: function() {
                    return useMutation
                }
            });
            var N = x(2265),
                U = x(46504),
                Z = x(490),
                $ = x(17156),
                Y = x(97004),
                q = x(5060),
                J = x(20447);

            function useMutation(l, c, x) {
                let X = (0, U.lV)(l, c, x),
                    en = (0, q.NL)({
                        context: X.context
                    }),
                    [er] = N.useState(() => new Z.X(en, X));
                N.useEffect(() => {
                    er.setOptions(X)
                }, [er, X]);
                let ea = (0, Y.$)(N.useCallback(l => er.subscribe($.V.batchCalls(l)), [er]), () => er.getCurrentResult(), () => er.getCurrentResult()),
                    eo = N.useCallback((l, c) => {
                        er.mutate(l, c).catch(noop)
                    }, [er]);
                if (ea.error && (0, J.L)(er.options.useErrorBoundary, [ea.error])) throw ea.error;
                return { ...ea,
                    mutate: eo,
                    mutateAsync: ea.mutate
                }
            }

            function noop() {}
        },
        66328: function(l, c, x) {
            "use strict";
            let N;
            x.d(c, {
                a: function() {
                    return useQuery
                }
            });
            var U = x(46504),
                Z = x(90127),
                $ = x(2265),
                Y = x(17156),
                q = x(97004);
            let J = $.createContext((N = !1, {
                    clearReset: () => {
                        N = !1
                    },
                    reset: () => {
                        N = !0
                    },
                    isReset: () => N
                })),
                useQueryErrorResetBoundary = () => $.useContext(J);
            var X = x(5060);
            let en = $.createContext(!1),
                useIsRestoring = () => $.useContext(en);
            en.Provider;
            var er = x(20447);
            let ensurePreventErrorBoundaryRetry = (l, c) => {
                    (l.suspense || l.useErrorBoundary) && !c.isReset() && (l.retryOnMount = !1)
                },
                useClearResetErrorBoundary = l => {
                    $.useEffect(() => {
                        l.clearReset()
                    }, [l])
                },
                getHasError = ({
                    result: l,
                    errorResetBoundary: c,
                    useErrorBoundary: x,
                    query: N
                }) => l.isError && !c.isReset() && !l.isFetching && (0, er.L)(x, [l.error, N]),
                ensureStaleTime = l => {
                    l.suspense && "number" != typeof l.staleTime && (l.staleTime = 1e3)
                },
                willFetch = (l, c) => l.isLoading && l.isFetching && !c,
                shouldSuspend = (l, c, x) => (null == l ? void 0 : l.suspense) && willFetch(c, x),
                fetchOptimistic = (l, c, x) => c.fetchOptimistic(l).then(({
                    data: c
                }) => {
                    null == l.onSuccess || l.onSuccess(c), null == l.onSettled || l.onSettled(c, null)
                }).catch(c => {
                    x.clearReset(), null == l.onError || l.onError(c), null == l.onSettled || l.onSettled(void 0, c)
                });

            function useQuery(l, c, x) {
                let N = (0, U._v)(l, c, x);
                return function(l, c) {
                    let x = (0, X.NL)({
                            context: l.context
                        }),
                        N = useIsRestoring(),
                        U = useQueryErrorResetBoundary(),
                        Z = x.defaultQueryOptions(l);
                    Z._optimisticResults = N ? "isRestoring" : "optimistic", Z.onError && (Z.onError = Y.V.batchCalls(Z.onError)), Z.onSuccess && (Z.onSuccess = Y.V.batchCalls(Z.onSuccess)), Z.onSettled && (Z.onSettled = Y.V.batchCalls(Z.onSettled)), ensureStaleTime(Z), ensurePreventErrorBoundaryRetry(Z, U), useClearResetErrorBoundary(U);
                    let [J] = $.useState(() => new c(x, Z)), en = J.getOptimisticResult(Z);
                    if ((0, q.$)($.useCallback(l => {
                            let c = N ? () => void 0 : J.subscribe(Y.V.batchCalls(l));
                            return J.updateResult(), c
                        }, [J, N]), () => J.getCurrentResult(), () => J.getCurrentResult()), $.useEffect(() => {
                            J.setOptions(Z, {
                                listeners: !1
                            })
                        }, [Z, J]), shouldSuspend(Z, en, N)) throw fetchOptimistic(Z, J, U);
                    if (getHasError({
                            result: en,
                            errorResetBoundary: U,
                            useErrorBoundary: Z.useErrorBoundary,
                            query: J.getCurrentQuery()
                        })) throw en.error;
                    return Z.notifyOnChangeProps ? en : J.trackResult(en)
                }(N, Z.z)
            }
        },
        97004: function(l, c, x) {
            "use strict";
            x.d(c, {
                $: function() {
                    return U
                }
            });
            var N = x(26272);
            let U = N.useSyncExternalStore
        },
        20447: function(l, c, x) {
            "use strict";

            function shouldThrowError(l, c) {
                return "function" == typeof l ? l(...c) : !!l
            }
            x.d(c, {
                L: function() {
                    return shouldThrowError
                }
            })
        },
        62367: function(l, c, x) {
            "use strict";
            x.d(c, {
                NL: function() {
                    return useQueryClient
                }
            });
            var N = x(2265);
            let U = N.createContext(void 0),
                Z = N.createContext(!1),
                useQueryClient = ({
                    context: l
                } = {}) => {
                    var c;
                    let x = N.useContext((c = N.useContext(Z), l || (c && "undefined" != typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = U), window.ReactQueryClientContext) : U)));
                    if (!x) throw Error("No QueryClient set, use QueryClientProvider to set one");
                    return x
                }
        },
        59641: function(l, c, x) {
            "use strict";
            x.d(c, {
                D: function() {
                    return useMutation
                }
            });
            var N = x(2265),
                U = x(46504),
                Z = x(490),
                $ = x(17156),
                Y = x(20026),
                q = x(62367),
                J = x(14904);

            function useMutation(l, c, x) {
                let X = (0, U.lV)(l, c, x),
                    en = (0, q.NL)({
                        context: X.context
                    }),
                    [er] = N.useState(() => new Z.X(en, X));
                N.useEffect(() => {
                    er.setOptions(X)
                }, [er, X]);
                let ea = (0, Y.$)(N.useCallback(l => er.subscribe($.V.batchCalls(l)), [er]), () => er.getCurrentResult(), () => er.getCurrentResult()),
                    eo = N.useCallback((l, c) => {
                        er.mutate(l, c).catch(noop)
                    }, [er]);
                if (ea.error && (0, J.L)(er.options.useErrorBoundary, [ea.error])) throw ea.error;
                return { ...ea,
                    mutate: eo,
                    mutateAsync: ea.mutate
                }
            }

            function noop() {}
        },
        91809: function(l, c, x) {
            "use strict";
            let N;
            x.d(c, {
                a: function() {
                    return useQuery
                }
            });
            var U = x(46504),
                Z = x(90127),
                $ = x(2265),
                Y = x(17156),
                q = x(20026);
            let J = $.createContext((N = !1, {
                    clearReset: () => {
                        N = !1
                    },
                    reset: () => {
                        N = !0
                    },
                    isReset: () => N
                })),
                useQueryErrorResetBoundary = () => $.useContext(J);
            var X = x(62367);
            let en = $.createContext(!1),
                useIsRestoring = () => $.useContext(en);
            en.Provider;
            var er = x(14904);
            let ensurePreventErrorBoundaryRetry = (l, c) => {
                    (l.suspense || l.useErrorBoundary) && !c.isReset() && (l.retryOnMount = !1)
                },
                useClearResetErrorBoundary = l => {
                    $.useEffect(() => {
                        l.clearReset()
                    }, [l])
                },
                getHasError = ({
                    result: l,
                    errorResetBoundary: c,
                    useErrorBoundary: x,
                    query: N
                }) => l.isError && !c.isReset() && !l.isFetching && (0, er.L)(x, [l.error, N]),
                ensureStaleTime = l => {
                    l.suspense && "number" != typeof l.staleTime && (l.staleTime = 1e3)
                },
                willFetch = (l, c) => l.isLoading && l.isFetching && !c,
                shouldSuspend = (l, c, x) => (null == l ? void 0 : l.suspense) && willFetch(c, x),
                fetchOptimistic = (l, c, x) => c.fetchOptimistic(l).then(({
                    data: c
                }) => {
                    null == l.onSuccess || l.onSuccess(c), null == l.onSettled || l.onSettled(c, null)
                }).catch(c => {
                    x.clearReset(), null == l.onError || l.onError(c), null == l.onSettled || l.onSettled(void 0, c)
                });

            function useQuery(l, c, x) {
                let N = (0, U._v)(l, c, x);
                return function(l, c) {
                    let x = (0, X.NL)({
                            context: l.context
                        }),
                        N = useIsRestoring(),
                        U = useQueryErrorResetBoundary(),
                        Z = x.defaultQueryOptions(l);
                    Z._optimisticResults = N ? "isRestoring" : "optimistic", Z.onError && (Z.onError = Y.V.batchCalls(Z.onError)), Z.onSuccess && (Z.onSuccess = Y.V.batchCalls(Z.onSuccess)), Z.onSettled && (Z.onSettled = Y.V.batchCalls(Z.onSettled)), ensureStaleTime(Z), ensurePreventErrorBoundaryRetry(Z, U), useClearResetErrorBoundary(U);
                    let [J] = $.useState(() => new c(x, Z)), en = J.getOptimisticResult(Z);
                    if ((0, q.$)($.useCallback(l => {
                            let c = N ? () => void 0 : J.subscribe(Y.V.batchCalls(l));
                            return J.updateResult(), c
                        }, [J, N]), () => J.getCurrentResult(), () => J.getCurrentResult()), $.useEffect(() => {
                            J.setOptions(Z, {
                                listeners: !1
                            })
                        }, [Z, J]), shouldSuspend(Z, en, N)) throw fetchOptimistic(Z, J, U);
                    if (getHasError({
                            result: en,
                            errorResetBoundary: U,
                            useErrorBoundary: Z.useErrorBoundary,
                            query: J.getCurrentQuery()
                        })) throw en.error;
                    return Z.notifyOnChangeProps ? en : J.trackResult(en)
                }(N, Z.z)
            }
        },
        20026: function(l, c, x) {
            "use strict";
            x.d(c, {
                $: function() {
                    return U
                }
            });
            var N = x(26272);
            let U = N.useSyncExternalStore
        },
        14904: function(l, c, x) {
            "use strict";

            function shouldThrowError(l, c) {
                return "function" == typeof l ? l(...c) : !!l
            }
            x.d(c, {
                L: function() {
                    return shouldThrowError
                }
            })
        },
        11953: function(l, c, x) {
            "use strict";
            var N = x(28729);
            c.Z = N
        },
        44035: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                CID: function() {
                    return CID
                },
                bases: function() {
                    return e3
                },
                bytes: function() {
                    return N
                },
                codecs: function() {
                    return e8
                },
                digest: function() {
                    return el
                },
                hasher: function() {
                    return ec
                },
                hashes: function() {
                    return e6
                },
                varint: function() {
                    return eo
                }
            });
            var N = {};
            x.r(N), x.d(N, {
                coerce: function() {
                    return coerce
                },
                empty: function() {
                    return ey
                },
                equals: function() {
                    return equals
                },
                fromHex: function() {
                    return fromHex
                },
                fromString: function() {
                    return fromString
                },
                isBinary: function() {
                    return isBinary
                },
                toHex: function() {
                    return toHex
                },
                toString: function() {
                    return bytes_toString
                }
            });
            var U = {};
            x.r(U), x.d(U, {
                identity: function() {
                    return ef
                }
            });
            var Z = {};
            x.r(Z), x.d(Z, {
                base2: function() {
                    return em
                }
            });
            var $ = {};
            x.r($), x.d($, {
                base8: function() {
                    return eg
                }
            });
            var Y = {};
            x.r(Y), x.d(Y, {
                base10: function() {
                    return eb
                }
            });
            var q = {};
            x.r(q), x.d(q, {
                base16: function() {
                    return ev
                },
                base16upper: function() {
                    return ew
                }
            });
            var J = {};
            x.r(J), x.d(J, {
                base32: function() {
                    return eT
                },
                base32hex: function() {
                    return eC
                },
                base32hexpad: function() {
                    return eD
                },
                base32hexpadupper: function() {
                    return eS
                },
                base32hexupper: function() {
                    return e_
                },
                base32pad: function() {
                    return eI
                },
                base32padupper: function() {
                    return ex
                },
                base32upper: function() {
                    return eM
                },
                base32z: function() {
                    return ek
                }
            });
            var X = {};
            x.r(X), x.d(X, {
                base36: function() {
                    return eE
                },
                base36upper: function() {
                    return eN
                }
            });
            var en = {};
            x.r(en), x.d(en, {
                base58btc: function() {
                    return eA
                },
                base58flickr: function() {
                    return ej
                }
            });
            var er = {};
            x.r(er), x.d(er, {
                base64: function() {
                    return eO
                },
                base64pad: function() {
                    return eP
                },
                base64url: function() {
                    return ez
                },
                base64urlpad: function() {
                    return eR
                }
            });
            var ea = {};
            x.r(ea), x.d(ea, {
                base256emoji: function() {
                    return eF
                }
            });
            var eo = {};
            x.r(eo), x.d(eo, {
                decode: function() {
                    return src_varint_decode
                },
                encodeTo: function() {
                    return encodeTo
                },
                encodingLength: function() {
                    return encodingLength
                }
            });
            var el = {};
            x.r(el), x.d(el, {
                Digest: function() {
                    return Digest
                },
                create: function() {
                    return create
                },
                decode: function() {
                    return digest_decode
                },
                equals: function() {
                    return digest_equals
                }
            });
            var ec = {};
            x.r(ec), x.d(ec, {
                Hasher: function() {
                    return Hasher
                },
                from: function() {
                    return hasher_from
                }
            });
            var eu = {};
            x.r(eu), x.d(eu, {
                sha256: function() {
                    return eZ
                },
                sha512: function() {
                    return eQ
                }
            });
            var ed = {};
            x.r(ed), x.d(ed, {
                identity: function() {
                    return eH
                }
            });
            var ep = {};
            x.r(ep), x.d(ep, {
                code: function() {
                    return eY
                },
                decode: function() {
                    return raw_decode
                },
                encode: function() {
                    return raw_encode
                },
                name: function() {
                    return e$
                }
            });
            var eh = {};
            x.r(eh), x.d(eh, {
                code: function() {
                    return eJ
                },
                decode: function() {
                    return json_decode
                },
                encode: function() {
                    return json_encode
                },
                name: function() {
                    return eK
                }
            });
            var base_x = function(l, c) {
                if (l.length >= 255) throw TypeError("Alphabet too long");
                for (var x = new Uint8Array(256), N = 0; N < x.length; N++) x[N] = 255;
                for (var U = 0; U < l.length; U++) {
                    var Z = l.charAt(U),
                        $ = Z.charCodeAt(0);
                    if (255 !== x[$]) throw TypeError(Z + " is ambiguous");
                    x[$] = U
                }
                var Y = l.length,
                    q = l.charAt(0),
                    J = Math.log(Y) / Math.log(256),
                    X = Math.log(256) / Math.log(Y);

                function decodeUnsafe(l) {
                    if ("string" != typeof l) throw TypeError("Expected String");
                    if (0 === l.length) return new Uint8Array;
                    var c = 0;
                    if (" " !== l[0]) {
                        for (var N = 0, U = 0; l[c] === q;) N++, c++;
                        for (var Z = (l.length - c) * J + 1 >>> 0, $ = new Uint8Array(Z); l[c];) {
                            var X = x[l.charCodeAt(c)];
                            if (255 === X) return;
                            for (var en = 0, er = Z - 1;
                                (0 !== X || en < U) && -1 !== er; er--, en++) X += Y * $[er] >>> 0, $[er] = X % 256 >>> 0, X = X / 256 >>> 0;
                            if (0 !== X) throw Error("Non-zero carry");
                            U = en, c++
                        }
                        if (" " !== l[c]) {
                            for (var ea = Z - U; ea !== Z && 0 === $[ea];) ea++;
                            for (var eo = new Uint8Array(N + (Z - ea)), el = N; ea !== Z;) eo[el++] = $[ea++];
                            return eo
                        }
                    }
                }
                return {
                    encode: function(c) {
                        if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                        if (0 === c.length) return "";
                        for (var x = 0, N = 0, U = 0, Z = c.length; U !== Z && 0 === c[U];) U++, x++;
                        for (var $ = (Z - U) * X + 1 >>> 0, J = new Uint8Array($); U !== Z;) {
                            for (var en = c[U], er = 0, ea = $ - 1;
                                (0 !== en || er < N) && -1 !== ea; ea--, er++) en += 256 * J[ea] >>> 0, J[ea] = en % Y >>> 0, en = en / Y >>> 0;
                            if (0 !== en) throw Error("Non-zero carry");
                            N = er, U++
                        }
                        for (var eo = $ - N; eo !== $ && 0 === J[eo];) eo++;
                        for (var el = q.repeat(x); eo < $; ++eo) el += l.charAt(J[eo]);
                        return el
                    },
                    decodeUnsafe: decodeUnsafe,
                    decode: function(l) {
                        var x = decodeUnsafe(l);
                        if (x) return x;
                        throw Error(`Non-${c} character`)
                    }
                }
            };
            let ey = new Uint8Array(0),
                toHex = l => l.reduce((l, c) => l + c.toString(16).padStart(2, "0"), ""),
                fromHex = l => {
                    let c = l.match(/../g);
                    return c ? new Uint8Array(c.map(l => parseInt(l, 16))) : ey
                },
                equals = (l, c) => {
                    if (l === c) return !0;
                    if (l.byteLength !== c.byteLength) return !1;
                    for (let x = 0; x < l.byteLength; x++)
                        if (l[x] !== c[x]) return !1;
                    return !0
                },
                coerce = l => {
                    if (l instanceof Uint8Array && "Uint8Array" === l.constructor.name) return l;
                    if (l instanceof ArrayBuffer) return new Uint8Array(l);
                    if (ArrayBuffer.isView(l)) return new Uint8Array(l.buffer, l.byteOffset, l.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                isBinary = l => l instanceof ArrayBuffer || ArrayBuffer.isView(l),
                fromString = l => new TextEncoder().encode(l),
                bytes_toString = l => new TextDecoder().decode(l);
            let Encoder = class Encoder {
                constructor(l, c, x) {
                    this.name = l, this.prefix = c, this.baseEncode = x
                }
                encode(l) {
                    if (l instanceof Uint8Array) return `${this.prefix}${this.baseEncode(l)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let Decoder = class Decoder {
                constructor(l, c, x) {
                    if (this.name = l, this.prefix = c, void 0 === c.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = x
                }
                decode(l) {
                    if ("string" == typeof l) {
                        if (l.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(l)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(l.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(l) {
                    return or(this, l)
                }
            };
            let ComposedDecoder = class ComposedDecoder {
                constructor(l) {
                    this.decoders = l
                }
                or(l) {
                    return or(this, l)
                }
                decode(l) {
                    let c = l[0],
                        x = this.decoders[c];
                    if (x) return x.decode(l);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(l)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let or = (l, c) => new ComposedDecoder({ ...l.decoders || {
                    [l.prefix]: l
                },
                ...c.decoders || {
                    [c.prefix]: c
                }
            });
            let Codec = class Codec {
                constructor(l, c, x, N) {
                    this.name = l, this.prefix = c, this.baseEncode = x, this.baseDecode = N, this.encoder = new Encoder(l, c, x), this.decoder = new Decoder(l, c, N)
                }
                encode(l) {
                    return this.encoder.encode(l)
                }
                decode(l) {
                    return this.decoder.decode(l)
                }
            };
            let from = ({
                    name: l,
                    prefix: c,
                    encode: x,
                    decode: N
                }) => new Codec(l, c, x, N),
                baseX = ({
                    prefix: l,
                    name: c,
                    alphabet: x
                }) => {
                    let {
                        encode: N,
                        decode: U
                    } = base_x(x, c);
                    return from({
                        prefix: l,
                        name: c,
                        encode: N,
                        decode: l => coerce(U(l))
                    })
                },
                decode = (l, c, x, N) => {
                    let U = {};
                    for (let l = 0; l < c.length; ++l) U[c[l]] = l;
                    let Z = l.length;
                    for (;
                        "=" === l[Z - 1];) --Z;
                    let $ = new Uint8Array(Z * x / 8 | 0),
                        Y = 0,
                        q = 0,
                        J = 0;
                    for (let c = 0; c < Z; ++c) {
                        let Z = U[l[c]];
                        if (void 0 === Z) throw SyntaxError(`Non-${N} character`);
                        q = q << x | Z, (Y += x) >= 8 && (Y -= 8, $[J++] = 255 & q >> Y)
                    }
                    if (Y >= x || 255 & q << 8 - Y) throw SyntaxError("Unexpected end of data");
                    return $
                },
                encode = (l, c, x) => {
                    let N = "=" === c[c.length - 1],
                        U = (1 << x) - 1,
                        Z = "",
                        $ = 0,
                        Y = 0;
                    for (let N = 0; N < l.length; ++N)
                        for (Y = Y << 8 | l[N], $ += 8; $ > x;) $ -= x, Z += c[U & Y >> $];
                    if ($ && (Z += c[U & Y << x - $]), N)
                        for (; Z.length * x & 7;) Z += "=";
                    return Z
                },
                rfc4648 = ({
                    name: l,
                    prefix: c,
                    bitsPerChar: x,
                    alphabet: N
                }) => from({
                    prefix: c,
                    name: l,
                    encode: l => encode(l, N, x),
                    decode: c => decode(c, N, x, l)
                }),
                ef = from({
                    prefix: "\x00",
                    name: "identity",
                    encode: l => bytes_toString(l),
                    decode: l => fromString(l)
                }),
                em = rfc4648({
                    prefix: "0",
                    name: "base2",
                    alphabet: "01",
                    bitsPerChar: 1
                }),
                eg = rfc4648({
                    prefix: "7",
                    name: "base8",
                    alphabet: "01234567",
                    bitsPerChar: 3
                }),
                eb = baseX({
                    prefix: "9",
                    name: "base10",
                    alphabet: "0123456789"
                }),
                ev = rfc4648({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                ew = rfc4648({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                }),
                eT = rfc4648({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                eM = rfc4648({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                eI = rfc4648({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                ex = rfc4648({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                eC = rfc4648({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                e_ = rfc4648({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                eD = rfc4648({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                eS = rfc4648({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                ek = rfc4648({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                }),
                eE = baseX({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                eN = baseX({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                }),
                eA = baseX({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                ej = baseX({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                }),
                eO = rfc4648({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                eP = rfc4648({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                ez = rfc4648({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                eR = rfc4648({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                }),
                eL = Array.from("\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                eB = eL.reduce((l, c, x) => (l[x] = c, l), []),
                eU = eL.reduce((l, c, x) => (l[c.codePointAt(0)] = x, l), []),
                eF = from({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(l) {
                        return l.reduce((l, c) => l += eB[c], "")
                    },
                    decode: function(l) {
                        let c = [];
                        for (let x of l) {
                            let l = eU[x.codePointAt(0)];
                            if (void 0 === l) throw Error(`Non-base256emoji character: ${x}`);
                            c.push(l)
                        }
                        return new Uint8Array(c)
                    }
                });

            function varint_encode(l, c, x) {
                c = c || [];
                for (var N = x = x || 0; l >= 2147483648;) c[x++] = 255 & l | 128, l /= 128;
                for (; - 128 & l;) c[x++] = 255 & l | 128, l >>>= 7;
                return c[x] = 0 | l, varint_encode.bytes = x - N + 1, c
            }

            function read(l, c) {
                var x, N = 0,
                    c = c || 0,
                    U = 0,
                    Z = c,
                    $ = l.length;
                do {
                    if (Z >= $) throw read.bytes = 0, RangeError("Could not decode varint");
                    x = l[Z++], N += U < 28 ? (127 & x) << U : (127 & x) * Math.pow(2, U), U += 7
                } while (x >= 128);
                return read.bytes = Z - c, N
            }
            var eW = {
                encode: varint_encode,
                decode: read,
                encodingLength: function(l) {
                    return l < 128 ? 1 : l < 16384 ? 2 : l < 2097152 ? 3 : l < 268435456 ? 4 : l < 34359738368 ? 5 : l < 4398046511104 ? 6 : l < 562949953421312 ? 7 : l < 72057594037927940 ? 8 : l < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let src_varint_decode = (l, c = 0) => {
                    let x = eW.decode(l, c);
                    return [x, eW.decode.bytes]
                },
                encodeTo = (l, c, x = 0) => (eW.encode(l, c, x), c),
                encodingLength = l => eW.encodingLength(l),
                create = (l, c) => {
                    let x = c.byteLength,
                        N = encodingLength(l),
                        U = N + encodingLength(x),
                        Z = new Uint8Array(U + x);
                    return encodeTo(l, Z, 0), encodeTo(x, Z, N), Z.set(c, U), new Digest(l, x, c, Z)
                },
                digest_decode = l => {
                    let c = coerce(l),
                        [x, N] = src_varint_decode(c),
                        [U, Z] = src_varint_decode(c.subarray(N)),
                        $ = c.subarray(N + Z);
                    if ($.byteLength !== U) throw Error("Incorrect length");
                    return new Digest(x, U, $, c)
                },
                digest_equals = (l, c) => l === c || l.code === c.code && l.size === c.size && equals(l.bytes, c.bytes);
            let Digest = class Digest {
                constructor(l, c, x, N) {
                    this.code = l, this.size = c, this.digest = x, this.bytes = N
                }
            };
            let hasher_from = ({
                name: l,
                code: c,
                encode: x
            }) => new Hasher(l, c, x);
            let Hasher = class Hasher {
                constructor(l, c, x) {
                    this.name = l, this.code = c, this.encode = x
                }
                digest(l) {
                    if (l instanceof Uint8Array) {
                        let c = this.encode(l);
                        return c instanceof Uint8Array ? create(this.code, c) : c.then(l => create(this.code, l))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let sha = l => async c => new Uint8Array(await crypto.subtle.digest(l, c)),
                eZ = hasher_from({
                    name: "sha2-256",
                    code: 18,
                    encode: sha("SHA-256")
                }),
                eQ = hasher_from({
                    name: "sha2-512",
                    code: 19,
                    encode: sha("SHA-512")
                }),
                eH = {
                    code: 0,
                    name: "identity",
                    encode: coerce,
                    digest: l => create(0, coerce(l))
                },
                e$ = "raw",
                eY = 85,
                raw_encode = l => coerce(l),
                raw_decode = l => coerce(l),
                eG = new TextEncoder,
                eV = new TextDecoder,
                eK = "json",
                eJ = 512,
                json_encode = l => eG.encode(JSON.stringify(l)),
                json_decode = l => JSON.parse(eV.decode(l));
            let CID = class CID {
                constructor(l, c, x, N) {
                    this.code = c, this.version = l, this.multihash = x, this.bytes = N, this.byteOffset = N.byteOffset, this.byteLength = N.byteLength, this.asCID = this, this._baseCache = new Map, Object.defineProperties(this, {
                        byteOffset: e5,
                        byteLength: e5,
                        code: e1,
                        version: e1,
                        multihash: e1,
                        bytes: e1,
                        _baseCache: e5,
                        asCID: e5
                    })
                }
                toV0() {
                    if (0 === this.version) return this; {
                        let {
                            code: l,
                            multihash: c
                        } = this;
                        if (l !== eX) throw Error("Cannot convert a non dag-pb CID to CIDv0");
                        if (c.code !== e0) throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                        return CID.createV0(c)
                    }
                }
                toV1() {
                    switch (this.version) {
                        case 0:
                            {
                                let {
                                    code: l,
                                    digest: c
                                } = this.multihash,
                                x = create(l, c);
                                return CID.createV1(this.code, x)
                            }
                        case 1:
                            return this;
                        default:
                            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
                    }
                }
                equals(l) {
                    return l && this.code === l.code && this.version === l.version && digest_equals(this.multihash, l.multihash)
                }
                toString(l) {
                    let {
                        bytes: c,
                        version: x,
                        _baseCache: N
                    } = this;
                    return 0 === x ? toStringV0(c, N, l || eA.encoder) : toStringV1(c, N, l || eT.encoder)
                }
                toJSON() {
                    return {
                        code: this.code,
                        version: this.version,
                        hash: this.multihash.bytes
                    }
                }
                get[Symbol.toStringTag]() {
                    return "CID"
                }[Symbol.for("nodejs.util.inspect.custom")]() {
                    return "CID(" + this.toString() + ")"
                }
                static isCID(l) {
                    return deprecate(/^0\.0/, e4), !!(l && (l[e2] || l.asCID === l))
                }
                get toBaseEncodedString() {
                    throw Error("Deprecated, use .toString()")
                }
                get codec() {
                    throw Error('"codec" property is deprecated, use integer "code" property instead')
                }
                get buffer() {
                    throw Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")
                }
                get multibaseName() {
                    throw Error('"multibaseName" property is deprecated')
                }
                get prefix() {
                    throw Error('"prefix" property is deprecated')
                }
                static asCID(l) {
                    if (l instanceof CID) return l;
                    if (null != l && l.asCID === l) {
                        let {
                            version: c,
                            code: x,
                            multihash: N,
                            bytes: U
                        } = l;
                        return new CID(c, x, N, U || encodeCID(c, x, N.bytes))
                    }
                    if (null == l || !0 !== l[e2]) return null; {
                        let {
                            version: c,
                            multihash: x,
                            code: N
                        } = l, U = digest_decode(x);
                        return CID.create(c, N, U)
                    }
                }
                static create(l, c, x) {
                    if ("number" != typeof c) throw Error("String codecs are no longer supported");
                    switch (l) {
                        case 0:
                            if (c === eX) return new CID(l, c, x, x.bytes);
                            throw Error(`Version 0 CID must use dag-pb (code: ${eX}) block encoding`);
                        case 1:
                            {
                                let N = encodeCID(l, c, x.bytes);
                                return new CID(l, c, x, N)
                            }
                        default:
                            throw Error("Invalid version")
                    }
                }
                static createV0(l) {
                    return CID.create(0, eX, l)
                }
                static createV1(l, c) {
                    return CID.create(1, l, c)
                }
                static decode(l) {
                    let [c, x] = CID.decodeFirst(l);
                    if (x.length) throw Error("Incorrect length");
                    return c
                }
                static decodeFirst(l) {
                    let c = CID.inspectBytes(l),
                        x = c.size - c.multihashSize,
                        N = coerce(l.subarray(x, x + c.multihashSize));
                    if (N.byteLength !== c.multihashSize) throw Error("Incorrect length");
                    let U = N.subarray(c.multihashSize - c.digestSize),
                        Z = new Digest(c.multihashCode, c.digestSize, U, N),
                        $ = 0 === c.version ? CID.createV0(Z) : CID.createV1(c.codec, Z);
                    return [$, l.subarray(c.size)]
                }
                static inspectBytes(l) {
                    let c = 0,
                        next = () => {
                            let [x, N] = src_varint_decode(l.subarray(c));
                            return c += N, x
                        },
                        x = next(),
                        N = eX;
                    if (18 === x ? (x = 0, c = 0) : 1 === x && (N = next()), 0 !== x && 1 !== x) throw RangeError(`Invalid CID version ${x}`);
                    let U = c,
                        Z = next(),
                        $ = next(),
                        Y = c + $;
                    return {
                        version: x,
                        codec: N,
                        multihashCode: Z,
                        digestSize: $,
                        multihashSize: Y - U,
                        size: Y
                    }
                }
                static parse(l, c) {
                    let [x, N] = parseCIDtoBytes(l, c), U = CID.decode(N);
                    return U._baseCache.set(x, l), U
                }
            };
            let parseCIDtoBytes = (l, c) => {
                    switch (l[0]) {
                        case "Q":
                            return [eA.prefix, (c || eA).decode(`${eA.prefix}${l}`)];
                        case eA.prefix:
                            return [eA.prefix, (c || eA).decode(l)];
                        case eT.prefix:
                            return [eT.prefix, (c || eT).decode(l)];
                        default:
                            if (null == c) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
                            return [l[0], c.decode(l)]
                    }
                },
                toStringV0 = (l, c, x) => {
                    let {
                        prefix: N
                    } = x;
                    if (N !== eA.prefix) throw Error(`Cannot string encode V0 in ${x.name} encoding`);
                    let U = c.get(N);
                    if (null != U) return U; {
                        let U = x.encode(l).slice(1);
                        return c.set(N, U), U
                    }
                },
                toStringV1 = (l, c, x) => {
                    let {
                        prefix: N
                    } = x, U = c.get(N);
                    if (null != U) return U; {
                        let U = x.encode(l);
                        return c.set(N, U), U
                    }
                },
                eX = 112,
                e0 = 18,
                encodeCID = (l, c, x) => {
                    let N = encodingLength(l),
                        U = N + encodingLength(c),
                        Z = new Uint8Array(U + x.byteLength);
                    return encodeTo(l, Z, 0), encodeTo(c, Z, N), Z.set(x, U), Z
                },
                e2 = Symbol.for("@ipld/js-cid/CID"),
                e1 = {
                    writable: !1,
                    configurable: !1,
                    enumerable: !0
                },
                e5 = {
                    writable: !1,
                    enumerable: !1,
                    configurable: !1
                },
                deprecate = (l, c) => {
                    if (l.test("0.0.0-dev")) console.warn(c);
                    else throw Error(c)
                },
                e4 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
                e3 = { ...U,
                    ...Z,
                    ...$,
                    ...Y,
                    ...q,
                    ...J,
                    ...X,
                    ...en,
                    ...er,
                    ...ea
                },
                e6 = { ...eu,
                    ...ed
                },
                e8 = {
                    raw: ep,
                    json: eh
                }
        },
        22130: function(l, c, x) {
            "use strict";

            function invariant(l, c) {
                if (!l) throw Error("Invariant failed")
            }
            x.d(c, {
                Z: function() {
                    return invariant
                }
            })
        },
        50741: function(l, c, x) {
            "use strict";

            function allocUnsafe(l = 0) {
                return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? globalThis.Buffer.allocUnsafe(l) : new Uint8Array(l)
            }
            x.d(c, {
                E: function() {
                    return allocUnsafe
                }
            })
        },
        72281: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                concat: function() {
                    return concat
                }
            });
            var N = x(50741);

            function concat(l, c) {
                c || (c = l.reduce((l, c) => l + c.length, 0));
                let x = (0, N.E)(c),
                    U = 0;
                for (let c of l) x.set(c, U), U += c.length;
                return x
            }
        },
        49605: function(l, c, x) {
            "use strict";

            function equals(l, c) {
                if (l === c) return !0;
                if (l.byteLength !== c.byteLength) return !1;
                for (let x = 0; x < l.byteLength; x++)
                    if (l[x] !== c[x]) return !1;
                return !0
            }
            x.r(c), x.d(c, {
                equals: function() {
                    return equals
                }
            })
        },
        34901: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                fromString: function() {
                    return fromString
                }
            });
            var N = x(37806);

            function fromString(l, c = "utf8") {
                let x = N.Z[c];
                if (!x) throw Error(`Unsupported encoding "${c}"`);
                return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(l, "utf8") : x.decoder.decode(`${x.prefix}${l}`)
            }
        },
        71188: function(l, c, x) {
            "use strict";
            x.d(c, {
                BB: function() {
                    return Z.toString
                },
                mL: function() {
                    return U.fromString
                },
                zo: function() {
                    return N.concat
                }
            });
            var N = x(72281),
                U = x(34901),
                Z = x(21361)
        },
        21361: function(l, c, x) {
            "use strict";
            x.r(c), x.d(c, {
                toString: function() {
                    return toString
                }
            });
            var N = x(37806);

            function toString(l, c = "utf8") {
                let x = N.Z[c];
                if (!x) throw Error(`Unsupported encoding "${c}"`);
                return ("utf8" === c || "utf-8" === c) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(l.buffer, l.byteOffset, l.byteLength).toString("utf8") : x.encoder.encode(l).substring(1)
            }
        },
        37806: function(l, c, x) {
            "use strict";
            var N = x(44035),
                U = x(50741);

            function createCodec(l, c, x, N) {
                return {
                    name: l,
                    prefix: c,
                    encoder: {
                        name: l,
                        prefix: c,
                        encode: x
                    },
                    decoder: {
                        decode: N
                    }
                }
            }
            let Z = createCodec("utf8", "u", l => {
                    let c = new TextDecoder("utf8");
                    return "u" + c.decode(l)
                }, l => {
                    let c = new TextEncoder;
                    return c.encode(l.substring(1))
                }),
                $ = createCodec("ascii", "a", l => {
                    let c = "a";
                    for (let x = 0; x < l.length; x++) c += String.fromCharCode(l[x]);
                    return c
                }, l => {
                    l = l.substring(1);
                    let c = (0, U.E)(l.length);
                    for (let x = 0; x < l.length; x++) c[x] = l.charCodeAt(x);
                    return c
                }),
                Y = {
                    utf8: Z,
                    "utf-8": Z,
                    hex: N.bases.base16,
                    latin1: $,
                    ascii: $,
                    binary: $,
                    ...N.bases
                };
            c.Z = Y
        },
        74578: function(l, c, x) {
            "use strict";
            let N;
            x.d(c, {
                Ry: function() {
                    return ek
                },
                Z_: function() {
                    return ef
                },
                z: function() {
                    return e3
                }
            }), (eV = eX || (eX = {})).assertEqual = l => l, eV.assertIs = function(l) {}, eV.assertNever = function(l) {
                throw Error()
            }, eV.arrayToEnum = l => {
                let c = {};
                for (let x of l) c[x] = x;
                return c
            }, eV.getValidEnumValues = l => {
                let c = eV.objectKeys(l).filter(c => "number" != typeof l[l[c]]),
                    x = {};
                for (let N of c) x[N] = l[N];
                return eV.objectValues(x)
            }, eV.objectValues = l => eV.objectKeys(l).map(function(c) {
                return l[c]
            }), eV.objectKeys = "function" == typeof Object.keys ? l => Object.keys(l) : l => {
                let c = [];
                for (let x in l) Object.prototype.hasOwnProperty.call(l, x) && c.push(x);
                return c
            }, eV.find = (l, c) => {
                for (let x of l)
                    if (c(x)) return x
            }, eV.isInteger = "function" == typeof Number.isInteger ? l => Number.isInteger(l) : l => "number" == typeof l && isFinite(l) && Math.floor(l) === l, eV.joinValues = function(l, c = " | ") {
                return l.map(l => "string" == typeof l ? `'${l}'` : l).join(c)
            }, eV.jsonStringifyReplacer = (l, c) => "bigint" == typeof c ? c.toString() : c, (e0 || (e0 = {})).mergeShapes = (l, c) => ({ ...l,
                ...c
            });
            let U = eX.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
                getParsedType = l => {
                    let c = typeof l;
                    switch (c) {
                        case "undefined":
                            return U.undefined;
                        case "string":
                            return U.string;
                        case "number":
                            return isNaN(l) ? U.nan : U.number;
                        case "boolean":
                            return U.boolean;
                        case "function":
                            return U.function;
                        case "bigint":
                            return U.bigint;
                        case "symbol":
                            return U.symbol;
                        case "object":
                            if (Array.isArray(l)) return U.array;
                            if (null === l) return U.null;
                            if (l.then && "function" == typeof l.then && l.catch && "function" == typeof l.catch) return U.promise;
                            if ("undefined" != typeof Map && l instanceof Map) return U.map;
                            if ("undefined" != typeof Set && l instanceof Set) return U.set;
                            if ("undefined" != typeof Date && l instanceof Date) return U.date;
                            return U.object;
                        default:
                            return U.unknown
                    }
                },
                Z = eX.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
            let ZodError = class ZodError extends Error {
                constructor(l) {
                    super(), this.issues = [], this.addIssue = l => {
                        this.issues = [...this.issues, l]
                    }, this.addIssues = (l = []) => {
                        this.issues = [...this.issues, ...l]
                    };
                    let c = new.target.prototype;
                    Object.setPrototypeOf ? Object.setPrototypeOf(this, c) : this.__proto__ = c, this.name = "ZodError", this.issues = l
                }
                get errors() {
                    return this.issues
                }
                format(l) {
                    let c = l || function(l) {
                            return l.message
                        },
                        x = {
                            _errors: []
                        },
                        processError = l => {
                            for (let N of l.issues)
                                if ("invalid_union" === N.code) N.unionErrors.map(processError);
                                else if ("invalid_return_type" === N.code) processError(N.returnTypeError);
                            else if ("invalid_arguments" === N.code) processError(N.argumentsError);
                            else if (0 === N.path.length) x._errors.push(c(N));
                            else {
                                let l = x,
                                    U = 0;
                                for (; U < N.path.length;) {
                                    let x = N.path[U],
                                        Z = U === N.path.length - 1;
                                    Z ? (l[x] = l[x] || {
                                        _errors: []
                                    }, l[x]._errors.push(c(N))) : l[x] = l[x] || {
                                        _errors: []
                                    }, l = l[x], U++
                                }
                            }
                        };
                    return processError(this), x
                }
                static assert(l) {
                    if (!(l instanceof ZodError)) throw Error(`Not a ZodError: ${l}`)
                }
                toString() {
                    return this.message
                }
                get message() {
                    return JSON.stringify(this.issues, eX.jsonStringifyReplacer, 2)
                }
                get isEmpty() {
                    return 0 === this.issues.length
                }
                flatten(l = l => l.message) {
                    let c = {},
                        x = [];
                    for (let N of this.issues) N.path.length > 0 ? (c[N.path[0]] = c[N.path[0]] || [], c[N.path[0]].push(l(N))) : x.push(l(N));
                    return {
                        formErrors: x,
                        fieldErrors: c
                    }
                }
                get formErrors() {
                    return this.flatten()
                }
            };
            ZodError.create = l => {
                let c = new ZodError(l);
                return c
            };
            let errorMap = (l, c) => {
                    let x;
                    switch (l.code) {
                        case Z.invalid_type:
                            x = l.received === U.undefined ? "Required" : `Expected ${l.expected}, received ${l.received}`;
                            break;
                        case Z.invalid_literal:
                            x = `Invalid literal value, expected ${JSON.stringify(l.expected,eX.jsonStringifyReplacer)}`;
                            break;
                        case Z.unrecognized_keys:
                            x = `Unrecognized key(s) in object: ${eX.joinValues(l.keys,", ")}`;
                            break;
                        case Z.invalid_union:
                            x = "Invalid input";
                            break;
                        case Z.invalid_union_discriminator:
                            x = `Invalid discriminator value. Expected ${eX.joinValues(l.options)}`;
                            break;
                        case Z.invalid_enum_value:
                            x = `Invalid enum value. Expected ${eX.joinValues(l.options)}, received '${l.received}'`;
                            break;
                        case Z.invalid_arguments:
                            x = "Invalid function arguments";
                            break;
                        case Z.invalid_return_type:
                            x = "Invalid function return type";
                            break;
                        case Z.invalid_date:
                            x = "Invalid date";
                            break;
                        case Z.invalid_string:
                            "object" == typeof l.validation ? "includes" in l.validation ? (x = `Invalid input: must include "${l.validation.includes}"`, "number" == typeof l.validation.position && (x = `${x} at one or more positions greater than or equal to ${l.validation.position}`)) : "startsWith" in l.validation ? x = `Invalid input: must start with "${l.validation.startsWith}"` : "endsWith" in l.validation ? x = `Invalid input: must end with "${l.validation.endsWith}"` : eX.assertNever(l.validation) : x = "regex" !== l.validation ? `Invalid ${l.validation}` : "Invalid";
                            break;
                        case Z.too_small:
                            x = "array" === l.type ? `Array must contain ${l.exact?"exactly":l.inclusive?"at least":"more than"} ${l.minimum} element(s)` : "string" === l.type ? `String must contain ${l.exact?"exactly":l.inclusive?"at least":"over"} ${l.minimum} character(s)` : "number" === l.type ? `Number must be ${l.exact?"exactly equal to ":l.inclusive?"greater than or equal to ":"greater than "}${l.minimum}` : "date" === l.type ? `Date must be ${l.exact?"exactly equal to ":l.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(l.minimum))}` : "Invalid input";
                            break;
                        case Z.too_big:
                            x = "array" === l.type ? `Array must contain ${l.exact?"exactly":l.inclusive?"at most":"less than"} ${l.maximum} element(s)` : "string" === l.type ? `String must contain ${l.exact?"exactly":l.inclusive?"at most":"under"} ${l.maximum} character(s)` : "number" === l.type ? `Number must be ${l.exact?"exactly":l.inclusive?"less than or equal to":"less than"} ${l.maximum}` : "bigint" === l.type ? `BigInt must be ${l.exact?"exactly":l.inclusive?"less than or equal to":"less than"} ${l.maximum}` : "date" === l.type ? `Date must be ${l.exact?"exactly":l.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(l.maximum))}` : "Invalid input";
                            break;
                        case Z.custom:
                            x = "Invalid input";
                            break;
                        case Z.invalid_intersection_types:
                            x = "Intersection results could not be merged";
                            break;
                        case Z.not_multiple_of:
                            x = `Number must be a multiple of ${l.multipleOf}`;
                            break;
                        case Z.not_finite:
                            x = "Number must be finite";
                            break;
                        default:
                            x = c.defaultError, eX.assertNever(l)
                    }
                    return {
                        message: x
                    }
                },
                $ = errorMap;

            function getErrorMap() {
                return $
            }
            let makeIssue = l => {
                let {
                    data: c,
                    path: x,
                    errorMaps: N,
                    issueData: U
                } = l, Z = [...x, ...U.path || []], $ = { ...U,
                    path: Z
                };
                if (void 0 !== U.message) return { ...U,
                    path: Z,
                    message: U.message
                };
                let Y = "",
                    q = N.filter(l => !!l).slice().reverse();
                for (let l of q) Y = l($, {
                    data: c,
                    defaultError: Y
                }).message;
                return { ...U,
                    path: Z,
                    message: Y
                }
            };

            function addIssueToContext(l, c) {
                let x = getErrorMap(),
                    N = makeIssue({
                        issueData: c,
                        data: l.data,
                        path: l.path,
                        errorMaps: [l.common.contextualErrorMap, l.schemaErrorMap, x, x === errorMap ? void 0 : errorMap].filter(l => !!l)
                    });
                l.common.issues.push(N)
            }
            let ParseStatus = class ParseStatus {
                constructor() {
                    this.value = "valid"
                }
                dirty() {
                    "valid" === this.value && (this.value = "dirty")
                }
                abort() {
                    "aborted" !== this.value && (this.value = "aborted")
                }
                static mergeArray(l, c) {
                    let x = [];
                    for (let N of c) {
                        if ("aborted" === N.status) return Y;
                        "dirty" === N.status && l.dirty(), x.push(N.value)
                    }
                    return {
                        status: l.value,
                        value: x
                    }
                }
                static async mergeObjectAsync(l, c) {
                    let x = [];
                    for (let l of c) {
                        let c = await l.key,
                            N = await l.value;
                        x.push({
                            key: c,
                            value: N
                        })
                    }
                    return ParseStatus.mergeObjectSync(l, x)
                }
                static mergeObjectSync(l, c) {
                    let x = {};
                    for (let N of c) {
                        let {
                            key: c,
                            value: U
                        } = N;
                        if ("aborted" === c.status || "aborted" === U.status) return Y;
                        "dirty" === c.status && l.dirty(), "dirty" === U.status && l.dirty(), "__proto__" !== c.value && (void 0 !== U.value || N.alwaysSet) && (x[c.value] = U.value)
                    }
                    return {
                        status: l.value,
                        value: x
                    }
                }
            };
            let Y = Object.freeze({
                    status: "aborted"
                }),
                DIRTY = l => ({
                    status: "dirty",
                    value: l
                }),
                OK = l => ({
                    status: "valid",
                    value: l
                }),
                isAborted = l => "aborted" === l.status,
                isDirty = l => "dirty" === l.status,
                isValid = l => "valid" === l.status,
                isAsync = l => "undefined" != typeof Promise && l instanceof Promise;

            function __classPrivateFieldGet(l, c, x, N) {
                if ("a" === x && !N) throw TypeError("Private accessor was defined without a getter");
                if ("function" == typeof c ? l !== c || !N : !c.has(l)) throw TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === x ? N : "a" === x ? N.call(l) : N ? N.value : c.get(l)
            }

            function __classPrivateFieldSet(l, c, x, N, U) {
                if ("m" === N) throw TypeError("Private method is not writable");
                if ("a" === N && !U) throw TypeError("Private accessor was defined without a setter");
                if ("function" == typeof c ? l !== c || !U : !c.has(l)) throw TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === N ? U.call(l, x) : U ? U.value = x : c.set(l, x), x
            }
            "function" == typeof SuppressedError && SuppressedError, (eK = e2 || (e2 = {})).errToObj = l => "string" == typeof l ? {
                message: l
            } : l || {}, eK.toString = l => "string" == typeof l ? l : null == l ? void 0 : l.message;
            let ParseInputLazyPath = class ParseInputLazyPath {
                constructor(l, c, x, N) {
                    this._cachedPath = [], this.parent = l, this.data = c, this._path = x, this._key = N
                }
                get path() {
                    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
                }
            };
            let handleResult = (l, c) => {
                if (isValid(c)) return {
                    success: !0,
                    data: c.value
                };
                if (!l.common.issues.length) throw Error("Validation failed but no issues detected.");
                return {
                    success: !1,
                    get error() {
                        if (this._error) return this._error;
                        let c = new ZodError(l.common.issues);
                        return this._error = c, this._error
                    }
                }
            };

            function processCreateParams(l) {
                if (!l) return {};
                let {
                    errorMap: c,
                    invalid_type_error: x,
                    required_error: N,
                    description: U
                } = l;
                if (c && (x || N)) throw Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
                return c ? {
                    errorMap: c,
                    description: U
                } : {
                    errorMap: (c, U) => {
                        var Z, $;
                        let {
                            message: Y
                        } = l;
                        return "invalid_enum_value" === c.code ? {
                            message: null != Y ? Y : U.defaultError
                        } : void 0 === U.data ? {
                            message: null !== (Z = null != Y ? Y : N) && void 0 !== Z ? Z : U.defaultError
                        } : "invalid_type" !== c.code ? {
                            message: U.defaultError
                        } : {
                            message: null !== ($ = null != Y ? Y : x) && void 0 !== $ ? $ : U.defaultError
                        }
                    },
                    description: U
                }
            }
            let ZodType = class ZodType {
                constructor(l) {
                    this.spa = this.safeParseAsync, this._def = l, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
                }
                get description() {
                    return this._def.description
                }
                _getType(l) {
                    return getParsedType(l.data)
                }
                _getOrReturnCtx(l, c) {
                    return c || {
                        common: l.parent.common,
                        data: l.data,
                        parsedType: getParsedType(l.data),
                        schemaErrorMap: this._def.errorMap,
                        path: l.path,
                        parent: l.parent
                    }
                }
                _processInputParams(l) {
                    return {
                        status: new ParseStatus,
                        ctx: {
                            common: l.parent.common,
                            data: l.data,
                            parsedType: getParsedType(l.data),
                            schemaErrorMap: this._def.errorMap,
                            path: l.path,
                            parent: l.parent
                        }
                    }
                }
                _parseSync(l) {
                    let c = this._parse(l);
                    if (isAsync(c)) throw Error("Synchronous parse encountered promise.");
                    return c
                }
                _parseAsync(l) {
                    let c = this._parse(l);
                    return Promise.resolve(c)
                }
                parse(l, c) {
                    let x = this.safeParse(l, c);
                    if (x.success) return x.data;
                    throw x.error
                }
                safeParse(l, c) {
                    var x;
                    let N = {
                            common: {
                                issues: [],
                                async: null !== (x = null == c ? void 0 : c.async) && void 0 !== x && x,
                                contextualErrorMap: null == c ? void 0 : c.errorMap
                            },
                            path: (null == c ? void 0 : c.path) || [],
                            schemaErrorMap: this._def.errorMap,
                            parent: null,
                            data: l,
                            parsedType: getParsedType(l)
                        },
                        U = this._parseSync({
                            data: l,
                            path: N.path,
                            parent: N
                        });
                    return handleResult(N, U)
                }
                async parseAsync(l, c) {
                    let x = await this.safeParseAsync(l, c);
                    if (x.success) return x.data;
                    throw x.error
                }
                async safeParseAsync(l, c) {
                    let x = {
                            common: {
                                issues: [],
                                contextualErrorMap: null == c ? void 0 : c.errorMap,
                                async: !0
                            },
                            path: (null == c ? void 0 : c.path) || [],
                            schemaErrorMap: this._def.errorMap,
                            parent: null,
                            data: l,
                            parsedType: getParsedType(l)
                        },
                        N = this._parse({
                            data: l,
                            path: x.path,
                            parent: x
                        }),
                        U = await (isAsync(N) ? N : Promise.resolve(N));
                    return handleResult(x, U)
                }
                refine(l, c) {
                    let getIssueProperties = l => "string" == typeof c || void 0 === c ? {
                        message: c
                    } : "function" == typeof c ? c(l) : c;
                    return this._refinement((c, x) => {
                        let N = l(c),
                            setError = () => x.addIssue({
                                code: Z.custom,
                                ...getIssueProperties(c)
                            });
                        return "undefined" != typeof Promise && N instanceof Promise ? N.then(l => !!l || (setError(), !1)) : !!N || (setError(), !1)
                    })
                }
                refinement(l, c) {
                    return this._refinement((x, N) => !!l(x) || (N.addIssue("function" == typeof c ? c(x, N) : c), !1))
                }
                _refinement(l) {
                    return new ZodEffects({
                        schema: this,
                        typeName: e4.ZodEffects,
                        effect: {
                            type: "refinement",
                            refinement: l
                        }
                    })
                }
                superRefine(l) {
                    return this._refinement(l)
                }
                optional() {
                    return ZodOptional.create(this, this._def)
                }
                nullable() {
                    return ZodNullable.create(this, this._def)
                }
                nullish() {
                    return this.nullable().optional()
                }
                array() {
                    return ZodArray.create(this, this._def)
                }
                promise() {
                    return ZodPromise.create(this, this._def)
                }
                or(l) {
                    return ZodUnion.create([this, l], this._def)
                }
                and(l) {
                    return ZodIntersection.create(this, l, this._def)
                }
                transform(l) {
                    return new ZodEffects({ ...processCreateParams(this._def),
                        schema: this,
                        typeName: e4.ZodEffects,
                        effect: {
                            type: "transform",
                            transform: l
                        }
                    })
                }
                default (l) {
                    return new ZodDefault({ ...processCreateParams(this._def),
                        innerType: this,
                        defaultValue: "function" == typeof l ? l : () => l,
                        typeName: e4.ZodDefault
                    })
                }
                brand() {
                    return new ZodBranded({
                        typeName: e4.ZodBranded,
                        type: this,
                        ...processCreateParams(this._def)
                    })
                } catch (l) {
                    return new ZodCatch({ ...processCreateParams(this._def),
                        innerType: this,
                        catchValue: "function" == typeof l ? l : () => l,
                        typeName: e4.ZodCatch
                    })
                }
                describe(l) {
                    let c = this.constructor;
                    return new c({ ...this._def,
                        description: l
                    })
                }
                pipe(l) {
                    return ZodPipeline.create(this, l)
                }
                readonly() {
                    return ZodReadonly.create(this)
                }
                isOptional() {
                    return this.safeParse(void 0).success
                }
                isNullable() {
                    return this.safeParse(null).success
                }
            };
            let q = /^c[^\s-]{8,}$/i,
                J = /^[0-9a-z]+$/,
                X = /^[0-9A-HJKMNP-TV-Z]{26}$/,
                en = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
                er = /^[a-z0-9_-]{21}$/i,
                ea = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
                eo = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
                el = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
                ec = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
                eu = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
                ed = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
                ep = RegExp(`^${ed}$`);

            function timeRegexSource(l) {
                let c = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
                return l.precision ? c = `${c}\\.\\d{${l.precision}}` : null == l.precision && (c = `${c}(\\.\\d+)?`), c
            }

            function datetimeRegex(l) {
                let c = `${ed}T${timeRegexSource(l)}`,
                    x = [];
                return x.push(l.local ? "Z?" : "Z"), l.offset && x.push("([+-]\\d{2}:?\\d{2})"), c = `${c}(${x.join("|")})`, RegExp(`^${c}$`)
            }
            let ZodString = class ZodString extends ZodType {
                _parse(l) {
                    var c, x;
                    let $;
                    this._def.coerce && (l.data = String(l.data));
                    let ed = this._getType(l);
                    if (ed !== U.string) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.string,
                            received: c.parsedType
                        }), Y
                    }
                    let eh = new ParseStatus;
                    for (let U of this._def.checks)
                        if ("min" === U.kind) l.data.length < U.value && (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                            code: Z.too_small,
                            minimum: U.value,
                            type: "string",
                            inclusive: !0,
                            exact: !1,
                            message: U.message
                        }), eh.dirty());
                        else if ("max" === U.kind) l.data.length > U.value && (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        code: Z.too_big,
                        maximum: U.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: U.message
                    }), eh.dirty());
                    else if ("length" === U.kind) {
                        let c = l.data.length > U.value,
                            x = l.data.length < U.value;
                        (c || x) && ($ = this._getOrReturnCtx(l, $), c ? addIssueToContext($, {
                            code: Z.too_big,
                            maximum: U.value,
                            type: "string",
                            inclusive: !0,
                            exact: !0,
                            message: U.message
                        }) : x && addIssueToContext($, {
                            code: Z.too_small,
                            minimum: U.value,
                            type: "string",
                            inclusive: !0,
                            exact: !0,
                            message: U.message
                        }), eh.dirty())
                    } else if ("email" === U.kind) eo.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "email",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("emoji" === U.kind) N || (N = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), N.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "emoji",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("uuid" === U.kind) en.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "uuid",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("nanoid" === U.kind) er.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "nanoid",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("cuid" === U.kind) q.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "cuid",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("cuid2" === U.kind) J.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "cuid2",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("ulid" === U.kind) X.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "ulid",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty());
                    else if ("url" === U.kind) try {
                        new URL(l.data)
                    } catch (c) {
                        addIssueToContext($ = this._getOrReturnCtx(l, $), {
                            validation: "url",
                            code: Z.invalid_string,
                            message: U.message
                        }), eh.dirty()
                    } else if ("regex" === U.kind) {
                        U.regex.lastIndex = 0;
                        let c = U.regex.test(l.data);
                        c || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                            validation: "regex",
                            code: Z.invalid_string,
                            message: U.message
                        }), eh.dirty())
                    } else if ("trim" === U.kind) l.data = l.data.trim();
                    else if ("includes" === U.kind) l.data.includes(U.value, U.position) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        code: Z.invalid_string,
                        validation: {
                            includes: U.value,
                            position: U.position
                        },
                        message: U.message
                    }), eh.dirty());
                    else if ("toLowerCase" === U.kind) l.data = l.data.toLowerCase();
                    else if ("toUpperCase" === U.kind) l.data = l.data.toUpperCase();
                    else if ("startsWith" === U.kind) l.data.startsWith(U.value) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        code: Z.invalid_string,
                        validation: {
                            startsWith: U.value
                        },
                        message: U.message
                    }), eh.dirty());
                    else if ("endsWith" === U.kind) l.data.endsWith(U.value) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        code: Z.invalid_string,
                        validation: {
                            endsWith: U.value
                        },
                        message: U.message
                    }), eh.dirty());
                    else if ("datetime" === U.kind) {
                        let c = datetimeRegex(U);
                        c.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                            code: Z.invalid_string,
                            validation: "datetime",
                            message: U.message
                        }), eh.dirty())
                    } else if ("date" === U.kind) ep.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        code: Z.invalid_string,
                        validation: "date",
                        message: U.message
                    }), eh.dirty());
                    else if ("time" === U.kind) {
                        let c = RegExp(`^${timeRegexSource(U)}$`);
                        c.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                            code: Z.invalid_string,
                            validation: "time",
                            message: U.message
                        }), eh.dirty())
                    } else "duration" === U.kind ? ea.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "duration",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty()) : "ip" === U.kind ? (c = l.data, ("v4" === (x = U.version) || !x) && el.test(c) || ("v6" === x || !x) && ec.test(c) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "ip",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty())) : "base64" === U.kind ? eu.test(l.data) || (addIssueToContext($ = this._getOrReturnCtx(l, $), {
                        validation: "base64",
                        code: Z.invalid_string,
                        message: U.message
                    }), eh.dirty()) : eX.assertNever(U);
                    return {
                        status: eh.value,
                        value: l.data
                    }
                }
                _regex(l, c, x) {
                    return this.refinement(c => l.test(c), {
                        validation: c,
                        code: Z.invalid_string,
                        ...e2.errToObj(x)
                    })
                }
                _addCheck(l) {
                    return new ZodString({ ...this._def,
                        checks: [...this._def.checks, l]
                    })
                }
                email(l) {
                    return this._addCheck({
                        kind: "email",
                        ...e2.errToObj(l)
                    })
                }
                url(l) {
                    return this._addCheck({
                        kind: "url",
                        ...e2.errToObj(l)
                    })
                }
                emoji(l) {
                    return this._addCheck({
                        kind: "emoji",
                        ...e2.errToObj(l)
                    })
                }
                uuid(l) {
                    return this._addCheck({
                        kind: "uuid",
                        ...e2.errToObj(l)
                    })
                }
                nanoid(l) {
                    return this._addCheck({
                        kind: "nanoid",
                        ...e2.errToObj(l)
                    })
                }
                cuid(l) {
                    return this._addCheck({
                        kind: "cuid",
                        ...e2.errToObj(l)
                    })
                }
                cuid2(l) {
                    return this._addCheck({
                        kind: "cuid2",
                        ...e2.errToObj(l)
                    })
                }
                ulid(l) {
                    return this._addCheck({
                        kind: "ulid",
                        ...e2.errToObj(l)
                    })
                }
                base64(l) {
                    return this._addCheck({
                        kind: "base64",
                        ...e2.errToObj(l)
                    })
                }
                ip(l) {
                    return this._addCheck({
                        kind: "ip",
                        ...e2.errToObj(l)
                    })
                }
                datetime(l) {
                    var c, x;
                    return "string" == typeof l ? this._addCheck({
                        kind: "datetime",
                        precision: null,
                        offset: !1,
                        local: !1,
                        message: l
                    }) : this._addCheck({
                        kind: "datetime",
                        precision: void 0 === (null == l ? void 0 : l.precision) ? null : null == l ? void 0 : l.precision,
                        offset: null !== (c = null == l ? void 0 : l.offset) && void 0 !== c && c,
                        local: null !== (x = null == l ? void 0 : l.local) && void 0 !== x && x,
                        ...e2.errToObj(null == l ? void 0 : l.message)
                    })
                }
                date(l) {
                    return this._addCheck({
                        kind: "date",
                        message: l
                    })
                }
                time(l) {
                    return "string" == typeof l ? this._addCheck({
                        kind: "time",
                        precision: null,
                        message: l
                    }) : this._addCheck({
                        kind: "time",
                        precision: void 0 === (null == l ? void 0 : l.precision) ? null : null == l ? void 0 : l.precision,
                        ...e2.errToObj(null == l ? void 0 : l.message)
                    })
                }
                duration(l) {
                    return this._addCheck({
                        kind: "duration",
                        ...e2.errToObj(l)
                    })
                }
                regex(l, c) {
                    return this._addCheck({
                        kind: "regex",
                        regex: l,
                        ...e2.errToObj(c)
                    })
                }
                includes(l, c) {
                    return this._addCheck({
                        kind: "includes",
                        value: l,
                        position: null == c ? void 0 : c.position,
                        ...e2.errToObj(null == c ? void 0 : c.message)
                    })
                }
                startsWith(l, c) {
                    return this._addCheck({
                        kind: "startsWith",
                        value: l,
                        ...e2.errToObj(c)
                    })
                }
                endsWith(l, c) {
                    return this._addCheck({
                        kind: "endsWith",
                        value: l,
                        ...e2.errToObj(c)
                    })
                }
                min(l, c) {
                    return this._addCheck({
                        kind: "min",
                        value: l,
                        ...e2.errToObj(c)
                    })
                }
                max(l, c) {
                    return this._addCheck({
                        kind: "max",
                        value: l,
                        ...e2.errToObj(c)
                    })
                }
                length(l, c) {
                    return this._addCheck({
                        kind: "length",
                        value: l,
                        ...e2.errToObj(c)
                    })
                }
                nonempty(l) {
                    return this.min(1, e2.errToObj(l))
                }
                trim() {
                    return new ZodString({ ...this._def,
                        checks: [...this._def.checks, {
                            kind: "trim"
                        }]
                    })
                }
                toLowerCase() {
                    return new ZodString({ ...this._def,
                        checks: [...this._def.checks, {
                            kind: "toLowerCase"
                        }]
                    })
                }
                toUpperCase() {
                    return new ZodString({ ...this._def,
                        checks: [...this._def.checks, {
                            kind: "toUpperCase"
                        }]
                    })
                }
                get isDatetime() {
                    return !!this._def.checks.find(l => "datetime" === l.kind)
                }
                get isDate() {
                    return !!this._def.checks.find(l => "date" === l.kind)
                }
                get isTime() {
                    return !!this._def.checks.find(l => "time" === l.kind)
                }
                get isDuration() {
                    return !!this._def.checks.find(l => "duration" === l.kind)
                }
                get isEmail() {
                    return !!this._def.checks.find(l => "email" === l.kind)
                }
                get isURL() {
                    return !!this._def.checks.find(l => "url" === l.kind)
                }
                get isEmoji() {
                    return !!this._def.checks.find(l => "emoji" === l.kind)
                }
                get isUUID() {
                    return !!this._def.checks.find(l => "uuid" === l.kind)
                }
                get isNANOID() {
                    return !!this._def.checks.find(l => "nanoid" === l.kind)
                }
                get isCUID() {
                    return !!this._def.checks.find(l => "cuid" === l.kind)
                }
                get isCUID2() {
                    return !!this._def.checks.find(l => "cuid2" === l.kind)
                }
                get isULID() {
                    return !!this._def.checks.find(l => "ulid" === l.kind)
                }
                get isIP() {
                    return !!this._def.checks.find(l => "ip" === l.kind)
                }
                get isBase64() {
                    return !!this._def.checks.find(l => "base64" === l.kind)
                }
                get minLength() {
                    let l = null;
                    for (let c of this._def.checks) "min" === c.kind && (null === l || c.value > l) && (l = c.value);
                    return l
                }
                get maxLength() {
                    let l = null;
                    for (let c of this._def.checks) "max" === c.kind && (null === l || c.value < l) && (l = c.value);
                    return l
                }
            };
            ZodString.create = l => {
                var c;
                return new ZodString({
                    checks: [],
                    typeName: e4.ZodString,
                    coerce: null !== (c = null == l ? void 0 : l.coerce) && void 0 !== c && c,
                    ...processCreateParams(l)
                })
            };
            let ZodNumber = class ZodNumber extends ZodType {
                constructor() {
                    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
                }
                _parse(l) {
                    let c;
                    this._def.coerce && (l.data = Number(l.data));
                    let x = this._getType(l);
                    if (x !== U.number) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.number,
                            received: c.parsedType
                        }), Y
                    }
                    let N = new ParseStatus;
                    for (let x of this._def.checks)
                        if ("int" === x.kind) eX.isInteger(l.data) || (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                            code: Z.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: x.message
                        }), N.dirty());
                        else if ("min" === x.kind) {
                        let U = x.inclusive ? l.data < x.value : l.data <= x.value;
                        U && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                            code: Z.too_small,
                            minimum: x.value,
                            type: "number",
                            inclusive: x.inclusive,
                            exact: !1,
                            message: x.message
                        }), N.dirty())
                    } else if ("max" === x.kind) {
                        let U = x.inclusive ? l.data > x.value : l.data >= x.value;
                        U && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                            code: Z.too_big,
                            maximum: x.value,
                            type: "number",
                            inclusive: x.inclusive,
                            exact: !1,
                            message: x.message
                        }), N.dirty())
                    } else "multipleOf" === x.kind ? 0 !== function(l, c) {
                        let x = (l.toString().split(".")[1] || "").length,
                            N = (c.toString().split(".")[1] || "").length,
                            U = x > N ? x : N,
                            Z = parseInt(l.toFixed(U).replace(".", "")),
                            $ = parseInt(c.toFixed(U).replace(".", ""));
                        return Z % $ / Math.pow(10, U)
                    }(l.data, x.value) && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                        code: Z.not_multiple_of,
                        multipleOf: x.value,
                        message: x.message
                    }), N.dirty()) : "finite" === x.kind ? Number.isFinite(l.data) || (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                        code: Z.not_finite,
                        message: x.message
                    }), N.dirty()) : eX.assertNever(x);
                    return {
                        status: N.value,
                        value: l.data
                    }
                }
                gte(l, c) {
                    return this.setLimit("min", l, !0, e2.toString(c))
                }
                gt(l, c) {
                    return this.setLimit("min", l, !1, e2.toString(c))
                }
                lte(l, c) {
                    return this.setLimit("max", l, !0, e2.toString(c))
                }
                lt(l, c) {
                    return this.setLimit("max", l, !1, e2.toString(c))
                }
                setLimit(l, c, x, N) {
                    return new ZodNumber({ ...this._def,
                        checks: [...this._def.checks, {
                            kind: l,
                            value: c,
                            inclusive: x,
                            message: e2.toString(N)
                        }]
                    })
                }
                _addCheck(l) {
                    return new ZodNumber({ ...this._def,
                        checks: [...this._def.checks, l]
                    })
                }
                int(l) {
                    return this._addCheck({
                        kind: "int",
                        message: e2.toString(l)
                    })
                }
                positive(l) {
                    return this._addCheck({
                        kind: "min",
                        value: 0,
                        inclusive: !1,
                        message: e2.toString(l)
                    })
                }
                negative(l) {
                    return this._addCheck({
                        kind: "max",
                        value: 0,
                        inclusive: !1,
                        message: e2.toString(l)
                    })
                }
                nonpositive(l) {
                    return this._addCheck({
                        kind: "max",
                        value: 0,
                        inclusive: !0,
                        message: e2.toString(l)
                    })
                }
                nonnegative(l) {
                    return this._addCheck({
                        kind: "min",
                        value: 0,
                        inclusive: !0,
                        message: e2.toString(l)
                    })
                }
                multipleOf(l, c) {
                    return this._addCheck({
                        kind: "multipleOf",
                        value: l,
                        message: e2.toString(c)
                    })
                }
                finite(l) {
                    return this._addCheck({
                        kind: "finite",
                        message: e2.toString(l)
                    })
                }
                safe(l) {
                    return this._addCheck({
                        kind: "min",
                        inclusive: !0,
                        value: Number.MIN_SAFE_INTEGER,
                        message: e2.toString(l)
                    })._addCheck({
                        kind: "max",
                        inclusive: !0,
                        value: Number.MAX_SAFE_INTEGER,
                        message: e2.toString(l)
                    })
                }
                get minValue() {
                    let l = null;
                    for (let c of this._def.checks) "min" === c.kind && (null === l || c.value > l) && (l = c.value);
                    return l
                }
                get maxValue() {
                    let l = null;
                    for (let c of this._def.checks) "max" === c.kind && (null === l || c.value < l) && (l = c.value);
                    return l
                }
                get isInt() {
                    return !!this._def.checks.find(l => "int" === l.kind || "multipleOf" === l.kind && eX.isInteger(l.value))
                }
                get isFinite() {
                    let l = null,
                        c = null;
                    for (let x of this._def.checks) {
                        if ("finite" === x.kind || "int" === x.kind || "multipleOf" === x.kind) return !0;
                        "min" === x.kind ? (null === c || x.value > c) && (c = x.value) : "max" === x.kind && (null === l || x.value < l) && (l = x.value)
                    }
                    return Number.isFinite(c) && Number.isFinite(l)
                }
            };
            ZodNumber.create = l => new ZodNumber({
                checks: [],
                typeName: e4.ZodNumber,
                coerce: (null == l ? void 0 : l.coerce) || !1,
                ...processCreateParams(l)
            });
            let ZodBigInt = class ZodBigInt extends ZodType {
                constructor() {
                    super(...arguments), this.min = this.gte, this.max = this.lte
                }
                _parse(l) {
                    let c;
                    this._def.coerce && (l.data = BigInt(l.data));
                    let x = this._getType(l);
                    if (x !== U.bigint) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.bigint,
                            received: c.parsedType
                        }), Y
                    }
                    let N = new ParseStatus;
                    for (let x of this._def.checks)
                        if ("min" === x.kind) {
                            let U = x.inclusive ? l.data < x.value : l.data <= x.value;
                            U && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                                code: Z.too_small,
                                type: "bigint",
                                minimum: x.value,
                                inclusive: x.inclusive,
                                message: x.message
                            }), N.dirty())
                        } else if ("max" === x.kind) {
                        let U = x.inclusive ? l.data > x.value : l.data >= x.value;
                        U && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                            code: Z.too_big,
                            type: "bigint",
                            maximum: x.value,
                            inclusive: x.inclusive,
                            message: x.message
                        }), N.dirty())
                    } else "multipleOf" === x.kind ? l.data % x.value !== BigInt(0) && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                        code: Z.not_multiple_of,
                        multipleOf: x.value,
                        message: x.message
                    }), N.dirty()) : eX.assertNever(x);
                    return {
                        status: N.value,
                        value: l.data
                    }
                }
                gte(l, c) {
                    return this.setLimit("min", l, !0, e2.toString(c))
                }
                gt(l, c) {
                    return this.setLimit("min", l, !1, e2.toString(c))
                }
                lte(l, c) {
                    return this.setLimit("max", l, !0, e2.toString(c))
                }
                lt(l, c) {
                    return this.setLimit("max", l, !1, e2.toString(c))
                }
                setLimit(l, c, x, N) {
                    return new ZodBigInt({ ...this._def,
                        checks: [...this._def.checks, {
                            kind: l,
                            value: c,
                            inclusive: x,
                            message: e2.toString(N)
                        }]
                    })
                }
                _addCheck(l) {
                    return new ZodBigInt({ ...this._def,
                        checks: [...this._def.checks, l]
                    })
                }
                positive(l) {
                    return this._addCheck({
                        kind: "min",
                        value: BigInt(0),
                        inclusive: !1,
                        message: e2.toString(l)
                    })
                }
                negative(l) {
                    return this._addCheck({
                        kind: "max",
                        value: BigInt(0),
                        inclusive: !1,
                        message: e2.toString(l)
                    })
                }
                nonpositive(l) {
                    return this._addCheck({
                        kind: "max",
                        value: BigInt(0),
                        inclusive: !0,
                        message: e2.toString(l)
                    })
                }
                nonnegative(l) {
                    return this._addCheck({
                        kind: "min",
                        value: BigInt(0),
                        inclusive: !0,
                        message: e2.toString(l)
                    })
                }
                multipleOf(l, c) {
                    return this._addCheck({
                        kind: "multipleOf",
                        value: l,
                        message: e2.toString(c)
                    })
                }
                get minValue() {
                    let l = null;
                    for (let c of this._def.checks) "min" === c.kind && (null === l || c.value > l) && (l = c.value);
                    return l
                }
                get maxValue() {
                    let l = null;
                    for (let c of this._def.checks) "max" === c.kind && (null === l || c.value < l) && (l = c.value);
                    return l
                }
            };
            ZodBigInt.create = l => {
                var c;
                return new ZodBigInt({
                    checks: [],
                    typeName: e4.ZodBigInt,
                    coerce: null !== (c = null == l ? void 0 : l.coerce) && void 0 !== c && c,
                    ...processCreateParams(l)
                })
            };
            let ZodBoolean = class ZodBoolean extends ZodType {
                _parse(l) {
                    this._def.coerce && (l.data = !!l.data);
                    let c = this._getType(l);
                    if (c !== U.boolean) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.boolean,
                            received: c.parsedType
                        }), Y
                    }
                    return OK(l.data)
                }
            };
            ZodBoolean.create = l => new ZodBoolean({
                typeName: e4.ZodBoolean,
                coerce: (null == l ? void 0 : l.coerce) || !1,
                ...processCreateParams(l)
            });
            let ZodDate = class ZodDate extends ZodType {
                _parse(l) {
                    let c;
                    this._def.coerce && (l.data = new Date(l.data));
                    let x = this._getType(l);
                    if (x !== U.date) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.date,
                            received: c.parsedType
                        }), Y
                    }
                    if (isNaN(l.data.getTime())) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_date
                        }), Y
                    }
                    let N = new ParseStatus;
                    for (let x of this._def.checks) "min" === x.kind ? l.data.getTime() < x.value && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                        code: Z.too_small,
                        message: x.message,
                        inclusive: !0,
                        exact: !1,
                        minimum: x.value,
                        type: "date"
                    }), N.dirty()) : "max" === x.kind ? l.data.getTime() > x.value && (addIssueToContext(c = this._getOrReturnCtx(l, c), {
                        code: Z.too_big,
                        message: x.message,
                        inclusive: !0,
                        exact: !1,
                        maximum: x.value,
                        type: "date"
                    }), N.dirty()) : eX.assertNever(x);
                    return {
                        status: N.value,
                        value: new Date(l.data.getTime())
                    }
                }
                _addCheck(l) {
                    return new ZodDate({ ...this._def,
                        checks: [...this._def.checks, l]
                    })
                }
                min(l, c) {
                    return this._addCheck({
                        kind: "min",
                        value: l.getTime(),
                        message: e2.toString(c)
                    })
                }
                max(l, c) {
                    return this._addCheck({
                        kind: "max",
                        value: l.getTime(),
                        message: e2.toString(c)
                    })
                }
                get minDate() {
                    let l = null;
                    for (let c of this._def.checks) "min" === c.kind && (null === l || c.value > l) && (l = c.value);
                    return null != l ? new Date(l) : null
                }
                get maxDate() {
                    let l = null;
                    for (let c of this._def.checks) "max" === c.kind && (null === l || c.value < l) && (l = c.value);
                    return null != l ? new Date(l) : null
                }
            };
            ZodDate.create = l => new ZodDate({
                checks: [],
                coerce: (null == l ? void 0 : l.coerce) || !1,
                typeName: e4.ZodDate,
                ...processCreateParams(l)
            });
            let ZodSymbol = class ZodSymbol extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    if (c !== U.symbol) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.symbol,
                            received: c.parsedType
                        }), Y
                    }
                    return OK(l.data)
                }
            };
            ZodSymbol.create = l => new ZodSymbol({
                typeName: e4.ZodSymbol,
                ...processCreateParams(l)
            });
            let ZodUndefined = class ZodUndefined extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    if (c !== U.undefined) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.undefined,
                            received: c.parsedType
                        }), Y
                    }
                    return OK(l.data)
                }
            };
            ZodUndefined.create = l => new ZodUndefined({
                typeName: e4.ZodUndefined,
                ...processCreateParams(l)
            });
            let ZodNull = class ZodNull extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    if (c !== U.null) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.null,
                            received: c.parsedType
                        }), Y
                    }
                    return OK(l.data)
                }
            };
            ZodNull.create = l => new ZodNull({
                typeName: e4.ZodNull,
                ...processCreateParams(l)
            });
            let ZodAny = class ZodAny extends ZodType {
                constructor() {
                    super(...arguments), this._any = !0
                }
                _parse(l) {
                    return OK(l.data)
                }
            };
            ZodAny.create = l => new ZodAny({
                typeName: e4.ZodAny,
                ...processCreateParams(l)
            });
            let ZodUnknown = class ZodUnknown extends ZodType {
                constructor() {
                    super(...arguments), this._unknown = !0
                }
                _parse(l) {
                    return OK(l.data)
                }
            };
            ZodUnknown.create = l => new ZodUnknown({
                typeName: e4.ZodUnknown,
                ...processCreateParams(l)
            });
            let ZodNever = class ZodNever extends ZodType {
                _parse(l) {
                    let c = this._getOrReturnCtx(l);
                    return addIssueToContext(c, {
                        code: Z.invalid_type,
                        expected: U.never,
                        received: c.parsedType
                    }), Y
                }
            };
            ZodNever.create = l => new ZodNever({
                typeName: e4.ZodNever,
                ...processCreateParams(l)
            });
            let ZodVoid = class ZodVoid extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    if (c !== U.undefined) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.void,
                            received: c.parsedType
                        }), Y
                    }
                    return OK(l.data)
                }
            };
            ZodVoid.create = l => new ZodVoid({
                typeName: e4.ZodVoid,
                ...processCreateParams(l)
            });
            let ZodArray = class ZodArray extends ZodType {
                _parse(l) {
                    let {
                        ctx: c,
                        status: x
                    } = this._processInputParams(l), N = this._def;
                    if (c.parsedType !== U.array) return addIssueToContext(c, {
                        code: Z.invalid_type,
                        expected: U.array,
                        received: c.parsedType
                    }), Y;
                    if (null !== N.exactLength) {
                        let l = c.data.length > N.exactLength.value,
                            U = c.data.length < N.exactLength.value;
                        (l || U) && (addIssueToContext(c, {
                            code: l ? Z.too_big : Z.too_small,
                            minimum: U ? N.exactLength.value : void 0,
                            maximum: l ? N.exactLength.value : void 0,
                            type: "array",
                            inclusive: !0,
                            exact: !0,
                            message: N.exactLength.message
                        }), x.dirty())
                    }
                    if (null !== N.minLength && c.data.length < N.minLength.value && (addIssueToContext(c, {
                            code: Z.too_small,
                            minimum: N.minLength.value,
                            type: "array",
                            inclusive: !0,
                            exact: !1,
                            message: N.minLength.message
                        }), x.dirty()), null !== N.maxLength && c.data.length > N.maxLength.value && (addIssueToContext(c, {
                            code: Z.too_big,
                            maximum: N.maxLength.value,
                            type: "array",
                            inclusive: !0,
                            exact: !1,
                            message: N.maxLength.message
                        }), x.dirty()), c.common.async) return Promise.all([...c.data].map((l, x) => N.type._parseAsync(new ParseInputLazyPath(c, l, c.path, x)))).then(l => ParseStatus.mergeArray(x, l));
                    let $ = [...c.data].map((l, x) => N.type._parseSync(new ParseInputLazyPath(c, l, c.path, x)));
                    return ParseStatus.mergeArray(x, $)
                }
                get element() {
                    return this._def.type
                }
                min(l, c) {
                    return new ZodArray({ ...this._def,
                        minLength: {
                            value: l,
                            message: e2.toString(c)
                        }
                    })
                }
                max(l, c) {
                    return new ZodArray({ ...this._def,
                        maxLength: {
                            value: l,
                            message: e2.toString(c)
                        }
                    })
                }
                length(l, c) {
                    return new ZodArray({ ...this._def,
                        exactLength: {
                            value: l,
                            message: e2.toString(c)
                        }
                    })
                }
                nonempty(l) {
                    return this.min(1, l)
                }
            };
            ZodArray.create = (l, c) => new ZodArray({
                type: l,
                minLength: null,
                maxLength: null,
                exactLength: null,
                typeName: e4.ZodArray,
                ...processCreateParams(c)
            });
            let ZodObject = class ZodObject extends ZodType {
                constructor() {
                    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
                }
                _getCached() {
                    if (null !== this._cached) return this._cached;
                    let l = this._def.shape(),
                        c = eX.objectKeys(l);
                    return this._cached = {
                        shape: l,
                        keys: c
                    }
                }
                _parse(l) {
                    let c = this._getType(l);
                    if (c !== U.object) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.object,
                            received: c.parsedType
                        }), Y
                    }
                    let {
                        status: x,
                        ctx: N
                    } = this._processInputParams(l), {
                        shape: $,
                        keys: q
                    } = this._getCached(), J = [];
                    if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys))
                        for (let l in N.data) q.includes(l) || J.push(l);
                    let X = [];
                    for (let l of q) {
                        let c = $[l],
                            x = N.data[l];
                        X.push({
                            key: {
                                status: "valid",
                                value: l
                            },
                            value: c._parse(new ParseInputLazyPath(N, x, N.path, l)),
                            alwaysSet: l in N.data
                        })
                    }
                    if (this._def.catchall instanceof ZodNever) {
                        let l = this._def.unknownKeys;
                        if ("passthrough" === l)
                            for (let l of J) X.push({
                                key: {
                                    status: "valid",
                                    value: l
                                },
                                value: {
                                    status: "valid",
                                    value: N.data[l]
                                }
                            });
                        else if ("strict" === l) J.length > 0 && (addIssueToContext(N, {
                            code: Z.unrecognized_keys,
                            keys: J
                        }), x.dirty());
                        else if ("strip" === l);
                        else throw Error("Internal ZodObject error: invalid unknownKeys value.")
                    } else {
                        let l = this._def.catchall;
                        for (let c of J) {
                            let x = N.data[c];
                            X.push({
                                key: {
                                    status: "valid",
                                    value: c
                                },
                                value: l._parse(new ParseInputLazyPath(N, x, N.path, c)),
                                alwaysSet: c in N.data
                            })
                        }
                    }
                    return N.common.async ? Promise.resolve().then(async () => {
                        let l = [];
                        for (let c of X) {
                            let x = await c.key,
                                N = await c.value;
                            l.push({
                                key: x,
                                value: N,
                                alwaysSet: c.alwaysSet
                            })
                        }
                        return l
                    }).then(l => ParseStatus.mergeObjectSync(x, l)) : ParseStatus.mergeObjectSync(x, X)
                }
                get shape() {
                    return this._def.shape()
                }
                strict(l) {
                    return e2.errToObj, new ZodObject({ ...this._def,
                        unknownKeys: "strict",
                        ...void 0 !== l ? {
                            errorMap: (c, x) => {
                                var N, U, Z, $;
                                let Y = null !== (Z = null === (U = (N = this._def).errorMap) || void 0 === U ? void 0 : U.call(N, c, x).message) && void 0 !== Z ? Z : x.defaultError;
                                return "unrecognized_keys" === c.code ? {
                                    message: null !== ($ = e2.errToObj(l).message) && void 0 !== $ ? $ : Y
                                } : {
                                    message: Y
                                }
                            }
                        } : {}
                    })
                }
                strip() {
                    return new ZodObject({ ...this._def,
                        unknownKeys: "strip"
                    })
                }
                passthrough() {
                    return new ZodObject({ ...this._def,
                        unknownKeys: "passthrough"
                    })
                }
                extend(l) {
                    return new ZodObject({ ...this._def,
                        shape: () => ({ ...this._def.shape(),
                            ...l
                        })
                    })
                }
                merge(l) {
                    let c = new ZodObject({
                        unknownKeys: l._def.unknownKeys,
                        catchall: l._def.catchall,
                        shape: () => ({ ...this._def.shape(),
                            ...l._def.shape()
                        }),
                        typeName: e4.ZodObject
                    });
                    return c
                }
                setKey(l, c) {
                    return this.augment({
                        [l]: c
                    })
                }
                catchall(l) {
                    return new ZodObject({ ...this._def,
                        catchall: l
                    })
                }
                pick(l) {
                    let c = {};
                    return eX.objectKeys(l).forEach(x => {
                        l[x] && this.shape[x] && (c[x] = this.shape[x])
                    }), new ZodObject({ ...this._def,
                        shape: () => c
                    })
                }
                omit(l) {
                    let c = {};
                    return eX.objectKeys(this.shape).forEach(x => {
                        l[x] || (c[x] = this.shape[x])
                    }), new ZodObject({ ...this._def,
                        shape: () => c
                    })
                }
                deepPartial() {
                    return function deepPartialify(l) {
                        if (l instanceof ZodObject) {
                            let c = {};
                            for (let x in l.shape) {
                                let N = l.shape[x];
                                c[x] = ZodOptional.create(deepPartialify(N))
                            }
                            return new ZodObject({ ...l._def,
                                shape: () => c
                            })
                        }
                        return l instanceof ZodArray ? new ZodArray({ ...l._def,
                            type: deepPartialify(l.element)
                        }) : l instanceof ZodOptional ? ZodOptional.create(deepPartialify(l.unwrap())) : l instanceof ZodNullable ? ZodNullable.create(deepPartialify(l.unwrap())) : l instanceof ZodTuple ? ZodTuple.create(l.items.map(l => deepPartialify(l))) : l
                    }(this)
                }
                partial(l) {
                    let c = {};
                    return eX.objectKeys(this.shape).forEach(x => {
                        let N = this.shape[x];
                        l && !l[x] ? c[x] = N : c[x] = N.optional()
                    }), new ZodObject({ ...this._def,
                        shape: () => c
                    })
                }
                required(l) {
                    let c = {};
                    return eX.objectKeys(this.shape).forEach(x => {
                        if (l && !l[x]) c[x] = this.shape[x];
                        else {
                            let l = this.shape[x],
                                N = l;
                            for (; N instanceof ZodOptional;) N = N._def.innerType;
                            c[x] = N
                        }
                    }), new ZodObject({ ...this._def,
                        shape: () => c
                    })
                }
                keyof() {
                    return createZodEnum(eX.objectKeys(this.shape))
                }
            };
            ZodObject.create = (l, c) => new ZodObject({
                shape: () => l,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: e4.ZodObject,
                ...processCreateParams(c)
            }), ZodObject.strictCreate = (l, c) => new ZodObject({
                shape: () => l,
                unknownKeys: "strict",
                catchall: ZodNever.create(),
                typeName: e4.ZodObject,
                ...processCreateParams(c)
            }), ZodObject.lazycreate = (l, c) => new ZodObject({
                shape: l,
                unknownKeys: "strip",
                catchall: ZodNever.create(),
                typeName: e4.ZodObject,
                ...processCreateParams(c)
            });
            let ZodUnion = class ZodUnion extends ZodType {
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l), x = this._def.options;
                    if (c.common.async) return Promise.all(x.map(async l => {
                        let x = { ...c,
                            common: { ...c.common,
                                issues: []
                            },
                            parent: null
                        };
                        return {
                            result: await l._parseAsync({
                                data: c.data,
                                path: c.path,
                                parent: x
                            }),
                            ctx: x
                        }
                    })).then(function(l) {
                        for (let c of l)
                            if ("valid" === c.result.status) return c.result;
                        for (let x of l)
                            if ("dirty" === x.result.status) return c.common.issues.push(...x.ctx.common.issues), x.result;
                        let x = l.map(l => new ZodError(l.ctx.common.issues));
                        return addIssueToContext(c, {
                            code: Z.invalid_union,
                            unionErrors: x
                        }), Y
                    }); {
                        let l;
                        let N = [];
                        for (let U of x) {
                            let x = { ...c,
                                    common: { ...c.common,
                                        issues: []
                                    },
                                    parent: null
                                },
                                Z = U._parseSync({
                                    data: c.data,
                                    path: c.path,
                                    parent: x
                                });
                            if ("valid" === Z.status) return Z;
                            "dirty" !== Z.status || l || (l = {
                                result: Z,
                                ctx: x
                            }), x.common.issues.length && N.push(x.common.issues)
                        }
                        if (l) return c.common.issues.push(...l.ctx.common.issues), l.result;
                        let U = N.map(l => new ZodError(l));
                        return addIssueToContext(c, {
                            code: Z.invalid_union,
                            unionErrors: U
                        }), Y
                    }
                }
                get options() {
                    return this._def.options
                }
            };
            ZodUnion.create = (l, c) => new ZodUnion({
                options: l,
                typeName: e4.ZodUnion,
                ...processCreateParams(c)
            });
            let getDiscriminator = l => {
                if (l instanceof ZodLazy) return getDiscriminator(l.schema);
                if (l instanceof ZodEffects) return getDiscriminator(l.innerType());
                if (l instanceof ZodLiteral) return [l.value];
                if (l instanceof ZodEnum) return l.options;
                if (l instanceof ZodNativeEnum) return eX.objectValues(l.enum);
                if (l instanceof ZodDefault) return getDiscriminator(l._def.innerType);
                if (l instanceof ZodUndefined) return [void 0];
                else if (l instanceof ZodNull) return [null];
                else if (l instanceof ZodOptional) return [void 0, ...getDiscriminator(l.unwrap())];
                else if (l instanceof ZodNullable) return [null, ...getDiscriminator(l.unwrap())];
                else if (l instanceof ZodBranded) return getDiscriminator(l.unwrap());
                else if (l instanceof ZodReadonly) return getDiscriminator(l.unwrap());
                else if (l instanceof ZodCatch) return getDiscriminator(l._def.innerType);
                else return []
            };
            let ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l);
                    if (c.parsedType !== U.object) return addIssueToContext(c, {
                        code: Z.invalid_type,
                        expected: U.object,
                        received: c.parsedType
                    }), Y;
                    let x = this.discriminator,
                        N = c.data[x],
                        $ = this.optionsMap.get(N);
                    return $ ? c.common.async ? $._parseAsync({
                        data: c.data,
                        path: c.path,
                        parent: c
                    }) : $._parseSync({
                        data: c.data,
                        path: c.path,
                        parent: c
                    }) : (addIssueToContext(c, {
                        code: Z.invalid_union_discriminator,
                        options: Array.from(this.optionsMap.keys()),
                        path: [x]
                    }), Y)
                }
                get discriminator() {
                    return this._def.discriminator
                }
                get options() {
                    return this._def.options
                }
                get optionsMap() {
                    return this._def.optionsMap
                }
                static create(l, c, x) {
                    let N = new Map;
                    for (let x of c) {
                        let c = getDiscriminator(x.shape[l]);
                        if (!c.length) throw Error(`A discriminator value for key \`${l}\` could not be extracted from all schema options`);
                        for (let U of c) {
                            if (N.has(U)) throw Error(`Discriminator property ${String(l)} has duplicate value ${String(U)}`);
                            N.set(U, x)
                        }
                    }
                    return new ZodDiscriminatedUnion({
                        typeName: e4.ZodDiscriminatedUnion,
                        discriminator: l,
                        options: c,
                        optionsMap: N,
                        ...processCreateParams(x)
                    })
                }
            };
            let ZodIntersection = class ZodIntersection extends ZodType {
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l), handleParsed = (l, N) => {
                        if (isAborted(l) || isAborted(N)) return Y;
                        let $ = function mergeValues(l, c) {
                            let x = getParsedType(l),
                                N = getParsedType(c);
                            if (l === c) return {
                                valid: !0,
                                data: l
                            };
                            if (x === U.object && N === U.object) {
                                let x = eX.objectKeys(c),
                                    N = eX.objectKeys(l).filter(l => -1 !== x.indexOf(l)),
                                    U = { ...l,
                                        ...c
                                    };
                                for (let x of N) {
                                    let N = mergeValues(l[x], c[x]);
                                    if (!N.valid) return {
                                        valid: !1
                                    };
                                    U[x] = N.data
                                }
                                return {
                                    valid: !0,
                                    data: U
                                }
                            }
                            if (x === U.array && N === U.array) {
                                if (l.length !== c.length) return {
                                    valid: !1
                                };
                                let x = [];
                                for (let N = 0; N < l.length; N++) {
                                    let U = l[N],
                                        Z = c[N],
                                        $ = mergeValues(U, Z);
                                    if (!$.valid) return {
                                        valid: !1
                                    };
                                    x.push($.data)
                                }
                                return {
                                    valid: !0,
                                    data: x
                                }
                            }
                            return x === U.date && N === U.date && +l == +c ? {
                                valid: !0,
                                data: l
                            } : {
                                valid: !1
                            }
                        }(l.value, N.value);
                        return $.valid ? ((isDirty(l) || isDirty(N)) && c.dirty(), {
                            status: c.value,
                            value: $.data
                        }) : (addIssueToContext(x, {
                            code: Z.invalid_intersection_types
                        }), Y)
                    };
                    return x.common.async ? Promise.all([this._def.left._parseAsync({
                        data: x.data,
                        path: x.path,
                        parent: x
                    }), this._def.right._parseAsync({
                        data: x.data,
                        path: x.path,
                        parent: x
                    })]).then(([l, c]) => handleParsed(l, c)) : handleParsed(this._def.left._parseSync({
                        data: x.data,
                        path: x.path,
                        parent: x
                    }), this._def.right._parseSync({
                        data: x.data,
                        path: x.path,
                        parent: x
                    }))
                }
            };
            ZodIntersection.create = (l, c, x) => new ZodIntersection({
                left: l,
                right: c,
                typeName: e4.ZodIntersection,
                ...processCreateParams(x)
            });
            let ZodTuple = class ZodTuple extends ZodType {
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l);
                    if (x.parsedType !== U.array) return addIssueToContext(x, {
                        code: Z.invalid_type,
                        expected: U.array,
                        received: x.parsedType
                    }), Y;
                    if (x.data.length < this._def.items.length) return addIssueToContext(x, {
                        code: Z.too_small,
                        minimum: this._def.items.length,
                        inclusive: !0,
                        exact: !1,
                        type: "array"
                    }), Y;
                    let N = this._def.rest;
                    !N && x.data.length > this._def.items.length && (addIssueToContext(x, {
                        code: Z.too_big,
                        maximum: this._def.items.length,
                        inclusive: !0,
                        exact: !1,
                        type: "array"
                    }), c.dirty());
                    let $ = [...x.data].map((l, c) => {
                        let N = this._def.items[c] || this._def.rest;
                        return N ? N._parse(new ParseInputLazyPath(x, l, x.path, c)) : null
                    }).filter(l => !!l);
                    return x.common.async ? Promise.all($).then(l => ParseStatus.mergeArray(c, l)) : ParseStatus.mergeArray(c, $)
                }
                get items() {
                    return this._def.items
                }
                rest(l) {
                    return new ZodTuple({ ...this._def,
                        rest: l
                    })
                }
            };
            ZodTuple.create = (l, c) => {
                if (!Array.isArray(l)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
                return new ZodTuple({
                    items: l,
                    typeName: e4.ZodTuple,
                    rest: null,
                    ...processCreateParams(c)
                })
            };
            let ZodRecord = class ZodRecord extends ZodType {
                get keySchema() {
                    return this._def.keyType
                }
                get valueSchema() {
                    return this._def.valueType
                }
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l);
                    if (x.parsedType !== U.object) return addIssueToContext(x, {
                        code: Z.invalid_type,
                        expected: U.object,
                        received: x.parsedType
                    }), Y;
                    let N = [],
                        $ = this._def.keyType,
                        q = this._def.valueType;
                    for (let l in x.data) N.push({
                        key: $._parse(new ParseInputLazyPath(x, l, x.path, l)),
                        value: q._parse(new ParseInputLazyPath(x, x.data[l], x.path, l)),
                        alwaysSet: l in x.data
                    });
                    return x.common.async ? ParseStatus.mergeObjectAsync(c, N) : ParseStatus.mergeObjectSync(c, N)
                }
                get element() {
                    return this._def.valueType
                }
                static create(l, c, x) {
                    return new ZodRecord(c instanceof ZodType ? {
                        keyType: l,
                        valueType: c,
                        typeName: e4.ZodRecord,
                        ...processCreateParams(x)
                    } : {
                        keyType: ZodString.create(),
                        valueType: l,
                        typeName: e4.ZodRecord,
                        ...processCreateParams(c)
                    })
                }
            };
            let ZodMap = class ZodMap extends ZodType {
                get keySchema() {
                    return this._def.keyType
                }
                get valueSchema() {
                    return this._def.valueType
                }
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l);
                    if (x.parsedType !== U.map) return addIssueToContext(x, {
                        code: Z.invalid_type,
                        expected: U.map,
                        received: x.parsedType
                    }), Y;
                    let N = this._def.keyType,
                        $ = this._def.valueType,
                        q = [...x.data.entries()].map(([l, c], U) => ({
                            key: N._parse(new ParseInputLazyPath(x, l, x.path, [U, "key"])),
                            value: $._parse(new ParseInputLazyPath(x, c, x.path, [U, "value"]))
                        }));
                    if (x.common.async) {
                        let l = new Map;
                        return Promise.resolve().then(async () => {
                            for (let x of q) {
                                let N = await x.key,
                                    U = await x.value;
                                if ("aborted" === N.status || "aborted" === U.status) return Y;
                                ("dirty" === N.status || "dirty" === U.status) && c.dirty(), l.set(N.value, U.value)
                            }
                            return {
                                status: c.value,
                                value: l
                            }
                        })
                    } {
                        let l = new Map;
                        for (let x of q) {
                            let N = x.key,
                                U = x.value;
                            if ("aborted" === N.status || "aborted" === U.status) return Y;
                            ("dirty" === N.status || "dirty" === U.status) && c.dirty(), l.set(N.value, U.value)
                        }
                        return {
                            status: c.value,
                            value: l
                        }
                    }
                }
            };
            ZodMap.create = (l, c, x) => new ZodMap({
                valueType: c,
                keyType: l,
                typeName: e4.ZodMap,
                ...processCreateParams(x)
            });
            let ZodSet = class ZodSet extends ZodType {
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l);
                    if (x.parsedType !== U.set) return addIssueToContext(x, {
                        code: Z.invalid_type,
                        expected: U.set,
                        received: x.parsedType
                    }), Y;
                    let N = this._def;
                    null !== N.minSize && x.data.size < N.minSize.value && (addIssueToContext(x, {
                        code: Z.too_small,
                        minimum: N.minSize.value,
                        type: "set",
                        inclusive: !0,
                        exact: !1,
                        message: N.minSize.message
                    }), c.dirty()), null !== N.maxSize && x.data.size > N.maxSize.value && (addIssueToContext(x, {
                        code: Z.too_big,
                        maximum: N.maxSize.value,
                        type: "set",
                        inclusive: !0,
                        exact: !1,
                        message: N.maxSize.message
                    }), c.dirty());
                    let $ = this._def.valueType;

                    function finalizeSet(l) {
                        let x = new Set;
                        for (let N of l) {
                            if ("aborted" === N.status) return Y;
                            "dirty" === N.status && c.dirty(), x.add(N.value)
                        }
                        return {
                            status: c.value,
                            value: x
                        }
                    }
                    let q = [...x.data.values()].map((l, c) => $._parse(new ParseInputLazyPath(x, l, x.path, c)));
                    return x.common.async ? Promise.all(q).then(l => finalizeSet(l)) : finalizeSet(q)
                }
                min(l, c) {
                    return new ZodSet({ ...this._def,
                        minSize: {
                            value: l,
                            message: e2.toString(c)
                        }
                    })
                }
                max(l, c) {
                    return new ZodSet({ ...this._def,
                        maxSize: {
                            value: l,
                            message: e2.toString(c)
                        }
                    })
                }
                size(l, c) {
                    return this.min(l, c).max(l, c)
                }
                nonempty(l) {
                    return this.min(1, l)
                }
            };
            ZodSet.create = (l, c) => new ZodSet({
                valueType: l,
                minSize: null,
                maxSize: null,
                typeName: e4.ZodSet,
                ...processCreateParams(c)
            });
            let ZodFunction = class ZodFunction extends ZodType {
                constructor() {
                    super(...arguments), this.validate = this.implement
                }
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l);
                    if (c.parsedType !== U.function) return addIssueToContext(c, {
                        code: Z.invalid_type,
                        expected: U.function,
                        received: c.parsedType
                    }), Y;

                    function makeArgsIssue(l, x) {
                        return makeIssue({
                            data: l,
                            path: c.path,
                            errorMaps: [c.common.contextualErrorMap, c.schemaErrorMap, getErrorMap(), errorMap].filter(l => !!l),
                            issueData: {
                                code: Z.invalid_arguments,
                                argumentsError: x
                            }
                        })
                    }

                    function makeReturnsIssue(l, x) {
                        return makeIssue({
                            data: l,
                            path: c.path,
                            errorMaps: [c.common.contextualErrorMap, c.schemaErrorMap, getErrorMap(), errorMap].filter(l => !!l),
                            issueData: {
                                code: Z.invalid_return_type,
                                returnTypeError: x
                            }
                        })
                    }
                    let x = {
                            errorMap: c.common.contextualErrorMap
                        },
                        N = c.data;
                    if (this._def.returns instanceof ZodPromise) {
                        let l = this;
                        return OK(async function(...c) {
                            let U = new ZodError([]),
                                Z = await l._def.args.parseAsync(c, x).catch(l => {
                                    throw U.addIssue(makeArgsIssue(c, l)), U
                                }),
                                $ = await Reflect.apply(N, this, Z),
                                Y = await l._def.returns._def.type.parseAsync($, x).catch(l => {
                                    throw U.addIssue(makeReturnsIssue($, l)), U
                                });
                            return Y
                        })
                    } {
                        let l = this;
                        return OK(function(...c) {
                            let U = l._def.args.safeParse(c, x);
                            if (!U.success) throw new ZodError([makeArgsIssue(c, U.error)]);
                            let Z = Reflect.apply(N, this, U.data),
                                $ = l._def.returns.safeParse(Z, x);
                            if (!$.success) throw new ZodError([makeReturnsIssue(Z, $.error)]);
                            return $.data
                        })
                    }
                }
                parameters() {
                    return this._def.args
                }
                returnType() {
                    return this._def.returns
                }
                args(...l) {
                    return new ZodFunction({ ...this._def,
                        args: ZodTuple.create(l).rest(ZodUnknown.create())
                    })
                }
                returns(l) {
                    return new ZodFunction({ ...this._def,
                        returns: l
                    })
                }
                implement(l) {
                    let c = this.parse(l);
                    return c
                }
                strictImplement(l) {
                    let c = this.parse(l);
                    return c
                }
                static create(l, c, x) {
                    return new ZodFunction({
                        args: l || ZodTuple.create([]).rest(ZodUnknown.create()),
                        returns: c || ZodUnknown.create(),
                        typeName: e4.ZodFunction,
                        ...processCreateParams(x)
                    })
                }
            };
            let ZodLazy = class ZodLazy extends ZodType {
                get schema() {
                    return this._def.getter()
                }
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l), x = this._def.getter();
                    return x._parse({
                        data: c.data,
                        path: c.path,
                        parent: c
                    })
                }
            };
            ZodLazy.create = (l, c) => new ZodLazy({
                getter: l,
                typeName: e4.ZodLazy,
                ...processCreateParams(c)
            });
            let ZodLiteral = class ZodLiteral extends ZodType {
                _parse(l) {
                    if (l.data !== this._def.value) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            received: c.data,
                            code: Z.invalid_literal,
                            expected: this._def.value
                        }), Y
                    }
                    return {
                        status: "valid",
                        value: l.data
                    }
                }
                get value() {
                    return this._def.value
                }
            };

            function createZodEnum(l, c) {
                return new ZodEnum({
                    values: l,
                    typeName: e4.ZodEnum,
                    ...processCreateParams(c)
                })
            }
            ZodLiteral.create = (l, c) => new ZodLiteral({
                value: l,
                typeName: e4.ZodLiteral,
                ...processCreateParams(c)
            });
            let ZodEnum = class ZodEnum extends ZodType {
                constructor() {
                    super(...arguments), e1.set(this, void 0)
                }
                _parse(l) {
                    if ("string" != typeof l.data) {
                        let c = this._getOrReturnCtx(l),
                            x = this._def.values;
                        return addIssueToContext(c, {
                            expected: eX.joinValues(x),
                            received: c.parsedType,
                            code: Z.invalid_type
                        }), Y
                    }
                    if (__classPrivateFieldGet(this, e1, "f") || __classPrivateFieldSet(this, e1, new Set(this._def.values), "f"), !__classPrivateFieldGet(this, e1, "f").has(l.data)) {
                        let c = this._getOrReturnCtx(l),
                            x = this._def.values;
                        return addIssueToContext(c, {
                            received: c.data,
                            code: Z.invalid_enum_value,
                            options: x
                        }), Y
                    }
                    return OK(l.data)
                }
                get options() {
                    return this._def.values
                }
                get enum() {
                    let l = {};
                    for (let c of this._def.values) l[c] = c;
                    return l
                }
                get Values() {
                    let l = {};
                    for (let c of this._def.values) l[c] = c;
                    return l
                }
                get Enum() {
                    let l = {};
                    for (let c of this._def.values) l[c] = c;
                    return l
                }
                extract(l, c = this._def) {
                    return ZodEnum.create(l, { ...this._def,
                        ...c
                    })
                }
                exclude(l, c = this._def) {
                    return ZodEnum.create(this.options.filter(c => !l.includes(c)), { ...this._def,
                        ...c
                    })
                }
            };
            e1 = new WeakMap, ZodEnum.create = createZodEnum;
            let ZodNativeEnum = class ZodNativeEnum extends ZodType {
                constructor() {
                    super(...arguments), e5.set(this, void 0)
                }
                _parse(l) {
                    let c = eX.getValidEnumValues(this._def.values),
                        x = this._getOrReturnCtx(l);
                    if (x.parsedType !== U.string && x.parsedType !== U.number) {
                        let l = eX.objectValues(c);
                        return addIssueToContext(x, {
                            expected: eX.joinValues(l),
                            received: x.parsedType,
                            code: Z.invalid_type
                        }), Y
                    }
                    if (__classPrivateFieldGet(this, e5, "f") || __classPrivateFieldSet(this, e5, new Set(eX.getValidEnumValues(this._def.values)), "f"), !__classPrivateFieldGet(this, e5, "f").has(l.data)) {
                        let l = eX.objectValues(c);
                        return addIssueToContext(x, {
                            received: x.data,
                            code: Z.invalid_enum_value,
                            options: l
                        }), Y
                    }
                    return OK(l.data)
                }
                get enum() {
                    return this._def.values
                }
            };
            e5 = new WeakMap, ZodNativeEnum.create = (l, c) => new ZodNativeEnum({
                values: l,
                typeName: e4.ZodNativeEnum,
                ...processCreateParams(c)
            });
            let ZodPromise = class ZodPromise extends ZodType {
                unwrap() {
                    return this._def.type
                }
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l);
                    if (c.parsedType !== U.promise && !1 === c.common.async) return addIssueToContext(c, {
                        code: Z.invalid_type,
                        expected: U.promise,
                        received: c.parsedType
                    }), Y;
                    let x = c.parsedType === U.promise ? c.data : Promise.resolve(c.data);
                    return OK(x.then(l => this._def.type.parseAsync(l, {
                        path: c.path,
                        errorMap: c.common.contextualErrorMap
                    })))
                }
            };
            ZodPromise.create = (l, c) => new ZodPromise({
                type: l,
                typeName: e4.ZodPromise,
                ...processCreateParams(c)
            });
            let ZodEffects = class ZodEffects extends ZodType {
                innerType() {
                    return this._def.schema
                }
                sourceType() {
                    return this._def.schema._def.typeName === e4.ZodEffects ? this._def.schema.sourceType() : this._def.schema
                }
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l), N = this._def.effect || null, U = {
                        addIssue: l => {
                            addIssueToContext(x, l), l.fatal ? c.abort() : c.dirty()
                        },
                        get path() {
                            return x.path
                        }
                    };
                    if (U.addIssue = U.addIssue.bind(U), "preprocess" === N.type) {
                        let l = N.transform(x.data, U);
                        if (x.common.async) return Promise.resolve(l).then(async l => {
                            if ("aborted" === c.value) return Y;
                            let N = await this._def.schema._parseAsync({
                                data: l,
                                path: x.path,
                                parent: x
                            });
                            return "aborted" === N.status ? Y : "dirty" === N.status || "dirty" === c.value ? DIRTY(N.value) : N
                        }); {
                            if ("aborted" === c.value) return Y;
                            let N = this._def.schema._parseSync({
                                data: l,
                                path: x.path,
                                parent: x
                            });
                            return "aborted" === N.status ? Y : "dirty" === N.status || "dirty" === c.value ? DIRTY(N.value) : N
                        }
                    }
                    if ("refinement" === N.type) {
                        let executeRefinement = l => {
                            let c = N.refinement(l, U);
                            if (x.common.async) return Promise.resolve(c);
                            if (c instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                            return l
                        };
                        if (!1 !== x.common.async) return this._def.schema._parseAsync({
                            data: x.data,
                            path: x.path,
                            parent: x
                        }).then(l => "aborted" === l.status ? Y : ("dirty" === l.status && c.dirty(), executeRefinement(l.value).then(() => ({
                            status: c.value,
                            value: l.value
                        })))); {
                            let l = this._def.schema._parseSync({
                                data: x.data,
                                path: x.path,
                                parent: x
                            });
                            return "aborted" === l.status ? Y : ("dirty" === l.status && c.dirty(), executeRefinement(l.value), {
                                status: c.value,
                                value: l.value
                            })
                        }
                    }
                    if ("transform" === N.type) {
                        if (!1 !== x.common.async) return this._def.schema._parseAsync({
                            data: x.data,
                            path: x.path,
                            parent: x
                        }).then(l => isValid(l) ? Promise.resolve(N.transform(l.value, U)).then(l => ({
                            status: c.value,
                            value: l
                        })) : l); {
                            let l = this._def.schema._parseSync({
                                data: x.data,
                                path: x.path,
                                parent: x
                            });
                            if (!isValid(l)) return l;
                            let Z = N.transform(l.value, U);
                            if (Z instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                            return {
                                status: c.value,
                                value: Z
                            }
                        }
                    }
                    eX.assertNever(N)
                }
            };
            ZodEffects.create = (l, c, x) => new ZodEffects({
                schema: l,
                typeName: e4.ZodEffects,
                effect: c,
                ...processCreateParams(x)
            }), ZodEffects.createWithPreprocess = (l, c, x) => new ZodEffects({
                schema: c,
                effect: {
                    type: "preprocess",
                    transform: l
                },
                typeName: e4.ZodEffects,
                ...processCreateParams(x)
            });
            let ZodOptional = class ZodOptional extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    return c === U.undefined ? OK(void 0) : this._def.innerType._parse(l)
                }
                unwrap() {
                    return this._def.innerType
                }
            };
            ZodOptional.create = (l, c) => new ZodOptional({
                innerType: l,
                typeName: e4.ZodOptional,
                ...processCreateParams(c)
            });
            let ZodNullable = class ZodNullable extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    return c === U.null ? OK(null) : this._def.innerType._parse(l)
                }
                unwrap() {
                    return this._def.innerType
                }
            };
            ZodNullable.create = (l, c) => new ZodNullable({
                innerType: l,
                typeName: e4.ZodNullable,
                ...processCreateParams(c)
            });
            let ZodDefault = class ZodDefault extends ZodType {
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l), x = c.data;
                    return c.parsedType === U.undefined && (x = this._def.defaultValue()), this._def.innerType._parse({
                        data: x,
                        path: c.path,
                        parent: c
                    })
                }
                removeDefault() {
                    return this._def.innerType
                }
            };
            ZodDefault.create = (l, c) => new ZodDefault({
                innerType: l,
                typeName: e4.ZodDefault,
                defaultValue: "function" == typeof c.default ? c.default : () => c.default,
                ...processCreateParams(c)
            });
            let ZodCatch = class ZodCatch extends ZodType {
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l), x = { ...c,
                        common: { ...c.common,
                            issues: []
                        }
                    }, N = this._def.innerType._parse({
                        data: x.data,
                        path: x.path,
                        parent: { ...x
                        }
                    });
                    return isAsync(N) ? N.then(l => ({
                        status: "valid",
                        value: "valid" === l.status ? l.value : this._def.catchValue({
                            get error() {
                                return new ZodError(x.common.issues)
                            },
                            input: x.data
                        })
                    })) : {
                        status: "valid",
                        value: "valid" === N.status ? N.value : this._def.catchValue({
                            get error() {
                                return new ZodError(x.common.issues)
                            },
                            input: x.data
                        })
                    }
                }
                removeCatch() {
                    return this._def.innerType
                }
            };
            ZodCatch.create = (l, c) => new ZodCatch({
                innerType: l,
                typeName: e4.ZodCatch,
                catchValue: "function" == typeof c.catch ? c.catch : () => c.catch,
                ...processCreateParams(c)
            });
            let ZodNaN = class ZodNaN extends ZodType {
                _parse(l) {
                    let c = this._getType(l);
                    if (c !== U.nan) {
                        let c = this._getOrReturnCtx(l);
                        return addIssueToContext(c, {
                            code: Z.invalid_type,
                            expected: U.nan,
                            received: c.parsedType
                        }), Y
                    }
                    return {
                        status: "valid",
                        value: l.data
                    }
                }
            };
            ZodNaN.create = l => new ZodNaN({
                typeName: e4.ZodNaN,
                ...processCreateParams(l)
            });
            let eh = Symbol("zod_brand");
            let ZodBranded = class ZodBranded extends ZodType {
                _parse(l) {
                    let {
                        ctx: c
                    } = this._processInputParams(l), x = c.data;
                    return this._def.type._parse({
                        data: x,
                        path: c.path,
                        parent: c
                    })
                }
                unwrap() {
                    return this._def.type
                }
            };
            let ZodPipeline = class ZodPipeline extends ZodType {
                _parse(l) {
                    let {
                        status: c,
                        ctx: x
                    } = this._processInputParams(l);
                    if (x.common.async) {
                        let handleAsync = async () => {
                            let l = await this._def.in._parseAsync({
                                data: x.data,
                                path: x.path,
                                parent: x
                            });
                            return "aborted" === l.status ? Y : "dirty" === l.status ? (c.dirty(), DIRTY(l.value)) : this._def.out._parseAsync({
                                data: l.value,
                                path: x.path,
                                parent: x
                            })
                        };
                        return handleAsync()
                    } {
                        let l = this._def.in._parseSync({
                            data: x.data,
                            path: x.path,
                            parent: x
                        });
                        return "aborted" === l.status ? Y : "dirty" === l.status ? (c.dirty(), {
                            status: "dirty",
                            value: l.value
                        }) : this._def.out._parseSync({
                            data: l.value,
                            path: x.path,
                            parent: x
                        })
                    }
                }
                static create(l, c) {
                    return new ZodPipeline({ in: l,
                        out: c,
                        typeName: e4.ZodPipeline
                    })
                }
            };
            let ZodReadonly = class ZodReadonly extends ZodType {
                _parse(l) {
                    let c = this._def.innerType._parse(l),
                        freeze = l => (isValid(l) && (l.value = Object.freeze(l.value)), l);
                    return isAsync(c) ? c.then(l => freeze(l)) : freeze(c)
                }
                unwrap() {
                    return this._def.innerType
                }
            };

            function custom(l, c = {}, x) {
                return l ? ZodAny.create().superRefine((N, U) => {
                    var Z, $;
                    if (!l(N)) {
                        let l = "function" == typeof c ? c(N) : "string" == typeof c ? {
                                message: c
                            } : c,
                            Y = null === ($ = null !== (Z = l.fatal) && void 0 !== Z ? Z : x) || void 0 === $ || $,
                            q = "string" == typeof l ? {
                                message: l
                            } : l;
                        U.addIssue({
                            code: "custom",
                            ...q,
                            fatal: Y
                        })
                    }
                }) : ZodAny.create()
            }
            ZodReadonly.create = (l, c) => new ZodReadonly({
                innerType: l,
                typeName: e4.ZodReadonly,
                ...processCreateParams(c)
            });
            let ey = {
                object: ZodObject.lazycreate
            };
            (eJ = e4 || (e4 = {})).ZodString = "ZodString", eJ.ZodNumber = "ZodNumber", eJ.ZodNaN = "ZodNaN", eJ.ZodBigInt = "ZodBigInt", eJ.ZodBoolean = "ZodBoolean", eJ.ZodDate = "ZodDate", eJ.ZodSymbol = "ZodSymbol", eJ.ZodUndefined = "ZodUndefined", eJ.ZodNull = "ZodNull", eJ.ZodAny = "ZodAny", eJ.ZodUnknown = "ZodUnknown", eJ.ZodNever = "ZodNever", eJ.ZodVoid = "ZodVoid", eJ.ZodArray = "ZodArray", eJ.ZodObject = "ZodObject", eJ.ZodUnion = "ZodUnion", eJ.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", eJ.ZodIntersection = "ZodIntersection", eJ.ZodTuple = "ZodTuple", eJ.ZodRecord = "ZodRecord", eJ.ZodMap = "ZodMap", eJ.ZodSet = "ZodSet", eJ.ZodFunction = "ZodFunction", eJ.ZodLazy = "ZodLazy", eJ.ZodLiteral = "ZodLiteral", eJ.ZodEnum = "ZodEnum", eJ.ZodEffects = "ZodEffects", eJ.ZodNativeEnum = "ZodNativeEnum", eJ.ZodOptional = "ZodOptional", eJ.ZodNullable = "ZodNullable", eJ.ZodDefault = "ZodDefault", eJ.ZodCatch = "ZodCatch", eJ.ZodPromise = "ZodPromise", eJ.ZodBranded = "ZodBranded", eJ.ZodPipeline = "ZodPipeline", eJ.ZodReadonly = "ZodReadonly";
            let ef = ZodString.create,
                em = ZodNumber.create,
                eg = ZodNaN.create,
                eb = ZodBigInt.create,
                ev = ZodBoolean.create,
                ew = ZodDate.create,
                eT = ZodSymbol.create,
                eM = ZodUndefined.create,
                eI = ZodNull.create,
                ex = ZodAny.create,
                eC = ZodUnknown.create,
                e_ = ZodNever.create,
                eD = ZodVoid.create,
                eS = ZodArray.create,
                ek = ZodObject.create,
                eE = ZodObject.strictCreate,
                eN = ZodUnion.create,
                eA = ZodDiscriminatedUnion.create,
                ej = ZodIntersection.create,
                eO = ZodTuple.create,
                eP = ZodRecord.create,
                ez = ZodMap.create,
                eR = ZodSet.create,
                eL = ZodFunction.create,
                eB = ZodLazy.create,
                eU = ZodLiteral.create,
                eF = ZodEnum.create,
                eW = ZodNativeEnum.create,
                eZ = ZodPromise.create,
                eQ = ZodEffects.create,
                eH = ZodOptional.create,
                e$ = ZodNullable.create,
                eY = ZodEffects.createWithPreprocess,
                eG = ZodPipeline.create;
            var eV, eK, eJ, eX, e0, e2, e1, e5, e4, e3 = Object.freeze({
                __proto__: null,
                defaultErrorMap: errorMap,
                setErrorMap: function(l) {
                    $ = l
                },
                getErrorMap: getErrorMap,
                makeIssue: makeIssue,
                EMPTY_PATH: [],
                addIssueToContext: addIssueToContext,
                ParseStatus: ParseStatus,
                INVALID: Y,
                DIRTY: DIRTY,
                OK: OK,
                isAborted: isAborted,
                isDirty: isDirty,
                isValid: isValid,
                isAsync: isAsync,
                get util() {
                    return eX
                },
                get objectUtil() {
                    return e0
                },
                ZodParsedType: U,
                getParsedType: getParsedType,
                ZodType: ZodType,
                datetimeRegex: datetimeRegex,
                ZodString: ZodString,
                ZodNumber: ZodNumber,
                ZodBigInt: ZodBigInt,
                ZodBoolean: ZodBoolean,
                ZodDate: ZodDate,
                ZodSymbol: ZodSymbol,
                ZodUndefined: ZodUndefined,
                ZodNull: ZodNull,
                ZodAny: ZodAny,
                ZodUnknown: ZodUnknown,
                ZodNever: ZodNever,
                ZodVoid: ZodVoid,
                ZodArray: ZodArray,
                ZodObject: ZodObject,
                ZodUnion: ZodUnion,
                ZodDiscriminatedUnion: ZodDiscriminatedUnion,
                ZodIntersection: ZodIntersection,
                ZodTuple: ZodTuple,
                ZodRecord: ZodRecord,
                ZodMap: ZodMap,
                ZodSet: ZodSet,
                ZodFunction: ZodFunction,
                ZodLazy: ZodLazy,
                ZodLiteral: ZodLiteral,
                ZodEnum: ZodEnum,
                ZodNativeEnum: ZodNativeEnum,
                ZodPromise: ZodPromise,
                ZodEffects: ZodEffects,
                ZodTransformer: ZodEffects,
                ZodOptional: ZodOptional,
                ZodNullable: ZodNullable,
                ZodDefault: ZodDefault,
                ZodCatch: ZodCatch,
                ZodNaN: ZodNaN,
                BRAND: eh,
                ZodBranded: ZodBranded,
                ZodPipeline: ZodPipeline,
                ZodReadonly: ZodReadonly,
                custom: custom,
                Schema: ZodType,
                ZodSchema: ZodType,
                late: ey,
                get ZodFirstPartyTypeKind() {
                    return e4
                },
                coerce: {
                    string: l => ZodString.create({ ...l,
                        coerce: !0
                    }),
                    number: l => ZodNumber.create({ ...l,
                        coerce: !0
                    }),
                    boolean: l => ZodBoolean.create({ ...l,
                        coerce: !0
                    }),
                    bigint: l => ZodBigInt.create({ ...l,
                        coerce: !0
                    }),
                    date: l => ZodDate.create({ ...l,
                        coerce: !0
                    })
                },
                any: ex,
                array: eS,
                bigint: eb,
                boolean: ev,
                date: ew,
                discriminatedUnion: eA,
                effect: eQ,
                enum: eF,
                function: eL,
                instanceof: (l, c = {
                    message: `Input not instance of ${l.name}`
                }) => custom(c => c instanceof l, c),
                intersection: ej,
                lazy: eB,
                literal: eU,
                map: ez,
                nan: eg,
                nativeEnum: eW,
                never: e_,
                null: eI,
                nullable: e$,
                number: em,
                object: ek,
                oboolean: () => ev().optional(),
                onumber: () => em().optional(),
                optional: eH,
                ostring: () => ef().optional(),
                pipeline: eG,
                preprocess: eY,
                promise: eZ,
                record: eP,
                set: eR,
                strictObject: eE,
                string: ef,
                symbol: eT,
                transformer: eQ,
                tuple: eO,
                undefined: eM,
                union: eN,
                unknown: eC,
                void: eD,
                NEVER: Y,
                ZodIssueCode: Z,
                quotelessJson: l => {
                    let c = JSON.stringify(l, null, 2);
                    return c.replace(/"([^"]+)":/g, "$1:")
                },
                ZodError: ZodError
            })
        },
        46762: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"address","name":"_trustedForwarder","type":"address"},{"internalType":"contract IContractPublisher","name":"_prevPublisher","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"publisher","type":"address"},{"components":[{"internalType":"string","name":"contractId","type":"string"},{"internalType":"uint256","name":"publishTimestamp","type":"uint256"},{"internalType":"string","name":"publishMetadataUri","type":"string"},{"internalType":"bytes32","name":"bytecodeHash","type":"bytes32"},{"internalType":"address","name":"implementation","type":"address"}],"indexed":false,"internalType":"struct IContractPublisher.CustomContractInstance","name":"publishedContract","type":"tuple"}],"name":"ContractPublished","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"publisher","type":"address"},{"indexed":true,"internalType":"string","name":"contractId","type":"string"}],"name":"ContractUnpublished","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bool","name":"isPaused","type":"bool"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"publisher","type":"address"},{"indexed":false,"internalType":"string","name":"prevURI","type":"string"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"}],"name":"PublisherProfileUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_publisher","type":"address"}],"name":"getAllPublishedContracts","outputs":[{"components":[{"internalType":"string","name":"contractId","type":"string"},{"internalType":"uint256","name":"publishTimestamp","type":"uint256"},{"internalType":"string","name":"publishMetadataUri","type":"string"},{"internalType":"bytes32","name":"bytecodeHash","type":"bytes32"},{"internalType":"address","name":"implementation","type":"address"}],"internalType":"struct IContractPublisher.CustomContractInstance[]","name":"published","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_publisher","type":"address"},{"internalType":"string","name":"_contractId","type":"string"}],"name":"getPublishedContract","outputs":[{"components":[{"internalType":"string","name":"contractId","type":"string"},{"internalType":"uint256","name":"publishTimestamp","type":"uint256"},{"internalType":"string","name":"publishMetadataUri","type":"string"},{"internalType":"bytes32","name":"bytecodeHash","type":"bytes32"},{"internalType":"address","name":"implementation","type":"address"}],"internalType":"struct IContractPublisher.CustomContractInstance","name":"published","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_publisher","type":"address"},{"internalType":"string","name":"_contractId","type":"string"}],"name":"getPublishedContractVersions","outputs":[{"components":[{"internalType":"string","name":"contractId","type":"string"},{"internalType":"uint256","name":"publishTimestamp","type":"uint256"},{"internalType":"string","name":"publishMetadataUri","type":"string"},{"internalType":"bytes32","name":"bytecodeHash","type":"bytes32"},{"internalType":"address","name":"implementation","type":"address"}],"internalType":"struct IContractPublisher.CustomContractInstance[]","name":"published","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"compilerMetadataUri","type":"string"}],"name":"getPublishedUriFromCompilerUri","outputs":[{"internalType":"string[]","name":"publishedMetadataUris","type":"string[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"publisher","type":"address"}],"name":"getPublisherProfileUri","outputs":[{"internalType":"string","name":"uri","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isPaused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"name":"isTrustedForwarder","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"prevPublisher","outputs":[{"internalType":"contract IContractPublisher","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_publisher","type":"address"},{"internalType":"string","name":"_contractId","type":"string"},{"internalType":"string","name":"_publishMetadataUri","type":"string"},{"internalType":"string","name":"_compilerMetadataUri","type":"string"},{"internalType":"bytes32","name":"_bytecodeHash","type":"bytes32"},{"internalType":"address","name":"_implementation","type":"address"}],"name":"publishContract","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_pause","type":"bool"}],"name":"setPause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"publisher","type":"address"},{"internalType":"string","name":"uri","type":"string"}],"name":"setPublisherProfileUri","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_publisher","type":"address"},{"internalType":"string","name":"_contractId","type":"string"}],"name":"unpublishContract","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        61303: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"gas","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Forwarder.ForwardRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"execute","outputs":[{"internalType":"bool","name":"","type":"bool"},{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"}],"name":"getNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"gas","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"internalType":"struct Forwarder.ForwardRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        97258: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"initCode","type":"bytes"},{"internalType":"bytes","name":"callData","type":"bytes"},{"internalType":"uint256","name":"callGasLimit","type":"uint256"},{"internalType":"uint256","name":"verificationGasLimit","type":"uint256"},{"internalType":"uint256","name":"preVerificationGas","type":"uint256"},{"internalType":"uint256","name":"maxFeePerGas","type":"uint256"},{"internalType":"uint256","name":"maxPriorityFeePerGas","type":"uint256"},{"internalType":"bytes","name":"paymasterAndData","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"internalType":"struct UserOperation","name":"userOp","type":"tuple"},{"internalType":"bytes32","name":"userOpHash","type":"bytes32"},{"internalType":"uint256","name":"missingAccountFunds","type":"uint256"}],"name":"validateUserOp","outputs":[{"internalType":"uint256","name":"validationData","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        92063: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"accountAdmin","type":"address"}],"name":"AccountCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"signer","type":"address"}],"name":"SignerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"signer","type":"address"}],"name":"SignerRemoved","type":"event"},{"inputs":[],"name":"accountImplementation","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"admin","type":"address"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"createAccount","outputs":[{"internalType":"address","name":"account","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"signer","type":"address"}],"name":"getAccountsOfSigner","outputs":[{"internalType":"address[]","name":"accounts","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"adminSigner","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"getAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAllAccounts","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"}]')
        },
        26644: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"signer","type":"address"},{"indexed":false,"internalType":"bool","name":"isAdmin","type":"bool"}],"name":"AdminUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"authorizingSigner","type":"address"},{"indexed":true,"internalType":"address","name":"targetSigner","type":"address"},{"components":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address[]","name":"approvedTargets","type":"address[]"},{"internalType":"uint256","name":"nativeTokenLimitPerTransaction","type":"uint256"},{"internalType":"uint128","name":"permissionStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"permissionEndTimestamp","type":"uint128"},{"internalType":"uint128","name":"reqValidityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"reqValidityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"indexed":false,"internalType":"struct IAccountPermissions.SignerPermissionRequest","name":"permissions","type":"tuple"}],"name":"SignerPermissionsUpdated","type":"event"},{"inputs":[],"name":"getAllActiveSigners","outputs":[{"components":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address[]","name":"approvedTargets","type":"address[]"},{"internalType":"uint256","name":"nativeTokenLimitPerTransaction","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"}],"internalType":"struct IAccountPermissions.SignerPermissions[]","name":"signers","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAllAdmins","outputs":[{"internalType":"address[]","name":"admins","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAllSigners","outputs":[{"components":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address[]","name":"approvedTargets","type":"address[]"},{"internalType":"uint256","name":"nativeTokenLimitPerTransaction","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"}],"internalType":"struct IAccountPermissions.SignerPermissions[]","name":"signers","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"signer","type":"address"}],"name":"getPermissionsForSigner","outputs":[{"components":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address[]","name":"approvedTargets","type":"address[]"},{"internalType":"uint256","name":"nativeTokenLimitPerTransaction","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"}],"internalType":"struct IAccountPermissions.SignerPermissions","name":"permissions","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"signer","type":"address"}],"name":"isActiveSigner","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"signer","type":"address"}],"name":"isAdmin","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bool","name":"isAdmin","type":"bool"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address[]","name":"approvedTargets","type":"address[]"},{"internalType":"uint256","name":"nativeTokenLimitPerTransaction","type":"uint256"},{"internalType":"uint128","name":"permissionStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"permissionEndTimestamp","type":"uint128"},{"internalType":"uint128","name":"reqValidityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"reqValidityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct IAccountPermissions.SignerPermissionRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"setPermissionsForSigner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"signer","type":"address"},{"internalType":"address[]","name":"approvedTargets","type":"address[]"},{"internalType":"uint256","name":"nativeTokenLimitPerTransaction","type":"uint256"},{"internalType":"uint128","name":"permissionStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"permissionEndTimestamp","type":"uint128"},{"internalType":"uint128","name":"reqValidityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"reqValidityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct IAccountPermissions.SignerPermissionRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"verifySignerPermissionRequest","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"view","type":"function"}]')
        },
        15560: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"tokenAddress","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"AirdropFailed","type":"event"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"tokenOwner","type":"address"},{"components":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct IAirdropERC1155.AirdropContent[]","name":"contents","type":"tuple[]"}],"name":"airdropERC1155","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        68133: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"tokenAddress","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"AirdropFailed","type":"event"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"tokenOwner","type":"address"},{"components":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct IAirdropERC20.AirdropContent[]","name":"contents","type":"tuple[]"}],"name":"airdropERC20","outputs":[],"stateMutability":"payable","type":"function"}]')
        },
        98730: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"tokenAddress","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"AirdropFailed","type":"event"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"address","name":"tokenOwner","type":"address"},{"components":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"internalType":"struct IAirdropERC721.AirdropContent[]","name":"contents","type":"tuple[]"}],"name":"airdropERC721","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        23194: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"prevURI","type":"string"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"}],"name":"AppURIUpdated","type":"event"},{"inputs":[],"name":"appURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_uri","type":"string"}],"name":"setAppURI","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        70357: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"uint256[]","name":"values","type":"uint256[]"}],"name":"burnBatch","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        83230: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        62281: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        1728: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"_receiver","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"},{"internalType":"uint256","name":"_quantity","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_claimer","type":"address"},{"internalType":"uint256","name":"_tokenId","type":"uint256"},{"internalType":"uint256","name":"_quantity","type":"uint256"}],"name":"verifyClaim","outputs":[],"stateMutability":"view","type":"function"}]')
        },
        29691: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"_receiver","type":"address"},{"internalType":"uint256","name":"_quantity","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_claimer","type":"address"},{"internalType":"uint256","name":"_quantity","type":"uint256"}],"name":"verifyClaim","outputs":[],"stateMutability":"view","type":"function"}]')
        },
        9748: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"prevURI","type":"string"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"}],"name":"ContractURIUpdated","type":"event"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"_uri","type":"string"}],"name":"setContractURI","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        28329: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"index","type":"uint256"},{"indexed":false,"internalType":"string","name":"revealedURI","type":"string"}],"name":"TokenURIRevealed","type":"event"},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"bytes","name":"key","type":"bytes"}],"name":"encryptDecrypt","outputs":[{"internalType":"bytes","name":"result","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"identifier","type":"uint256"},{"internalType":"bytes","name":"key","type":"bytes"}],"name":"reveal","outputs":[{"internalType":"string","name":"revealedURI","type":"string"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        5834: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"index","type":"uint256"},{"indexed":false,"internalType":"string","name":"revealedURI","type":"string"}],"name":"TokenURIRevealed","type":"event"},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"bytes","name":"key","type":"bytes"}],"name":"encryptDecrypt","outputs":[{"internalType":"bytes","name":"result","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"identifier","type":"uint256"}],"name":"encryptedBaseURI","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"identifier","type":"uint256"},{"internalType":"bytes","name":"key","type":"bytes"}],"name":"reveal","outputs":[{"internalType":"string","name":"revealedURI","type":"string"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        96409: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"listingId","type":"uint256"},{"indexed":true,"internalType":"address","name":"buyer","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"BuyerApprovedForListing","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"listingCreator","type":"address"},{"indexed":true,"internalType":"uint256","name":"listingId","type":"uint256"}],"name":"CancelledListing","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"listingId","type":"uint256"},{"indexed":true,"internalType":"address","name":"currency","type":"address"},{"indexed":false,"internalType":"uint256","name":"pricePerToken","type":"uint256"}],"name":"CurrencyApprovedForListing","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"listingCreator","type":"address"},{"indexed":true,"internalType":"uint256","name":"listingId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"components":[{"internalType":"uint256","name":"listingId","type":"uint256"},{"internalType":"address","name":"listingCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"},{"internalType":"enum IDirectListings.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IDirectListings.Status","name":"status","type":"uint8"}],"indexed":false,"internalType":"struct IDirectListings.Listing","name":"listing","type":"tuple"}],"name":"NewListing","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"listingCreator","type":"address"},{"indexed":true,"internalType":"uint256","name":"listingId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"buyer","type":"address"},{"indexed":false,"internalType":"uint256","name":"quantityBought","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalPricePaid","type":"uint256"}],"name":"NewSale","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"listingCreator","type":"address"},{"indexed":true,"internalType":"uint256","name":"listingId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"components":[{"internalType":"uint256","name":"listingId","type":"uint256"},{"internalType":"address","name":"listingCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"},{"internalType":"enum IDirectListings.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IDirectListings.Status","name":"status","type":"uint8"}],"indexed":false,"internalType":"struct IDirectListings.Listing","name":"listing","type":"tuple"}],"name":"UpdatedListing","type":"event"},{"inputs":[{"internalType":"uint256","name":"_listingId","type":"uint256"},{"internalType":"address","name":"_buyer","type":"address"},{"internalType":"bool","name":"_toApprove","type":"bool"}],"name":"approveBuyerForListing","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_listingId","type":"uint256"},{"internalType":"address","name":"_currency","type":"address"},{"internalType":"uint256","name":"_pricePerTokenInCurrency","type":"uint256"}],"name":"approveCurrencyForListing","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_listingId","type":"uint256"},{"internalType":"address","name":"_buyFor","type":"address"},{"internalType":"uint256","name":"_quantity","type":"uint256"},{"internalType":"address","name":"_currency","type":"address"},{"internalType":"uint256","name":"_expectedTotalPrice","type":"uint256"}],"name":"buyFromListing","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_listingId","type":"uint256"}],"name":"cancelListing","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"}],"internalType":"struct IDirectListings.ListingParameters","name":"_params","type":"tuple"}],"name":"createListing","outputs":[{"internalType":"uint256","name":"listingId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startId","type":"uint256"},{"internalType":"uint256","name":"_endId","type":"uint256"}],"name":"getAllListings","outputs":[{"components":[{"internalType":"uint256","name":"listingId","type":"uint256"},{"internalType":"address","name":"listingCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"},{"internalType":"enum IDirectListings.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IDirectListings.Status","name":"status","type":"uint8"}],"internalType":"struct IDirectListings.Listing[]","name":"listings","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startId","type":"uint256"},{"internalType":"uint256","name":"_endId","type":"uint256"}],"name":"getAllValidListings","outputs":[{"components":[{"internalType":"uint256","name":"listingId","type":"uint256"},{"internalType":"address","name":"listingCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"},{"internalType":"enum IDirectListings.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IDirectListings.Status","name":"status","type":"uint8"}],"internalType":"struct IDirectListings.Listing[]","name":"listings","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_listingId","type":"uint256"}],"name":"getListing","outputs":[{"components":[{"internalType":"uint256","name":"listingId","type":"uint256"},{"internalType":"address","name":"listingCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"},{"internalType":"enum IDirectListings.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IDirectListings.Status","name":"status","type":"uint8"}],"internalType":"struct IDirectListings.Listing","name":"listing","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalListings","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_listingId","type":"uint256"},{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"uint128","name":"startTimestamp","type":"uint128"},{"internalType":"uint128","name":"endTimestamp","type":"uint128"},{"internalType":"bool","name":"reserved","type":"bool"}],"internalType":"struct IDirectListings.ListingParameters","name":"_params","type":"tuple"}],"name":"updateListing","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        58478: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"indexed":false,"internalType":"struct IClaimCondition.ClaimCondition[]","name":"claimConditions","type":"tuple[]"},{"indexed":false,"internalType":"bool","name":"resetEligibility","type":"bool"}],"name":"ClaimConditionsUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"claimConditionIndex","type":"uint256"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"components":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDrop.AllowlistProof","name":"allowlistProof","type":"tuple"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"internalType":"struct IClaimCondition.ClaimCondition[]","name":"phases","type":"tuple[]"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        17845: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"indexed":false,"internalType":"struct IClaimCondition.ClaimCondition[]","name":"claimConditions","type":"tuple[]"},{"indexed":false,"internalType":"bool","name":"resetEligibility","type":"bool"}],"name":"ClaimConditionsUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"claimConditionIndex","type":"uint256"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"components":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDrop1155.AllowlistProof","name":"allowlistProof","type":"tuple"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"internalType":"struct IClaimCondition.ClaimCondition[]","name":"phases","type":"tuple[]"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        39046: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"indexed":false,"internalType":"struct IDropClaimCondition_V2.ClaimCondition[]","name":"claimConditions","type":"tuple[]"}],"name":"ClaimConditionsUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxTotalSupply","type":"uint256"}],"name":"MaxTotalSupplyUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"count","type":"uint256"}],"name":"MaxWalletClaimCountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"saleRecipient","type":"address"}],"name":"SaleRecipientForTokenUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"claimConditionIndex","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":false,"internalType":"address","name":"receiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endTokenId","type":"uint256"},{"indexed":false,"internalType":"string","name":"baseURI","type":"string"}],"name":"TokensLazyMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256[]","name":"values","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"value","type":"string"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"}],"name":"URI","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"wallet","type":"address"},{"indexed":false,"internalType":"uint256","name":"count","type":"uint256"}],"name":"WalletClaimCountUpdated","type":"event"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"accounts","type":"address[]"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"}],"name":"balanceOfBatch","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"bytes32[]","name":"proofs","type":"bytes32[]"},{"internalType":"uint256","name":"proofMaxQuantityPerTransaction","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"baseURIForTokens","type":"string"}],"name":"lazyMint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeBatchTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDropClaimCondition_V2.ClaimCondition[]","name":"phases","type":"tuple[]"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        90863: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"indexed":false,"internalType":"struct IDropClaimCondition_V2.ClaimCondition[]","name":"claimConditions","type":"tuple[]"}],"name":"ClaimConditionsUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"prevURI","type":"string"},{"indexed":false,"internalType":"string","name":"newURI","type":"string"}],"name":"ContractURIUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"maxTotalSupply","type":"uint256"}],"name":"MaxTotalSupplyUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"count","type":"uint256"}],"name":"MaxWalletClaimCountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"claimConditionIndex","type":"uint256"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"wallet","type":"address"},{"indexed":false,"internalType":"uint256","name":"count","type":"uint256"}],"name":"WalletClaimCountUpdated","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"bytes32[]","name":"proofs","type":"bytes32[]"},{"internalType":"uint256","name":"proofMaxQuantityPerTransaction","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDropClaimCondition_V2.ClaimCondition[]","name":"phases","type":"tuple[]"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        99818: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"indexed":false,"internalType":"struct IDropClaimCondition_V2.ClaimCondition[]","name":"claimConditions","type":"tuple[]"}],"name":"ClaimConditionsUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"maxTotalSupply","type":"uint256"}],"name":"MaxTotalSupplyUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"count","type":"uint256"}],"name":"MaxWalletClaimCountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"endTokenId","type":"uint256"},{"indexed":false,"internalType":"string","name":"revealedURI","type":"string"}],"name":"NFTRevealed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"claimConditionIndex","type":"uint256"},{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endTokenId","type":"uint256"},{"indexed":false,"internalType":"string","name":"baseURI","type":"string"},{"indexed":false,"internalType":"bytes","name":"encryptedBaseURI","type":"bytes"}],"name":"TokensLazyMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"wallet","type":"address"},{"indexed":false,"internalType":"uint256","name":"count","type":"uint256"}],"name":"WalletClaimCountUpdated","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"bytes32[]","name":"proofs","type":"bytes32[]"},{"internalType":"uint256","name":"proofMaxQuantityPerTransaction","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"operator","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"baseURIForTokens","type":"string"},{"internalType":"bytes","name":"encryptedBaseURI","type":"bytes"}],"name":"lazyMint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"owner","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDropClaimCondition_V2.ClaimCondition[]","name":"phases","type":"tuple[]"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        4129: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"indexed":false,"internalType":"struct IClaimCondition.ClaimCondition","name":"condition","type":"tuple"},{"indexed":false,"internalType":"bool","name":"resetEligibility","type":"bool"}],"name":"ClaimConditionUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"components":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDropSinglePhase.AllowlistProof","name":"allowlistProof","type":"tuple"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"internalType":"struct IClaimCondition.ClaimCondition","name":"phase","type":"tuple"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        60805: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"indexed":false,"internalType":"struct IClaimCondition.ClaimCondition","name":"condition","type":"tuple"},{"indexed":false,"internalType":"bool","name":"resetEligibility","type":"bool"}],"name":"ClaimConditionUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"components":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IDropSinglePhase1155.AllowlistProof","name":"allowlistProof","type":"tuple"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerWallet","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"string","name":"metadata","type":"string"}],"internalType":"struct IClaimCondition.ClaimCondition","name":"phase","type":"tuple"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        18128: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"indexed":false,"internalType":"struct IClaimCondition_V1.ClaimCondition","name":"condition","type":"tuple"},{"indexed":false,"internalType":"bool","name":"resetEligibility","type":"bool"}],"name":"ClaimConditionUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"components":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"},{"internalType":"uint256","name":"maxQuantityInAllowlist","type":"uint256"}],"internalType":"struct IDropSinglePhase1155_V1.AllowlistProof","name":"allowlistProof","type":"tuple"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IClaimCondition_V1.ClaimCondition","name":"phase","type":"tuple"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        14565: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"indexed":false,"internalType":"struct IClaimCondition_V1.ClaimCondition","name":"condition","type":"tuple"},{"indexed":false,"internalType":"bool","name":"resetEligibility","type":"bool"}],"name":"ClaimConditionUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"claimer","type":"address"},{"indexed":true,"internalType":"address","name":"receiver","type":"address"},{"indexed":true,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantityClaimed","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"components":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"},{"internalType":"uint256","name":"maxQuantityInAllowlist","type":"uint256"}],"internalType":"struct IDropSinglePhase_V1.AllowlistProof","name":"allowlistProof","type":"tuple"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"startTimestamp","type":"uint256"},{"internalType":"uint256","name":"maxClaimableSupply","type":"uint256"},{"internalType":"uint256","name":"supplyClaimed","type":"uint256"},{"internalType":"uint256","name":"quantityLimitPerTransaction","type":"uint256"},{"internalType":"uint256","name":"waitTimeInSecondsBetweenClaims","type":"uint256"},{"internalType":"bytes32","name":"merkleRoot","type":"bytes32"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"}],"internalType":"struct IClaimCondition_V1.ClaimCondition","name":"phase","type":"tuple"},{"internalType":"bool","name":"resetClaimEligibility","type":"bool"}],"name":"setClaimConditions","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        10506: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_owner","type":"address"},{"indexed":true,"internalType":"address","name":"_operator","type":"address"},{"indexed":false,"internalType":"bool","name":"_approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_operator","type":"address"},{"indexed":true,"internalType":"address","name":"_from","type":"address"},{"indexed":true,"internalType":"address","name":"_to","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"_ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256[]","name":"_values","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_operator","type":"address"},{"indexed":true,"internalType":"address","name":"_from","type":"address"},{"indexed":true,"internalType":"address","name":"_to","type":"address"},{"indexed":false,"internalType":"uint256","name":"_id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_value","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"_value","type":"string"},{"indexed":true,"internalType":"uint256","name":"_id","type":"uint256"}],"name":"URI","type":"event"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"_owners","type":"address[]"},{"internalType":"uint256[]","name":"_ids","type":"uint256[]"}],"name":"balanceOfBatch","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256[]","name":"_ids","type":"uint256[]"},{"internalType":"uint256[]","name":"_values","type":"uint256[]"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeBatchTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"_value","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_operator","type":"address"},{"internalType":"bool","name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        56011: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"nextTokenIdToMint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]')
        },
        31617: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"uri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}]')
        },
        38925: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]')
        },
        31787: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        54497: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"who","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        61053: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}]')
        },
        38649: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        73496: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"address","name":"forwarder","type":"address"}],"name":"isTrustedForwarder","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        32557: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        62984: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"ApprovalCallerNotOwnerNorApproved","type":"error"},{"inputs":[],"name":"ApprovalQueryForNonexistentToken","type":"error"},{"inputs":[],"name":"BalanceQueryForZeroAddress","type":"error"},{"inputs":[],"name":"InvalidQueryRange","type":"error"},{"inputs":[],"name":"MintERC2309QuantityExceedsLimit","type":"error"},{"inputs":[],"name":"MintToZeroAddress","type":"error"},{"inputs":[],"name":"MintZeroQuantity","type":"error"},{"inputs":[],"name":"OwnerQueryForNonexistentToken","type":"error"},{"inputs":[],"name":"OwnershipNotInitializedForExtraData","type":"error"},{"inputs":[],"name":"TransferCallerNotOwnerNorApproved","type":"error"},{"inputs":[],"name":"TransferFromIncorrectOwner","type":"error"},{"inputs":[],"name":"TransferToNonERC721ReceiverImplementer","type":"error"},{"inputs":[],"name":"TransferToZeroAddress","type":"error"},{"inputs":[],"name":"URIQueryForNonexistentToken","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"fromTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"toTokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"}],"name":"ConsecutiveTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"explicitOwnershipOf","outputs":[{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"bool","name":"burned","type":"bool"},{"internalType":"uint24","name":"extraData","type":"uint24"}],"internalType":"struct IERC721AUpgradeable.TokenOwnership","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"operator","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"owner","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"tokensOfOwner","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"start","type":"uint256"},{"internalType":"uint256","name":"stop","type":"uint256"}],"name":"tokensOfOwnerIn","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"payable","type":"function"}]')
        },
        18125: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"uint256","name":"_index","type":"uint256"}],"name":"tokenByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"uint256","name":"_index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]')
        },
        19115: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}]')
        },
        41730: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]')
        },
        97463: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"auctionId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"indexed":true,"internalType":"address","name":"closer","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"auctionCreator","type":"address"},{"indexed":false,"internalType":"address","name":"winningBidder","type":"address"}],"name":"AuctionClosed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"auctionCreator","type":"address"},{"indexed":true,"internalType":"uint256","name":"auctionId","type":"uint256"}],"name":"CancelledAuction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"auctionCreator","type":"address"},{"indexed":true,"internalType":"uint256","name":"auctionId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"components":[{"internalType":"uint256","name":"auctionId","type":"uint256"},{"internalType":"address","name":"auctionCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"minimumBidAmount","type":"uint256"},{"internalType":"uint256","name":"buyoutBidAmount","type":"uint256"},{"internalType":"uint64","name":"timeBufferInSeconds","type":"uint64"},{"internalType":"uint64","name":"bidBufferBps","type":"uint64"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"uint64","name":"endTimestamp","type":"uint64"},{"internalType":"enum IEnglishAuctions.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IEnglishAuctions.Status","name":"status","type":"uint8"}],"indexed":false,"internalType":"struct IEnglishAuctions.Auction","name":"auction","type":"tuple"}],"name":"NewAuction","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"auctionId","type":"uint256"},{"indexed":true,"internalType":"address","name":"bidder","type":"address"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"indexed":false,"internalType":"uint256","name":"bidAmount","type":"uint256"},{"components":[{"internalType":"uint256","name":"auctionId","type":"uint256"},{"internalType":"address","name":"auctionCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"minimumBidAmount","type":"uint256"},{"internalType":"uint256","name":"buyoutBidAmount","type":"uint256"},{"internalType":"uint64","name":"timeBufferInSeconds","type":"uint64"},{"internalType":"uint64","name":"bidBufferBps","type":"uint64"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"uint64","name":"endTimestamp","type":"uint64"},{"internalType":"enum IEnglishAuctions.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IEnglishAuctions.Status","name":"status","type":"uint8"}],"indexed":false,"internalType":"struct IEnglishAuctions.Auction","name":"auction","type":"tuple"}],"name":"NewBid","type":"event"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"},{"internalType":"uint256","name":"_bidAmount","type":"uint256"}],"name":"bidInAuction","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"}],"name":"cancelAuction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"}],"name":"collectAuctionPayout","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"}],"name":"collectAuctionTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"minimumBidAmount","type":"uint256"},{"internalType":"uint256","name":"buyoutBidAmount","type":"uint256"},{"internalType":"uint64","name":"timeBufferInSeconds","type":"uint64"},{"internalType":"uint64","name":"bidBufferBps","type":"uint64"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"uint64","name":"endTimestamp","type":"uint64"}],"internalType":"struct IEnglishAuctions.AuctionParameters","name":"_params","type":"tuple"}],"name":"createAuction","outputs":[{"internalType":"uint256","name":"auctionId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startId","type":"uint256"},{"internalType":"uint256","name":"_endId","type":"uint256"}],"name":"getAllAuctions","outputs":[{"components":[{"internalType":"uint256","name":"auctionId","type":"uint256"},{"internalType":"address","name":"auctionCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"minimumBidAmount","type":"uint256"},{"internalType":"uint256","name":"buyoutBidAmount","type":"uint256"},{"internalType":"uint64","name":"timeBufferInSeconds","type":"uint64"},{"internalType":"uint64","name":"bidBufferBps","type":"uint64"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"uint64","name":"endTimestamp","type":"uint64"},{"internalType":"enum IEnglishAuctions.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IEnglishAuctions.Status","name":"status","type":"uint8"}],"internalType":"struct IEnglishAuctions.Auction[]","name":"auctions","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startId","type":"uint256"},{"internalType":"uint256","name":"_endId","type":"uint256"}],"name":"getAllValidAuctions","outputs":[{"components":[{"internalType":"uint256","name":"auctionId","type":"uint256"},{"internalType":"address","name":"auctionCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"minimumBidAmount","type":"uint256"},{"internalType":"uint256","name":"buyoutBidAmount","type":"uint256"},{"internalType":"uint64","name":"timeBufferInSeconds","type":"uint64"},{"internalType":"uint64","name":"bidBufferBps","type":"uint64"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"uint64","name":"endTimestamp","type":"uint64"},{"internalType":"enum IEnglishAuctions.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IEnglishAuctions.Status","name":"status","type":"uint8"}],"internalType":"struct IEnglishAuctions.Auction[]","name":"auctions","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"}],"name":"getAuction","outputs":[{"components":[{"internalType":"uint256","name":"auctionId","type":"uint256"},{"internalType":"address","name":"auctionCreator","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"minimumBidAmount","type":"uint256"},{"internalType":"uint256","name":"buyoutBidAmount","type":"uint256"},{"internalType":"uint64","name":"timeBufferInSeconds","type":"uint64"},{"internalType":"uint64","name":"bidBufferBps","type":"uint64"},{"internalType":"uint64","name":"startTimestamp","type":"uint64"},{"internalType":"uint64","name":"endTimestamp","type":"uint64"},{"internalType":"enum IEnglishAuctions.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IEnglishAuctions.Status","name":"status","type":"uint8"}],"internalType":"struct IEnglishAuctions.Auction","name":"auction","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"}],"name":"getWinningBid","outputs":[{"internalType":"address","name":"bidder","type":"address"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"bidAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"}],"name":"isAuctionExpired","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_auctionId","type":"uint256"},{"internalType":"uint256","name":"_bidAmount","type":"uint256"}],"name":"isNewWinningBid","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        50021: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endTokenId","type":"uint256"},{"indexed":false,"internalType":"string","name":"baseURI","type":"string"},{"indexed":false,"internalType":"bytes","name":"encryptedBaseURI","type":"bytes"}],"name":"TokensLazyMinted","type":"event"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"string","name":"baseURIForTokens","type":"string"},{"internalType":"bytes","name":"extraData","type":"bytes"}],"name":"lazyMint","outputs":[{"internalType":"uint256","name":"batchId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        78694: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenIdMinted","type":"uint256"},{"indexed":false,"internalType":"string","name":"uri","type":"string"}],"name":"TokensMinted","type":"event"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"cancel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"string","name":"uri","type":"string"}],"name":"mintTo","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"revoke","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        46929: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenIdMinted","type":"uint256"},{"indexed":false,"internalType":"string","name":"uri","type":"string"},{"indexed":false,"internalType":"uint256","name":"quantityMinted","type":"uint256"}],"name":"TokensMinted","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mintTo","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        4470: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"indexed":false,"internalType":"uint256","name":"quantityMinted","type":"uint256"}],"name":"TokensMinted","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mintTo","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        93938: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenIdMinted","type":"uint256"},{"indexed":false,"internalType":"string","name":"uri","type":"string"}],"name":"TokensMinted","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"string","name":"uri","type":"string"}],"name":"mintTo","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        10205: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"multicall","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        2093: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_fromTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_toTokenId","type":"uint256"}],"name":"BatchMetadataUpdate","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"MetadataUpdate","type":"event"},{"inputs":[{"internalType":"uint256","name":"_tokenId","type":"uint256"},{"internalType":"string","name":"_uri","type":"string"}],"name":"setTokenURI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        60027: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"offeror","type":"address"},{"indexed":true,"internalType":"uint256","name":"offerId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"seller","type":"address"},{"indexed":false,"internalType":"uint256","name":"quantityBought","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalPricePaid","type":"uint256"}],"name":"AcceptedOffer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"offeror","type":"address"},{"indexed":true,"internalType":"uint256","name":"offerId","type":"uint256"}],"name":"CancelledOffer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"offeror","type":"address"},{"indexed":true,"internalType":"uint256","name":"offerId","type":"uint256"},{"indexed":true,"internalType":"address","name":"assetContract","type":"address"},{"components":[{"internalType":"uint256","name":"offerId","type":"uint256"},{"internalType":"address","name":"offeror","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"totalPrice","type":"uint256"},{"internalType":"uint256","name":"expirationTimestamp","type":"uint256"},{"internalType":"enum IOffers.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IOffers.Status","name":"status","type":"uint8"}],"indexed":false,"internalType":"struct IOffers.Offer","name":"offer","type":"tuple"}],"name":"NewOffer","type":"event"},{"inputs":[{"internalType":"uint256","name":"_offerId","type":"uint256"}],"name":"acceptOffer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_offerId","type":"uint256"}],"name":"cancelOffer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startId","type":"uint256"},{"internalType":"uint256","name":"_endId","type":"uint256"}],"name":"getAllOffers","outputs":[{"components":[{"internalType":"uint256","name":"offerId","type":"uint256"},{"internalType":"address","name":"offeror","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"totalPrice","type":"uint256"},{"internalType":"uint256","name":"expirationTimestamp","type":"uint256"},{"internalType":"enum IOffers.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IOffers.Status","name":"status","type":"uint8"}],"internalType":"struct IOffers.Offer[]","name":"offers","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_startId","type":"uint256"},{"internalType":"uint256","name":"_endId","type":"uint256"}],"name":"getAllValidOffers","outputs":[{"components":[{"internalType":"uint256","name":"offerId","type":"uint256"},{"internalType":"address","name":"offeror","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"totalPrice","type":"uint256"},{"internalType":"uint256","name":"expirationTimestamp","type":"uint256"},{"internalType":"enum IOffers.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IOffers.Status","name":"status","type":"uint8"}],"internalType":"struct IOffers.Offer[]","name":"offers","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_offerId","type":"uint256"}],"name":"getOffer","outputs":[{"components":[{"internalType":"uint256","name":"offerId","type":"uint256"},{"internalType":"address","name":"offeror","type":"address"},{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"totalPrice","type":"uint256"},{"internalType":"uint256","name":"expirationTimestamp","type":"uint256"},{"internalType":"enum IOffers.TokenType","name":"tokenType","type":"uint8"},{"internalType":"enum IOffers.Status","name":"status","type":"uint8"}],"internalType":"struct IOffers.Offer","name":"offer","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint256","name":"totalPrice","type":"uint256"},{"internalType":"uint256","name":"expirationTimestamp","type":"uint256"}],"internalType":"struct IOffers.OfferParams","name":"_params","type":"tuple"}],"name":"makeOffer","outputs":[{"internalType":"uint256","name":"offerId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        75581: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"packId","type":"uint256"},{"indexed":false,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"totalPacksCreated","type":"uint256"}],"name":"PackCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"opener","type":"address"},{"indexed":true,"internalType":"uint256","name":"packId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountToOpen","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"requestId","type":"uint256"}],"name":"PackOpenRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"packId","type":"uint256"},{"indexed":true,"internalType":"address","name":"opener","type":"address"},{"indexed":false,"internalType":"uint256","name":"numOfPacksOpened","type":"uint256"},{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"enum ITokenBundle.TokenType","name":"tokenType","type":"uint8"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"totalAmount","type":"uint256"}],"indexed":false,"internalType":"struct ITokenBundle.Token[]","name":"rewardUnitsDistributed","type":"tuple[]"}],"name":"PackOpened","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"packId","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"requestId","type":"uint256"}],"name":"PackRandomnessFulfilled","type":"event"},{"inputs":[{"internalType":"address","name":"_opener","type":"address"}],"name":"canClaimRewards","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimRewards","outputs":[{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"enum ITokenBundle.TokenType","name":"tokenType","type":"uint8"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"totalAmount","type":"uint256"}],"internalType":"struct ITokenBundle.Token[]","name":"rewardUnits","type":"tuple[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"assetContract","type":"address"},{"internalType":"enum ITokenBundle.TokenType","name":"tokenType","type":"uint8"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"totalAmount","type":"uint256"}],"internalType":"struct ITokenBundle.Token[]","name":"contents","type":"tuple[]"},{"internalType":"uint256[]","name":"numOfRewardUnits","type":"uint256[]"},{"internalType":"string","name":"packUri","type":"string"},{"internalType":"uint128","name":"openStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"amountDistributedPerOpen","type":"uint128"},{"internalType":"address","name":"recipient","type":"address"}],"name":"createPack","outputs":[{"internalType":"uint256","name":"packId","type":"uint256"},{"internalType":"uint256","name":"packTotalSupply","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"packId","type":"uint256"},{"internalType":"uint256","name":"amountToOpen","type":"uint256"}],"name":"openPack","outputs":[{"internalType":"uint256","name":"requestId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_packId","type":"uint256"},{"internalType":"uint256","name":"_amountToOpen","type":"uint256"},{"internalType":"uint32","name":"_callBackGasLimit","type":"uint32"}],"name":"openPackAndClaimRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        24857: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        65313: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getRoleMember","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleMemberCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        44662: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"platformFeeRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"flatFee","type":"uint256"}],"name":"FlatPlatformFeeUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"platformFeeRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"platformFeeBps","type":"uint256"}],"name":"PlatformFeeInfoUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"enum IPlatformFee.PlatformFeeType","name":"feeType","type":"uint8"}],"name":"PlatformFeeTypeUpdated","type":"event"},{"inputs":[],"name":"getPlatformFeeInfo","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_platformFeeRecipient","type":"address"},{"internalType":"uint256","name":"_platformFeeBps","type":"uint256"}],"name":"setPlatformFeeInfo","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        77438: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"recipient","type":"address"}],"name":"PrimarySaleRecipientUpdated","type":"event"},{"inputs":[],"name":"primarySaleRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_saleRecipient","type":"address"}],"name":"setPrimarySaleRecipient","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        91671: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newRoyaltyRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"newRoyaltyBps","type":"uint256"}],"name":"DefaultRoyalty","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":true,"internalType":"address","name":"royaltyRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"royaltyBps","type":"uint256"}],"name":"RoyaltyForToken","type":"event"},{"inputs":[],"name":"getDefaultRoyaltyInfo","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getRoyaltyInfoForToken","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"salePrice","type":"uint256"}],"name":"royaltyInfo","outputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"royaltyAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_royaltyRecipient","type":"address"},{"internalType":"uint256","name":"_royaltyBps","type":"uint256"}],"name":"setDefaultRoyaltyInfo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"bps","type":"uint256"}],"name":"setRoyaltyInfoForToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        5053: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"signer","type":"address"},{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenIdMinted","type":"uint256"},{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"indexed":false,"internalType":"struct ISignatureMintERC1155.MintRequest","name":"mintRequest","type":"tuple"}],"name":"TokensMintedWithSignature","type":"event"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ISignatureMintERC1155.MintRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"mintWithSignature","outputs":[{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ISignatureMintERC1155.MintRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"view","type":"function"}]')
        },
        57101: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"signer","type":"address"},{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"indexed":false,"internalType":"struct ISignatureMintERC20.MintRequest","name":"mintRequest","type":"tuple"}],"name":"TokensMintedWithSignature","type":"event"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ISignatureMintERC20.MintRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"mintWithSignature","outputs":[{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ISignatureMintERC20.MintRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"view","type":"function"}]')
        },
        1377: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"signer","type":"address"},{"indexed":true,"internalType":"address","name":"mintedTo","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenIdMinted","type":"uint256"},{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"indexed":false,"internalType":"struct ISignatureMintERC721.MintRequest","name":"mintRequest","type":"tuple"}],"name":"TokensMintedWithSignature","type":"event"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ISignatureMintERC721.MintRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"mintWithSignature","outputs":[{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ISignatureMintERC721.MintRequest","name":"req","type":"tuple"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"address","name":"signer","type":"address"}],"stateMutability":"view","type":"function"}]')
        },
        63393: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ITokenERC721.MintRequest","name":"_req","type":"tuple"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"mintWithSignature","outputs":[{"internalType":"uint256","name":"tokenIdMinted","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"royaltyRecipient","type":"address"},{"internalType":"uint256","name":"royaltyBps","type":"uint256"},{"internalType":"address","name":"primarySaleRecipient","type":"address"},{"internalType":"string","name":"uri","type":"string"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"address","name":"currency","type":"address"},{"internalType":"uint128","name":"validityStartTimestamp","type":"uint128"},{"internalType":"uint128","name":"validityEndTimestamp","type":"uint128"},{"internalType":"bytes32","name":"uid","type":"bytes32"}],"internalType":"struct ITokenERC721.MintRequest","name":"_req","type":"tuple"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"verify","outputs":[{"internalType":"bool","name":"","type":"bool"},{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]')
        },
        74939: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[],"name":"contractType","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"contractURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"string","name":"_uri","type":"string"}],"name":"setContractURI","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        74241: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"string","name":"tier","type":"string"},{"indexed":true,"internalType":"uint256","name":"startTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endTokenId","type":"uint256"},{"indexed":false,"internalType":"string","name":"baseURI","type":"string"},{"indexed":false,"internalType":"bytes","name":"encryptedBaseURI","type":"bytes"}],"name":"TokensLazyMinted","type":"event"},{"inputs":[],"name":"getBaseURICount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_index","type":"uint256"}],"name":"getBatchIdAtIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getMetadataForAllTiers","outputs":[{"components":[{"internalType":"string","name":"tier","type":"string"},{"components":[{"internalType":"uint256","name":"startIdInclusive","type":"uint256"},{"internalType":"uint256","name":"endIdNonInclusive","type":"uint256"}],"internalType":"struct LazyMintWithTier.TokenRange[]","name":"ranges","type":"tuple[]"},{"internalType":"string[]","name":"baseURIs","type":"string[]"}],"internalType":"struct LazyMintWithTier.TierMetadata[]","name":"metadataForAllTiers","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"string","name":"_baseURIForTokens","type":"string"},{"internalType":"string","name":"_tier","type":"string"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"lazyMint","outputs":[{"internalType":"uint256","name":"batchId","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]')
        },
        46083: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"prevOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnerUpdated","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_newOwner","type":"address"}],"name":"setOwner","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        81570: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_fromTokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_toTokenId","type":"uint256"}],"name":"BatchMetadataUpdate","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_tokenId","type":"uint256"}],"name":"MetadataUpdate","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"name","type":"string"},{"indexed":false,"internalType":"string","name":"description","type":"string"},{"indexed":false,"internalType":"string","name":"imageURI","type":"string"},{"indexed":false,"internalType":"string","name":"animationURI","type":"string"}],"name":"SharedMetadataUpdated","type":"event"},{"inputs":[{"components":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"description","type":"string"},{"internalType":"string","name":"imageURI","type":"string"},{"internalType":"string","name":"animationURI","type":"string"}],"internalType":"struct ISharedMetadata.SharedMetadataInfo","name":"_metadata","type":"tuple"}],"name":"setSharedMetadata","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"sharedMetadata","outputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"description","type":"string"},{"internalType":"string","name":"imageURI","type":"string"},{"internalType":"string","name":"animationURI","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}]')
        },
        30707: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"deployer","type":"address"},{"indexed":true,"internalType":"address","name":"deployment","type":"address"},{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":false,"internalType":"string","name":"metadataUri","type":"string"}],"name":"Added","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"deployer","type":"address"},{"indexed":true,"internalType":"address","name":"deployment","type":"address"},{"indexed":true,"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"Deleted","type":"event"},{"inputs":[],"name":"OPERATOR_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_msgData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_msgSender","outputs":[{"internalType":"address","name":"sender","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"},{"internalType":"address","name":"_deployment","type":"address"},{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"string","name":"metadataUri","type":"string"}],"name":"add","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"contractType","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"contractVersion","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"}],"name":"count","outputs":[{"internalType":"uint256","name":"deploymentCount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"}],"name":"getAll","outputs":[{"components":[{"internalType":"address","name":"deploymentAddress","type":"address"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"string","name":"metadataURI","type":"string"}],"internalType":"struct ITWMultichainRegistry.Deployment[]","name":"allDeployments","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"},{"internalType":"address","name":"_deployment","type":"address"}],"name":"getMetadataUri","outputs":[{"internalType":"string","name":"metadataUri","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_deployer","type":"address"},{"internalType":"address","name":"_deployment","type":"address"},{"internalType":"uint256","name":"_chainId","type":"uint256"}],"name":"remove","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        },
        56535: function(l) {
            "use strict";
            l.exports = JSON.parse('[{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"Access_MissingRoleOrAdmin","type":"error"},{"inputs":[],"name":"Access_OnlyAdmin","type":"error"},{"inputs":[],"name":"Access_WithdrawNotAllowed","type":"error"},{"inputs":[{"internalType":"address","name":"proposedAddress","type":"address"}],"name":"Admin_InvalidUpgradeAddress","type":"error"},{"inputs":[],"name":"Admin_UnableToFinalizeNotOpenEdition","type":"error"},{"inputs":[],"name":"ExternalMetadataRenderer_CallFailed","type":"error"},{"inputs":[],"name":"InvalidMintSchedule","type":"error"},{"inputs":[],"name":"MarketFilterDAOAddressNotSupportedForChain","type":"error"},{"inputs":[],"name":"MintFee_FundsSendFailure","type":"error"},{"inputs":[],"name":"Mint_SoldOut","type":"error"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"OperatorNotAllowed","type":"error"},{"inputs":[],"name":"Presale_Inactive","type":"error"},{"inputs":[],"name":"Presale_MerkleNotApproved","type":"error"},{"inputs":[],"name":"Presale_TooManyForAddress","type":"error"},{"inputs":[],"name":"Purchase_TooManyForAddress","type":"error"},{"inputs":[{"internalType":"uint256","name":"correctPrice","type":"uint256"}],"name":"Purchase_WrongPrice","type":"error"},{"inputs":[],"name":"RemoteOperatorFilterRegistryCallFailed","type":"error"},{"inputs":[],"name":"Sale_Inactive","type":"error"},{"inputs":[{"internalType":"uint16","name":"maxRoyaltyBPS","type":"uint16"}],"name":"Setup_RoyaltyPercentageTooHigh","type":"error"},{"inputs":[],"name":"Withdraw_FundsSendFailure","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"newAddress","type":"address"},{"indexed":true,"internalType":"address","name":"changedBy","type":"address"}],"name":"FundsRecipientChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"withdrawnBy","type":"address"},{"indexed":true,"internalType":"address","name":"withdrawnTo","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"address","name":"feeRecipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"feeAmount","type":"uint256"}],"name":"FundsWithdrawn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"tokenContract","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"quantity","type":"uint256"},{"indexed":false,"internalType":"string","name":"comment","type":"string"}],"name":"MintComment","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"mintFeeAmount","type":"uint256"},{"indexed":false,"internalType":"address","name":"mintFeeRecipient","type":"address"},{"indexed":false,"internalType":"bool","name":"success","type":"bool"}],"name":"MintFeePayout","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"numberOfMints","type":"uint256"}],"name":"OpenMintFinalized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"quantity","type":"uint256"},{"indexed":true,"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"firstPurchasedTokenId","type":"uint256"}],"name":"Sale","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"changedBy","type":"address"}],"name":"SalesConfigChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"contract IMetadataRenderer","name":"renderer","type":"address"}],"name":"UpdatedMetadataRenderer","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"quantity","type":"uint256"}],"name":"adminMint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"to","type":"address[]"}],"name":"adminMintAirdrop","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"isAdmin","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"minter","type":"address"}],"name":"mintedPerAddress","outputs":[{"components":[{"internalType":"uint256","name":"totalMints","type":"uint256"},{"internalType":"uint256","name":"presaleMints","type":"uint256"},{"internalType":"uint256","name":"publicMints","type":"uint256"}],"internalType":"struct IERC721Drop.AddressMintDetails","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"quantity","type":"uint256"}],"name":"purchase","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"quantity","type":"uint256"},{"internalType":"uint256","name":"maxQuantity","type":"uint256"},{"internalType":"uint256","name":"pricePerToken","type":"uint256"},{"internalType":"bytes32[]","name":"merkleProof","type":"bytes32[]"}],"name":"purchasePresale","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"saleDetails","outputs":[{"components":[{"internalType":"bool","name":"publicSaleActive","type":"bool"},{"internalType":"bool","name":"presaleActive","type":"bool"},{"internalType":"uint256","name":"publicSalePrice","type":"uint256"},{"internalType":"uint64","name":"publicSaleStart","type":"uint64"},{"internalType":"uint64","name":"publicSaleEnd","type":"uint64"},{"internalType":"uint64","name":"presaleStart","type":"uint64"},{"internalType":"uint64","name":"presaleEnd","type":"uint64"},{"internalType":"bytes32","name":"presaleMerkleRoot","type":"bytes32"},{"internalType":"uint256","name":"maxSalePurchasePerAddress","type":"uint256"},{"internalType":"uint256","name":"totalMinted","type":"uint256"},{"internalType":"uint256","name":"maxSupply","type":"uint256"}],"internalType":"struct IERC721Drop.SaleDetails","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract IMetadataRenderer","name":"newRenderer","type":"address"},{"internalType":"bytes","name":"setupRenderer","type":"bytes"}],"name":"setMetadataRenderer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint104","name":"publicSalePrice","type":"uint104"},{"internalType":"uint32","name":"maxSalePurchasePerAddress","type":"uint32"},{"internalType":"uint64","name":"publicSaleStart","type":"uint64"},{"internalType":"uint64","name":"publicSaleEnd","type":"uint64"},{"internalType":"uint64","name":"presaleStart","type":"uint64"},{"internalType":"uint64","name":"presaleEnd","type":"uint64"},{"internalType":"bytes32","name":"presaleMerkleRoot","type":"bytes32"}],"name":"setSaleConfiguration","outputs":[],"stateMutability":"nonpayable","type":"function"}]')
        }
    }
]);