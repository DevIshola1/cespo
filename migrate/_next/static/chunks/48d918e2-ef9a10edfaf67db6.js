"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [8836], {
        27058: function(t, e, r) {
            let a, n, i, s, o, c, l, d, p, u, f, m;
            r.d(e, {
                G: function() {
                    return e3
                },
                H: function() {
                    return e7
                },
                I: function() {
                    return e4
                },
                a7: function() {
                    return ed
                },
                a8: function() {
                    return ep
                },
                aD: function() {
                    return Erc721
                },
                aE: function() {
                    return Erc721WithQuantitySignatureMintable
                },
                aL: function() {
                    return Erc1155
                },
                aM: function() {
                    return Erc1155SignatureMintable
                },
                aN: function() {
                    return MarketplaceV3DirectListings
                },
                aO: function() {
                    return MarketplaceV3EnglishAuctions
                },
                aP: function() {
                    return MarketplaceV3Offers
                },
                aQ: function() {
                    return GasCostEstimator
                },
                aR: function() {
                    return ContractEvents
                },
                aS: function() {
                    return ContractInterceptor
                },
                aT: function() {
                    return ContractPlatformFee
                },
                aV: function() {
                    return ContractOwner
                },
                aW: function() {
                    return Transaction
                },
                aX: function() {
                    return DeployTransaction
                },
                ab: function() {
                    return eA
                },
                ac: function() {
                    return eS
                },
                ag: function() {
                    return ContractEncoder
                },
                ah: function() {
                    return ContractMetadata
                },
                ai: function() {
                    return ContractRoles
                },
                aj: function() {
                    return ContractRoyalty
                },
                ak: function() {
                    return ContractPrimarySale
                },
                al: function() {
                    return DelayedReveal
                },
                am: function() {
                    return DropClaimConditions
                },
                an: function() {
                    return DropErc1155ClaimConditions
                },
                at: function() {
                    return Erc20SignatureMintable
                },
                au: function() {
                    return Erc20
                },
                b0: function() {
                    return ContractAppURI
                },
                b8: function() {
                    return isNativeToken
                },
                b9: function() {
                    return cleanCurrencyAddress
                },
                bB: function() {
                    return AuctionHasNotEndedError
                },
                bI: function() {
                    return getRoleHash
                },
                bJ: function() {
                    return fetchContractMetadataFromAddress
                },
                bL: function() {
                    return getDefaultGasOverrides
                },
                bM: function() {
                    return getDynamicFeeData
                },
                bV: function() {
                    return extractConstructorParamsFromAbi
                },
                bZ: function() {
                    return resolveContractUriFromAddress
                },
                ba: function() {
                    return normalizePriceValue
                },
                bb: function() {
                    return fetchCurrencyMetadata
                },
                bc: function() {
                    return fetchCurrencyValue
                },
                bd: function() {
                    return setErc20Allowance
                },
                bg: function() {
                    return toWei
                },
                bv: function() {
                    return AuctionAlreadyStartedError
                },
                bx: function() {
                    return ListingNotFoundError
                },
                by: function() {
                    return WrongListingTypeError
                },
                c$: function() {
                    return getChainProvider
                },
                c3: function() {
                    return fetchExtendedReleaseMetadata
                },
                c4: function() {
                    return detectFeatures
                },
                cA: function() {
                    return getDeploymentInfo
                },
                cB: function() {
                    return deployWithThrowawayDeployer
                },
                cC: function() {
                    return computeDeploymentInfo
                },
                cD: function() {
                    return encodeConstructorParamsForImplementation
                },
                cE: function() {
                    return getCreate2FactoryDeploymentInfo
                },
                cF: function() {
                    return nH
                },
                cG: function() {
                    return fetchPublishedContractFromPolygon
                },
                cH: function() {
                    return fetchAndCacheDeployMetadata
                },
                cJ: function() {
                    return createTransactionBatches
                },
                cL: function() {
                    return resolveAddress
                },
                cN: function() {
                    return n_
                },
                cO: function() {
                    return getContractAddressByChainId
                },
                cP: function() {
                    return getContractPublisherAddress
                },
                cQ: function() {
                    return getMultichainRegistryAddress
                },
                cR: function() {
                    return ev
                },
                cS: function() {
                    return setSupportedChains
                },
                cU: function() {
                    return nj
                },
                cV: function() {
                    return nq
                },
                cW: function() {
                    return eT
                },
                cX: function() {
                    return eE
                },
                cZ: function() {
                    return ek
                },
                c_: function() {
                    return nG
                },
                cc: function() {
                    return assertEnabled
                },
                cd: function() {
                    return detectContractFeature
                },
                cj: function() {
                    return fetchSourceFilesFromMetadata
                },
                cm: function() {
                    return a7
                },
                cq: function() {
                    return isContractDeployed
                },
                cr: function() {
                    return isEIP155Enforced
                },
                cs: function() {
                    return getCreate2FactoryAddress
                },
                cu: function() {
                    return getInitBytecodeWithSalt
                },
                cv: function() {
                    return computeDeploymentAddress
                },
                cx: function() {
                    return computeForwarderAddress
                },
                cz: function() {
                    return deployContractDeterministic
                },
                d$: function() {
                    return nb
                },
                d2: function() {
                    return isChainConfig
                },
                d4: function() {
                    return getSignerAndProvider
                },
                d6: function() {
                    return iW
                },
                d7: function() {
                    return iT
                },
                d8: function() {
                    return iE
                },
                d9: function() {
                    return ik
                },
                dA: function() {
                    return getCompositePluginABI
                },
                dB: function() {
                    return buildDeployTransactionFunction
                },
                dC: function() {
                    return getProcessEnv
                },
                dD: function() {
                    return na
                },
                dE: function() {
                    return mapOffer
                },
                dF: function() {
                    return fetchTokenMetadataForContract
                },
                dG: function() {
                    return isTokenApprovedForTransfer
                },
                dH: function() {
                    return validateNewListingParam
                },
                dI: function() {
                    return handleTokenApproval
                },
                dJ: function() {
                    return isWinningBid
                },
                dK: function() {
                    return iy
                },
                dL: function() {
                    return no
                },
                dM: function() {
                    return nx
                },
                dN: function() {
                    return iw
                },
                dO: function() {
                    return nl
                },
                dP: function() {
                    return aW
                },
                dQ: function() {
                    return aT
                },
                dR: function() {
                    return aE
                },
                dS: function() {
                    return iA
                },
                dT: function() {
                    return ih
                },
                dU: function() {
                    return uploadOrExtractURI
                },
                dV: function() {
                    return nS
                },
                dW: function() {
                    return rB
                },
                dX: function() {
                    return aC
                },
                dY: function() {
                    return ib
                },
                dZ: function() {
                    return nf
                },
                d_: function() {
                    return ig
                },
                da: function() {
                    return iS
                },
                db: function() {
                    return iP
                },
                dc: function() {
                    return iF
                },
                dd: function() {
                    return iI
                },
                de: function() {
                    return ix
                },
                df: function() {
                    return iM
                },
                dg: function() {
                    return iR
                },
                dh: function() {
                    return iO
                },
                di: function() {
                    return iN
                },
                dj: function() {
                    return iD
                },
                dk: function() {
                    return iB
                },
                dm: function() {
                    return getContractTypeForRemoteName
                },
                dn: function() {
                    return getContractName
                },
                dr: function() {
                    return nz
                },
                ds: function() {
                    return extractFeatures
                },
                dt: function() {
                    return a8
                },
                du: function() {
                    return RPCConnectionHandler
                },
                dv: function() {
                    return signTypedDataInternal
                },
                dw: function() {
                    return ContractWrapper
                },
                dx: function() {
                    return buildTransactionFunction
                },
                dy: function() {
                    return ContractPublisher
                },
                dz: function() {
                    return SmartContract
                },
                e: function() {
                    return ro
                },
                e0: function() {
                    return iC
                },
                e1: function() {
                    return id
                },
                e2: function() {
                    return nW
                },
                e3: function() {
                    return nB
                },
                w: function() {
                    return e2
                },
                y: function() {
                    return e6
                },
                z: function() {
                    return e8
                }
            });
            var h, g, y, w, b, C = r(44049),
                A = r(74578),
                v = r(92598),
                W = r(61127),
                T = r(17213),
                E = r(39318),
                k = r(13010),
                S = r(99227),
                P = r(86816),
                F = r(18994),
                I = r(5572),
                x = r(57273),
                M = r(58337),
                R = r(73760),
                O = r(28410),
                N = r(14184),
                D = r(12060),
                B = r(36339),
                L = r(47293),
                z = r(55725),
                $ = r(77273),
                U = r(31822),
                V = r(53690),
                _ = r(98291),
                j = r(22130),
                q = r(51872),
                G = r(29822),
                H = r(31787),
                Z = r(19115),
                J = r(31617),
                K = r(54497),
                Q = r(61053),
                Y = r(53010),
                X = r.n(Y),
                tt = r(41650),
                te = r(74939),
                tr = r(5834),
                ta = r(10506),
                tn = r(32557),
                ti = r(46762),
                ts = r(44931),
                to = r(68870),
                tc = r.n(to),
                tl = r(30707),
                td = r(83230),
                tp = r(58478),
                tu = r(90863),
                tf = r(4129),
                tm = r(14565),
                th = r(38649),
                tg = r(4470),
                ty = r(10205),
                tw = r(57101),
                tb = r(62281),
                tC = r(29691),
                tA = r(28329),
                tv = r(99818),
                tW = r(18125),
                tT = r(62984),
                tE = r(41730),
                tk = r(50021),
                tS = r(93938),
                tP = r(1377),
                tF = r(63393),
                tI = r(74241),
                tx = r(81570),
                tM = r(56535),
                tR = r(78694),
                tO = r(2093),
                tN = r(70357),
                tD = r(1728),
                tB = r(17845),
                tL = r(39046),
                tz = r(60805),
                t$ = r(18128),
                tU = r(38925),
                tV = r(56011),
                t_ = r(46929),
                tj = r(5053),
                tq = r(73496),
                tG = r(23194),
                tH = r(9748),
                tZ = r(96409),
                tJ = r(97463),
                tK = r(60027),
                tQ = r(75581),
                tY = r(24857),
                tX = r(65313),
                t0 = r(44662),
                t1 = r(77438),
                t2 = r(91671),
                t5 = r(46083),
                t6 = r(68133),
                t8 = r(98730),
                t3 = r(15560),
                t7 = r(92063),
                t4 = r(26644),
                t9 = r(97258),
                et = r(6691),
                ee = r(61303),
                er = r(9366),
                ea = r.n(er),
                en = r(11953),
                ei = r(67133).Buffer,
                es = r(25566);
            let eo = "0|[1-9]\\d*",
                ec = `(${eo})\\.(${eo})\\.(${eo})`,
                el = new RegExp(ec);

            function toSemver(t) {
                if (t.length > 256) throw Error("version is longer than 256 characters");
                let e = t.trim().match(el);
                if (!e || e ? .length !== 4) throw Error(`${t} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
                let r = Number(e[1]),
                    a = Number(e[2]),
                    n = Number(e[3]),
                    i = [r, a, n].join(".");
                return {
                    major: r,
                    minor: a,
                    patch: n,
                    versionString: i
                }
            }
            let ed = A.z.union([A.z.string(), A.z.number(), A.z.bigint(), A.z.custom(t => v.O$.isBigNumber(t))]).transform(t => v.O$.from(t)),
                ep = ed.transform(t => t.toString()),
                eu = A.z.union([A.z.bigint(), A.z.custom(t => v.O$.isBigNumber(t))]).transform(t => v.O$.from(t).toString());

            function isSigner(t) {
                return !!(t && t._isSigner)
            }

            function isProvider(t) {
                return !!(t && t._isProvider)
            }
            let ef = {
                timeLimitMs: 50,
                sizeLimit: 250
            };
            let StaticJsonRpcBatchProvider = class StaticJsonRpcBatchProvider extends W.c {
                constructor(t, e) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ef;
                    super(t, e), this._timeLimitMs = r.timeLimitMs || 250, this._sizeLimit = r.sizeLimit || 50, this._pendingBatchAggregator = null, this._pendingBatch = null
                }
                sendCurrentBatch(t) {
                    this._pendingBatchAggregator && clearTimeout(this._pendingBatchAggregator);
                    let e = this._pendingBatch || [];
                    this._pendingBatch = null, this._pendingBatchAggregator = null;
                    let r = e.map(t => t.request);
                    return this.emit("debug", {
                        action: "requestBatch",
                        request: T.deepCopy(t),
                        provider: this
                    }), E.fetchJson(this.connection, JSON.stringify(r)).then(t => {
                        this.emit("debug", {
                            action: "response",
                            request: r,
                            response: t,
                            provider: this
                        }), e.forEach((e, r) => {
                            let a = t[r];
                            if (a) {
                                if (a.error) {
                                    let t = Error(a.error.message);
                                    t.code = a.error.code, t.data = a.error.data, e.reject(t)
                                } else e.resolve(a.result)
                            } else e.reject(Error("No response for request"))
                        })
                    }, t => {
                        this.emit("debug", {
                            action: "response",
                            error: t,
                            request: r,
                            provider: this
                        }), e.forEach(e => {
                            e.reject(t)
                        })
                    })
                }
                send(t, e) {
                    let r = {
                        method: t,
                        params: e,
                        id: this._nextId++,
                        jsonrpc: "2.0"
                    };
                    null === this._pendingBatch && (this._pendingBatch = []);
                    let a = {
                            request: r,
                            resolve: null,
                            reject: null
                        },
                        n = new Promise((t, e) => {
                            a.resolve = t, a.reject = e
                        });
                    return this._pendingBatch.push(a), this._pendingBatch.length === this._sizeLimit && this.sendCurrentBatch(r), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => {
                        this.sendCurrentBatch(r)
                    }, this._timeLimitMs)), n
                }
            };
            let em = A.z.object({
                    rpc: A.z.array(A.z.string().url()),
                    chainId: A.z.number(),
                    nativeCurrency: A.z.object({
                        name: A.z.string(),
                        symbol: A.z.string(),
                        decimals: A.z.number()
                    }),
                    slug: A.z.string()
                }),
                eh = A.z.object({
                    supportedChains: A.z.array(em).default(ts.gL9),
                    clientId: A.z.string().optional(),
                    secretKey: A.z.string().optional(),
                    readonlySettings: A.z.object({
                        rpcUrl: A.z.string().url(),
                        chainId: A.z.number().optional()
                    }).optional(),
                    gasSettings: A.z.object({
                        maxPriceInGwei: A.z.number().min(1, "gas price cannot be less than 1").default(300),
                        speed: A.z.enum(["standard", "fast", "fastest"]).default("fastest")
                    }).default({
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }),
                    gasless: A.z.union([A.z.object({
                        openzeppelin: A.z.object({
                            relayerUrl: A.z.string().url(),
                            relayerForwarderAddress: A.z.string().optional(),
                            useEOAForwarder: A.z.boolean().default(!1),
                            domainName: A.z.string().default("GSNv2 Forwarder"),
                            domainVersion: A.z.string().default("0.0.1")
                        }),
                        experimentalChainlessSupport: A.z.boolean().default(!1)
                    }), A.z.object({
                        biconomy: A.z.object({
                            apiId: A.z.string(),
                            apiKey: A.z.string(),
                            deadlineSeconds: A.z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
                        })
                    })]).optional(),
                    gatewayUrls: A.z.array(A.z.string()).optional()
                }).default({
                    gasSettings: {
                        maxPriceInGwei: 300,
                        speed: "fastest"
                    }
                });
            var eg = {
                name: "@thirdweb-dev/sdk",
                version: "3.10.67"
            };

            function getChainProvider(t, e) {
                let r;
                if ("string" == typeof t && function(t) {
                        let e = t.match(/^(ws|http)s?:/i);
                        if (e) switch (e[1].toLowerCase()) {
                            case "http":
                            case "https":
                            case "ws":
                            case "wss":
                                return !0
                        }
                        return !1
                    }(t)) return getProviderFromRpcUrl(t, e);
                let a = eh.parse(e);
                isChainConfig(t) && (a.supportedChains = [t, ...a.supportedChains.filter(e => e.chainId !== t.chainId)]);
                let n = a.supportedChains.reduce((t, e) => (t[e.chainId] = e, t), {}),
                    i = "";
                try {
                    r = function(t, e) {
                        if (isChainConfig(t)) return t.chainId;
                        if ("number" == typeof t) return t; {
                            let r = e.supportedChains.reduce((t, e) => (t[e.slug] = e.chainId, t), {});
                            if (t in r) return r[t]
                        }
                        throw Error(`Cannot resolve chainId from: ${t} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`)
                    }(t, a), i = (0, ts.OZ$)(n[r], a.clientId)[0]
                } catch (t) {}
                if (i || (i = `https://${r||t}.rpc.thirdweb.com/${a.clientId||""}`), !i) throw Error(`No rpc url found for chain ${t}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
                return getProviderFromRpcUrl(i, e, r)
            }

            function isChainConfig(t) {
                return "string" != typeof t && "number" != typeof t && !isSigner(t) && !isProvider(t)
            }
            let ey = new Map;

            function getProviderFromRpcUrl(t, e, r) {
                try {
                    var a;
                    let n = {},
                        i = "none";
                    if (a = t, new URL(a).hostname.endsWith(".thirdweb.com")) {
                        if (e ? .secretKey) throw Error("Cannot use secretKey in browser context");
                        if (e ? .clientId) {
                            let r = new URL(t);
                            r.pathname = e.clientId, n["x-client-id"] = e.clientId, t = r.toString(), i = "clientId"
                        }
                        "undefined" != typeof globalThis && "TW_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_AUTH_TOKEN && (n.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`, i = "twAuthToken"), "undefined" != typeof globalThis && "TW_CLI_AUTH_TOKEN" in globalThis && "string" == typeof globalThis.TW_CLI_AUTH_TOKEN && (n["x-authorize-wallet"] = "true");
                        let r = "undefined" != typeof globalThis && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
                        t.includes("bundleId") || (t += r ? `?bundleId=${r}` : ""), n["x-sdk-version"] = eg.version, n["x-sdk-name"] = eg.name, n["x-sdk-platform"] = r ? "react-native" : (0, G.jU)() ? void 0 !== window.bridge ? "webGL" : "browser" : "node"
                    }
                    let s = t.match(/^(ws|http)s?:/i);
                    if (s) switch (s[1].toLowerCase()) {
                        case "http":
                        case "https":
                            let o = `${t}-${r||-1}-${i}`,
                                c = ey.get(o);
                            if (c) return c;
                            let l = r ? new StaticJsonRpcBatchProvider({
                                url: t,
                                headers: n
                            }, r) : new k.I({
                                url: t,
                                headers: n
                            });
                            return ey.set(o, l), l;
                        case "ws":
                        case "wss":
                            return new S.q(t, r)
                    }
                } catch (t) {}
                return P.getDefaultProvider(t)
            }

            function getSignerAndProvider(t, e) {
                let r, a;
                if (isSigner(t) ? (r = t, t.provider && (a = t.provider)) : a = isProvider(t) ? t : getChainProvider(t, e), e ? .readonlySettings && (a = getProviderFromRpcUrl(e.readonlySettings.rpcUrl, e, e.readonlySettings.chainId)), !a) {
                    if (r) throw Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
                    throw Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!")
                }
                return [r, a]
            }
            let ew = new Map;
            async function resolveEns(t) {
                let e, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                a || (a = getSignerAndProvider("ethereum")[1]), e = ew.has(t) ? ew.get(t) : a.resolveName(t).then(t => t ? {
                    address: t,
                    expirationTime: new Date(Date.now() + 3e5)
                } : {
                    address: null,
                    expirationTime: new Date(Date.now() + 3e4)
                });
                let n = await e;
                return n.expirationTime < new Date && (ew.delete(t), 0 === r && resolveEns(t, r + 1)), n.address
            }
            let eb = A.z.custom(t => "string" == typeof t && (t.endsWith(".eth") || t.endsWith(".cb.id"))).transform(async t => resolveEns(t)).refine(t => !!t && F.isAddress(t), {
                    message: "Provided value was not a valid ENS name"
                }),
                eC = A.z.custom(t => "string" == typeof t && F.isAddress(t), t => ({
                    message: `${t} is not a valid address`
                })),
                eA = A.z.union([eC, eb], {
                    invalid_type_error: "Provided value was not a valid address or ENS name"
                }),
                ev = ((h = {})[h.Mainnet = 1] = "Mainnet", h[h.Goerli = 5] = "Goerli", h[h.Polygon = 137] = "Polygon", h[h.Mumbai = 80001] = "Mumbai", h[h.Localhost = 1337] = "Localhost", h[h.Hardhat = 31337] = "Hardhat", h[h.Fantom = 250] = "Fantom", h[h.FantomTestnet = 4002] = "FantomTestnet", h[h.Avalanche = 43114] = "Avalanche", h[h.AvalancheFujiTestnet = 43113] = "AvalancheFujiTestnet", h[h.Optimism = 10] = "Optimism", h[h.OptimismGoerli = 420] = "OptimismGoerli", h[h.Arbitrum = 42161] = "Arbitrum", h[h.ArbitrumGoerli = 421613] = "ArbitrumGoerli", h[h.BinanceSmartChainMainnet = 56] = "BinanceSmartChainMainnet", h[h.BinanceSmartChainTestnet = 97] = "BinanceSmartChainTestnet", h),
                eW = ts.gL9;

            function setSupportedChains(t) {
                eW = t && t.length > 0 ? t : ts.gL9
            }
            let eT = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
                eE = {
                    [ev.Mainnet]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.Goerli]: {
                        name: "G\xf6rli Ether",
                        symbol: "GOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    11155111: {
                        name: "Sepolia Ether",
                        symbol: "SEP",
                        decimals: 18,
                        wrapped: {
                            address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.Polygon]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [ev.Mumbai]: {
                        name: "Matic",
                        symbol: "MATIC",
                        decimals: 18,
                        wrapped: {
                            address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
                            name: "Wrapped Matic",
                            symbol: "WMATIC"
                        }
                    },
                    [ev.Avalanche]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [ev.AvalancheFujiTestnet]: {
                        name: "Avalanche",
                        symbol: "AVAX",
                        decimals: 18,
                        wrapped: {
                            address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
                            name: "Wrapped AVAX",
                            symbol: "WAVAX"
                        }
                    },
                    [ev.Fantom]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [ev.FantomTestnet]: {
                        name: "Fantom",
                        symbol: "FTM",
                        decimals: 18,
                        wrapped: {
                            address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
                            name: "Wrapped Fantom",
                            symbol: "WFTM"
                        }
                    },
                    [ev.Arbitrum]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.ArbitrumGoerli]: {
                        name: "Arbitrum Goerli Ether",
                        symbol: "AGOR",
                        decimals: 18,
                        wrapped: {
                            address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.Optimism]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.OptimismGoerli]: {
                        name: "Goerli Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.BinanceSmartChainMainnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "BNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
                            name: "Wrapped Binance Chain Token",
                            symbol: "WBNB"
                        }
                    },
                    [ev.BinanceSmartChainTestnet]: {
                        name: "Binance Chain Native Token",
                        symbol: "TBNB",
                        decimals: 18,
                        wrapped: {
                            address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
                            name: "Wrapped Binance Chain Testnet Token",
                            symbol: "WBNB"
                        }
                    },
                    [ev.Hardhat]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    [ev.Localhost]: {
                        name: "Ether",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    84531: {
                        name: "Base Goerli Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x4200000000000000000000000000000000000006",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    },
                    280: {
                        name: "zkSync Era Testnet",
                        symbol: "ETH",
                        decimals: 18,
                        wrapped: {
                            address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
                            name: "Wrapped Ether",
                            symbol: "WETH"
                        }
                    }
                };

            function getNativeTokenByChainId(t) {
                let e = eW.find(e => e.chainId === t);
                return e && e.nativeCurrency ? {
                    name: e.nativeCurrency.name,
                    symbol: e.nativeCurrency.symbol,
                    decimals: 18,
                    wrapped: {
                        address: I.d,
                        name: `Wrapped ${e.nativeCurrency.name}`,
                        symbol: `W${e.nativeCurrency.symbol}`
                    }
                } : eE[t] || {
                    name: "Ether",
                    symbol: "ETH",
                    decimals: 18,
                    wrapped: {
                        address: I.d,
                        name: "Wrapped Ether",
                        symbol: "WETH"
                    }
                }
            }
            let ek = {
                    [ev.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
                    [ev.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                    [ev.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
                    [ev.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
                    [ev.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
                    [ev.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
                    [ev.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
                    [ev.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
                    [ev.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
                },
                eS = A.z.union([A.z.date().transform(t => v.O$.from(Math.floor(t.getTime() / 1e3))), A.z.number().transform(t => v.O$.from(t))]),
                eP = eS.default(new Date(0)),
                eF = eS.default(new Date(Date.now() + 31536e7)),
                eI = A.z.object({
                    name: A.z.string(),
                    symbol: A.z.string(),
                    decimals: A.z.number()
                }),
                ex = eI.extend({
                    value: ed,
                    displayValue: A.z.string()
                }),
                eM = A.z.object({
                    merkle: A.z.record(A.z.string()).default({})
                }),
                eR = A.z.object({
                    address: eA,
                    maxClaimable: C.Q.default(0),
                    price: C.Q.optional(),
                    currencyAddress: eA.default(I.d).optional()
                }),
                eO = A.z.union([A.z.array(A.z.string()).transform(async t => await Promise.all(t.map(t => eR.parseAsync({
                    address: t
                })))), A.z.array(eR)]),
                eN = eR.extend({
                    proof: A.z.array(A.z.string())
                }),
                eD = A.z.object({
                    merkleRoot: A.z.string(),
                    claims: A.z.array(eN)
                }),
                eB = A.z.object({
                    name: A.z.string().optional()
                }).catchall(A.z.unknown()),
                eL = A.z.object({
                    startTime: eP,
                    currencyAddress: A.z.string().default(eT),
                    price: C.A.default(0),
                    maxClaimableSupply: C.Q,
                    maxClaimablePerWallet: C.Q,
                    waitInSeconds: ep.default(0),
                    merkleRootHash: C.B.default(x.hexZeroPad([0], 32)),
                    snapshot: A.z.optional(eO).nullable(),
                    metadata: eB.optional()
                }),
                ez = A.z.array(eL),
                e$ = eL.extend({
                    availableSupply: C.Q,
                    currentMintSupply: C.Q,
                    currencyMetadata: ex.default({
                        value: v.O$.from("0"),
                        displayValue: "0",
                        symbol: "",
                        decimals: 18,
                        name: ""
                    }),
                    price: ed,
                    waitInSeconds: ed,
                    startTime: ed.transform(t => new Date(1e3 * t.toNumber())),
                    snapshot: eO.optional().nullable()
                });

            function resolveOrGenerateId(t) {
                if (void 0 !== t) return x.hexlify(t); {
                    let t = ei.alloc(16);
                    return (0, q.Z)({}, t), x.hexlify(M.Y0(t.toString("hex")))
                }
            }
            let eU = A.z.object({
                    to: eA.refine(t => t.toLowerCase() !== I.d, {
                        message: "Cannot create payload to mint to zero address"
                    }),
                    price: C.A.default(0),
                    currencyAddress: eC.default(eT),
                    mintStartTime: eP,
                    mintEndTime: eF,
                    uid: A.z.string().optional().transform(t => resolveOrGenerateId(t)),
                    primarySaleRecipient: eA.default(I.d)
                }),
                eV = eU.extend({
                    quantity: C.A
                }),
                e_ = eV.extend({
                    mintStartTime: ed,
                    mintEndTime: ed
                }),
                ej = eU.extend({
                    metadata: C.N,
                    royaltyRecipient: A.z.string().default(I.d),
                    royaltyBps: C.a.default(0)
                }),
                eq = ej.extend({
                    metadata: C.N.default(""),
                    uri: A.z.string(),
                    royaltyBps: ed,
                    mintStartTime: ed,
                    mintEndTime: ed
                }),
                eG = ej.extend({
                    metadata: C.N.default(""),
                    quantity: ep
                }),
                eH = eG.extend({
                    tokenId: ep
                }),
                eZ = eq.extend({
                    tokenId: ed,
                    quantity: ed
                }),
                eJ = ej.extend({
                    metadata: C.N.default(""),
                    quantity: ed.default(1)
                }),
                eK = eq.extend({
                    quantity: ed.default(1)
                }),
                eQ = [{
                    name: "to",
                    type: "address"
                }, {
                    name: "primarySaleRecipient",
                    type: "address"
                }, {
                    name: "quantity",
                    type: "uint256"
                }, {
                    name: "price",
                    type: "uint256"
                }, {
                    name: "currency",
                    type: "address"
                }, {
                    name: "validityStartTimestamp",
                    type: "uint128"
                }, {
                    name: "validityEndTimestamp",
                    type: "uint128"
                }, {
                    name: "uid",
                    type: "bytes32"
                }],
                eY = [{
                    name: "to",
                    type: "address"
                }, {
                    name: "royaltyRecipient",
                    type: "address"
                }, {
                    name: "royaltyBps",
                    type: "uint256"
                }, {
                    name: "primarySaleRecipient",
                    type: "address"
                }, {
                    name: "uri",
                    type: "string"
                }, {
                    name: "price",
                    type: "uint256"
                }, {
                    name: "currency",
                    type: "address"
                }, {
                    name: "validityStartTimestamp",
                    type: "uint128"
                }, {
                    name: "validityEndTimestamp",
                    type: "uint128"
                }, {
                    name: "uid",
                    type: "bytes32"
                }],
                eX = [{
                    name: "to",
                    type: "address"
                }, {
                    name: "royaltyRecipient",
                    type: "address"
                }, {
                    name: "royaltyBps",
                    type: "uint256"
                }, {
                    name: "primarySaleRecipient",
                    type: "address"
                }, {
                    name: "tokenId",
                    type: "uint256"
                }, {
                    name: "uri",
                    type: "string"
                }, {
                    name: "quantity",
                    type: "uint256"
                }, {
                    name: "pricePerToken",
                    type: "uint256"
                }, {
                    name: "currency",
                    type: "address"
                }, {
                    name: "validityStartTimestamp",
                    type: "uint128"
                }, {
                    name: "validityEndTimestamp",
                    type: "uint128"
                }, {
                    name: "uid",
                    type: "bytes32"
                }],
                e0 = [{
                    name: "to",
                    type: "address"
                }, {
                    name: "royaltyRecipient",
                    type: "address"
                }, {
                    name: "royaltyBps",
                    type: "uint256"
                }, {
                    name: "primarySaleRecipient",
                    type: "address"
                }, {
                    name: "uri",
                    type: "string"
                }, {
                    name: "quantity",
                    type: "uint256"
                }, {
                    name: "pricePerToken",
                    type: "uint256"
                }, {
                    name: "currency",
                    type: "address"
                }, {
                    name: "validityStartTimestamp",
                    type: "uint128"
                }, {
                    name: "validityEndTimestamp",
                    type: "uint128"
                }, {
                    name: "uid",
                    type: "bytes32"
                }],
                e1 = [{
                    name: "validityStartTimestamp",
                    type: "uint128"
                }, {
                    name: "validityEndTimestamp",
                    type: "uint128"
                }, {
                    name: "uid",
                    type: "bytes32"
                }, {
                    name: "data",
                    type: "bytes"
                }],
                e2 = A.z.object({
                    name: A.z.string(),
                    description: A.z.string().optional(),
                    image: C.F.optional(),
                    external_link: A.z.string().optional(),
                    app_uri: A.z.string().optional(),
                    social_urls: A.z.record(A.z.string()).optional()
                }).catchall(A.z.unknown()),
                e5 = e2.extend({
                    image: A.z.string().optional()
                }).catchall(A.z.unknown()),
                e6 = A.z.object({
                    seller_fee_basis_points: C.a.default(0),
                    fee_recipient: eA.default(I.d)
                }),
                e8 = A.z.object({
                    primary_sale_recipient: eA
                }),
                e3 = A.z.object({
                    platform_fee_basis_points: C.a.default(0),
                    platform_fee_recipient: eA.default(I.d)
                }),
                e7 = A.z.object({
                    trusted_forwarders: A.z.array(eA).default([])
                }),
                e4 = A.z.object({
                    symbol: A.z.string().default("")
                }),
                e9 = e2.catchall(A.z.union([eu, A.z.unknown()])),
                rt = e9.merge(e6.merge(eM).merge(e4).partial()).catchall(A.z.any()),
                re = e5.merge(e6.merge(eM).merge(e4).partial()).catchall(A.z.any()),
                rr = rt.merge(e3.merge(e8).merge(e7).partial()),
                ra = {
                    deploy: rr,
                    output: re,
                    input: rt
                },
                rn = A.z.object({
                    type: A.z.string(),
                    name: A.z.string().default("")
                }).catchall(A.z.any()),
                ri = rn.extend({
                    stateMutability: A.z.string().optional(),
                    components: A.z.array(rn).optional()
                }).catchall(A.z.any()),
                rs = A.z.object({
                    type: A.z.string(),
                    name: A.z.string().default(""),
                    inputs: A.z.array(ri).default([]),
                    outputs: A.z.array(ri).default([])
                }).catchall(A.z.any()),
                ro = A.z.array(rs),
                rc = A.z.object({
                    name: A.z.string(),
                    metadataUri: A.z.string(),
                    bytecodeUri: A.z.string(),
                    analytics: A.z.any().optional()
                }).catchall(A.z.any()),
                rl = A.z.record(A.z.string(), A.z.string()),
                rd = A.z.object({
                    factoryFunction: A.z.string(),
                    params: A.z.array(A.z.object({
                        name: A.z.string(),
                        type: A.z.string()
                    })).default([]),
                    customFactoryAddresses: rl
                }),
                rp = A.z.object({
                    implementationAddresses: rl,
                    implementationInitializerFunction: A.z.string().default("initialize"),
                    customFactoryInput: rd.optional(),
                    factoryAddresses: rl.optional()
                }),
                ru = A.z.union([A.z.literal("standard"), A.z.literal("autoFactory"), A.z.literal("customFactory")]),
                rf = A.z.union([A.z.literal("none"), A.z.literal("plugin"), A.z.literal("dynamic")]),
                rm = A.z.object({
                    allNetworks: A.z.boolean().optional(),
                    networksEnabled: A.z.array(A.z.number()).default([])
                }),
                rh = A.z.object({
                    version: A.z.string().refine(t => {
                        try {
                            return toSemver(t), !0
                        } catch (t) {
                            return !1
                        }
                    }, t => ({
                        message: `'${t}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
                    })),
                    displayName: A.z.string().optional(),
                    description: A.z.string().optional(),
                    readme: A.z.string().optional(),
                    license: A.z.string().optional(),
                    changelog: A.z.string().optional(),
                    tags: A.z.array(A.z.string()).optional(),
                    audit: C.F.nullable().optional(),
                    logo: C.F.nullable().optional(),
                    isDeployableViaFactory: A.z.boolean().optional(),
                    isDeployableViaProxy: A.z.boolean().optional(),
                    factoryDeploymentData: rp.optional(),
                    deployType: ru.optional(),
                    routerType: rf.optional(),
                    defaultExtensions: A.z.array(A.z.object({
                        extensionName: A.z.string(),
                        extensionVersion: A.z.string().default("latest"),
                        publisherAddress: eA
                    })).optional(),
                    networksForDeployment: rm.optional(),
                    constructorParams: A.z.record(A.z.string(), A.z.object({
                        displayName: A.z.string().optional(),
                        description: A.z.string().optional(),
                        defaultValue: A.z.string().optional(),
                        hidden: A.z.boolean().optional()
                    }).catchall(A.z.any())).optional(),
                    compositeAbi: ro.optional()
                }).catchall(A.z.any()),
                rg = rh.extend({
                    audit: A.z.string().nullable().optional(),
                    logo: A.z.string().nullable().optional()
                }),
                ry = rc.merge(rh).extend({
                    publisher: eA.optional()
                }),
                rw = rc.merge(rg).extend({
                    publisher: eA.optional()
                }),
                rb = A.z.object({
                    name: A.z.string().optional(),
                    bio: A.z.string().optional(),
                    avatar: C.F.nullable().optional(),
                    website: A.z.string().optional(),
                    twitter: A.z.string().optional(),
                    telegram: A.z.string().optional(),
                    facebook: A.z.string().optional(),
                    github: A.z.string().optional(),
                    medium: A.z.string().optional(),
                    linkedin: A.z.string().optional(),
                    reddit: A.z.string().optional(),
                    discord: A.z.string().optional()
                }),
                rC = rb.extend({
                    avatar: A.z.string().nullable().optional()
                }),
                rA = A.z.object({
                    id: A.z.string(),
                    timestamp: ep,
                    metadataUri: A.z.string()
                }),
                rv = A.z.object({
                    title: A.z.string().optional(),
                    author: A.z.string().optional(),
                    details: A.z.string().optional(),
                    notice: A.z.string().optional()
                }),
                rW = A.z.object({
                    name: A.z.string(),
                    abi: ro,
                    metadata: A.z.record(A.z.string(), A.z.any()),
                    info: rv,
                    licenses: A.z.array(A.z.string().optional()).default([]).transform(t => t.filter(t => void 0 !== t)),
                    isPartialAbi: A.z.boolean().optional()
                }),
                rT = rc.merge(rW).extend({
                    bytecode: A.z.string()
                }),
                rE = A.z.object({
                    gasLimit: ep.optional(),
                    gasPrice: ep.optional(),
                    maxFeePerGas: ep.optional(),
                    maxPriorityFeePerGas: ep.optional(),
                    nonce: ep.optional(),
                    value: ep.optional(),
                    blockTag: A.z.union([A.z.string(), A.z.number()]).optional(),
                    from: eA.optional(),
                    type: A.z.number().optional()
                }).strict();
            let ContractEncoder = class ContractEncoder {
                constructor(t) {
                    this.contractWrapper = t
                }
                encode(t, e) {
                    return this.contractWrapper.readContract.interface.encodeFunctionData(t, e)
                }
                decode(t, e) {
                    return this.contractWrapper.readContract.interface.decodeFunctionData(t, e)
                }
            };
            let NotFoundError = class NotFoundError extends Error {
                constructor(t) {
                    super(t ? `Object with id ${t} NOT FOUND` : "NOT_FOUND")
                }
            };
            let MissingRoleError = class MissingRoleError extends Error {
                constructor(t, e) {
                    super(`MISSING ROLE: ${t} does not have the '${e}' role`)
                }
            };
            let DuplicateLeafsError = class DuplicateLeafsError extends Error {
                constructor(t) {
                    super(`DUPLICATE_LEAFS${t?` : ${t}`:""}`)
                }
            };
            let AuctionAlreadyStartedError = class AuctionAlreadyStartedError extends Error {
                constructor(t) {
                    super(`Auction already started with existing bid${t?`, id: ${t}`:""}`)
                }
            };
            let ListingNotFoundError = class ListingNotFoundError extends Error {
                constructor(t, e) {
                    super(`Could not find listing.${t?` marketplace address: ${t}`:""}${e?` listing id: ${e}`:""}`)
                }
            };
            let WrongListingTypeError = class WrongListingTypeError extends Error {
                constructor(t, e, r, a) {
                    super(`Incorrect listing type. Are you sure you're using the right method?.${t?` marketplace address: ${t}`:""}${e?` listing id: ${e}`:""}${a?` expected type: ${a}`:""}${r?` actual type: ${r}`:""}`)
                }
            };
            let AuctionHasNotEndedError = class AuctionHasNotEndedError extends Error {
                constructor(t, e) {
                    super(`Auction has not ended yet${t?`, id: ${t}`:""}${e?`, end time: ${e.toString()}`:""}`)
                }
            };
            let ExtensionNotImplementedError = class ExtensionNotImplementedError extends Error {
                constructor(t) {
                    super(`This functionality is not available because the contract does not implement the '${t.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `)
                }
            };
            let TransactionError = class TransactionError extends Error {#
                t;#
                e;#
                r;
                constructor(t, e) {
                    let r = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
                    if (r += `Reason: ${t.reason}


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
` + withSpaces("from", t.from), t.to && (r += withSpaces("to", t.contractName ? `${t.to} (${t.contractName})` : t.to)), r += withSpaces("chain", `${t.network.name} (${t.network.chainId})`), t.rpcUrl) try {
                        let e = new URL(t.rpcUrl);
                        r += withSpaces("rpc", e.hostname)
                    } catch (t) {}
                    if (t.hash && (r += withSpaces("tx hash", t.hash)), t.value && t.value.gt(0) && (r += withSpaces("value", `${R.formatEther(t.value)} ${eE[t.network.chainId]?.symbol||""}`)), r += withSpaces("data", `${t.data}`), t.method && (r += withSpaces("method", t.method)), t.sources) {
                        let e = t.sources.find(e => e.source.includes(t.reason));
                        if (e) {
                            let a = e.source.split("\n").map((t, e) => `${e+1}  ${t}`),
                                n = a.findIndex(e => e.includes(t.reason));
                            a[n] += "   <-- REVERT";
                            let i = a.slice(n - 8, n + 4);
                            r += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

File: ${e.filename.replace("node_modules/","")}

` + i.join("\n")
                        }
                    }
                    super(r += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

Need helping debugging? Join our Discord: https://discord.gg/thirdweb

`), this.#t = t.reason, this.#e = t, this.#r = e
                }
                get reason() {
                    return this.#t
                }
                get raw() {
                    return this.#r
                }
                get info() {
                    return this.#e
                }
            };

            function parseRevertReason(t) {
                if (t.reason && !t.reason.includes("cannot estimate gas")) return t.reason;
                if (t.error) return t.error;
                let e = t;
                return "object" == typeof t ? e = JSON.stringify(t) : "string" != typeof t && (e = t.toString()), parseMessageParts(/.*?"message":"([^"\\]*).*?/, e) || parseMessageParts(/.*?"reason":"([^"\\]*).*?/, e) || t.message || ""
            }

            function withSpaces(t, e) {
                if ("" === e) return e;
                let r = Array(10 - t.length).fill(" ").join("");
                return e = e.includes("\n") ? "\n\n  " + e.split("\n").join(`
  `) : `${r}${e}`, `
${t}:${e}`
            }

            function parseMessageParts(t, e) {
                let r = e.match(t) || [],
                    a = "";
                return r ? .length > 0 && (a += r[1]), a
            }

            function includesErrorMessage(t, e) {
                return !!t && (t && t.toString().includes(e) || t && t.message && t.message.toString().includes(e) || t && t.error && t.error.toString().includes(e))
            }
            let rk = {
                    name: "ERC20ClaimConditionsV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [K, tm],
                    features: {}
                },
                rS = {
                    name: "ERC20ClaimConditionsV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimconditions"
                    },
                    abis: [K, tf],
                    features: {}
                },
                rP = {
                    name: "ERC20ClaimPhasesV2",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [K, tp],
                    features: {}
                },
                rF = {
                    name: "ERC20ClaimPhasesV1",
                    namespace: "token.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc20dclaimable",
                        contracts: "erc20claimphases"
                    },
                    abis: [tu],
                    features: {}
                },
                rI = {
                    name: "ERC20Burnable",
                    namespace: "token.burn",
                    docLinks: {
                        sdk: "sdk.erc20burnable",
                        contracts: "erc20burnable"
                    },
                    abis: [K, td],
                    features: {}
                },
                rx = {
                    name: "ERC20SignatureMintable",
                    namespace: "token.signature",
                    docLinks: {
                        sdk: "sdk.erc20signaturemintable",
                        contracts: "erc20signaturemint"
                    },
                    abis: [K, tw],
                    features: {}
                },
                rM = {
                    name: "ERC20BatchMintable",
                    namespace: "token.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc20batchmintable",
                        contracts: "erc20batchmintable"
                    },
                    abis: [K, tg, ty],
                    features: {}
                },
                rR = {
                    name: "ERC20Mintable",
                    namespace: "token.mint",
                    docLinks: {
                        sdk: "sdk.erc20mintable",
                        contracts: "erc20mintable"
                    },
                    abis: [K, tg],
                    features: {
                        [rM.name]: rM
                    }
                },
                rO = {
                    name: "ERC20Permit",
                    namespace: "token.permit",
                    docLinks: {
                        sdk: "sdk.erc20permit",
                        contracts: "erc20permit"
                    },
                    abis: [K, th],
                    features: {}
                },
                rN = {
                    name: "ERC20",
                    namespace: "token",
                    docLinks: {
                        sdk: "sdk.erc20",
                        contracts: "erc20"
                    },
                    abis: [K, Q],
                    features: {
                        [rI.name]: rI,
                        [rR.name]: rR,
                        [rk.name]: rk,
                        [rS.name]: rS,
                        [rF.name]: rF,
                        [rP.name]: rP,
                        [rx.name]: rx,
                        [rO.name]: rO
                    }
                },
                rD = {
                    name: "ERC721Burnable",
                    namespace: "nft.burn",
                    docLinks: {
                        sdk: "sdk.erc721burnable",
                        contracts: "erc721burnable"
                    },
                    abis: [tn, tb],
                    features: {}
                },
                rB = {
                    name: "ERC721Revealable",
                    namespace: "nft.drop.revealer",
                    docLinks: {
                        sdk: "sdk.delayedreveal",
                        contracts: "erc721revealable"
                    },
                    abis: [tn, tk, tA],
                    features: {}
                },
                rL = {
                    name: "ERC721TieredDrop",
                    namespace: "nft.tieredDrop",
                    docLinks: {
                        sdk: "sdk.erc721tiereddrop",
                        contracts: ""
                    },
                    abis: [tn, tI],
                    features: {}
                },
                rz = {
                    name: "ERC721ClaimConditionsV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [tn, tm],
                    features: {}
                },
                r$ = {
                    name: "ERC721ClaimConditionsV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimconditions"
                    },
                    abis: [tn, tf],
                    features: {}
                },
                rU = {
                    name: "ERC721ClaimPhasesV1",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [tv],
                    features: {}
                },
                rV = {
                    name: "ERC721ClaimPhasesV2",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimphases"
                    },
                    abis: [tn, tp],
                    features: {}
                },
                r_ = {
                    name: "ERC721ClaimCustom",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimcustom"
                    },
                    abis: [tn, tC],
                    features: {}
                },
                rj = {
                    name: "ERC721ClaimZora",
                    namespace: "nft.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc721claimable",
                        contracts: "erc721claimzora"
                    },
                    abis: [tn, tM],
                    features: {}
                },
                rq = {
                    name: "ERC721LazyMintable",
                    namespace: "nft.drop",
                    docLinks: {
                        sdk: "sdk.erc721lazymintable",
                        contracts: "lazymint"
                    },
                    abis: [tn, tk],
                    features: {
                        [rB.name]: rB
                    }
                },
                rG = {
                    name: "ERC721BatchMintable",
                    namespace: "nft.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc721batchmintable",
                        contracts: "erc721batchmintable"
                    },
                    abis: [tn, tS, ty],
                    features: {}
                },
                rH = {
                    name: "ERC721Mintable",
                    namespace: "nft.mint",
                    docLinks: {
                        sdk: "sdk.erc721mintable",
                        contracts: "erc721mintable"
                    },
                    abis: [tn, tS],
                    features: {
                        [rG.name]: rG
                    }
                },
                rZ = {
                    name: "ERC721SignatureMintV2",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [tn, tP],
                    features: {}
                },
                rJ = {
                    name: "ERC721SignatureMintV1",
                    namespace: "nft.signature",
                    docLinks: {
                        sdk: "sdk.erc721signaturemint",
                        contracts: "erc721signaturemint"
                    },
                    abis: [tF],
                    features: {}
                },
                rK = {
                    name: "ERC721Enumerable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "sdk.erc721enumerable",
                        contracts: "erc721enumerable"
                    },
                    abis: [tn, tW],
                    features: {}
                },
                rQ = {
                    name: "ERC721AQueryable",
                    namespace: "nft.query.owned",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [tT],
                    features: {}
                },
                rY = {
                    name: "ERC721Supply",
                    namespace: "nft.query",
                    docLinks: {
                        sdk: "sdk.erc721supply",
                        contracts: "erc721supply"
                    },
                    abis: [tn, tE],
                    features: {
                        [rK.name]: rK,
                        [rQ.name]: rQ
                    }
                },
                rX = {
                    name: "ERC721SharedMetadata",
                    namespace: "nft.sharedmetadata",
                    docLinks: {
                        sdk: "sdk.sharedmetadata",
                        contracts: "SharedMetadata"
                    },
                    abis: [tn, tx],
                    features: {}
                },
                r0 = {
                    name: "ERC721LoyaltyCard",
                    namespace: "nft.loyaltyCard",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [tR],
                    features: {}
                },
                r1 = {
                    name: "ERC721UpdatableMetadata",
                    namespace: "nft.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [tn, tO],
                    features: {}
                },
                r2 = {
                    name: "ERC721",
                    namespace: "nft",
                    docLinks: {
                        sdk: "sdk.erc721",
                        contracts: "erc721"
                    },
                    abis: [tn, Z],
                    features: {
                        [rD.name]: rD,
                        [rY.name]: rY,
                        [rH.name]: rH,
                        [rq.name]: rq,
                        [rJ.name]: rJ,
                        [rZ.name]: rZ,
                        [rL.name]: rL,
                        [r_.name]: r_,
                        [rj.name]: rj,
                        [rz.name]: rz,
                        [r$.name]: r$,
                        [rU.name]: rU,
                        [rV.name]: rV,
                        [rX.name]: rX,
                        [r0.name]: r0,
                        [r1.name]: r1
                    }
                },
                r5 = {
                    name: "ERC1155Burnable",
                    namespace: "edition.burn",
                    docLinks: {
                        sdk: "sdk.erc1155burnable",
                        contracts: "erc1155burnable"
                    },
                    abis: [ta, tN],
                    features: {}
                },
                r6 = {
                    name: "ERC1155ClaimConditionsV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155dropsinglephase"
                    },
                    abis: [ta, t$],
                    features: {}
                },
                r8 = {
                    name: "ERC1155ClaimConditionsV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimconditions"
                    },
                    abis: [ta, tz],
                    features: {}
                },
                r3 = {
                    name: "ERC1155ClaimPhasesV2",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [ta, tB],
                    features: {}
                },
                r7 = {
                    name: "ERC1155ClaimPhasesV1",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimphases"
                    },
                    abis: [tL],
                    features: {}
                },
                r4 = {
                    name: "ERC1155ClaimCustom",
                    namespace: "edition.drop.claim",
                    docLinks: {
                        sdk: "sdk.erc1155claimable",
                        contracts: "erc1155claimcustom"
                    },
                    abis: [ta, tD],
                    features: {}
                },
                r9 = {
                    name: "ERC1155Revealable",
                    namespace: "edition.drop.revealer",
                    docLinks: {
                        sdk: "sdk.drop.delayedreveal",
                        contracts: "erc1155revealable"
                    },
                    abis: [ta, tk, tA],
                    features: {}
                },
                at = {
                    name: "ERC1155LazyMintableV2",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [ta, tk],
                    features: {
                        [r9.name]: r9
                    }
                },
                ae = {
                    name: "ERC1155LazyMintableV1",
                    namespace: "edition.drop",
                    docLinks: {
                        sdk: "sdk.erc1155droppable",
                        contracts: "lazymint"
                    },
                    abis: [tL],
                    features: {
                        [r7.name]: r7
                    }
                },
                ar = {
                    name: "ERC1155SignatureMintable",
                    namespace: "edition.signature",
                    docLinks: {
                        sdk: "sdk.erc1155signaturemintable",
                        contracts: "erc1155signaturemint"
                    },
                    abis: [ta, tj],
                    features: {}
                },
                aa = {
                    name: "ERC1155BatchMintable",
                    namespace: "edition.mint.batch",
                    docLinks: {
                        sdk: "sdk.erc1155batchmintable",
                        contracts: "erc1155batchmintable"
                    },
                    abis: [ta, t_, ty],
                    features: {}
                },
                an = {
                    name: "ERC1155Mintable",
                    namespace: "edition.mint",
                    docLinks: {
                        sdk: "sdk.erc1155mintable",
                        contracts: "erc1155mintable"
                    },
                    abis: [ta, t_],
                    features: {
                        [aa.name]: aa
                    }
                },
                ai = {
                    name: "ERC1155Enumerable",
                    namespace: "edition.query",
                    docLinks: {
                        sdk: "sdk.erc1155",
                        contracts: "erc1155enumerable"
                    },
                    abis: [ta, tV],
                    features: {}
                },
                as = {
                    name: "ERC1155UpdatableMetadata",
                    namespace: "edition.metadata",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ta, tO],
                    features: {}
                },
                ao = {
                    name: "ERC1155Supply",
                    namespace: "edition.supply",
                    docLinks: {
                        sdk: "",
                        contracts: ""
                    },
                    abis: [ta, tU],
                    features: {}
                },
                ac = {
                    name: "ERC1155",
                    namespace: "edition",
                    docLinks: {
                        sdk: "sdk.erc1155enumerable",
                        contracts: "erc1155"
                    },
                    abis: [ta, J, [{
                        inputs: [],
                        name: "name",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }, {
                        inputs: [],
                        name: "symbol",
                        outputs: [{
                            internalType: "string",
                            name: "",
                            type: "string"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }]],
                    features: {
                        [ao.name]: ao,
                        [r5.name]: r5,
                        [ai.name]: ai,
                        [an.name]: an,
                        [ae.name]: ae,
                        [at.name]: at,
                        [r9.name]: r9,
                        [ar.name]: ar,
                        [r4.name]: r4,
                        [r6.name]: r6,
                        [r8.name]: r8,
                        [r3.name]: r3,
                        [as.name]: as
                    }
                },
                al = [{
                    inputs: [],
                    name: "getAllPlugins",
                    outputs: [{
                        components: [{
                            internalType: "bytes4",
                            name: "functionSelector",
                            type: "bytes4"
                        }, {
                            internalType: "string",
                            name: "functionSignature",
                            type: "string"
                        }, {
                            internalType: "address",
                            name: "pluginAddress",
                            type: "address"
                        }],
                        internalType: "struct IPluginMap.Plugin[]",
                        name: "registered",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ad = [{
                    inputs: [],
                    name: "getAllExtensions",
                    outputs: [{
                        components: [{
                            components: [{
                                internalType: "string",
                                name: "name",
                                type: "string"
                            }, {
                                internalType: "string",
                                name: "metadataURI",
                                type: "string"
                            }, {
                                internalType: "address",
                                name: "implementation",
                                type: "address"
                            }],
                            internalType: "struct IExtension.ExtensionMetadata",
                            name: "metadata",
                            type: "tuple"
                        }, {
                            components: [{
                                internalType: "bytes4",
                                name: "functionSelector",
                                type: "bytes4"
                            }, {
                                internalType: "string",
                                name: "functionSignature",
                                type: "string"
                            }],
                            internalType: "struct IExtension.ExtensionFunction[]",
                            name: "functions",
                            type: "tuple[]"
                        }],
                        internalType: "struct IExtension.Extension[]",
                        name: "allExtensions",
                        type: "tuple[]"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                ap = {
                    name: "Royalty",
                    namespace: "royalty",
                    docLinks: {
                        sdk: "sdk.contractroyalty",
                        contracts: "royalty"
                    },
                    abis: [t2],
                    features: {}
                },
                au = {
                    name: "PrimarySale",
                    namespace: "sales",
                    docLinks: {
                        sdk: "sdk.contractprimarysale",
                        contracts: "primarysale"
                    },
                    abis: [t1],
                    features: {}
                },
                af = {
                    name: "PlatformFee",
                    namespace: "platformFees",
                    docLinks: {
                        sdk: "sdk.platformfee",
                        contracts: "platformfee"
                    },
                    abis: [t0],
                    features: {}
                },
                am = {
                    name: "PermissionsEnumerable",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissionsenumerable"
                    },
                    abis: [tX],
                    features: {}
                },
                ah = {
                    name: "Permissions",
                    namespace: "roles",
                    docLinks: {
                        sdk: "sdk.contractroles",
                        contracts: "permissions"
                    },
                    abis: [tY],
                    features: {
                        [am.name]: am
                    }
                },
                ag = {
                    name: "ContractMetadata",
                    namespace: "metadata",
                    docLinks: {
                        sdk: "sdk.contractmetadata",
                        contracts: "contractmetadata"
                    },
                    abis: [tH],
                    features: {}
                },
                ay = {
                    name: "AppURI",
                    namespace: "appURI",
                    docLinks: {
                        sdk: "sdk.appURI",
                        contracts: ""
                    },
                    abis: [tG],
                    features: {}
                },
                aw = {
                    name: "Ownable",
                    namespace: "owner",
                    docLinks: {
                        sdk: "sdk.owner",
                        contracts: "ownable"
                    },
                    abis: [t5],
                    features: {}
                },
                ab = {
                    name: "Gasless",
                    namespace: "gasless",
                    docLinks: {
                        sdk: "sdk.gaslesstransaction",
                        contracts: "IERC2771Context"
                    },
                    abis: [tq],
                    features: {}
                },
                aC = {
                    name: "PackVRF",
                    namespace: "pack.vrf",
                    docLinks: {
                        sdk: "sdk.packvrf",
                        contracts: "IPackVRF"
                    },
                    abis: [tQ],
                    features: {}
                },
                aA = {
                    name: "PluginRouter",
                    namespace: "plugin.router",
                    docLinks: {
                        sdk: "sdk.pluginrouter",
                        contracts: "PluginRouter"
                    },
                    abis: [al],
                    features: {}
                },
                av = {
                    name: "DynamicContract",
                    namespace: "dynamic.contract",
                    docLinks: {
                        sdk: "",
                        contracts: "IExtensionsManager"
                    },
                    abis: [ad],
                    features: {}
                },
                aW = {
                    name: "DirectListings",
                    namespace: "direct.listings",
                    docLinks: {
                        sdk: "",
                        contracts: "IDirectListings"
                    },
                    abis: [tZ],
                    features: {}
                },
                aT = {
                    name: "EnglishAuctions",
                    namespace: "english.auctions",
                    docLinks: {
                        sdk: "",
                        contracts: "IEnglishAuctions"
                    },
                    abis: [tJ],
                    features: {}
                },
                aE = {
                    name: "Offers",
                    namespace: "offers",
                    docLinks: {
                        sdk: "",
                        contracts: "IOffers"
                    },
                    abis: [tK],
                    features: {}
                },
                ak = {
                    name: "AccountFactory",
                    namespace: "accountFactory",
                    docLinks: {
                        sdk: "sdk.accountFactory",
                        contracts: "IAccountFactory"
                    },
                    abis: [t7],
                    features: {}
                },
                aS = {
                    name: "AccountPermissions",
                    namespace: "accountPermissions",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccountPermissions"
                    },
                    abis: [t4],
                    features: {}
                },
                aP = {
                    name: "Account",
                    namespace: "account",
                    docLinks: {
                        sdk: "sdk.account",
                        contracts: "IAccount"
                    },
                    abis: [t9],
                    features: {
                        [aS.name]: aS
                    }
                },
                aF = {
                    name: "AirdropERC20",
                    namespace: "airdrop20",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC20"
                    },
                    abis: [t6],
                    features: {}
                },
                aI = {
                    name: "AirdropERC721",
                    namespace: "airdrop721",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC721"
                    },
                    abis: [t8],
                    features: {}
                },
                ax = {
                    name: "AirdropERC1155",
                    namespace: "airdrop1155",
                    docLinks: {
                        sdk: "",
                        contracts: "IAirdropERC1155"
                    },
                    abis: [t3],
                    features: {}
                },
                aM = {
                    [rN.name]: rN,
                    [r2.name]: r2,
                    [ac.name]: ac,
                    [ap.name]: ap,
                    [af.name]: af,
                    [au.name]: au,
                    [ah.name]: ah,
                    [ag.name]: ag,
                    [ay.name]: ay,
                    [aw.name]: aw,
                    [ab.name]: ab,
                    [aC.name]: aC,
                    [aA.name]: aA,
                    [av.name]: av,
                    [aW.name]: aW,
                    [aT.name]: aT,
                    [aE.name]: aE,
                    [aF.name]: aF,
                    [aI.name]: aI,
                    [ax.name]: ax,
                    [ak.name]: ak,
                    [aP.name]: aP,
                    [r0.name]: r0,
                    [r1.name]: r1
                };

            function toJSType(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    a = t.type,
                    n = !1;
                return a.endsWith("[]") && (n = !0, a = a.slice(0, -2)), a.startsWith("bytes") && (a = "BytesLike"), (a.startsWith("uint") || a.startsWith("int")) && (a = e ? "BigNumber" : "BigNumberish"), a.startsWith("bool") && (a = "boolean"), "address" === a && (a = "string"), "tuple" === a && t.components && (a = `{ ${t.components.map(t=>toJSType(t,!1,!0)).join(", ")} }`), n && (a += "[]"), r && (a = `${t.name}: ${a}`), a
            }

            function extractCommentFromMetadata(t, e, r) {
                return e ? .output ? .userdoc ? .[r] ? .[Object.keys(e ? .output ? .userdoc[r] || {}).find(e => e.includes(t || "unknown")) || ""] ? .notice || e ? .output ? .devdoc ? .[r] ? .[Object.keys(e ? .output ? .devdoc[r] || {}).find(e => e.includes(t || "unknown")) || ""] ? .details
            }

            function extractFunctionsFromAbi(t, e) {
                let r = (t || []).filter(t => "function" === t.type),
                    a = [];
                for (let t of r) {
                    let r = extractCommentFromMetadata(t.name, e, "methods"),
                        n = t.inputs ? .map(t => `${t.name||"key"}: ${toJSType(t)}`) ? .join(", ") || "",
                        i = n ? `, [${n}]` : "",
                        s = t.outputs ? .map(t => toJSType(t, !0)) ? .join(", "),
                        o = s ? `: Promise<${s}>` : ": Promise<TransactionResult>",
                        c = `contract.call("${t.name}"${i})${o}`;
                    a.push({
                        inputs: t.inputs || [],
                        outputs: t.outputs || [],
                        name: t.name || "unknown",
                        signature: c,
                        stateMutability: t.stateMutability || "",
                        comment: r
                    })
                }
                return a
            }

            function detectFeatures(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : aM,
                    r = {};
                for (let a in e) {
                    let n = e[a],
                        i = function(t, e) {
                            let r = extractFunctionsFromAbi(t),
                                a = e.flatMap(t => extractFunctionsFromAbi(t)),
                                n = r.filter(t => {
                                    let e = a.find(e => e.name === t.name && e.inputs.length === t.inputs.length && e.inputs.every((e, r) => "tuple" === e.type || "tuple[]" === e.type ? e.type === t.inputs[r].type && e.components ? .every((e, a) => e.type === t.inputs[r].components ? .[a] ? .type) : e.type === t.inputs[r].type));
                                    return void 0 !== e
                                });
                            return n.length === a.length
                        }(t, n.abis),
                        s = detectFeatures(t, n.features);
                    r[a] = { ...n,
                        features: s,
                        enabled: i
                    }
                }
                return r
            }

            function isFeatureEnabled(t, e) {
                let r = detectFeatures(t);
                return function _featureEnabled(t, e) {
                    let r = Object.keys(t);
                    if (!r.includes(e)) {
                        let a = !1;
                        for (let n of r) {
                            let r = t[n];
                            if (a = _featureEnabled(r.features, e)) break
                        }
                        return a
                    }
                    let a = t[e];
                    return a.enabled
                }(r, e)
            }

            function detectContractFeature(t, e) {
                return isFeatureEnabled(ro.parse(t.abi), e)
            }

            function hasFunction(t, e) {
                return t in e.readContract.functions
            }
            try {
                n = new TextDecoder
            } catch (t) {}
            let aR = 0,
                aO = {},
                aN = {},
                aD = 0,
                aB = 0,
                aL = [],
                az = [],
                a$ = {
                    useRecords: !1,
                    mapsAsObjects: !0
                },
                aU = !1;
            let Decoder = class Decoder {
                constructor(t) {
                    if (t && ((t.keyMap || t._keyMap) && !t.useRecords && (t.useRecords = !1, t.mapsAsObjects = !0), !1 === t.useRecords && void 0 === t.mapsAsObjects && (t.mapsAsObjects = !0), t.getStructures && (t.getShared = t.getStructures), t.getShared && !t.structures && ((t.structures = []).uninitialized = !0), t.keyMap))
                        for (let [e, r] of (this.mapKey = new Map, Object.entries(t.keyMap))) this.mapKey.set(r, e);
                    Object.assign(this, t)
                }
                decodeKey(t) {
                    return this.keyMap && this.mapKey.get(t) || t
                }
                decode(t, e) {
                    if (i) return saveState(() => (clearSource(), this ? this.decode(t, e) : Decoder.prototype.decode.call(a$, t, e)));
                    s = e > -1 ? e : t.length, aR = 0, aB = 0, c = null, l = null, i = t;
                    try {
                        u = t.dataView || (t.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength))
                    } catch (e) {
                        if (i = null, t instanceof Uint8Array) throw e;
                        throw Error("Source must be a Uint8Array or Buffer but was a " + (t && "object" == typeof t ? t.constructor.name : typeof t))
                    }
                    return this instanceof Decoder ? (aN = this, p = this.sharedValues && (this.pack ? Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues), this.structures ? o = this.structures : (!o || o.length > 0) && (o = [])) : (aN = a$, (!o || o.length > 0) && (o = []), p = null),
                        function() {
                            try {
                                let t = read();
                                if (l) {
                                    if (aR >= l.postBundlePosition) {
                                        let t = Error("Unexpected bundle position");
                                        throw t.incomplete = !0, t
                                    }
                                    aR = l.postBundlePosition, l = null
                                }
                                if (aR == s) o = null, i = null, d && (d = null);
                                else if (aR > s) {
                                    let t = Error("Unexpected end of CBOR data");
                                    throw t.incomplete = !0, t
                                } else if (!aU) throw Error("Data read, but end of buffer not reached");
                                return t
                            } catch (t) {
                                throw clearSource(), (t instanceof RangeError || t.message.startsWith("Unexpected end of buffer")) && (t.incomplete = !0), t
                            }
                        }()
                }
            };

            function read() {
                let t = i[aR++],
                    e = t >> 5;
                if ((t &= 31) > 23) switch (t) {
                    case 24:
                        t = i[aR++];
                        break;
                    case 25:
                        if (7 == e) return function() {
                            let t = i[aR++],
                                e = i[aR++],
                                r = (127 & t) >> 2;
                            if (31 === r) return e || 3 & t ? NaN : 128 & t ? -1 / 0 : 1 / 0;
                            if (0 === r) {
                                let r = ((3 & t) << 8 | e) / 16777216;
                                return 128 & t ? -r : r
                            }
                            return aG[3] = 128 & t | (r >> 1) + 56, aG[2] = (7 & t) << 5 | e >> 3, aG[1] = e << 5, aG[0] = 0, aq[0]
                        }();
                        t = u.getUint16(aR), aR += 2;
                        break;
                    case 26:
                        if (7 == e) {
                            let t = u.getFloat32(aR);
                            if (aN.useFloat32 > 2) {
                                let e = aQ[(127 & i[aR]) << 1 | i[aR + 1] >> 7];
                                return aR += 4, (e * t + (t > 0 ? .5 : -.5) >> 0) / e
                            }
                            return aR += 4, t
                        }
                        t = u.getUint32(aR), aR += 4;
                        break;
                    case 27:
                        if (7 == e) {
                            let t = u.getFloat64(aR);
                            return aR += 8, t
                        }
                        if (e > 1) {
                            if (u.getUint32(aR) > 0) throw Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
                            t = u.getUint32(aR + 4)
                        } else t = aN.int64AsNumber ? 4294967296 * u.getUint32(aR) + u.getUint32(aR + 4) : u.getBigUint64(aR);
                        aR += 8;
                        break;
                    case 31:
                        switch (e) {
                            case 2:
                            case 3:
                                throw Error("Indefinite length not supported for byte or text strings");
                            case 4:
                                let r = [],
                                    a, n = 0;
                                for (;
                                    (a = read()) != aO;) r[n++] = a;
                                return 4 == e ? r : 3 == e ? r.join("") : ei.concat(r);
                            case 5:
                                let d;
                                if (aN.mapsAsObjects) {
                                    let t = {};
                                    if (aN.keyMap)
                                        for (;
                                            (d = read()) != aO;) t[safeKey(aN.decodeKey(d))] = read();
                                    else
                                        for (;
                                            (d = read()) != aO;) t[safeKey(d)] = read();
                                    return t
                                } {
                                    f && (aN.mapsAsObjects = !0, f = !1);
                                    let t = new Map;
                                    if (aN.keyMap)
                                        for (;
                                            (d = read()) != aO;) t.set(aN.decodeKey(d), read());
                                    else
                                        for (;
                                            (d = read()) != aO;) t.set(d, read());
                                    return t
                                }
                            case 7:
                                return aO;
                            default:
                                throw Error("Invalid major type for indefinite length " + e)
                        }
                    default:
                        throw Error("Unknown token " + t)
                }
                switch (e) {
                    case 0:
                        return t;
                    case 1:
                        return ~t;
                    case 2:
                        var m;
                        return m = t, aN.copyBuffers ? Uint8Array.prototype.slice.call(i, aR, aR += m) : i.subarray(aR, aR += m);
                    case 3:
                        if (aB >= aR) return c.slice(aR - aD, (aR += t) - aD);
                        if (0 == aB && s < 140 && t < 32) {
                            let e = t < 16 ? shortStringInJS(t) : function(t) {
                                let e = aR,
                                    r = Array(t);
                                for (let a = 0; a < t; a++) {
                                    let t = i[aR++];
                                    if ((128 & t) > 0) {
                                        aR = e;
                                        return
                                    }
                                    r[a] = t
                                }
                                return aj.apply(String, r)
                            }(t);
                            if (null != e) return e
                        }
                        return a_(t);
                    case 4:
                        let h = Array(t);
                        for (let e = 0; e < t; e++) h[e] = read();
                        return h;
                    case 5:
                        if (aN.mapsAsObjects) {
                            let e = {};
                            if (aN.keyMap)
                                for (let r = 0; r < t; r++) e[safeKey(aN.decodeKey(read()))] = read();
                            else
                                for (let r = 0; r < t; r++) e[safeKey(read())] = read();
                            return e
                        } {
                            f && (aN.mapsAsObjects = !0, f = !1);
                            let e = new Map;
                            if (aN.keyMap)
                                for (let r = 0; r < t; r++) e.set(aN.decodeKey(read()), read());
                            else
                                for (let r = 0; r < t; r++) e.set(read(), read());
                            return e
                        }
                    case 6:
                        if (t >= 57337) {
                            let e = o[8191 & t];
                            if (e) return e.read || (e.read = createStructureReader(e)), e.read();
                            if (t < 65536) {
                                if (57343 == t) return recordDefinition(read());
                                if (57342 == t) {
                                    let t = readJustLength(),
                                        e = read();
                                    for (let r = 2; r < t; r++) recordDefinition([e++, read()]);
                                    return read()
                                }
                                if (57337 == t) return function() {
                                    let t = readJustLength(),
                                        e = aR + read();
                                    for (let e = 2; e < t; e++) {
                                        let t = readJustLength();
                                        aR += t
                                    }
                                    let r = aR;
                                    return aR = e, (l = [readStringJS(readJustLength()), readStringJS(readJustLength())]).position0 = 0, l.position1 = 0, l.postBundlePosition = aR, aR = r, read()
                                }();
                                if (aN.getShared && (loadShared(), e = o[8191 & t])) return e.read || (e.read = createStructureReader(e)), e.read()
                            }
                        }
                        let g = aL[t];
                        if (g) {
                            if (g.handlesRead) return g(read);
                            return g(read())
                        } {
                            let e = read();
                            for (let r = 0; r < az.length; r++) {
                                let a = az[r](t, e);
                                if (void 0 !== a) return a
                            }
                            return new Tag(e, t)
                        }
                    case 7:
                        switch (t) {
                            case 20:
                                return !1;
                            case 21:
                                return !0;
                            case 22:
                                return null;
                            case 23:
                                return;
                            default:
                                let y = (p || getPackedValues())[t];
                                if (void 0 !== y) return y;
                                throw Error("Unknown token " + t)
                        }
                    default:
                        if (isNaN(t)) {
                            let t = Error("Unexpected end of CBOR data");
                            throw t.incomplete = !0, t
                        }
                        throw Error("Unknown CBOR token " + t)
                }
            }
            let aV = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;

            function createStructureReader(t) {
                return t.slowReads = 0,
                    function() {
                        let t = i[aR++];
                        if ((t &= 31) > 23) switch (t) {
                            case 24:
                                t = i[aR++];
                                break;
                            case 25:
                                t = u.getUint16(aR), aR += 2;
                                break;
                            case 26:
                                t = u.getUint32(aR), aR += 4;
                                break;
                            default:
                                throw Error("Expected array header, but got " + i[aR - 1])
                        }
                        let e = this.compiledReader;
                        for (; e;) {
                            if (e.propertyCount === t) return e(read);
                            e = e.next
                        }
                        if (this.slowReads++ >= 3) {
                            let r = this.length == t ? this : this.slice(0, t);
                            return e = aN.keyMap ? Function("r", "return {" + r.map(t => aN.decodeKey(t)).map(t => aV.test(t) ? safeKey(t) + ":r()" : "[" + JSON.stringify(t) + "]:r()").join(",") + "}") : Function("r", "return {" + r.map(t => aV.test(t) ? safeKey(t) + ":r()" : "[" + JSON.stringify(t) + "]:r()").join(",") + "}"), this.compiledReader && (e.next = this.compiledReader), e.propertyCount = t, this.compiledReader = e, e(read)
                        }
                        let r = {};
                        if (aN.keyMap)
                            for (let e = 0; e < t; e++) r[safeKey(aN.decodeKey(this[e]))] = read();
                        else
                            for (let e = 0; e < t; e++) r[safeKey(this[e])] = read();
                        return r
                    }
            }

            function safeKey(t) {
                return "__proto__" === t ? "__proto_" : t
            }
            let a_ = readStringJS;

            function readStringJS(t) {
                let e;
                if (t < 16 && (e = shortStringInJS(t))) return e;
                if (t > 64 && n) return n.decode(i.subarray(aR, aR += t));
                let r = aR + t,
                    a = [];
                for (e = ""; aR < r;) {
                    let t = i[aR++];
                    if ((128 & t) == 0) a.push(t);
                    else if ((224 & t) == 192) {
                        let e = 63 & i[aR++];
                        a.push((31 & t) << 6 | e)
                    } else if ((240 & t) == 224) {
                        let e = 63 & i[aR++],
                            r = 63 & i[aR++];
                        a.push((31 & t) << 12 | e << 6 | r)
                    } else if ((248 & t) == 240) {
                        let e = 63 & i[aR++],
                            r = 63 & i[aR++],
                            n = 63 & i[aR++],
                            s = (7 & t) << 18 | e << 12 | r << 6 | n;
                        s > 65535 && (s -= 65536, a.push(s >>> 10 & 1023 | 55296), s = 56320 | 1023 & s), a.push(s)
                    } else a.push(t);
                    a.length >= 4096 && (e += aj.apply(String, a), a.length = 0)
                }
                return a.length > 0 && (e += aj.apply(String, a)), e
            }
            let aj = String.fromCharCode;

            function shortStringInJS(t) {
                if (t < 4) {
                    if (t < 2) {
                        if (0 === t) return ""; {
                            let t = i[aR++];
                            if ((128 & t) > 1) {
                                aR -= 1;
                                return
                            }
                            return aj(t)
                        }
                    } {
                        let e = i[aR++],
                            r = i[aR++];
                        if ((128 & e) > 0 || (128 & r) > 0) {
                            aR -= 2;
                            return
                        }
                        if (t < 3) return aj(e, r);
                        let a = i[aR++];
                        if ((128 & a) > 0) {
                            aR -= 3;
                            return
                        }
                        return aj(e, r, a)
                    }
                } {
                    let e = i[aR++],
                        r = i[aR++],
                        a = i[aR++],
                        n = i[aR++];
                    if ((128 & e) > 0 || (128 & r) > 0 || (128 & a) > 0 || (128 & n) > 0) {
                        aR -= 4;
                        return
                    }
                    if (t < 6) {
                        if (4 === t) return aj(e, r, a, n); {
                            let t = i[aR++];
                            if ((128 & t) > 0) {
                                aR -= 5;
                                return
                            }
                            return aj(e, r, a, n, t)
                        }
                    }
                    if (t < 8) {
                        let s = i[aR++],
                            o = i[aR++];
                        if ((128 & s) > 0 || (128 & o) > 0) {
                            aR -= 6;
                            return
                        }
                        if (t < 7) return aj(e, r, a, n, s, o);
                        let c = i[aR++];
                        if ((128 & c) > 0) {
                            aR -= 7;
                            return
                        }
                        return aj(e, r, a, n, s, o, c)
                    } {
                        let s = i[aR++],
                            o = i[aR++],
                            c = i[aR++],
                            l = i[aR++];
                        if ((128 & s) > 0 || (128 & o) > 0 || (128 & c) > 0 || (128 & l) > 0) {
                            aR -= 8;
                            return
                        }
                        if (t < 10) {
                            if (8 === t) return aj(e, r, a, n, s, o, c, l); {
                                let t = i[aR++];
                                if ((128 & t) > 0) {
                                    aR -= 9;
                                    return
                                }
                                return aj(e, r, a, n, s, o, c, l, t)
                            }
                        }
                        if (t < 12) {
                            let d = i[aR++],
                                p = i[aR++];
                            if ((128 & d) > 0 || (128 & p) > 0) {
                                aR -= 10;
                                return
                            }
                            if (t < 11) return aj(e, r, a, n, s, o, c, l, d, p);
                            let u = i[aR++];
                            if ((128 & u) > 0) {
                                aR -= 11;
                                return
                            }
                            return aj(e, r, a, n, s, o, c, l, d, p, u)
                        } {
                            let d = i[aR++],
                                p = i[aR++],
                                u = i[aR++],
                                f = i[aR++];
                            if ((128 & d) > 0 || (128 & p) > 0 || (128 & u) > 0 || (128 & f) > 0) {
                                aR -= 12;
                                return
                            }
                            if (t < 14) {
                                if (12 === t) return aj(e, r, a, n, s, o, c, l, d, p, u, f); {
                                    let t = i[aR++];
                                    if ((128 & t) > 0) {
                                        aR -= 13;
                                        return
                                    }
                                    return aj(e, r, a, n, s, o, c, l, d, p, u, f, t)
                                }
                            } {
                                let m = i[aR++],
                                    h = i[aR++];
                                if ((128 & m) > 0 || (128 & h) > 0) {
                                    aR -= 14;
                                    return
                                }
                                if (t < 15) return aj(e, r, a, n, s, o, c, l, d, p, u, f, m, h);
                                let g = i[aR++];
                                if ((128 & g) > 0) {
                                    aR -= 15;
                                    return
                                }
                                return aj(e, r, a, n, s, o, c, l, d, p, u, f, m, h, g)
                            }
                        }
                    }
                }
            }
            let aq = new Float32Array(1),
                aG = new Uint8Array(aq.buffer, 0, 4);
            let Tag = class Tag {
                constructor(t, e) {
                    this.value = t, this.tag = e
                }
            };
            aL[0] = t => new Date(t), aL[1] = t => new Date(Math.round(1e3 * t)), aL[2] = t => {
                let e = BigInt(0);
                for (let r = 0, a = t.byteLength; r < a; r++) e = BigInt(t[r]) + e << BigInt(8);
                return e
            }, aL[3] = t => BigInt(-1) - aL[2](t), aL[4] = t => Number(t[1] + "e" + t[0]), aL[5] = t => t[1] * Math.exp(t[0] * Math.log(2));
            let recordDefinition = t => {
                let e = t[0] - 57344,
                    r = t[1],
                    a = o[e];
                a && a.isShared && ((o.restoreStructures || (o.restoreStructures = []))[e] = a), o[e] = r, r.read = createStructureReader(r);
                let n = {};
                if (aN.keyMap)
                    for (let e = 2, a = t.length; e < a; e++) n[safeKey(aN.decodeKey(r[e - 2]))] = t[e];
                else
                    for (let e = 2, a = t.length; e < a; e++) n[safeKey(r[e - 2])] = t[e];
                return n
            };
            aL[105] = recordDefinition, aL[14] = t => l ? l[0].slice(l.position0, l.position0 += t) : new Tag(t, 14), aL[15] = t => l ? l[1].slice(l.position1, l.position1 += t) : new Tag(t, 15);
            let aH = {
                Error,
                RegExp
            };
            aL[27] = t => (aH[t[0]] || Error)(t[1], t[2]);
            let packedTable = t => {
                if (132 != i[aR++]) throw Error("Packed values structure must be followed by a 4 element array");
                let e = t();
                return (p = p ? e.concat(p.slice(e.length)) : e).prefixes = t(), p.suffixes = t(), t()
            };

            function combine(t, e) {
                return "string" == typeof t ? t + e : t instanceof Array ? t.concat(e) : Object.assign({}, t, e)
            }

            function getPackedValues() {
                if (!p) {
                    if (aN.getShared) loadShared();
                    else throw Error("No packed values available")
                }
                return p
            }
            packedTable.handlesRead = !0, aL[51] = packedTable, aL[6] = t => {
                if (!p) {
                    if (!aN.getShared) return new Tag(t, 6);
                    loadShared()
                }
                if ("number" == typeof t) return p[16 + (t >= 0 ? 2 * t : -2 * t - 1)];
                throw Error("No support for non-integer packed references yet")
            }, aL[25] = t => stringRefs[t], aL[256] = t => {
                stringRefs = [];
                try {
                    return t()
                } finally {
                    stringRefs = null
                }
            }, aL[256].handlesRead = !0, aL[28] = t => {
                let e;
                d || ((d = new Map).id = 0);
                let r = d.id++,
                    a = {
                        target: e = i[aR] >> 5 == 4 ? [] : {}
                    };
                d.set(r, a);
                let n = t();
                return a.used ? Object.assign(e, n) : (a.target = n, n)
            }, aL[28].handlesRead = !0, aL[29] = t => {
                let e = d.get(t);
                return e.used = !0, e.target
            }, aL[258] = t => new Set(t), (aL[259] = t => (aN.mapsAsObjects && (aN.mapsAsObjects = !1, f = !0), t())).handlesRead = !0, az.push((t, e) => t >= 225 && t <= 255 ? combine(getPackedValues().prefixes[t - 224], e) : t >= 28704 && t <= 32767 ? combine(getPackedValues().prefixes[t - 28672], e) : t >= 1879052288 && t <= 2147483647 ? combine(getPackedValues().prefixes[t - 1879048192], e) : t >= 216 && t <= 223 ? combine(e, getPackedValues().suffixes[t - 216]) : t >= 27647 && t <= 28671 ? combine(e, getPackedValues().suffixes[t - 27639]) : t >= 1811940352 && t <= 1879048191 ? combine(e, getPackedValues().suffixes[t - 1811939328]) : 1399353956 == t ? {
                packedValues: p,
                structures: o.slice(0),
                version: e
            } : 55799 == t ? e : void 0);
            let aZ = 1 == new Uint8Array(new Uint16Array([1]).buffer)[0],
                aJ = [Uint8Array],
                aK = [64];
            for (let t = 0; t < aJ.length; t++) ! function(t, e) {
                let r = "get" + t.name.slice(0, -5);
                "function" != typeof t && (t = null);
                let a = t.BYTES_PER_ELEMENT;
                for (let n = 0; n < 2; n++) {
                    if (!n && 1 == a) continue;
                    let i = 2 == a ? 1 : 4 == a ? 2 : 3;
                    aL[n ? e : e - 4] = 1 == a || n == aZ ? r => {
                        if (!t) throw Error("Could not find typed array for code " + e);
                        return new t(Uint8Array.prototype.slice.call(r, 0).buffer)
                    } : a => {
                        if (!t) throw Error("Could not find typed array for code " + e);
                        let s = new DataView(a.buffer, a.byteOffset, a.byteLength),
                            o = a.length >> i,
                            c = new t(o),
                            l = s[r];
                        for (let t = 0; t < o; t++) c[t] = l.call(s, t << i, n);
                        return c
                    }
                }
            }(aJ[t], aK[t]);

            function readJustLength() {
                let t = 31 & i[aR++];
                if (t > 23) switch (t) {
                    case 24:
                        t = i[aR++];
                        break;
                    case 25:
                        t = u.getUint16(aR), aR += 2;
                        break;
                    case 26:
                        t = u.getUint32(aR), aR += 4
                }
                return t
            }

            function loadShared() {
                if (aN.getShared) {
                    let t = saveState(() => (i = null, aN.getShared())) || {},
                        e = t.structures || [];
                    aN.sharedVersion = t.version, p = aN.sharedValues = t.packedValues, !0 === o ? aN.structures = o = e : o.splice.apply(o, [0, e.length].concat(e))
                }
            }

            function saveState(t) {
                let e = s,
                    r = aR,
                    a = aD,
                    n = aB,
                    p = c,
                    f = d,
                    m = l,
                    h = new Uint8Array(i.slice(0, s)),
                    g = o,
                    y = aN,
                    w = aU,
                    b = t();
                return s = e, aR = r, aD = a, aB = n, c = p, d = f, l = m, i = h, aU = w, o = g, aN = y, u = new DataView(i.buffer, i.byteOffset, i.byteLength), b
            }

            function clearSource() {
                i = null, d = null, o = null
            }
            let aQ = Array(147);
            for (let t = 0; t < 256; t++) aQ[t] = Number("1e" + Math.floor(45.15 - .30103 * t));
            let aY = new Decoder({
                    useRecords: !1
                }),
                aX = aY.decode;

            function extractIPFSHashFromBytecode(t) {
                let e = function(t) {
                        var e;
                        if ((t = t.toString(16)).startsWith("0x") || (t = `0x${t}`), !(("string" == typeof(e = t) || "number" == typeof e) && /^(-)?0x[0-9a-f]*$/i.test(e.toString()))) throw Error(`Given value "${t}" is not a valid hex string.`);
                        t = t.replace(/^0x/i, "");
                        let r = [];
                        for (let e = 0; e < t.length; e += 2) r.push(parseInt(t.slice(e, e + 2), 16));
                        return r
                    }(t),
                    r = 256 * e[e.length - 2] + e[e.length - 1],
                    a = Uint8Array.from(e.slice(e.length - 2 - r, -2)),
                    n = aX(a);
                if ("ipfs" in n && n.ipfs) try {
                    return `ipfs://${tc().encode(n.ipfs)}`
                } catch (t) {
                    console.warn("feature-detection ipfs cbor failed", t)
                }
            }
            async function resolveContractUriFromAddress(t, e) {
                let {
                    bytecode: r
                } = await resolveImplementation(t, e);
                return extractIPFSHashFromBytecode(r)
            }
            async function resolveContractUriAndBytecode(t, e) {
                let {
                    bytecode: r
                } = await resolveImplementation(t, e);
                return {
                    uri: extractIPFSHashFromBytecode(r),
                    bytecode: r
                }
            }
            async function resolveImplementation(t, e) {
                let r;
                try {
                    r = await e.getCode(t)
                } catch (e) {
                    throw Error(`Failed to get bytecode for address ${t}: ${e}`)
                }
                if ("0x" === r) {
                    let r = await e.getNetwork();
                    throw Error(`Contract at ${t} does not exist on chain '${r.name}' (chainId: ${r.chainId})`)
                }
                try {
                    let t = function(t) {
                        if (t.startsWith("0x363d3d373d3d3d363d73")) {
                            let e = t.slice(22, 62);
                            return `0x${e}`
                        }
                        if (t.startsWith("0x36603057343d5230")) {
                            let e = t.slice(122, 162);
                            return `0x${e}`
                        }
                        if (t.startsWith("0x3d3d3d3d363d3d37363d73")) {
                            let e = t.slice(24, 64);
                            return `0x${e}`
                        }
                        if (t.startsWith("0x366000600037611000600036600073")) {
                            let e = t.slice(32, 72);
                            return `0x${e}`
                        }
                    }(r);
                    if (t) return await resolveImplementation(t, e)
                } catch (t) {}
                try {
                    let r = await e.getStorageAt(t, v.O$.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc")),
                        a = `0x${r.slice(-40)}`;
                    if (F.isAddress(a) && a !== I.d) return await resolveImplementation(a, e)
                } catch (t) {}
                if (!r) throw Error(`Error fetching bytecode for ${t}`);
                return {
                    address: t,
                    bytecode: r
                }
            }
            async function fetchContractMetadata(t, e) {
                let r = await e.downloadJSON(t, {
                    timeoutInSeconds: 2
                });
                if (!r || !r.output) throw Error(`Could not resolve metadata for contract at ${t}`);
                let a = ro.parse(r.output.abi),
                    n = r.settings.compilationTarget,
                    i = Object.keys(n),
                    s = n[i[0]],
                    o = rv.parse({
                        title: r.output.devdoc.title,
                        author: r.output.devdoc.author,
                        details: r.output.devdoc.detail,
                        notice: r.output.userdoc.notice
                    }),
                    c = [...new Set(Object.entries(r.sources).map(t => {
                        let [, e] = t;
                        return e.license
                    }))];
                return {
                    name: s,
                    abi: a,
                    metadata: r,
                    info: o,
                    licenses: c
                }
            }

            function getProcessEnv(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                return void 0 !== es && es.env[t] ? es.env[t] : e
            }

            function getMultichainRegistryAddress() {
                return getProcessEnv("multiChainRegistryAddress", "0xcdAD8FA86e18538aC207872E8ff3536501431B73")
            }
            let isBrowser = () => !0,
                isNode = () => !isBrowser();

            function joinABIs(t) {
                let e = t.map(t => ro.parse(t)).flat(),
                    r = function(t, e) {
                        if (0 === t.length || 1 === t.length || !e) return t;
                        for (let r = 0; r < t.length; r++)
                            for (let a = r + 1; a < t.length; a++) e(t[r], t[a]) && t.splice(a, 1);
                        return t
                    }(e, (t, e) => t.name === e.name && t.type === e.type && t.inputs.length === e.inputs.length),
                    a = r.filter(t => "constructor" !== t.type);
                return ro.parse(a)
            }

            function extractFeatures(t, e) {
                if (t)
                    for (let r in t) {
                        let a = t[r];
                        a.enabled && e.push(a), extractFeatures(a.features, e)
                    }
            }
            let a0 = {};
            async function fetchContractMetadataFromAddress(t, e, r) {
                var a;
                let n, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                    s = (await e.getNetwork()).chainId,
                    o = a0[`${t}-${s}`];
                if (o) return o;
                let [c, l] = await Promise.all([resolveContractUriAndBytecode(t, e).catch(() => void 0), getMetadataUriFromMultichainRegistry(t, s, i).then(t => {
                    if (t) return {
                        uri: t,
                        bytecode: ""
                    }
                }).catch(() => void 0)]), d = c ? .bytecode, p = l ? .uri || c ? .uri;
                if (!p && !d) throw Error(`Could not fetch bytecode for contract at ${t} on chain ${s}, double check that the address and chainId are correct.`);
                try {
                    n = await fetchContractMetadata(p, r)
                } catch (t) {}
                if (!n && d) {
                    let e = function(t) {
                        let e = function(t) {
                            let e = [];
                            return extractFeatures(function detectFeaturesFromBytecode(t) {
                                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : aM,
                                    r = {};
                                for (let a in e) {
                                    let n = e[a],
                                        i = function(t, e) {
                                            let r = e.map(t => new et.Interface(t)),
                                                a = r.flatMap(t => Object.values(t.functions).map(e => Number(t.getSighash(e)).toString(16))),
                                                n = [...new Set(a)];
                                            return n.every(e => t.includes(e))
                                        }(t, n.abis),
                                        s = detectFeaturesFromBytecode(t, n.features);
                                    r[a] = { ...n,
                                        features: s,
                                        enabled: i
                                    }
                                }
                                return r
                            }(t), e), e
                        }(t);
                        e.find(t => "ERC721" === t.name) && (e = e.filter(t => "ERC20" !== t.name));
                        let r = joinABIs(e.map(t => joinABIs(t.abis)));
                        return r
                    }(d);
                    if (e && e.length > 0) return console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${s}/${t}`), n = {
                        name: "Unimported Contract",
                        abi: e,
                        metadata: {},
                        info: {},
                        licenses: [],
                        isPartialAbi: !0
                    }
                }
                if (!n) throw Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${s}/${t}`);
                return a = n, a0[`${t}-${s}`] = a, n
            }
            async function getMetadataUriFromMultichainRegistry(t, e, r) {
                if (!m) {
                    let t = r ? .supportedChains ? .find(t => 137 === t.chainId),
                        e = t || ts.mgq;
                    m = new O.CH(getMultichainRegistryAddress(), tl, getChainProvider(e, r))
                }
                let a = await m.getMetadataUri(e, t);
                return a
            }
            async function fetchAbiFromAddress(t, e, r) {
                try {
                    let a = await fetchContractMetadataFromAddress(t, e, r);
                    if (a && a.abi) return a.abi
                } catch (t) {}
            }

            function buildDeployTransactionFunction(t) {
                async function executeFn() {
                    let e = await t(...arguments);
                    return e.execute()
                }
                return executeFn.prepare = t, executeFn
            }

            function buildTransactionFunction(t) {
                async function executeFn() {
                    let e = await t(...arguments);
                    return e.execute()
                }
                return executeFn.prepare = t, executeFn
            }
            async function getDefaultGasOverrides(t) {
                if (isBrowser()) return {};
                t.originalProvider && (t = t.originalProvider);
                let e = await getDynamicFeeData(t);
                return e.maxFeePerGas && e.maxPriorityFeePerGas ? {
                    maxFeePerGas: e.maxFeePerGas,
                    maxPriorityFeePerGas: e.maxPriorityFeePerGas
                } : {
                    gasPrice: await getGasPrice(t)
                }
            }
            async function getDynamicFeeData(t) {
                let e = null,
                    [{
                        chainId: r
                    }, a, n] = await Promise.all([t.getNetwork(), t.getBlock("latest"), t.send("eth_maxPriorityFeePerGas", []).catch(() => null)]),
                    i = a && a.baseFeePerGas ? a.baseFeePerGas : R.parseUnits("100", "wei");
                if (r === ts.Nj4.chainId || r === ts.mgq.chainId) e = await getPolygonGasPriorityFee(r);
                else if (n) e = v.O$.from(n);
                else {
                    let r = await t.getFeeData();
                    if (!(e = r.maxPriorityFeePerGas)) return {
                        maxFeePerGas: null,
                        maxPriorityFeePerGas: null
                    }
                }
                return {
                    maxFeePerGas: i.mul(2).add(function(t) {
                        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
                            r = t.div(100).mul(e),
                            a = t.add(r);
                        return a
                    }(e)),
                    maxPriorityFeePerGas: e
                }
            }
            async function getGasPrice(t) {
                let e = await t.getGasPrice(),
                    r = R.parseUnits("300", "gwei"),
                    a = e.div(100).mul(10),
                    n = e.add(a);
                return n.gt(r) ? r : n
            }
            let a1 = R.parseUnits("31", "gwei"),
                a2 = R.parseUnits("1", "gwei");
            async function getPolygonGasPriorityFee(t) {
                let e = function(t) {
                    switch (t) {
                        case ev.Polygon:
                            return "https://gasstation.polygon.technology/v2";
                        case ev.Mumbai:
                            return "https://gasstation-testnet.polygon.technology/v2"
                    }
                }(t);
                try {
                    let t = await (await ea()(e)).json(),
                        r = t.fast.maxPriorityFee;
                    if (r > 0) {
                        let t = parseFloat(r).toFixed(9);
                        return R.parseUnits(t, "gwei")
                    }
                } catch (t) {
                    console.error("failed to fetch gas", t)
                }
                return function(t) {
                    switch (t) {
                        case ev.Polygon:
                            return a1;
                        case ev.Mumbai:
                            return a2
                    }
                }(t)
            }
            async function fetchSourceFilesFromMetadata(t, e) {
                return await Promise.all(Object.entries(t.metadata.sources).map(async t => {
                    let [r, a] = t, n = a.urls, i = n ? n.find(t => t.includes("ipfs")) : void 0;
                    if (!i) return {
                        filename: r,
                        source: a.content || "Could not find source for this contract"
                    }; {
                        let t = i.split("ipfs/")[1],
                            a = new Promise((t, e) => setTimeout(() => e("timeout"), 3e3)),
                            n = await Promise.race([(await e.download(`ipfs://${t}`)).text(), a]);
                        return {
                            filename: r,
                            source: n
                        }
                    }
                }))
            }
            let a5 = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"],
                a6 = [
                    ["account", "not found"],
                    ["wrong", "chainid"]
                ],
                a8 = {
                    5001: {
                        name: "Mantle Testnet",
                        gasPrice: 1
                    },
                    71402: {
                        name: "Godwoken Mainnet",
                        gasPrice: 4e13
                    },
                    1351057110: {
                        name: "Chaos (SKALE Testnet)",
                        gasPrice: 1e5
                    },
                    361: {
                        name: "Theta Mainnet",
                        gasPrice: 4e3 * 1e9
                    },
                    365: {
                        name: "Theta Testnet",
                        gasPrice: 4e3 * 1e9
                    },
                    7700: {
                        name: "Canto",
                        gasPrice: 1e3 * 1e9
                    },
                    7701: {
                        name: "Canto Testnet",
                        gasPrice: 1e3 * 1e9
                    },
                    338: {
                        name: "Cronos Testnet",
                        gasPrice: 2e3 * 1e9
                    },
                    199: {
                        name: "BitTorrent Chain",
                        gasPrice: 3e14
                    }
                };

            function matchError(t) {
                let e = a5.findIndex(e => t.includes(e)),
                    r = a6.findIndex(e => {
                        let r = !0;
                        return e.forEach(e => {
                            r && = t.includes(e)
                        }), r
                    });
                return -1 !== e || -1 !== r
            }
            let a3 = {
                    v: 27,
                    r: "0x2222222222222222222222222222222222222222222222222222222222222222",
                    s: "0x2222222222222222222222222222222222222222222222222222222222222222"
                },
                a7 = "0x4e59b44847b379578588920cA78FbF26c0B4956C",
                a4 = [{
                    inputs: [{
                        components: [{
                            internalType: "address",
                            name: "predictedAddress",
                            type: "address"
                        }, {
                            internalType: "address",
                            name: "to",
                            type: "address"
                        }, {
                            internalType: "bytes",
                            name: "data",
                            type: "bytes"
                        }],
                        internalType: "struct IDeployer.Transaction[]",
                        name: "transactions",
                        type: "tuple[]"
                    }],
                    stateMutability: "payable",
                    type: "constructor"
                }];
            async function isContractDeployed(t, e) {
                let r = await e.getCode(t);
                return "0x" !== r && "0x0" !== r
            }
            async function isEIP155Enforced(t) {
                try {
                    await t.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222")
                } catch (r) {
                    let t = r.toString().toLowerCase(),
                        e = JSON.stringify(r).toLowerCase();
                    if (matchError(t) || matchError(e)) return !0
                }
                return !1
            }

            function getCreate2FactoryDeploymentInfo(t, e) {
                let r = x.joinSignature(a3),
                    a = function(t, e) {
                        let r = x.arrayify(N.keccak256(D.serialize(t))),
                            a = D.recoverAddress(r, e),
                            n = D.serialize(t, e);
                        return {
                            signer: a,
                            transaction: n
                        }
                    }({
                        gasPrice: e || 100 * 1e9,
                        gasLimit: 1e5,
                        nonce: 0,
                        data: "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",
                        chainId: t
                    }, r),
                    n = F.getContractAddress({
                        from: a.signer,
                        nonce: 0
                    });
                return { ...a,
                    deployment: n
                }
            }
            async function getCreate2FactoryAddress(t) {
                let e = await isContractDeployed(a7, t);
                if (e) return a7;
                let r = await isEIP155Enforced(t),
                    a = (await t.getNetwork()).chainId,
                    n = r ? a : 0,
                    i = a8[a] ? getCreate2FactoryDeploymentInfo(n, a8[a].gasPrice) : getCreate2FactoryDeploymentInfo(n);
                return i.deployment
            }
            let a9 = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";

            function getContractPublisherAddress() {
                return getProcessEnv("contractPublisherAddress", "0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7")
            }
            let nt = e2.merge(e6).merge(eM).merge(e4),
                ne = e5.merge(e6).merge(eM).merge(e4),
                nr = nt.merge(e3).merge(e8).merge(e7),
                na = {
                    deploy: nr,
                    output: ne,
                    input: nt
                },
                nn = e2.merge(e6).merge(eM).merge(e4),
                ni = e5.merge(e6).merge(eM).merge(e4),
                ns = nn.merge(e3).merge(e8).merge(e7),
                no = {
                    deploy: ns,
                    output: ni,
                    input: nn
                },
                nc = e2.merge(e3).merge(e7),
                nl = {
                    deploy: nc,
                    output: e5,
                    input: e2
                },
                nd = e2.merge(e6).merge(e4),
                np = e5.merge(e6).merge(e4),
                nu = nd.merge(e3).merge(e7),
                nf = {
                    deploy: nu,
                    output: np,
                    input: nd
                },
                nm = A.z.object({
                    address: eA,
                    sharesBps: C.a.gt(0, "Shares must be greater than 0")
                }),
                nh = nm.extend({
                    address: eA,
                    sharesBps: C.a
                }),
                ng = e2.extend({
                    recipients: A.z.array(nm).default([]).superRefine((t, e) => {
                        let r = {},
                            a = 0;
                        for (let n = 0; n < t.length; n++) {
                            let i = t[n];
                            r[i.address] && e.addIssue({
                                code: A.z.ZodIssueCode.custom,
                                message: "Duplicate address.",
                                path: [n, "address"]
                            }), r[i.address] = !0, (a += i.sharesBps) > 1e4 && e.addIssue({
                                code: A.z.ZodIssueCode.custom,
                                message: "Total shares cannot go over 100%.",
                                path: [n, "sharesBps"]
                            })
                        }
                        1e4 !== a && e.addIssue({
                            code: A.z.ZodIssueCode.custom,
                            message: `Total shares need to add up to 100%. Total shares are currently ${a/100}%`,
                            path: []
                        })
                    })
                }),
                ny = e5.extend({
                    recipients: A.z.array(nh)
                }),
                nw = ng.merge(ng).merge(e7),
                nb = {
                    deploy: nw,
                    output: ny,
                    input: ng
                },
                nC = e2.merge(e4),
                nA = e5.merge(e4),
                nv = nC.merge(e3).merge(e8).merge(e7),
                nW = {
                    deploy: nv,
                    output: nA,
                    input: nC
                },
                nT = e2.merge(e6).merge(e4),
                nE = e5.merge(e6).merge(e4),
                nk = nT.merge(e3).merge(e8).merge(e7),
                nS = {
                    deploy: nk,
                    output: nE,
                    input: nT
                },
                nP = e2.merge(e6).merge(e4),
                nF = e5.merge(e6).merge(e4),
                nI = nP.merge(e3).merge(e8).merge(e7),
                nx = {
                    deploy: nI,
                    output: nF,
                    input: nP
                },
                nM = A.z.object({
                    voting_delay_in_blocks: A.z.number().min(0).default(0),
                    voting_period_in_blocks: A.z.number().min(1).default(1),
                    voting_token_address: eA,
                    voting_quorum_fraction: C.P.default(0),
                    proposal_token_threshold: ep.default(1)
                }),
                nR = nM.extend({
                    proposal_token_threshold: ed
                }),
                nO = e2.merge(nM),
                nN = e5.merge(nR),
                nD = nO.merge(e7),
                nB = {
                    deploy: nD,
                    output: nN,
                    input: nO
                };
            async function resolveAddress(t) {
                return eA.parseAsync(t)
            }
            async function fetchExtendedReleaseMetadata(t, e) {
                let r = await (await e.download(t)).text();
                return rw.parse(JSON.parse(r))
            }
            async function fetchRawPredeployMetadata(t, e) {
                return rc.parse(JSON.parse(await (await e.download(t)).text()))
            }
            async function fetchPreDeployMetadata(t, e) {
                let r = await fetchRawPredeployMetadata(t, e),
                    a = await (await e.download(r.bytecodeUri)).text(),
                    n = await fetchContractMetadata(r.metadataUri, e);
                return rT.parse({ ...r,
                    ...n,
                    bytecode: a
                })
            }
            let nL = {};
            async function fetchAndCacheDeployMetadata(t, e) {
                let r;
                if (nL[t]) return nL[t];
                let a = await fetchPreDeployMetadata(t, e);
                try {
                    r = await fetchExtendedReleaseMetadata(t, e)
                } catch (t) {}
                let n = {
                    compilerMetadata: a,
                    extendedMetadata: r
                };
                return nL[t] = n, n
            }
            let nz = "0x0000000000000000000000000000000000000000",
                n$ = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
                nU = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",
                nV = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",
                n_ = {
                    [ev.Mainnet]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
                        biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.Goerli]: {
                        openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
                    },
                    [ev.Polygon]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
                    },
                    [ev.Mumbai]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
                    },
                    [ev.Avalanche]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.AvalancheFujiTestnet]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
                        biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [ev.Fantom]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
                        biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
                        twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.FantomTestnet]: {
                        openzeppelinForwarder: nV,
                        openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
                        biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
                        twFactory: nU,
                        twRegistry: n$,
                        twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
                    },
                    [ev.Arbitrum]: {
                        openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
                        openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
                        biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.ArbitrumGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: nz,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.Optimism]: {
                        openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.OptimismGoerli]: {
                        openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
                        openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
                        biconomyForwarder: nz,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: n$,
                        twBYOCRegistry: nz
                    },
                    [ev.BinanceSmartChainMainnet]: {
                        openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
                        openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
                        biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
                        twBYOCRegistry: nz,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: n$
                    },
                    [ev.BinanceSmartChainTestnet]: {
                        openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
                        openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
                        biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
                        twBYOCRegistry: nz,
                        twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
                        twRegistry: n$
                    },
                    [ev.Hardhat]: {
                        openzeppelinForwarder: nz,
                        openzeppelinForwarderEOA: nz,
                        biconomyForwarder: nz,
                        twFactory: nz,
                        twRegistry: nz,
                        twBYOCRegistry: nz
                    },
                    [ev.Localhost]: {
                        openzeppelinForwarder: nz,
                        openzeppelinForwarderEOA: nz,
                        biconomyForwarder: nz,
                        twFactory: nz,
                        twRegistry: nz,
                        twBYOCRegistry: nz
                    }
                };

            function getContractAddressByChainId(t, e) {
                return t === ev.Hardhat || t === ev.Localhost ? "twFactory" === e ? getProcessEnv("factoryAddress") : "twRegistry" === e ? getProcessEnv("registryAddress") : nz : n_[t] ? .[e]
            }
            let nj = x.arrayify("0x80ac58cd"),
                nq = x.arrayify("0xd9b67a26"),
                nG = ((g = {}).Transaction = "transaction", g.Signature = "signature", g),
                nH = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
            async function fetchPublishedContractFromPolygon(t, e) {
                let r, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                    n = arguments.length > 3 ? arguments[3] : void 0,
                    i = arguments.length > 4 ? arguments[4] : void 0,
                    s = arguments.length > 5 ? arguments[5] : void 0,
                    o = eW.find(t => 137 === t.chainId),
                    c = o || ts.mgq,
                    l = await resolveAddress(t),
                    d = new O.CH(getContractPublisherAddress(), ti, getChainProvider(c, {
                        clientId: i,
                        secretKey: s
                    }));
                if (a && "latest" !== a) {
                    let t = (await d.getPublishedContractVersions(l, e)).map(t => rA.parse({
                            id: t.contractId,
                            timestamp: t.publishTimestamp,
                            metadataUri: t.publishMetadataUri
                        })),
                        i = await Promise.all(t.map(async t => ({
                            name: t.id,
                            publishedTimestamp: t.timestamp,
                            publishedMetadata: await fetchAndCacheDeployMetadata(t.metadataUri, n)
                        }))),
                        s = i.find(t => t.publishedMetadata.extendedMetadata ? .version === a);
                    (0, j.Z)(s, "Contract version not found"), r = t.find(t => t.timestamp === s.publishedTimestamp)
                } else {
                    let t = await d.getPublishedContract(l, e);
                    r = rA.parse({
                        id: t.contractId,
                        timestamp: t.publishTimestamp,
                        metadataUri: t.publishMetadataUri
                    })
                }
                if (!r) throw Error(`No published contract found for ${e} at version by '${nH}'`);
                return r
            }

            function getSaltHash(t) {
                let e = t.startsWith("0x") ? t : `0x${t}`,
                    r = B.id(e),
                    a = `tw.${r}`,
                    n = B.id(a);
                return n
            }

            function getInitBytecodeWithSalt(t, e, r) {
                let a = t.startsWith("0x") ? t : `0x${t}`,
                    n = r ? B.id(r) : getSaltHash(a),
                    i = L.pack(["bytes32", "bytes", "bytes"], [n, a, e]);
                return i
            }

            function computeDeploymentAddress(t, e, r, a) {
                let n = t.startsWith("0x") ? t : `0x${t}`,
                    i = a ? B.id(a) : getSaltHash(n),
                    s = L.pack(["bytes", "bytes"], [n, e]),
                    o = L.pack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", r, i, L.keccak256(["bytes"], [s])]),
                    c = L.keccak256(["bytes"], [o]);
                return `0x${c.slice(26)}`
            }

            function extractConstructorParamsFromAbi(t) {
                let e = ro.parse(t || []);
                for (let t of e)
                    if ("constructor" === t.type) return t.inputs || [];
                return []
            }
            let nZ = {
                    deploymentPresets: {}
                },
                nJ = {
                    [ev.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
                    [ev.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [ev.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [ev.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
                    [ev.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
                    [ev.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [ev.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
                    [ev.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
                };
            async function computeDeploymentInfo(t, e, r, a, n, i, s) {
                let o = n && n.contractName,
                    c = n && n.version,
                    l = n && n.publisherAddress,
                    d = n && n.metadata;
                if ((0, j.Z)(o || d, "Require contract name or metadata"), o && nZ.deploymentPresets[o]) return nZ.deploymentPresets[o];
                if ("WETH9" === o) {
                    let r = computeDeploymentAddress(a9, [], a),
                        n = await isContractDeployed(r, e),
                        i = "";
                    return n || (i = getInitBytecodeWithSalt(a9, [])), {
                        name: o,
                        type: t,
                        transaction: {
                            predictedAddress: r,
                            to: a,
                            data: i
                        }
                    }
                }
                if (!d) {
                    (0, j.Z)(o, "Require contract name"), l || (l = nH);
                    let t = await fetchPublishedContractFromPolygon(l, o, c, r, i, s);
                    d = (await fetchAndCacheDeployMetadata(t.metadataUri, r)).compilerMetadata
                }
                let p = await encodeConstructorParamsForImplementation(d, e, r, a, n ? .constructorParams, i, s),
                    u = computeDeploymentAddress(d.bytecode, p, a),
                    f = await isContractDeployed(u, e),
                    m = "";
                return f || (m = getInitBytecodeWithSalt(d.bytecode, p)), {
                    name: o,
                    type: t,
                    transaction: {
                        predictedAddress: u,
                        to: a,
                        data: m
                    },
                    encodedArgs: p
                }
            }
            async function encodeConstructorParamsForImplementation(t, e, r, a, n, i, s) {
                let o = extractConstructorParamsFromAbi(t.abi),
                    c = o.map(t => "tuple[]" === t.type ? z._R.from(t) : t.type),
                    l = await Promise.all(o.map(async o => {
                        if (n && n[o.name]) return n[o.name].type && (0, j.Z)(n[o.name].type === o.type, `Provided type ${n[o.name].type} doesn't match the actual type ${o.type} from Abi`), n[o.name].value;
                        if (o.name && o.name.includes("nativeTokenWrapper")) {
                            let t = (await e.getNetwork()).chainId,
                                n = getNativeTokenByChainId(t).wrapped.address;
                            if (n === I.d) {
                                let t = await computeDeploymentInfo("infra", e, r, a, {
                                    contractName: "WETH9"
                                }, i, s);
                                nZ.deploymentPresets.WETH9 || (nZ.deploymentPresets.WETH9 = t), n = t.transaction.predictedAddress
                            }
                            return n
                        }
                        if (o.name && o.name.includes("trustedForwarder")) {
                            if ("Pack" === t.name) {
                                let t = await computeDeploymentInfo("infra", e, r, a, {
                                    contractName: "ForwarderEOAOnly"
                                }, i, s);
                                return nZ.deploymentPresets.ForwarderEOAOnly || (nZ.deploymentPresets.ForwarderEOAOnly = t), t.transaction.predictedAddress
                            }
                            let n = await computeDeploymentInfo("infra", e, r, a, {
                                contractName: "Forwarder"
                            }, i, s);
                            return nZ.deploymentPresets.Forwarder || (nZ.deploymentPresets.Forwarder = n), n.transaction.predictedAddress
                        }
                        if (o.name && o.name.includes("royaltyEngineAddress")) {
                            let t = (await e.getNetwork()).chainId;
                            return nJ[t] || I.d
                        }
                        throw Error("Can't resolve constructor arguments")
                    })),
                    d = $.$.encode(c, l);
                return d
            }
            async function computeEOAForwarderAddress(t, e, r, a, n) {
                return r && "" !== r || (r = await getCreate2FactoryAddress(t)), (await computeDeploymentInfo("infra", t, e, r, {
                    contractName: "ForwarderEOAOnly"
                }, a, n)).transaction.predictedAddress
            }
            async function computeForwarderAddress(t, e, r, a, n) {
                return r && "" !== r || (r = await getCreate2FactoryAddress(t)), (await computeDeploymentInfo("infra", t, e, r, {
                    contractName: "Forwarder"
                }, a, n)).transaction.predictedAddress
            }
            let nK = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }],
                nQ = [{
                    name: "from",
                    type: "address"
                }, {
                    name: "to",
                    type: "address"
                }, {
                    name: "value",
                    type: "uint256"
                }, {
                    name: "gas",
                    type: "uint256"
                }, {
                    name: "nonce",
                    type: "uint256"
                }, {
                    name: "data",
                    type: "bytes"
                }, {
                    name: "chainid",
                    type: "uint256"
                }],
                nY = [{
                    inputs: [{
                        internalType: "address",
                        name: "from",
                        type: "address"
                    }, {
                        internalType: "uint256",
                        name: "batchId",
                        type: "uint256"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                nX = {},
                n0 = {};
            async function getAndIncrementNonce(t, e, r) {
                let a = r.join("|"),
                    n = n0[a],
                    i = Date.now() - n >= 2e3;
                if (!(a in nX) || i) {
                    let n = await t.functions[e](...r);
                    Array.isArray(n) && n.length > 0 ? nX[a] = v.O$.from(n[0]) : nX[a] = v.O$.from(n), n0[a] = Date.now()
                }
                let s = nX[a];
                return nX[a] = v.O$.from(nX[a]).add(1), s
            }
            async function signTypedDataInternal(t, e, r, a) {
                let n = t;
                t.originalSigner && (n = t.originalSigner);
                let i = n ? .provider;
                if (!i) throw Error("missing provider");
                let s = U.E.getPayload(e, r, a),
                    o = "",
                    c = (await n.getAddress()).toLowerCase();
                if (i ? .provider ? .isWalletConnect) o = await i.send("eth_signTypedData", [(await n.getAddress()).toLowerCase(), JSON.stringify(s)]);
                else try {
                    o = await n._signTypedData(e, r, a)
                } catch (t) {
                    if (t ? .message ? .includes("eth_signTypedData_v4")) o = await i.send("eth_signTypedData", [c, JSON.stringify(s)]);
                    else try {
                        await i.send("eth_signTypedData_v4", [c, JSON.stringify(s)])
                    } catch (t) {
                        throw t
                    }
                }
                return {
                    payload: s,
                    signature: x.joinSignature(x.splitSignature(o))
                }
            }
            let n1 = [{
                    inputs: [],
                    name: "name",
                    outputs: [{
                        internalType: "string",
                        name: "",
                        type: "string"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                n2 = [{
                    constant: !0,
                    inputs: [],
                    name: "DOMAIN_SEPARATOR",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    payable: !1,
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [],
                    name: "getDomainSeperator",
                    outputs: [{
                        internalType: "bytes32",
                        name: "",
                        type: "bytes32"
                    }],
                    stateMutability: "view",
                    type: "function"
                }],
                n5 = [{
                    inputs: [{
                        internalType: "address",
                        name: "owner",
                        type: "address"
                    }],
                    name: "nonces",
                    outputs: [{
                        internalType: "uint256",
                        name: "",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }, {
                    inputs: [{
                        internalType: "address",
                        name: "user",
                        type: "address"
                    }],
                    name: "getNonce",
                    outputs: [{
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    }],
                    stateMutability: "view",
                    type: "function"
                }];
            async function getSignerNonce(t, e) {
                let r = new O.CH(e, n5, t);
                try {
                    return await r.nonces(await t.getAddress())
                } catch (e) {
                    return await r.getNonce(await t.getAddress())
                }
            }
            async function getDomainSeperator(t, e) {
                let r = new O.CH(e, n2, t);
                try {
                    return await r.DOMAIN_SEPARATOR()
                } catch (t) {
                    try {
                        return await r.getDomainSeperator()
                    } catch (t) {
                        console.error("Error getting domain separator", t)
                    }
                }
            }
            async function getTokenName(t, e) {
                return new O.CH(e, n1, t).name()
            }
            async function getChainDomainSeperator(t, e) {
                let r = await getDomainSeperator(t, e.verifyingContract),
                    a = {
                        name: e.name,
                        version: e.version,
                        verifyingContract: e.verifyingContract,
                        salt: x.hexZeroPad(v.O$.from(e.chainId).toHexString(), 32)
                    };
                return U.E.hashDomain(a) === r ? a : e
            }
            async function signEIP2612Permit(t, e, r, a, n, i, s) {
                let o = await getChainDomainSeperator(t, {
                    name: await getTokenName(t, e),
                    version: "1",
                    chainId: await t.getChainId(),
                    verifyingContract: e
                });
                s = s || (await getSignerNonce(t, e)).toString(), i = i || V.Bz;
                let c = {
                        owner: r,
                        spender: a,
                        value: n,
                        nonce: s,
                        deadline: i
                    },
                    {
                        signature: l
                    } = await signTypedDataInternal(t, o, {
                        Permit: [{
                            name: "owner",
                            type: "address"
                        }, {
                            name: "spender",
                            type: "address"
                        }, {
                            name: "value",
                            type: "uint256"
                        }, {
                            name: "nonce",
                            type: "uint256"
                        }, {
                            name: "deadline",
                            type: "uint256"
                        }]
                    }, c);
                return {
                    message: c,
                    signature: l
                }
            }
            let TransactionContext = class TransactionContext {
                constructor(t) {
                    this.args = t.args, this.overrides = t.overrides || {}, this.provider = t.provider, this.signer = t.signer, this.storage = t.storage, this.signer.provider || (this.signer = this.signer.connect(this.provider))
                }
                get getSigner() {
                    return this.signer
                }
                get getProvider() {
                    return this.provider
                }
                get getStorage() {
                    return this.storage
                }
                getArgs() {
                    return this.args
                }
                getOverrides() {
                    return this.overrides
                }
                getValue() {
                    return this.overrides.value || 0
                }
                setArgs(t) {
                    return this.args = t, this
                }
                setOverrides(t) {
                    return this.overrides = t, this
                }
                updateOverrides(t) {
                    return this.overrides = { ...this.overrides,
                        ...t
                    }, this
                }
                setValue(t) {
                    return this.updateOverrides({
                        value: t
                    }), this
                }
                setGasLimit(t) {
                    return this.updateOverrides({
                        gasLimit: t
                    }), this
                }
                setGasPrice(t) {
                    return this.updateOverrides({
                        gasPrice: t
                    }), this
                }
                setNonce(t) {
                    return this.updateOverrides({
                        nonce: t
                    }), this
                }
                setMaxFeePerGas(t) {
                    return this.updateOverrides({
                        maxFeePerGas: t
                    }), this
                }
                setMaxPriorityFeePerGas(t) {
                    return this.updateOverrides({
                        maxPriorityFeePerGas: t
                    }), this
                }
                setType(t) {
                    return this.updateOverrides({
                        type: t
                    }), this
                }
                setAccessList(t) {
                    return this.updateOverrides({
                        accessList: t
                    }), this
                }
                setCustomData(t) {
                    return this.updateOverrides({
                        customData: t
                    }), this
                }
                setCcipReadEnabled(t) {
                    return this.updateOverrides({
                        ccipReadEnabled: t
                    }), this
                }
                setGasLimitMultiple(t) {
                    v.O$.isBigNumber(this.overrides.gasLimit) ? this.overrides.gasLimit = v.O$.from(Math.floor(v.O$.from(this.overrides.gasLimit).toNumber() * t)) : this.gasMultiple = t
                }
                async estimateGasCost() {
                    let [t, e] = await Promise.all([this.estimateGasLimit(), this.getGasPrice()]), r = t.mul(e);
                    return {
                        ether: R.formatEther(r),
                        wei: r
                    }
                }
                async getGasPrice() {
                    return getGasPrice(this.provider)
                }
                async getSignerAddress() {
                    return this.signer.getAddress()
                }
                async getGasOverrides() {
                    return getDefaultGasOverrides(this.provider)
                }
                getPreferredPriorityFee(t) {
                    let e = t.div(100).mul(10),
                        r = t.add(e);
                    return r
                }
            };
            let Transaction = class Transaction extends TransactionContext {
                static fromContractWrapper(t) {
                    let e = t.contractWrapper.getSigner();
                    if (!e) throw Error("Cannot create a transaction without a signer. Please ensure that you have a connected signer.");
                    let r = { ...t,
                        contract: t.contractWrapper.writeContract,
                        provider: t.contractWrapper.getProvider(),
                        signer: e,
                        gasless: t.contractWrapper.options.gasless,
                        storage: t.contractWrapper.storage
                    };
                    return new Transaction(r)
                }
                static async fromContractInfo(t) {
                    let e = t.storage,
                        r = t.contractAbi;
                    if (!r) try {
                        let a = await fetchContractMetadataFromAddress(t.contractAddress, t.provider, e);
                        r = a.abi
                    } catch {
                        throw Error(`Could resolve contract metadata for address ${t.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`)
                    }
                    let a = new O.CH(t.contractAddress, r, t.provider),
                        n = { ...t,
                            storage: e,
                            contract: a
                        };
                    return new Transaction(n)
                }
                constructor(t) {
                    super({
                        args: t.args,
                        overrides: t.overrides,
                        provider: t.provider,
                        signer: t.signer,
                        storage: t.storage
                    }), this.method = t.method, this.gaslessOptions = t.gasless, this.parse = t.parse, this.contract = t.contract.connect(this.signer), this.storage = t.storage
                }
                getTarget() {
                    return this.contract.address
                }
                getMethod() {
                    return this.method
                }
                getGaslessOptions() {
                    return this.gaslessOptions
                }
                setGaslessOptions(t) {
                    return this.gaslessOptions = t, this
                }
                setParse(t) {
                    return this.parse = t, this
                }
                encode() {
                    return this.contract.interface.encodeFunctionData(this.method, this.args)
                }
                async sign() {
                    let t = await this.populateTransaction(),
                        e = await this.contract.signer.signTransaction(t);
                    return e
                }
                async populateTransaction() {
                    let t = await this.getGasOverrides(),
                        e = { ...t,
                            ...this.overrides
                        };
                    e.gasLimit || (e.gasLimit = await this.estimateGasLimit());
                    let r = await this.contract.populateTransaction[this.method](...this.args, e),
                        a = await this.contract.signer.populateTransaction(r);
                    return a
                }
                async simulate() {
                    if (!this.contract.callStatic[this.method]) throw this.functionError();
                    try {
                        return await this.contract.callStatic[this.method](...this.args, ...this.overrides.value ? [{
                            value: this.overrides.value
                        }] : [])
                    } catch (t) {
                        throw await this.transactionError(t)
                    }
                }
                async estimateGasLimit() {
                    if (!this.contract.estimateGas[this.method]) throw this.functionError();
                    try {
                        let t = await this.contract.estimateGas[this.method](...this.args, this.overrides);
                        if (this.gasMultiple) return v.O$.from(Math.floor(v.O$.from(t).toNumber() * this.gasMultiple));
                        return t
                    } catch (t) {
                        throw await this.simulate(), await this.transactionError(t)
                    }
                }
                async send() {
                    if (!this.contract.functions[this.method]) throw this.functionError();
                    if (this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions)) return this.sendGasless();
                    let t = await this.getGasOverrides(),
                        e = { ...t,
                            ...this.overrides
                        };
                    if (!e.gasLimit) {
                        e.gasLimit = await this.estimateGasLimit();
                        try {
                            let t = JSON.parse(this.contract.interface.format("json"));
                            (function(t) {
                                let e = isFeatureEnabled(ro.parse(t), "PluginRouter"),
                                    r = isFeatureEnabled(ro.parse(t), "DynamicContract");
                                return r || e
                            })(t) && (e.gasLimit = e.gasLimit.mul(110).div(100))
                        } catch (t) {
                            console.warn("Error raising gas limit", t)
                        }
                    }
                    try {
                        return await this.contract.functions[this.method](...this.args, e)
                    } catch (t) {
                        throw await this.transactionError(t)
                    }
                }
                async execute() {
                    let t;
                    let e = await this.send();
                    try {
                        t = await e.wait()
                    } catch (t) {
                        throw await this.simulate(), await this.transactionError(t)
                    }
                    return this.parse ? this.parse(t) : {
                        receipt: t
                    }
                }
                async sendGasless() {
                    let t;
                    let e = await this.prepareGasless(),
                        r = await defaultGaslessSendFunction(e, this.signer, this.provider, this.storage, this.gaslessOptions),
                        a = 1;
                    for (; !t;) {
                        try {
                            t = await this.provider.getTransaction(r)
                        } catch (t) {}
                        if (!t && (await new Promise(t => setTimeout(t, Math.min(1e3 * a, 1e4))), a++), a > 20) throw Error(`Unable to retrieve transaction with hash ${r}`)
                    }
                    return t
                }
                async prepareGasless() {
                    (0, j.Z)(this.gaslessOptions && ("openzeppelin" in this.gaslessOptions || "biconomy" in this.gaslessOptions), "No gasless options set on this transaction!");
                    let t = await this.getSignerAddress(),
                        e = [...this.args];
                    "multicall" === this.method && Array.isArray(this.args[0]) && e[0].length > 0 && (e[0] = e[0].map(e => L.pack(["bytes", "address"], [e, t]))), (0, j.Z)(this.signer, "Cannot execute gasless transaction without valid signer");
                    let [{
                        chainId: r
                    }, a] = await Promise.all([this.provider.getNetwork(), this.overrides.from || t]), n = this.contract.address, i = this.overrides ? .value || 0;
                    if (v.O$.from(i).gt(0)) throw Error("Cannot send native token value with gasless transaction");
                    let s = this.contract.interface.encodeFunctionData(this.method, e),
                        o = v.O$.from(0);
                    try {
                        let t = await this.contract.estimateGas[this.method](...e);
                        o = t.mul(2)
                    } catch (t) {}
                    return o.lt(1e5) && (o = v.O$.from(5e5)), this.overrides.gasLimit && v.O$.from(this.overrides.gasLimit).gt(o) && (o = v.O$.from(this.overrides.gasLimit)), {
                        from: a,
                        to: n,
                        data: s,
                        chainId: r,
                        gasLimit: o,
                        functionName: this.method,
                        functionArgs: e,
                        callOverrides: this.overrides
                    }
                }
                functionError() {
                    return Error(`Contract "${this.contract.address}" does not have function "${this.method}"`)
                }
                async transactionError(t) {
                    let e, r;
                    let a = this.provider,
                        [n, i] = await Promise.all([a.getNetwork(), this.overrides.from || this.getSignerAddress()]),
                        s = this.contract.address,
                        o = this.encode(),
                        c = v.O$.from(this.overrides.value || 0),
                        l = a.connection ? .url,
                        d = this.contract.interface.getFunction(this.method),
                        p = this.args.map(t => JSON.stringify(t).length <= 80 ? JSON.stringify(t) : JSON.stringify(t, void 0, 2)),
                        u = p.join(", ").length <= 80 ? p.join(", ") : "\n" + p.map(t => "  " + t.split("\n").join("\n  ")).join(",\n") + "\n",
                        f = `${d.name}(${u})`,
                        m = t.transactionHash || t.transaction ? .hash || t.receipt ? .transactionHash,
                        h = parseRevertReason(t);
                    try {
                        let t = await fetchContractMetadataFromAddress(this.contract.address, this.provider, this.storage);
                        t.name && (r = t.name), t.metadata.sources && (e = await fetchSourceFilesFromMetadata(t, this.storage))
                    } catch (t) {}
                    return new TransactionError({
                        reason: h,
                        from: i,
                        to: s,
                        method: f,
                        data: o,
                        network: n,
                        rpcUrl: l,
                        value: c,
                        hash: m,
                        contractName: r,
                        sources: e
                    }, t)
                }
            };
            let DeployTransaction = class DeployTransaction extends TransactionContext {
                constructor(t) {
                    super(t), this.factory = t.factory, this.events = t.events
                }
                encode() {
                    return x.hexlify(x.concat([this.factory.bytecode, this.factory.interface.encodeDeploy(this.args)]))
                }
                getTarget() {
                    return I.d
                }
                getMethod() {
                    return "deploy"
                }
                async sign() {
                    let t = await this.populateTransaction();
                    return this.signer.signTransaction(t)
                }
                async simulate() {
                    let t = await this.populateTransaction();
                    return this.signer.call(t)
                }
                async estimateGasLimit() {
                    try {
                        let t = await this.getGasOverrides(),
                            e = { ...t,
                                ...this.overrides
                            },
                            r = this.factory.getDeployTransaction(...this.args, e);
                        return this.signer.estimateGas(r)
                    } catch (t) {
                        throw await this.deployError(t)
                    }
                }
                async send() {
                    try {
                        let t = await this.populateTransaction();
                        return await this.signer.sendTransaction(t)
                    } catch (t) {
                        throw await this.deployError(t)
                    }
                }
                async execute() {
                    let t = await this.send();
                    try {
                        await t.wait()
                    } catch (t) {
                        throw await this.simulate(), await this.deployError(t)
                    }
                    let e = F.getContractAddress({
                        from: t.from,
                        nonce: t.nonce
                    });
                    return this.events && this.events.emit("contractDeployed", {
                        status: "completed",
                        contractAddress: e,
                        transactionHash: t.hash
                    }), e
                }
                async populateTransaction() {
                    let t = await this.getGasOverrides(),
                        e = { ...t,
                            ...this.overrides
                        };
                    return e.gasLimit || (e.gasLimit = await this.estimateGasLimit()), this.factory.getDeployTransaction(...this.args, e)
                }
                async deployError(t) {
                    let e = this.provider,
                        [r, a] = await Promise.all([e.getNetwork(), this.overrides.from || this.getSignerAddress()]),
                        n = this.encode(),
                        i = v.O$.from(this.overrides.value || 0),
                        s = e.connection ? .url,
                        o = this.args.map(t => JSON.stringify(t).length <= 80 ? JSON.stringify(t) : JSON.stringify(t, void 0, 2)),
                        c = o.join(", ").length <= 80 ? o.join(", ") : "\n" + o.map(t => "  " + t.split("\n").join("\n  ")).join(",\n") + "\n",
                        l = `deployContract(${c})`,
                        d = t.transactionHash || t.transaction ? .hash || t.receipt ? .transactionHash,
                        p = parseRevertReason(t);
                    return new TransactionError({
                        reason: p,
                        from: a,
                        method: l,
                        data: n,
                        network: r,
                        rpcUrl: s,
                        value: i,
                        hash: d
                    }, t)
                }
            };
            async function defaultGaslessSendFunction(t, e, r, a, n) {
                return n && "biconomy" in n ? biconomySendFunction(t, e, r, n) : defenderSendFunction(t, e, r, a, n)
            }
            async function biconomySendFunction(t, e, r, a) {
                let n = await biconomyPrepareRequest(t, e, r, a),
                    i = await ea()("https://api.biconomy.io/api/v2/meta-tx/native", n);
                if (i.ok) {
                    let t = await i.json();
                    if (!t.txHash) throw Error(`relay transaction failed: ${t.log}`);
                    return t.txHash
                }
                throw Error(`relay transaction failed with status: ${i.status} (${i.statusText})`)
            }
            async function defenderSendFunction(t, e, r, a, n) {
                (0, j.Z)(n && "openzeppelin" in n, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
                let i = await defenderPrepareRequest(t, e, r, a, n),
                    s = await ea()(n.openzeppelin.relayerUrl, i);
                if (s.ok) {
                    let t = await s.json();
                    if (!t.result) throw Error(`Relay transaction failed: ${t.message}`);
                    let e = JSON.parse(t.result);
                    return e.txHash
                }
                throw Error(`relay transaction failed with status: ${s.status} (${s.statusText})`)
            }
            async function defenderPrepareRequest(t, e, r, a, n) {
                let i, s, o, c;
                (0, j.Z)(n && "openzeppelin" in n, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options"), (0, j.Z)(e, "provider is not set"), (0, j.Z)(r, "provider is not set");
                let l = n.openzeppelin.relayerForwarderAddress || (n.openzeppelin.useEOAForwarder ? n_[t.chainId].openzeppelinForwarderEOA || await computeEOAForwarderAddress(r, a) : n_[t.chainId].openzeppelinForwarder || await computeForwarderAddress(r, a)),
                    d = new O.CH(l, ee, r),
                    p = await getAndIncrementNonce(d, "getNonce", [t.from]);
                if (n.experimentalChainlessSupport ? (i = {
                        name: "GSNv2 Forwarder",
                        version: "0.0.1",
                        verifyingContract: l
                    }, s = {
                        ForwardRequest: nQ
                    }, o = {
                        from: t.from,
                        to: t.to,
                        value: v.O$.from(0).toString(),
                        gas: v.O$.from(t.gasLimit).toString(),
                        nonce: v.O$.from(p).toString(),
                        data: t.data,
                        chainid: v.O$.from(t.chainId).toString()
                    }) : (i = {
                        name: n.openzeppelin.domainName,
                        version: n.openzeppelin.domainVersion,
                        chainId: t.chainId,
                        verifyingContract: l
                    }, s = {
                        ForwardRequest: nK
                    }, o = {
                        from: t.from,
                        to: t.to,
                        value: v.O$.from(0).toString(),
                        gas: v.O$.from(t.gasLimit).toString(),
                        nonce: v.O$.from(p).toString(),
                        data: t.data
                    }), "approve" === t.functionName && 2 === t.functionArgs.length) {
                    let r = t.functionArgs[0],
                        a = t.functionArgs[1],
                        {
                            message: n,
                            signature: i
                        } = await signEIP2612Permit(e, t.to, t.from, r, a),
                        {
                            r: s,
                            s: l,
                            v: d
                        } = x.splitSignature(i);
                    o = {
                        to: t.to,
                        owner: n.owner,
                        spender: n.spender,
                        value: v.O$.from(n.value).toString(),
                        nonce: v.O$.from(n.nonce).toString(),
                        deadline: v.O$.from(n.deadline).toString(),
                        r: s,
                        s: l,
                        v: d
                    }, c = i
                } else {
                    let {
                        signature: t
                    } = await signTypedDataInternal(e, i, s, o);
                    c = t
                }
                let u = "forward";
                return o ? .owner && (u = "permit"), {
                    method: "POST",
                    body: JSON.stringify({
                        request: o,
                        signature: c,
                        forwarderAddress: l,
                        type: u
                    })
                }
            }
            async function biconomyPrepareRequest(t, e, r, a) {
                (0, j.Z)(a && "biconomy" in a, "calling biconomySendFunction without biconomy"), (0, j.Z)(e && r, "signer and provider must be set");
                let n = new O.CH(getContractAddressByChainId(t.chainId, "biconomyForwarder"), nY, r),
                    i = await getAndIncrementNonce(n, "getNonce", [t.from, 0]),
                    s = {
                        from: t.from,
                        to: t.to,
                        token: I.d,
                        txGas: t.gasLimit.toNumber(),
                        tokenGasPrice: "0",
                        batchId: 0,
                        batchNonce: i.toNumber(),
                        deadline: Math.floor(Date.now() / 1e3 + (a && "biconomy" in a && a.biconomy ? .deadlineSeconds || 3600)),
                        data: t.data
                    },
                    o = x.arrayify(L.keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [s.from, s.to, s.token, s.txGas, s.tokenGasPrice, s.batchId, s.batchNonce, s.deadline, N.keccak256(s.data)])),
                    c = await e.signMessage(o);
                return {
                    method: "POST",
                    body: JSON.stringify({
                        from: t.from,
                        apiId: a.biconomy.apiId,
                        params: [s, c],
                        to: t.to,
                        gasLimit: t.gasLimit.toHexString()
                    }),
                    headers: {
                        "x-api-key": a.biconomy.apiKey,
                        "Content-Type": "application/json;charset=utf-8"
                    }
                }
            }
            let ContractMetadata = class ContractMetadata {
                featureName = ag.name;
                constructor(t, e, r) {
                    this.contractWrapper = t, this.schema = e, this.storage = r
                }
                parseOutputMetadata(t) {
                    return this.schema.output.parseAsync(t)
                }
                parseInputMetadata(t) {
                    return this.schema.input.parseAsync(t)
                }
                async get() {
                    let t;
                    if (this.supportsContractMetadata(this.contractWrapper)) {
                        let e = await this.contractWrapper.read("contractURI", []);
                        e && e.includes("://") && (t = await this.storage.downloadJSON(e))
                    }
                    if (!t) try {
                        let e, r, a;
                        try {
                            hasFunction("name", this.contractWrapper) && (e = await this.contractWrapper.read("name", []))
                        } catch (t) {}
                        try {
                            hasFunction("symbol", this.contractWrapper) && (r = await this.contractWrapper.read("symbol", []))
                        } catch (t) {}
                        try {
                            a = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options)
                        } catch (t) {}
                        t = {
                            name: e || a ? .name,
                            symbol: r,
                            description: a ? .info.title
                        }
                    } catch (t) {
                        throw Error("Could not fetch contract metadata")
                    }
                    return this.parseOutputMetadata(t)
                }
                set = buildTransactionFunction(async t => {
                    let e = await this._parseAndUploadMetadata(t),
                        r = this.contractWrapper;
                    if (this.supportsContractMetadata(r)) return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setContractURI",
                        args: [e],
                        parse: t => ({
                            receipt: t,
                            data: this.get
                        })
                    });
                    throw new ExtensionNotImplementedError(ag)
                });
                update = buildTransactionFunction(async t => await this.set.prepare({ ...await this.get(),
                    ...t
                }));
                async _parseAndUploadMetadata(t) {
                    let e = await this.parseInputMetadata(t);
                    return this.storage.upload(e)
                }
                supportsContractMetadata(t) {
                    return detectContractFeature(t, "ContractMetadata")
                }
            };
            let n6 = {
                    admin: "",
                    transfer: "TRANSFER_ROLE",
                    minter: "MINTER_ROLE",
                    pauser: "PAUSER_ROLE",
                    lister: "LISTER_ROLE",
                    asset: "ASSET_ROLE",
                    unwrap: "UNWRAP_ROLE",
                    factory: "FACTORY_ROLE",
                    signer: "SIGNER_ROLE"
                },
                n8 = Object.keys(n6);

            function getRoleHash(t) {
                return "admin" === t ? x.hexZeroPad([0], 32) : B.id(n6[t])
            }
            let ContractRoles = class ContractRoles {
                featureName = ah.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.roles = e
                }
                async getAll() {
                    (0, j.Z)(this.roles.length, "this contract has no support for roles");
                    let t = {};
                    for (let e of this.roles) t[e] = await this.get(e);
                    return t
                }
                async get(t) {
                    (0, j.Z)(this.roles.includes(t), `this contract does not support the "${t}" role`);
                    let e = this.contractWrapper;
                    if (hasFunction("getRoleMemberCount", e) && hasFunction("getRoleMember", e)) {
                        let r = getRoleHash(t),
                            a = (await e.read("getRoleMemberCount", [r])).toNumber();
                        return await Promise.all(Array.from(Array(a).keys()).map(t => e.read("getRoleMember", [r, t])))
                    }
                    throw Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")
                }
                setAll = buildTransactionFunction(async t => {
                    let e = new ContractEncoder(this.contractWrapper),
                        r = Object.keys(t);
                    (0, j.Z)(r.length, "you must provide at least one role to set"), (0, j.Z)(r.every(t => this.roles.includes(t)), "this contract does not support the given role");
                    let a = await this.getAll(),
                        n = [],
                        i = r.sort(t => "admin" === t ? 1 : -1);
                    for (let r = 0; r < i.length; r++) {
                        let s = i[r],
                            o = await Promise.all(t[s] ? .map(async t => await resolveAddress(t)) || []),
                            c = await Promise.all(a[s] ? .map(async t => await resolveAddress(t)) || []),
                            l = o.filter(t => !c.includes(t)),
                            d = c.filter(t => !o.includes(t));
                        if (l.length && l.forEach(t => {
                                n.push(e.encode("grantRole", [getRoleHash(s), t]))
                            }), d.length)
                            for (let t = 0; t < d.length; t++) {
                                let r = d[t],
                                    a = await this.getRevokeRoleFunctionName(r);
                                n.push(e.encode(a, [getRoleHash(s), r]))
                            }
                    }
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [n]
                    })
                });
                async verify(t, e) {
                    await Promise.all(t.map(async t => {
                        let r = await this.get(t),
                            a = await resolveAddress(e);
                        if (!r.map(t => t.toLowerCase()).includes(a.toLowerCase())) throw new MissingRoleError(a, t)
                    }))
                }
                grant = buildTransactionFunction(async (t, e) => {
                    (0, j.Z)(this.roles.includes(t), `this contract does not support the "${t}" role`);
                    let r = await resolveAddress(e);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "grantRole",
                        args: [getRoleHash(t), r]
                    })
                });
                revoke = buildTransactionFunction(async (t, e) => {
                    (0, j.Z)(this.roles.includes(t), `this contract does not support the "${t}" role`);
                    let r = await resolveAddress(e),
                        a = await this.getRevokeRoleFunctionName(r);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: a,
                        args: [getRoleHash(t), r]
                    })
                });
                async getRevokeRoleFunctionName(t) {
                    let e = await resolveAddress(t),
                        r = await this.contractWrapper.getSignerAddress();
                    return r.toLowerCase() === e.toLowerCase() ? "renounceRole" : "revokeRole"
                }
            };
            let ContractRoyalty = class ContractRoyalty {
                featureName = ap.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.metadata = e
                }
                async getDefaultRoyaltyInfo() {
                    let [t, e] = await this.contractWrapper.read("getDefaultRoyaltyInfo", []);
                    return e6.parseAsync({
                        fee_recipient: t,
                        seller_fee_basis_points: e
                    })
                }
                async getTokenRoyaltyInfo(t) {
                    let [e, r] = await this.contractWrapper.read("getRoyaltyInfoForToken", [t]);
                    return e6.parseAsync({
                        fee_recipient: e,
                        seller_fee_basis_points: r
                    })
                }
                setDefaultRoyaltyInfo = buildTransactionFunction(async t => {
                    let e = await this.metadata.get(),
                        r = await this.metadata.parseInputMetadata({ ...e,
                            ...t
                        }),
                        a = await this.metadata._parseAndUploadMetadata(r);
                    if (hasFunction("setContractURI", this.contractWrapper)) {
                        let t = new ContractEncoder(this.contractWrapper),
                            e = [t.encode("setDefaultRoyaltyInfo", [r.fee_recipient, r.seller_fee_basis_points]), t.encode("setContractURI", [a])];
                        return Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "multicall",
                            args: [e],
                            parse: t => ({
                                receipt: t,
                                data: () => this.getDefaultRoyaltyInfo()
                            })
                        })
                    }
                    throw Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")
                });
                setTokenRoyaltyInfo = buildTransactionFunction(async (t, e) => {
                    let r = e6.parse(e);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setRoyaltyInfoForToken",
                        args: [t, r.fee_recipient, r.seller_fee_basis_points],
                        parse: t => ({
                            receipt: t,
                            data: () => this.getDefaultRoyaltyInfo()
                        })
                    })
                })
            };
            let ContractPrimarySale = class ContractPrimarySale {
                featureName = au.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                async getRecipient() {
                    let t = await this.contractWrapper.read("primarySaleRecipient", []);
                    return t
                }
                setRecipient = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "setPrimarySaleRecipient",
                    args: [t]
                }))
            };
            let n3 = {
                name: "Failed to load NFT metadata"
            };
            async function fetchTokenMetadata(t, e, r) {
                let a;
                if (e.startsWith("data:application/json;base64") && void 0 !== ei) {
                    let r = e.split(",")[1],
                        a = JSON.parse(ei.from(r, "base64").toString("utf-8"));
                    return C.C.parse({ ...a,
                        id: v.O$.from(t).toString(),
                        uri: e
                    })
                }
                let n = e.replace("{id}", x.hexZeroPad(v.O$.from(t).toHexString(), 32).slice(2));
                try {
                    a = await r.downloadJSON(n)
                } catch (i) {
                    let n = e.replace("{id}", v.O$.from(t).toString());
                    try {
                        a = await r.downloadJSON(n)
                    } catch (r) {
                        console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`), a = n3
                    }
                }
                return C.C.parse({ ...a,
                    id: v.O$.from(t).toString(),
                    uri: e
                })
            }
            async function fetchTokenMetadataForContract(t, e, r, a) {
                let n;
                let i = new O.CH(t, H, e),
                    [s, o] = await Promise.all([i.supportsInterface(nj), i.supportsInterface(nq)]);
                if (s) {
                    let a = new O.CH(t, Z, e);
                    n = await a.tokenURI(r)
                } else if (o) {
                    let a = new O.CH(t, J, e);
                    n = await a.uri(r)
                } else throw Error("Contract must implement ERC 1155 or ERC 721.");
                return n ? fetchTokenMetadata(r, n, a) : C.C.parse({ ...n3,
                    id: v.O$.from(r).toString(),
                    uri: ""
                })
            }
            async function uploadOrExtractURI(t, e) {
                return "string" == typeof t ? t : await e.upload(C.b.parse(t))
            }
            async function uploadOrExtractURIs(t, e, r, a) {
                if (void 0 === t.find(t => "string" != typeof t)) return t;
                if (void 0 === t.find(t => "object" != typeof t)) {
                    let n = await e.uploadBatch(t.map(t => C.b.parse(t)), {
                        rewriteFileNames: {
                            fileStartNumber: r || 0
                        },
                        onProgress: a ? .onProgress
                    });
                    return n
                }
                throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")
            }

            function getBaseUriFromBatch(t) {
                let e = t[0].substring(0, t[0].lastIndexOf("/"));
                for (let r = 0; r < t.length; r++) {
                    let a = t[r].substring(0, t[r].lastIndexOf("/"));
                    if (e !== a) throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${a}'`)
                }
                return e.replace(/\/$/, "") + "/"
            }
            let DelayedReveal = class DelayedReveal {
                constructor(t, e, r, a) {
                    this.featureName = r, this.nextTokenIdToMintFn = a, this.contractWrapper = t, this.storage = e
                }
                createDelayedRevealBatch = buildTransactionFunction(async (t, e, r, a) => {
                    let n;
                    if (!r) throw Error("Password is required");
                    let i = await this.storage.uploadBatch([C.b.parse(t)], {
                            rewriteFileNames: {
                                fileStartNumber: 0
                            }
                        }),
                        s = getBaseUriFromBatch(i),
                        o = await this.nextTokenIdToMintFn(),
                        c = await this.storage.uploadBatch(e.map(t => C.b.parse(t)), {
                            onProgress: a ? .onProgress,
                            rewriteFileNames: {
                                fileStartNumber: o.toNumber()
                            }
                        }),
                        l = getBaseUriFromBatch(c),
                        d = await this.contractWrapper.read("getBaseURICount", []),
                        p = await this.hashDelayRevealPassword(d, r),
                        u = await this.contractWrapper.read("encryptDecrypt", [M.Y0(l), p]),
                        f = await this.isLegacyContract();
                    if (f) n = u;
                    else {
                        let t = await this.contractWrapper.getChainID(),
                            e = L.keccak256(["bytes", "bytes", "uint256"], [M.Y0(l), p, t]);
                        n = $.$.encode(["bytes", "bytes32"], [u, e])
                    }
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "lazyMint",
                        args: [c.length, s.endsWith("/") ? s : `${s}/`, n],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensLazyMinted", t ? .logs),
                                r = e[0].args.startTokenId,
                                a = e[0].args.endTokenId,
                                n = [];
                            for (let e = r; e.lte(a); e = e.add(1)) n.push({
                                id: e,
                                receipt: t
                            });
                            return n
                        }
                    })
                });
                reveal = buildTransactionFunction(async (t, e) => {
                    if (!e) throw Error("Password is required");
                    let r = await this.hashDelayRevealPassword(t, e);
                    try {
                        let e = await this.contractWrapper.callStatic().reveal(t, r);
                        if (!e.includes("://") || !e.endsWith("/")) throw Error("invalid password")
                    } catch (t) {
                        throw Error("invalid password")
                    }
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "reveal",
                        args: [t, r]
                    })
                });
                async getBatchesToReveal() {
                    let t = await this.contractWrapper.read("getBaseURICount", []);
                    if (t.isZero()) return [];
                    let e = Array.from(Array(t.toNumber()).keys()),
                        r = await Promise.all(e.map(t => {
                            if (hasFunction("getBatchIdAtIndex", this.contractWrapper)) return this.contractWrapper.read("getBatchIdAtIndex", [t]);
                            if (hasFunction("baseURIIndices", this.contractWrapper)) return this.contractWrapper.read("baseURIIndices", [t]);
                            throw Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")
                        })),
                        a = r.slice(0, r.length - 1),
                        n = await Promise.all(Array.from([0, ...a]).map(t => this.getNftMetadata(t.toString()))),
                        i = await this.isLegacyContract(),
                        s = await Promise.all(Array.from([...r]).map(t => i ? this.getLegacyEncryptedData(t) : this.contractWrapper.read("encryptedData", [t]))),
                        o = s.map(t => {
                            if (!(x.hexDataLength(t) > 0)) return t; {
                                if (i) return t;
                                let e = $.$.decode(["bytes", "bytes32"], t);
                                return e[0]
                            }
                        });
                    return n.map((t, e) => ({
                        batchId: v.O$.from(e),
                        batchUri: t.uri,
                        placeholderMetadata: t
                    })).filter((t, e) => x.hexDataLength(o[e]) > 0)
                }
                async hashDelayRevealPassword(t, e) {
                    let r = await this.contractWrapper.getChainID(),
                        a = this.contractWrapper.address;
                    return L.keccak256(["string", "uint256", "uint256", "address"], [e, r, t, a])
                }
                async getNftMetadata(t) {
                    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), t, this.storage)
                }
                async isLegacyContract() {
                    if (hasFunction("contractVersion", this.contractWrapper)) try {
                        let t = await this.contractWrapper.read("contractVersion", []);
                        return t <= 2
                    } catch (t) {}
                    return !1
                }
                async getLegacyEncryptedData(t) {
                    let e = new O.CH(this.contractWrapper.address, tr, this.contractWrapper.getProvider()),
                        r = await e.functions.encryptedBaseURI(t);
                    return r.length > 0 ? r[0] : "0x"
                }
            };

            function abstractContractModelToLegacy(t) {
                return {
                    startTimestamp: t.startTimestamp,
                    maxClaimableSupply: t.maxClaimableSupply,
                    supplyClaimed: t.supplyClaimed,
                    merkleRoot: t.merkleRoot,
                    pricePerToken: t.pricePerToken,
                    currency: t.currency,
                    quantityLimitPerTransaction: t.maxClaimablePerWallet,
                    waitTimeInSecondsBetweenClaims: t.waitTimeInSecondsBetweenClaims || 0
                }
            }

            function abstractContractModelToNew(t) {
                return {
                    startTimestamp: t.startTimestamp,
                    maxClaimableSupply: t.maxClaimableSupply,
                    supplyClaimed: t.supplyClaimed,
                    merkleRoot: t.merkleRoot,
                    pricePerToken: t.pricePerToken,
                    currency: t.currency,
                    quantityLimitPerWallet: t.maxClaimablePerWallet,
                    metadata: t.metadata || ""
                }
            }

            function convertQuantityToBigNumber(t, e) {
                return "unlimited" === t ? V.Bz : R.parseUnits(t, e)
            }

            function isNativeToken(t) {
                return t.toLowerCase() === eT || t.toLowerCase() === I.d
            }
            async function fetchCurrencyMetadata(t, e) {
                if (isNativeToken(e)) {
                    let e = await t.getNetwork(),
                        r = getNativeTokenByChainId(e.chainId);
                    return {
                        name: r.name,
                        symbol: r.symbol,
                        decimals: r.decimals
                    }
                } {
                    let r = new O.CH(e, Q, t),
                        [a, n, i] = await Promise.all([r.name(), r.symbol(), r.decimals()]);
                    return {
                        name: a,
                        symbol: n,
                        decimals: i
                    }
                }
            }
            async function parseSnapshotInputs(t) {
                let e = Array.from({
                        length: Math.ceil(t.length / 25e3)
                    }, (e, r) => t.slice(25e3 * r, 25e3 * r + 25e3)),
                    r = [];
                for (let t of e) r.push(...await eO.parseAsync(t));
                return r
            }
            let n7 = ((y = {})[y.V1 = 1] = "V1", y[y.V2 = 2] = "V2", y);
            let ShardedMerkleTree = class ShardedMerkleTree {
                constructor(t, e, r, a, n) {
                    this.storage = t, this.shardNybbles = a, this.baseUri = e, this.originalEntriesUri = r, this.tokenDecimals = n, this.shards = {}, this.trees = {}
                }
                static async fromUri(t, e) {
                    try {
                        let r = await e.downloadJSON(t);
                        if (r.isShardedMerkleTree) return ShardedMerkleTree.fromShardedMerkleTreeInfo(r, e)
                    } catch (t) {
                        return
                    }
                }
                static async fromShardedMerkleTreeInfo(t, e) {
                    return new ShardedMerkleTree(e, t.baseUri, t.originalEntriesUri, t.shardNybbles, t.tokenDecimals)
                }
                static hashEntry(t, e, r, a) {
                    switch (a) {
                        case n7.V1:
                            return L.keccak256(["address", "uint256"], [t.address, convertQuantityToBigNumber(t.maxClaimable, e)]);
                        case n7.V2:
                            return L.keccak256(["address", "uint256", "uint256", "address"], [t.address, convertQuantityToBigNumber(t.maxClaimable, e), convertQuantityToBigNumber(t.price || "unlimited", r), t.currencyAddress || I.d])
                    }
                }
                static async fetchAndCacheDecimals(t, e, r) {
                    if (!r) return 18;
                    let a = t[r];
                    if (void 0 === a) {
                        let n = await fetchCurrencyMetadata(e, r);
                        a = n.decimals, t[r] = a
                    }
                    return a
                }
                static async buildAndUpload(t, e, r, a, n) {
                    let i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2,
                        s = await parseSnapshotInputs(t),
                        o = {};
                    for (let t of s) {
                        let e = t.address.slice(2, 2 + i).toLowerCase();
                        void 0 === o[e] && (o[e] = []), o[e].push(t)
                    }
                    let c = {},
                        l = await Promise.all(Object.entries(o).map(async t => {
                            let [a, i] = t;
                            return [a, new tt.MerkleTree(await Promise.all(i.map(async t => {
                                let a = await ShardedMerkleTree.fetchAndCacheDecimals(c, r, t.currencyAddress);
                                return ShardedMerkleTree.hashEntry(t, e, a, n)
                            })), N.keccak256, {
                                sort: !0
                            }).getHexRoot()]
                        })),
                        d = Object.fromEntries(l),
                        p = new tt.MerkleTree(Object.values(d), N.keccak256, {
                            sort: !0
                        }),
                        u = [];
                    for (let [t, e] of Object.entries(o)) {
                        let r = {
                            proofs: p.getProof(d[t]).map(t => "0x" + t.data.toString("hex")),
                            entries: e
                        };
                        u.push({
                            data: JSON.stringify(r),
                            name: `${t}.json`
                        })
                    }
                    let f = await a.uploadBatch(u),
                        m = f[0].slice(0, f[0].lastIndexOf("/")),
                        h = await a.upload(s),
                        g = {
                            merkleRoot: p.getHexRoot(),
                            baseUri: m,
                            originalEntriesUri: h,
                            shardNybbles: i,
                            tokenDecimals: e,
                            isShardedMerkleTree: !0
                        },
                        y = await a.upload(g);
                    return {
                        shardedMerkleInfo: g,
                        uri: y
                    }
                }
                async getProof(t, e, r) {
                    let a = t.slice(2, 2 + this.shardNybbles).toLowerCase(),
                        n = this.shards[a],
                        i = {};
                    if (void 0 === n) try {
                        n = this.shards[a] = await this.storage.downloadJSON(`${this.baseUri}/${a}.json`);
                        let t = await Promise.all(n.entries.map(async t => {
                            let a = await ShardedMerkleTree.fetchAndCacheDecimals(i, e, t.currencyAddress);
                            return ShardedMerkleTree.hashEntry(t, this.tokenDecimals, a, r)
                        }));
                        this.trees[a] = new tt.MerkleTree(t, N.keccak256, {
                            sort: !0
                        })
                    } catch (t) {
                        return null
                    }
                    let s = n.entries.find(e => e.address.toLowerCase() === t.toLowerCase());
                    if (!s) return null;
                    let o = await ShardedMerkleTree.fetchAndCacheDecimals(i, e, s.currencyAddress),
                        c = ShardedMerkleTree.hashEntry(s, this.tokenDecimals, o, r),
                        l = this.trees[a].getProof(c).map(t => "0x" + t.data.toString("hex"));
                    return eN.parseAsync({ ...s,
                        proof: l.concat(n.proofs)
                    })
                }
                async getAllEntries() {
                    try {
                        return await this.storage.downloadJSON(this.originalEntriesUri)
                    } catch (t) {
                        return console.warn("Could not fetch original snapshot entries", t), []
                    }
                }
            };
            async function fetchSnapshotEntryForAddress(t, e, r, a, n, i) {
                if (!r) return null;
                let s = r[e];
                if (s) {
                    let r = await n.downloadJSON(s);
                    if (r.isShardedMerkleTree && r.merkleRoot === e) {
                        let e = await ShardedMerkleTree.fromShardedMerkleTreeInfo(r, n);
                        return await e.getProof(t, a, i)
                    }
                    let o = await eD.parseAsync(r);
                    if (e === o.merkleRoot) return o.claims.find(e => e.address.toLowerCase() === t.toLowerCase()) || null
                }
                return null
            }

            function legacyContractModelToAbstract(t) {
                return {
                    startTimestamp: t.startTimestamp,
                    maxClaimableSupply: t.maxClaimableSupply,
                    supplyClaimed: t.supplyClaimed,
                    merkleRoot: t.merkleRoot.toString(),
                    pricePerToken: t.pricePerToken,
                    currency: t.currency,
                    maxClaimablePerWallet: t.quantityLimitPerTransaction,
                    waitTimeInSecondsBetweenClaims: t.waitTimeInSecondsBetweenClaims
                }
            }

            function newContractModelToAbstract(t) {
                return {
                    startTimestamp: t.startTimestamp,
                    maxClaimableSupply: t.maxClaimableSupply,
                    supplyClaimed: t.supplyClaimed,
                    merkleRoot: t.merkleRoot.toString(),
                    pricePerToken: t.pricePerToken,
                    currency: t.currency,
                    maxClaimablePerWallet: t.quantityLimitPerWallet,
                    waitTimeInSecondsBetweenClaims: 0,
                    metadata: t.metadata
                }
            }
            let RPCConnectionHandler = class RPCConnectionHandler extends en.Z {
                constructor(t, e) {
                    super();
                    try {
                        this.options = eh.parse(e)
                    } catch (t) {
                        console.error("invalid sdk options object passed, falling back to default options", t), this.options = eh.parse({})
                    }
                    let [r, a] = getSignerAndProvider(t, this.options);
                    this.network = t, this.signer = r, this.provider = a
                }
                updateSignerOrProvider(t) {
                    let [e, r] = getSignerAndProvider(t, this.options);
                    this.network = t, this.signer = e, this.provider = r
                }
                isReadOnly() {
                    return !isSigner(this.signer)
                }
                getSigner() {
                    return this.signer
                }
                getProvider() {
                    return this.provider
                }
                getSignerOrProvider() {
                    return this.getSigner() || this.getProvider()
                }
            };
            let ContractWrapper = class ContractWrapper extends RPCConnectionHandler {
                isValidContract = !1;
                customOverrides = () => ({});
                constructor(t, e, r, a, n) {
                    super(t, a), this.abi = r, this.address = e, this.writeContract = new O.CH(e, r, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.storage = n
                }
                updateSignerOrProvider(t) {
                    super.updateSignerOrProvider(t), this.writeContract = this.writeContract.connect(this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider())
                }
                updateAbi(t) {
                    this.writeContract = new O.CH(this.address, t, this.getSignerOrProvider()), this.readContract = this.writeContract.connect(this.getProvider()), this.abi = ro.parse(t)
                }
                async getChainID() {
                    let t = this.getProvider(),
                        {
                            chainId: e
                        } = await t.getNetwork();
                    return e
                }
                async getSignerAddress() {
                    let t = this.getSigner();
                    if (!t) throw Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
                    return await t.getAddress()
                }
                callStatic() {
                    return this.writeContract.callStatic
                }
                async getCallOverrides() {
                    return getDefaultGasOverrides(this.getProvider())
                }
                emitTransactionEvent(t, e) {
                    this.emit(nG.Transaction, {
                        status: t,
                        transactionHash: e
                    })
                }
                async multiCall(t) {
                    return this.sendTransaction("multicall", [t])
                }
                async estimateGas(t, e) {
                    return this.writeContract.estimateGas[t](...e)
                }
                withTransactionOverride(t) {
                    this.customOverrides = t
                }
                async read(t, e) {
                    let r = extractFunctionsFromAbi(ro.parse(this.abi)).filter(e => e.name === t);
                    if (!r.length) throw Error(`Function "${t.toString()}" not found in contract. Check your dashboard for the list of functions available`);
                    let a = r.find(r => r.name === t && r.inputs.length === e.length);
                    if (!a) throw Error(`Function "${t.toString()}" requires ${r[0].inputs.length} arguments, but ${e.length} were provided.
Expected function signature: ${r[0].signature}`);
                    let n = `${t.toString()}(${a.inputs.map(t=>t.type).join()})`,
                        i = n in this.readContract.functions ? n : t;
                    if ("view" === a.stateMutability || "pure" === a.stateMutability) {
                        let t = await this.readContract[i.toString()](...e);
                        return t
                    }
                    throw Error("Cannot call a write function with read()")
                }
                async call(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        r = arguments.length > 2 ? arguments[2] : void 0,
                        a = r ? await rE.parseAsync(r) : void 0,
                        n = extractFunctionsFromAbi(ro.parse(this.abi)).filter(e => e.name === t);
                    if (!n.length) throw Error(`Function "${t}" not found in contract. Check your dashboard for the list of functions available`);
                    let i = n.find(r => r.name === t && r.inputs.length === e.length);
                    if (!i) throw Error(`Function "${t}" requires ${n[0].inputs.length} arguments, but ${e.length} were provided.
Expected function signature: ${n[0].signature}`);
                    let s = `${t}(${i.inputs.map(t=>t.type).join()})`,
                        o = s in this.readContract.functions ? s : t;
                    if ("view" === i.stateMutability || "pure" === i.stateMutability) return a ? this.readContract[o](...e, a) : this.readContract[o](...e); {
                        let t = await this.sendTransaction(o, e, a);
                        return {
                            receipt: t
                        }
                    }
                }
                async sendTransaction(t, e, r) {
                    if (r || (r = await this.getCallOverrides()), r = { ...r,
                            ...this.customOverrides()
                        }, this.customOverrides = () => ({}), this.options ? .gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless)) {
                        if ("multicall" === t && Array.isArray(e[0]) && e[0].length > 0) {
                            let t = await this.getSignerAddress();
                            e[0] = e[0].map(e => L.pack(["bytes", "address"], [e, t]))
                        }
                        let a = this.getProvider(),
                            n = await this.sendGaslessTransaction(t, e, r);
                        this.emitTransactionEvent("submitted", n);
                        let i = await a.waitForTransaction(n);
                        return this.emitTransactionEvent("completed", n), i
                    } {
                        let a;
                        if (!this.isValidContract) {
                            let t = await this.getProvider().getCode(this.address);
                            if (this.isValidContract = "0x" !== t, !this.isValidContract) throw Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct")
                        }
                        let n = await this.sendTransactionByFunction(t, e, r);
                        this.emitTransactionEvent("submitted", n.hash);
                        try {
                            a = await n.wait()
                        } catch (a) {
                            try {
                                await this.writeContract.callStatic[t](...e, ...r.value ? [{
                                    value: r.value
                                }] : [])
                            } catch (a) {
                                throw await this.formatError(a, t, e, r)
                            }
                            throw await this.formatError(a, t, e, r)
                        }
                        return this.emitTransactionEvent("completed", n.hash), a
                    }
                }
                async sendTransactionByFunction(t, e, r) {
                    let a = this.writeContract.functions[t];
                    if (!a) throw Error(`invalid function: "${t.toString()}"`);
                    if (!r.gasLimit) try {
                        r.gasLimit = await this.writeContract.estimateGas[t](...e, r)
                    } catch (a) {
                        try {
                            await this.writeContract.callStatic[t](...e, ...r.value ? [{
                                value: r.value
                            }] : [])
                        } catch (a) {
                            throw await this.formatError(a, t, e, r)
                        }
                    }
                    try {
                        return await a(...e, r)
                    } catch (a) {
                        throw await this.formatError(a, t, e, r)
                    }
                }
                async formatError(t, e, r, a) {
                    let n, i;
                    let s = this.getProvider(),
                        o = await s.getNetwork(),
                        c = await (a.from || this.getSignerAddress()),
                        l = this.address,
                        d = this.readContract.interface.encodeFunctionData(e, r),
                        p = v.O$.from(a.value || 0),
                        u = s.connection ? .url,
                        f = this.readContract.interface.getFunction(e),
                        m = r.map(t => JSON.stringify(t).length <= 80 ? JSON.stringify(t) : JSON.stringify(t, void 0, 2)),
                        h = m.join(", ").length <= 80 ? m.join(", ") : "\n" + m.map(t => "  " + t.split("\n").join("\n  ")).join(",\n") + "\n",
                        g = `${f.name}(${h})`,
                        y = t.transactionHash || t.transaction ? .hash || t.receipt ? .transactionHash,
                        w = parseRevertReason(t);
                    try {
                        let t = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);
                        t.name && (i = t.name), t.metadata.sources && (n = await fetchSourceFilesFromMetadata(t, this.storage))
                    } catch (t) {}
                    return new TransactionError({
                        reason: w,
                        from: c,
                        to: l,
                        method: g,
                        data: d,
                        network: o,
                        rpcUrl: u,
                        value: p,
                        hash: y,
                        contractName: i,
                        sources: n
                    }, t)
                }
                async sendGaslessTransaction(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                        r = arguments.length > 2 ? arguments[2] : void 0,
                        a = this.getSigner();
                    (0, j.Z)(a, "Cannot execute gasless transaction without valid signer");
                    let n = await this.getChainID(),
                        i = await this.getSignerAddress(),
                        s = this.writeContract.address,
                        o = r ? .value || 0;
                    if (v.O$.from(o).gt(0)) throw Error("Cannot send native token value with gasless transaction");
                    let c = this.writeContract.interface.encodeFunctionData(t, e),
                        l = v.O$.from(0);
                    try {
                        let r = await this.readContract.estimateGas[t](...e);
                        l = r.mul(2)
                    } catch (t) {}
                    l.lt(1e5) && (l = v.O$.from(5e5)), r.gasLimit && v.O$.from(r.gasLimit).gt(l) && (l = v.O$.from(r.gasLimit));
                    let d = {
                        from: i,
                        to: s,
                        data: c,
                        chainId: n,
                        gasLimit: l,
                        functionName: t.toString(),
                        functionArgs: e,
                        callOverrides: r
                    };
                    return await this.defaultGaslessSendFunction(d)
                }
                async signTypedData(t, e, r, a) {
                    this.emit(nG.Signature, {
                        status: "submitted",
                        message: a,
                        signature: ""
                    });
                    let {
                        signature: n
                    } = await signTypedDataInternal(t, e, r, a);
                    return this.emit(nG.Signature, {
                        status: "completed",
                        message: a,
                        signature: n
                    }), n
                }
                parseLogs(t, e) {
                    if (!e || 0 === e.length) return [];
                    let r = this.writeContract.interface.getEventTopic(t),
                        a = e.filter(t => t.topics.indexOf(r) >= 0);
                    return a.map(t => this.writeContract.interface.parseLog(t))
                }
                async defaultGaslessSendFunction(t) {
                    return this.options.gasless && "biconomy" in this.options.gasless ? this.biconomySendFunction(t) : this.defenderSendFunction(t)
                }
                async biconomySendFunction(t) {
                    (0, j.Z)(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
                    let e = this.getSigner(),
                        r = this.getProvider();
                    (0, j.Z)(e && r, "signer and provider must be set");
                    let a = new O.CH(getContractAddressByChainId(t.chainId, "biconomyForwarder"), nY, r),
                        n = await getAndIncrementNonce(a, "getNonce", [t.from, 0]),
                        i = {
                            from: t.from,
                            to: t.to,
                            token: I.d,
                            txGas: t.gasLimit.toNumber(),
                            tokenGasPrice: "0",
                            batchId: 0,
                            batchNonce: n.toNumber(),
                            deadline: Math.floor(Date.now() / 1e3 + (this.options ? .gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy ? .deadlineSeconds || 3600)),
                            data: t.data
                        },
                        s = x.arrayify(L.keccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [i.from, i.to, i.token, i.txGas, i.tokenGasPrice, i.batchId, i.batchNonce, i.deadline, N.keccak256(i.data)]));
                    this.emit(nG.Signature, {
                        status: "submitted",
                        message: s,
                        signature: ""
                    });
                    let o = await e.signMessage(s);
                    this.emit(nG.Signature, {
                        status: "completed",
                        message: s,
                        signature: o
                    });
                    let c = await ea()("https://api.biconomy.io/api/v2/meta-tx/native", {
                        method: "POST",
                        body: JSON.stringify({
                            from: t.from,
                            apiId: this.options.gasless.biconomy.apiId,
                            params: [i, o],
                            to: t.to,
                            gasLimit: t.gasLimit.toHexString()
                        }),
                        headers: {
                            "x-api-key": this.options.gasless.biconomy.apiKey,
                            "Content-Type": "application/json;charset=utf-8"
                        }
                    });
                    if (c.ok) {
                        let t = await c.json();
                        if (!t.txHash) throw Error(`relay transaction failed: ${t.log}`);
                        return t.txHash
                    }
                    throw Error(`relay transaction failed with status: ${c.status} (${c.statusText})`)
                }
                async defenderSendFunction(t) {
                    let e, r, a, n;
                    (0, j.Z)(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
                    let i = this.getSigner(),
                        s = this.getProvider();
                    (0, j.Z)(i, "provider is not set"), (0, j.Z)(s, "provider is not set");
                    let o = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? n_[t.chainId].openzeppelinForwarderEOA || await computeEOAForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey) : n_[t.chainId].openzeppelinForwarder || await computeForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)),
                        c = new O.CH(o, ee, s),
                        l = await getAndIncrementNonce(c, "getNonce", [t.from]);
                    if (this.options.gasless.experimentalChainlessSupport ? (e = {
                            name: "GSNv2 Forwarder",
                            version: "0.0.1",
                            verifyingContract: o
                        }, r = {
                            ForwardRequest: nQ
                        }, a = {
                            from: t.from,
                            to: t.to,
                            value: v.O$.from(0).toString(),
                            gas: v.O$.from(t.gasLimit).toString(),
                            nonce: v.O$.from(l).toString(),
                            data: t.data,
                            chainid: v.O$.from(t.chainId).toString()
                        }) : (e = {
                            name: this.options.gasless.openzeppelin.domainName,
                            version: this.options.gasless.openzeppelin.domainVersion,
                            chainId: t.chainId,
                            verifyingContract: o
                        }, r = {
                            ForwardRequest: nK
                        }, a = {
                            from: t.from,
                            to: t.to,
                            value: v.O$.from(0).toString(),
                            gas: v.O$.from(t.gasLimit).toString(),
                            nonce: v.O$.from(l).toString(),
                            data: t.data
                        }), this.emit(nG.Signature, {
                            status: "submitted",
                            message: a,
                            signature: ""
                        }), "approve" === t.functionName && 2 === t.functionArgs.length) {
                        let e = t.functionArgs[0],
                            r = t.functionArgs[1],
                            {
                                message: s,
                                signature: o
                            } = await signEIP2612Permit(i, this.writeContract.address, t.from, e, r),
                            {
                                r: c,
                                s: l,
                                v: d
                            } = x.splitSignature(o);
                        a = {
                            to: this.address,
                            owner: s.owner,
                            spender: s.spender,
                            value: v.O$.from(s.value).toString(),
                            nonce: v.O$.from(s.nonce).toString(),
                            deadline: v.O$.from(s.deadline).toString(),
                            r: c,
                            s: l,
                            v: d
                        }, n = o
                    } else {
                        let {
                            signature: t
                        } = await signTypedDataInternal(i, e, r, a);
                        n = t
                    }
                    let d = "forward";
                    a ? .owner && (d = "permit");
                    let p = JSON.stringify({
                        request: a,
                        signature: n,
                        forwarderAddress: o,
                        type: d
                    });
                    this.emit(nG.Signature, {
                        status: "completed",
                        message: a,
                        signature: n
                    });
                    let u = await ea()(this.options.gasless.openzeppelin.relayerUrl, {
                        method: "POST",
                        body: p
                    });
                    if (u.ok) {
                        let t = await u.json();
                        if (!t.result) throw Error(`Relay transaction failed: ${t.message}`);
                        let e = JSON.parse(t.result);
                        return e.txHash
                    }
                    throw Error(`relay transaction failed with status: ${u.status} (${u.statusText})`)
                }
            };
            async function approveErc20Allowance(t, e, r, a, n) {
                let i = t.getSigner(),
                    s = t.getProvider(),
                    o = new ContractWrapper(i || s, e, K, t.options, t.storage),
                    c = await t.getSignerAddress(),
                    l = t.address,
                    d = await o.read("allowance", [c, l]),
                    p = v.O$.from(r).mul(v.O$.from(a)).div(R.parseUnits("1", n));
                d.lt(p) && await o.sendTransaction("approve", [l, d.add(p)])
            }
            async function normalizePriceValue(t, e, r) {
                let a = await fetchCurrencyMetadata(t, r);
                return R.parseUnits(C.A.parse(e), a.decimals)
            }
            async function prepareClaim(t, e, r, a, n, i, s, o, c) {
                let l = convertQuantityToBigNumber(r.maxClaimablePerWallet, n),
                    d = [x.hexZeroPad([0], 32)],
                    p = r.price,
                    u = r.currencyAddress;
                try {
                    if (!r.merkleRootHash.toString().startsWith(I.d)) {
                        let e = await fetchSnapshotEntryForAddress(t, r.merkleRootHash.toString(), await a(), i.getProvider(), s, c);
                        if (e) d = e.proof, l = "unlimited" === e.maxClaimable ? V.Bz : R.parseUnits(e.maxClaimable, n), p = void 0 === e.price || "unlimited" === e.price ? V.Bz : await normalizePriceValue(i.getProvider(), e.price, e.currencyAddress || I.d), u = e.currencyAddress || I.d;
                        else if (c === n7.V1) throw Error("No claim found for this address")
                    }
                } catch (t) {
                    if (t ? .message === "No claim found for this address") throw t;
                    console.warn("failed to check claim condition merkle root hash, continuing anyways", t)
                }
                let f = await i.getCallOverrides() || {},
                    m = p.toString() !== V.Bz.toString() ? p : r.price,
                    h = u !== I.d ? u : r.currencyAddress;
                return m.gt(0) && (isNativeToken(h) ? f.value = v.O$.from(m).mul(e).div(R.parseUnits("1", n)) : o && await approveErc20Allowance(i, h, m, e, n)), {
                    overrides: f,
                    proofs: d,
                    maxClaimable: l,
                    price: m,
                    currencyAddress: h,
                    priceInProof: p,
                    currencyAddressInProof: u
                }
            }
            async function createSnapshot(t, e, r, a, n) {
                let i = await parseSnapshotInputs(t),
                    s = i.map(t => t.address),
                    o = new Set(s).size < s.length;
                if (o) throw new DuplicateLeafsError;
                let c = await ShardedMerkleTree.buildAndUpload(i, e, r, a, n);
                return {
                    merkleRoot: c.shardedMerkleInfo.merkleRoot,
                    snapshotUri: c.uri
                }
            }
            async function processSnapshotData(t, e, r, a, n) {
                let i = [],
                    s = await Promise.all(t.map(async t => {
                        if (t.snapshot && t.snapshot.length > 0) {
                            let s = await createSnapshot(t.snapshot, e, r, a, n);
                            i.push(s), t.merkleRootHash = s.merkleRoot
                        } else t.merkleRootHash = x.hexZeroPad([0], 32);
                        return t
                    }));
                return {
                    inputsWithSnapshots: s,
                    snapshotInfos: i
                }
            }
            async function convertToContractModel(t, e, r, a) {
                let n;
                let i = t.currencyAddress === I.d ? eT : t.currencyAddress,
                    s = convertQuantityToBigNumber(t.maxClaimableSupply, e),
                    o = convertQuantityToBigNumber(t.maxClaimablePerWallet, e);
                return t.metadata && (n = "string" == typeof t.metadata ? t.metadata : await a.upload(t.metadata)), {
                    startTimestamp: t.startTime,
                    maxClaimableSupply: s,
                    supplyClaimed: 0,
                    maxClaimablePerWallet: o,
                    pricePerToken: await normalizePriceValue(r, t.price, i),
                    currency: i,
                    merkleRoot: t.merkleRootHash.toString(),
                    waitTimeInSecondsBetweenClaims: t.waitInSeconds || 0,
                    metadata: n
                }
            }
            async function processClaimConditionInputs(t, e, r, a, n) {
                let {
                    inputsWithSnapshots: i,
                    snapshotInfos: s
                } = await processSnapshotData(t, e, r, a, n), o = await ez.parseAsync(i), c = (await Promise.all(o.map(t => convertToContractModel(t, e, r, a)))).sort((t, e) => (function(t, e) {
                    let r = v.O$.from(t),
                        a = v.O$.from(e);
                    return r.eq(a) ? 0 : r.gt(a) ? 1 : -1
                })(t.startTimestamp, e.startTimestamp));
                return {
                    snapshotInfos: s,
                    sortedConditions: c
                }
            }
            async function fetchCurrencyValue(t, e, r) {
                let a = await fetchCurrencyMetadata(t, e);
                return { ...a,
                    value: v.O$.from(r),
                    displayValue: R.formatUnits(r, a.decimals)
                }
            }
            async function fetchSnapshot(t, e, r) {
                if (!e) return null;
                let a = e[t];
                if (a) {
                    let e = await r.downloadJSON(a);
                    if (e.isShardedMerkleTree && e.merkleRoot === t) {
                        let t = await ShardedMerkleTree.fromUri(a, r);
                        return t ? .getAllEntries() || null
                    } {
                        let r = await eD.parseAsync(e);
                        if (t === r.merkleRoot) return r.claims.map(t => ({
                            address: t.address,
                            maxClaimable: t.maxClaimable,
                            price: t.price,
                            currencyAddress: t.currencyAddress
                        }))
                    }
                }
                return null
            }

            function convertToReadableQuantity(t, e) {
                return t.toString() === V.Bz.toString() ? "unlimited" : R.formatUnits(t, e)
            }
            async function transformResultToClaimCondition(t, e, r, a, n, i) {
                let s;
                let o = await fetchCurrencyValue(r, t.currency, t.pricePerToken),
                    c = convertToReadableQuantity(t.maxClaimableSupply, e),
                    l = convertToReadableQuantity(t.maxClaimablePerWallet, e),
                    d = convertToReadableQuantity(v.O$.from(t.maxClaimableSupply).sub(t.supplyClaimed), e),
                    p = convertToReadableQuantity(t.supplyClaimed, e);
                return t.metadata && (s = await n.downloadJSON(t.metadata)), e$.parseAsync({
                    startTime: t.startTimestamp,
                    maxClaimableSupply: c,
                    maxClaimablePerWallet: l,
                    currentMintSupply: p,
                    availableSupply: d,
                    waitInSeconds: t.waitTimeInSecondsBetweenClaims ? .toString(),
                    price: v.O$.from(t.pricePerToken),
                    currency: t.currency,
                    currencyAddress: t.currency,
                    currencyMetadata: o,
                    merkleRootHash: t.merkleRoot,
                    snapshot: i ? await fetchSnapshot(t.merkleRoot, a, n) : void 0,
                    metadata: s
                })
            }
            async function updateExistingClaimConditions(t, e, r) {
                if (t >= r.length) throw Error(`Index out of bounds - got index: ${t} with ${r.length} conditions`);
                let a = r[t].currencyMetadata.decimals,
                    n = r[t].price,
                    i = R.formatUnits(n, a),
                    s = await eL.parseAsync({ ...r[t],
                        price: i,
                        ...e
                    }),
                    o = await e$.parseAsync({ ...s,
                        price: n
                    });
                return r.map((e, r) => {
                    let n;
                    n = r === t ? o : e;
                    let i = R.formatUnits(n.price, a);
                    return { ...n,
                        price: i
                    }
                })
            }
            let n4 = ((w = {})[w.UNSET = 0] = "UNSET", w[w.Created = 1] = "Created", w[w.Completed = 2] = "Completed", w[w.Cancelled = 3] = "Cancelled", w[w.Active = 4] = "Active", w[w.Expired = 5] = "Expired", w),
                n9 = ((b = {}).NotEnoughSupply = "There is not enough supply to claim.", b.AddressNotAllowed = "This address is not on the allowlist.", b.WaitBeforeNextClaimTransaction = "Not enough time since last claim transaction. Please wait.", b.ClaimPhaseNotStarted = "Claim phase has not started yet.", b.AlreadyClaimed = "You have already claimed the token.", b.WrongPriceOrCurrency = "Incorrect price or currency.", b.OverMaxClaimablePerWallet = "Cannot claim more than maximum allowed quantity.", b.NotEnoughTokens = "There are not enough tokens in the wallet to pay for the claim.", b.NoActiveClaimPhase = "There is no active claim phase at the moment. Please check back in later.", b.NoClaimConditionSet = "There is no claim condition set.", b.NoWallet = "No wallet connected.", b.Unknown = "No claim conditions found.", b);
            let DropClaimConditions = class DropClaimConditions {
                constructor(t, e, r) {
                    this.storage = r, this.contractWrapper = t, this.metadata = e
                }
                async getActive(t) {
                    let e = await this.get(),
                        r = await this.metadata.get();
                    return await transformResultToClaimCondition(e, await this.getTokenDecimals(), this.contractWrapper.getProvider(), r.merkle || {}, this.storage, t ? .withAllowList || !1)
                }
                async get(t) {
                    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                        let t = await this.contractWrapper.read("claimCondition", []);
                        return legacyContractModelToAbstract(t)
                    }
                    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                        let e = void 0 !== t ? t : await this.contractWrapper.read("getActiveClaimConditionId", []),
                            r = await this.contractWrapper.read("getClaimConditionById", [e]);
                        return legacyContractModelToAbstract(r)
                    }
                    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
                        let t = await this.contractWrapper.read("claimCondition", []);
                        return newContractModelToAbstract(t)
                    }
                    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
                        let e = void 0 !== t ? t : await this.contractWrapper.read("getActiveClaimConditionId", []),
                            r = await this.contractWrapper.read("getClaimConditionById", [e]);
                        return newContractModelToAbstract(r)
                    }
                    throw Error("Contract does not support claim conditions")
                }
                async getAll(t) {
                    if (!(this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper))) return [await this.getActive(t)]; {
                        let [e, r] = await this.contractWrapper.read("claimCondition", []), a = e.toNumber(), n = r.toNumber(), i = [];
                        for (let t = a; t < a + n; t++) i.push(this.get(t));
                        let [s, o, ...c] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...i]);
                        return Promise.all(c.map(e => transformResultToClaimCondition(e, o, this.contractWrapper.getProvider(), s.merkle, this.storage, t ? .withAllowList || !1)))
                    }
                }
                async canClaim(t, e) {
                    return e && (e = await resolveAddress(e)), 0 === (await this.getClaimIneligibilityReasons(t, e)).length
                }
                async getClaimIneligibilityReasons(t, e) {
                    let r, a;
                    let n = [],
                        i = await this.getTokenDecimals(),
                        s = R.parseUnits(C.A.parse(t), i);
                    if (void 0 === e) try {
                        e = await this.contractWrapper.getSignerAddress()
                    } catch (t) {
                        console.warn("failed to get signer address", t)
                    }
                    if (!e) return [n9.NoWallet];
                    let o = await resolveAddress(e);
                    try {
                        a = await this.getActive()
                    } catch (t) {
                        if (includesErrorMessage(t, "!CONDITION") || includesErrorMessage(t, "no active mint condition")) return n.push(n9.NoClaimConditionSet), n;
                        return console.warn("failed to get active claim condition", t), n.push(n9.Unknown), n
                    }
                    if ("unlimited" !== a.availableSupply) {
                        let t = R.parseUnits(a.availableSupply, i);
                        if (t.lt(s)) return n.push(n9.NotEnoughSupply), n
                    }
                    let c = x.stripZeros(a.merkleRootHash),
                        l = c.length > 0,
                        d = null;
                    if (l) {
                        if (!(d = await this.getClaimerProofs(o)) && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) return n.push(n9.AddressNotAllowed), n;
                        if (d) try {
                            let e;
                            let a = await this.prepareClaim(t, !1, i, o);
                            if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                                if (r = await this.contractWrapper.read("getActiveClaimConditionId", []), [e] = await this.contractWrapper.read("verifyClaimMerkleProof", [r, o, t, a.proofs, a.maxClaimable]), !e) return n.push(n9.AddressNotAllowed), n
                            } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                                if ([e] = await this.contractWrapper.read("verifyClaimMerkleProof", [o, t, {
                                        proof: a.proofs,
                                        maxQuantityInAllowlist: a.maxClaimable
                                    }]), !e) return n.push(n9.AddressNotAllowed), n
                            } else this.isNewSinglePhaseDrop(this.contractWrapper) ? await this.contractWrapper.read("verifyClaim", [o, t, a.currencyAddress, a.price, {
                                proof: a.proofs,
                                quantityLimitPerWallet: a.maxClaimable,
                                currency: a.currencyAddressInProof,
                                pricePerToken: a.priceInProof
                            }]) : this.isNewMultiphaseDrop(this.contractWrapper) && (r = await this.contractWrapper.read("getActiveClaimConditionId", []), await this.contractWrapper.read("verifyClaim", [r, o, t, a.currencyAddress, a.price, {
                                proof: a.proofs,
                                quantityLimitPerWallet: a.maxClaimable,
                                currency: a.currencyAddressInProof,
                                pricePerToken: a.priceInProof
                            }]))
                        } catch (e) {
                            console.warn("Merkle proof verification failed:", "reason" in e ? e.reason : e);
                            let t = e.reason;
                            switch (t) {
                                case "!Qty":
                                    n.push(n9.OverMaxClaimablePerWallet);
                                    break;
                                case "!PriceOrCurrency":
                                    n.push(n9.WrongPriceOrCurrency);
                                    break;
                                case "!MaxSupply":
                                    n.push(n9.NotEnoughSupply);
                                    break;
                                case "cant claim yet":
                                    n.push(n9.ClaimPhaseNotStarted);
                                    break;
                                default:
                                    n.push(n9.AddressNotAllowed)
                            }
                            return n
                        }
                    }
                    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
                        let t = v.O$.from(0),
                            e = convertQuantityToBigNumber(a.maxClaimablePerWallet, i);
                        try {
                            t = await this.getSupplyClaimedByWallet(o)
                        } catch (t) {}
                        if (d && (e = convertQuantityToBigNumber(d.maxClaimable, i)), e.gt(0) && e.lt(t.add(s))) return n.push(n9.OverMaxClaimablePerWallet), n;
                        if ((!l || l && !d) && (e.lte(t) || e.eq(0))) return n.push(n9.AddressNotAllowed), n
                    }
                    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                        let [t, e] = [v.O$.from(0), v.O$.from(0)];
                        this.isLegacyMultiPhaseDrop(this.contractWrapper) ? (r = await this.contractWrapper.read("getActiveClaimConditionId", []), [t, e] = await this.contractWrapper.read("getClaimTimestamp", [r, o])) : this.isLegacySinglePhaseDrop(this.contractWrapper) && ([t, e] = await this.contractWrapper.read("getClaimTimestamp", [o]));
                        let a = v.O$.from(Date.now()).div(1e3);
                        if (t.gt(0) && a.lt(e)) return e.eq(V.Bz) ? n.push(n9.AlreadyClaimed) : n.push(n9.WaitBeforeNextClaimTransaction), n
                    }
                    if (a.price.gt(0) && isNode()) {
                        let e = a.price.mul(v.O$.from(t)),
                            r = this.contractWrapper.getProvider();
                        if (isNativeToken(a.currencyAddress)) {
                            let t = await r.getBalance(o);
                            t.lt(e) && n.push(n9.NotEnoughTokens)
                        } else {
                            let t = new ContractWrapper(r, a.currencyAddress, K, {}, this.storage),
                                i = await t.read("balanceOf", [o]);
                            i.lt(e) && n.push(n9.NotEnoughTokens)
                        }
                    }
                    return n
                }
                async getClaimerProofs(t, e) {
                    let r = await this.get(e),
                        a = r.merkleRoot,
                        n = x.stripZeros(a);
                    if (!(n.length > 0)) return null; {
                        let e = await this.metadata.get(),
                            r = await resolveAddress(t);
                        return await fetchSnapshotEntryForAddress(r, a.toString(), e.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion())
                    }
                }
                async getSupplyClaimedByWallet(t) {
                    let e = await resolveAddress(t);
                    if (this.isNewSinglePhaseDrop(this.contractWrapper)) return await this.contractWrapper.read("getSupplyClaimedByWallet", [e]);
                    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
                        let t = await this.contractWrapper.read("getActiveClaimConditionId", []);
                        return await this.contractWrapper.read("getSupplyClaimedByWallet", [t, e])
                    }
                    throw Error("This contract does not support the getSupplyClaimedByWallet function")
                }
                set = buildTransactionFunction((() => {
                    var t = this;
                    return async function(e) {
                        let r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            a = e;
                        if (t.isLegacySinglePhaseDrop(t.contractWrapper) || t.isNewSinglePhaseDrop(t.contractWrapper)) {
                            if (r = !0, 0 === e.length) a = [{
                                startTime: new Date(0),
                                currencyAddress: I.d,
                                price: 0,
                                maxClaimableSupply: 0,
                                maxClaimablePerWallet: 0,
                                waitInSeconds: 0,
                                merkleRootHash: x.hexZeroPad([0], 32),
                                snapshot: []
                            }];
                            else if (e.length > 1) throw Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")
                        }(t.isNewSinglePhaseDrop(t.contractWrapper) || t.isNewMultiphaseDrop(t.contractWrapper)) && a.forEach(t => {
                            if (t.snapshot && t.snapshot.length > 0 && (void 0 === t.maxClaimablePerWallet || "unlimited" === t.maxClaimablePerWallet)) throw Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
                            if (t.snapshot && t.snapshot.length > 0 && t.maxClaimablePerWallet ? .toString() === "0" && 0 === t.snapshot.map(t => "string" == typeof t ? 0 : Number(t.maxClaimable ? .toString() || 0)).reduce((t, e) => t + e, 0)) throw Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")
                        });
                        let {
                            snapshotInfos: n,
                            sortedConditions: i
                        } = await processClaimConditionInputs(a, await t.getTokenDecimals(), t.contractWrapper.getProvider(), t.storage, t.getSnapshotFormatVersion()), s = {};
                        n.forEach(t => {
                            s[t.merkleRoot] = t.snapshotUri
                        });
                        let o = await t.metadata.get(),
                            c = [];
                        if (!X()(o.merkle, s)) {
                            let e = await t.metadata.parseInputMetadata({ ...o,
                                    merkle: s
                                }),
                                r = await t.metadata._parseAndUploadMetadata(e);
                            if (hasFunction("setContractURI", t.contractWrapper)) {
                                let e = new ContractEncoder(t.contractWrapper);
                                c.push(e.encode("setContractURI", [r]))
                            } else throw Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")
                        }
                        let l = t.contractWrapper,
                            d = new ContractEncoder(l);
                        if (t.isLegacySinglePhaseDrop(l)) {
                            let t = new ContractEncoder(l);
                            c.push(t.encode("setClaimConditions", [abstractContractModelToLegacy(i[0]), r]))
                        } else if (t.isLegacyMultiPhaseDrop(l)) c.push(d.encode("setClaimConditions", [i.map(abstractContractModelToLegacy), r]));
                        else if (t.isNewSinglePhaseDrop(l)) c.push(d.encode("setClaimConditions", [abstractContractModelToNew(i[0]), r]));
                        else if (t.isNewMultiphaseDrop(l)) c.push(d.encode("setClaimConditions", [i.map(abstractContractModelToNew), r]));
                        else throw Error("Contract does not support claim conditions");
                        if (hasFunction("multicall", t.contractWrapper)) return Transaction.fromContractWrapper({
                            contractWrapper: t.contractWrapper,
                            method: "multicall",
                            args: [c]
                        });
                        throw Error("Contract does not support multicall")
                    }
                })());
                update = buildTransactionFunction(async (t, e) => {
                    let r = await this.getAll(),
                        a = await updateExistingClaimConditions(t, e, r);
                    return await this.set.prepare(a)
                });
                async getTokenDecimals() {
                    return detectContractFeature(this.contractWrapper, "ERC20") ? this.contractWrapper.read("decimals", []) : Promise.resolve(0)
                }
                async prepareClaim(t, e) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        a = arguments.length > 3 ? arguments[3] : void 0,
                        n = a || await this.contractWrapper.getSignerAddress();
                    return prepareClaim(n, t, await this.getActive(), async () => (await this.metadata.get()).merkle, r, this.contractWrapper, this.storage, e, this.getSnapshotFormatVersion())
                }
                async getClaimArguments(t, e, r) {
                    let a = await resolveAddress(t);
                    return this.isLegacyMultiPhaseDrop(this.contractWrapper) ? [a, e, r.currencyAddress, r.price, r.proofs, r.maxClaimable] : this.isLegacySinglePhaseDrop(this.contractWrapper) ? [a, e, r.currencyAddress, r.price, {
                        proof: r.proofs,
                        maxQuantityInAllowlist: r.maxClaimable
                    }, M.Y0("")] : [a, e, r.currencyAddress, r.price, {
                        proof: r.proofs,
                        quantityLimitPerWallet: r.maxClaimable,
                        pricePerToken: r.priceInProof,
                        currency: r.currencyAddressInProof
                    }, M.Y0("")]
                }
                async getClaimTransaction(t, e, r) {
                    if (r ? .pricePerToken) throw Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");
                    let a = await this.prepareClaim(e, r ? .checkERC20Allowance === void 0 || r.checkERC20Allowance, await this.getTokenDecimals());
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "claim",
                        args: await this.getClaimArguments(t, e, a),
                        overrides: a.overrides
                    })
                }
                isNewSinglePhaseDrop(t) {
                    return detectContractFeature(t, "ERC721ClaimConditionsV2") || detectContractFeature(t, "ERC20ClaimConditionsV2")
                }
                isNewMultiphaseDrop(t) {
                    return detectContractFeature(t, "ERC721ClaimPhasesV2") || detectContractFeature(t, "ERC20ClaimPhasesV2")
                }
                isLegacySinglePhaseDrop(t) {
                    return detectContractFeature(t, "ERC721ClaimConditionsV1") || detectContractFeature(t, "ERC20ClaimConditionsV1")
                }
                isLegacyMultiPhaseDrop(t) {
                    return detectContractFeature(t, "ERC721ClaimPhasesV1") || detectContractFeature(t, "ERC20ClaimPhasesV1")
                }
                getSnapshotFormatVersion() {
                    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? n7.V1 : n7.V2
                }
            };
            let DropErc1155ClaimConditions = class DropErc1155ClaimConditions {
                constructor(t, e, r) {
                    this.storage = r, this.contractWrapper = t, this.metadata = e
                }
                async getActive(t, e) {
                    let r = await this.get(t),
                        a = await this.metadata.get();
                    return await transformResultToClaimCondition(r, 0, this.contractWrapper.getProvider(), a.merkle, this.storage, e ? .withAllowList || !1)
                }
                async get(t, e) {
                    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                        let e = await this.contractWrapper.read("claimCondition", [t]);
                        return legacyContractModelToAbstract(e)
                    }
                    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                        let r = void 0 !== e ? e : await this.contractWrapper.read("getActiveClaimConditionId", [t]),
                            a = await this.contractWrapper.read("getClaimConditionById", [t, r]);
                        return legacyContractModelToAbstract(a)
                    }
                    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
                        let e = await this.contractWrapper.read("claimCondition", [t]);
                        return newContractModelToAbstract(e)
                    }
                    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
                        let r = void 0 !== e ? e : await this.contractWrapper.read("getActiveClaimConditionId", [t]),
                            a = await this.contractWrapper.read("getClaimConditionById", [t, r]);
                        return newContractModelToAbstract(a)
                    }
                    throw Error("Contract does not support claim conditions")
                }
                async getAll(t, e) {
                    if (!(this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper))) return [await this.getActive(t, e)]; {
                        let r = await this.contractWrapper.read("claimCondition", [t]),
                            a = r.currentStartId.toNumber(),
                            n = r.count.toNumber(),
                            i = [];
                        for (let e = a; e < a + n; e++) i.push(await this.get(t, e));
                        let s = await this.metadata.get();
                        return Promise.all(i.map(t => transformResultToClaimCondition(t, 0, this.contractWrapper.getProvider(), s.merkle, this.storage, e ? .withAllowList || !1)))
                    }
                }
                async canClaim(t, e, r) {
                    return r && (r = await resolveAddress(r)), 0 === (await this.getClaimIneligibilityReasons(t, e, r)).length
                }
                async getClaimIneligibilityReasons(t, e, r) {
                    let a, n;
                    let i = [];
                    if (void 0 === r) try {
                        r = await this.contractWrapper.getSignerAddress()
                    } catch (t) {
                        console.warn("failed to get signer address", t)
                    }
                    if (!r) return [n9.NoWallet];
                    let s = await resolveAddress(r);
                    try {
                        n = await this.getActive(t)
                    } catch (t) {
                        if (includesErrorMessage(t, "!CONDITION") || includesErrorMessage(t, "no active mint condition")) return i.push(n9.NoClaimConditionSet), i;
                        return i.push(n9.Unknown), i
                    }
                    if ("unlimited" !== n.availableSupply && v.O$.from(n.availableSupply).lt(e)) return i.push(n9.NotEnoughSupply), i;
                    let o = x.stripZeros(n.merkleRootHash),
                        c = o.length > 0,
                        l = null;
                    if (c) {
                        if (!(l = await this.getClaimerProofs(t, s)) && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) return i.push(n9.AddressNotAllowed), i;
                        if (l) try {
                            let r;
                            let n = await this.prepareClaim(t, e, !1, s);
                            if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                                if (a = await this.contractWrapper.read("getActiveClaimConditionId", [t]), [r] = await this.contractWrapper.read("verifyClaimMerkleProof", [a, s, t, e, n.proofs, n.maxClaimable]), !r) return i.push(n9.AddressNotAllowed), i
                            } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                                if ([r] = await this.contractWrapper.read("verifyClaimMerkleProof", [t, s, e, {
                                        proof: n.proofs,
                                        maxQuantityInAllowlist: n.maxClaimable
                                    }]), !r) return i.push(n9.AddressNotAllowed), i
                            } else this.isNewSinglePhaseDrop(this.contractWrapper) ? await this.contractWrapper.read("verifyClaim", [t, s, e, n.currencyAddress, n.price, {
                                proof: n.proofs,
                                quantityLimitPerWallet: n.maxClaimable,
                                currency: n.currencyAddressInProof,
                                pricePerToken: n.priceInProof
                            }]) : this.isNewMultiphaseDrop(this.contractWrapper) && (a = await this.contractWrapper.read("getActiveClaimConditionId", [t]), await this.contractWrapper.read("verifyClaim", [a, s, t, e, n.currencyAddress, n.price, {
                                proof: n.proofs,
                                quantityLimitPerWallet: n.maxClaimable,
                                currency: n.currencyAddressInProof,
                                pricePerToken: n.priceInProof
                            }]))
                        } catch (e) {
                            console.warn("Merkle proof verification failed:", "reason" in e ? e.reason : e);
                            let t = e.reason;
                            switch (t) {
                                case "!Qty":
                                    i.push(n9.OverMaxClaimablePerWallet);
                                    break;
                                case "!PriceOrCurrency":
                                    i.push(n9.WrongPriceOrCurrency);
                                    break;
                                case "!MaxSupply":
                                    i.push(n9.NotEnoughSupply);
                                    break;
                                case "cant claim yet":
                                    i.push(n9.ClaimPhaseNotStarted);
                                    break;
                                default:
                                    i.push(n9.AddressNotAllowed)
                            }
                            return i
                        }
                    }
                    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
                        let r = v.O$.from(0),
                            a = convertQuantityToBigNumber(n.maxClaimablePerWallet, 0);
                        try {
                            r = await this.getSupplyClaimedByWallet(t, s)
                        } catch (t) {}
                        if (l && (a = convertQuantityToBigNumber(l.maxClaimable, 0)), a.gt(0) && a.lt(r.add(e))) return i.push(n9.OverMaxClaimablePerWallet), i;
                        if ((!c || c && !l) && (a.lte(r) || a.eq(0))) return i.push(n9.AddressNotAllowed), i
                    }
                    let [d, p] = [v.O$.from(0), v.O$.from(0)];
                    this.isLegacyMultiPhaseDrop(this.contractWrapper) ? (a = await this.contractWrapper.read("getActiveClaimConditionId", [t]), [d, p] = await this.contractWrapper.read("getClaimTimestamp", [t, a, s])) : this.isLegacySinglePhaseDrop(this.contractWrapper) && ([d, p] = await this.contractWrapper.read("getClaimTimestamp", [t, s]));
                    let u = v.O$.from(Date.now()).div(1e3);
                    if (d.gt(0) && u.lt(p)) return p.eq(V.Bz) ? i.push(n9.AlreadyClaimed) : i.push(n9.WaitBeforeNextClaimTransaction), i;
                    if (n.price.gt(0) && isNode()) {
                        let t = n.price.mul(e),
                            r = this.contractWrapper.getProvider();
                        if (isNativeToken(n.currencyAddress)) {
                            let e = await r.getBalance(s);
                            e.lt(t) && i.push(n9.NotEnoughTokens)
                        } else {
                            let e = new ContractWrapper(r, n.currencyAddress, K, {}, this.storage),
                                a = await e.read("balanceOf", [s]);
                            a.lt(t) && i.push(n9.NotEnoughTokens)
                        }
                    }
                    return i
                }
                async getClaimerProofs(t, e, r) {
                    let a = await this.get(t, r),
                        n = a.merkleRoot,
                        i = x.stripZeros(n);
                    if (!(i.length > 0)) return null; {
                        let t = await this.metadata.get(),
                            r = await resolveAddress(e);
                        return await fetchSnapshotEntryForAddress(r, n.toString(), t.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion())
                    }
                }
                async getSupplyClaimedByWallet(t, e) {
                    let r = await resolveAddress(e);
                    if (this.isNewSinglePhaseDrop(this.contractWrapper)) return await this.contractWrapper.read("getSupplyClaimedByWallet", [t, r]);
                    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
                        let e = await this.contractWrapper.read("getActiveClaimConditionId", [t]);
                        return await this.contractWrapper.read("getSupplyClaimedByWallet", [t, e, r])
                    }
                    throw Error("This contract does not support the getSupplyClaimedByWallet function")
                }
                set = buildTransactionFunction((() => {
                    var t = this;
                    return async function(e, r) {
                        let a = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        return t.setBatch.prepare([{
                            tokenId: e,
                            claimConditions: r
                        }], a)
                    }
                })());
                setBatch = buildTransactionFunction((() => {
                    var t = this;
                    return async function(e) {
                        let r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            a = {},
                            n = await Promise.all(e.map(async e => {
                                let {
                                    tokenId: n,
                                    claimConditions: i
                                } = e, s = i;
                                if (t.isLegacySinglePhaseDrop(t.contractWrapper)) {
                                    if (r = !0, 0 === i.length) s = [{
                                        startTime: new Date(0),
                                        currencyAddress: I.d,
                                        price: 0,
                                        maxClaimableSupply: 0,
                                        maxClaimablePerWallet: 0,
                                        waitInSeconds: 0,
                                        merkleRootHash: x.hexZeroPad([0], 32),
                                        snapshot: []
                                    }];
                                    else if (i.length > 1) throw Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")
                                }(t.isNewSinglePhaseDrop(t.contractWrapper) || t.isNewMultiphaseDrop(t.contractWrapper)) && s.forEach(t => {
                                    if (t.snapshot && t.snapshot.length > 0 && (void 0 === t.maxClaimablePerWallet || "unlimited" === t.maxClaimablePerWallet)) throw Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
                                    if (t.snapshot && t.snapshot.length > 0 && t.maxClaimablePerWallet ? .toString() === "0" && 0 === t.snapshot.map(t => "string" == typeof t ? 0 : Number(t.maxClaimable ? .toString() || 0)).reduce((t, e) => t + e, 0)) throw Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")
                                });
                                let {
                                    snapshotInfos: o,
                                    sortedConditions: c
                                } = await processClaimConditionInputs(s, 0, t.contractWrapper.getProvider(), t.storage, t.getSnapshotFormatVersion());
                                return o.forEach(t => {
                                    a[t.merkleRoot] = t.snapshotUri
                                }), {
                                    tokenId: n,
                                    sortedConditions: c
                                }
                            })),
                            i = await t.metadata.get(),
                            s = [];
                        for (let t of Object.keys(i.merkle || {})) a[t] = i.merkle[t];
                        if (!X()(i.merkle, a)) {
                            let e = await t.metadata.parseInputMetadata({ ...i,
                                    merkle: a
                                }),
                                r = await t.metadata._parseAndUploadMetadata(e);
                            if (hasFunction("setContractURI", t.contractWrapper)) {
                                let e = new ContractEncoder(t.contractWrapper);
                                s.push(e.encode("setContractURI", [r]))
                            } else throw Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")
                        }
                        if (n.forEach(e => {
                                let {
                                    tokenId: a,
                                    sortedConditions: n
                                } = e, i = new ContractEncoder(t.contractWrapper);
                                if (t.isLegacySinglePhaseDrop(t.contractWrapper)) {
                                    let e = new ContractEncoder(t.contractWrapper);
                                    s.push(e.encode("setClaimConditions", [a, abstractContractModelToLegacy(n[0]), r]))
                                } else if (t.isLegacyMultiPhaseDrop(t.contractWrapper)) s.push(i.encode("setClaimConditions", [a, n.map(abstractContractModelToLegacy), r]));
                                else if (t.isNewSinglePhaseDrop(t.contractWrapper)) s.push(i.encode("setClaimConditions", [a, abstractContractModelToNew(n[0]), r]));
                                else if (t.isNewMultiphaseDrop(t.contractWrapper)) s.push(i.encode("setClaimConditions", [a, n.map(abstractContractModelToNew), r]));
                                else throw Error("Contract does not support claim conditions")
                            }), hasFunction("multicall", t.contractWrapper)) return Transaction.fromContractWrapper({
                            contractWrapper: t.contractWrapper,
                            method: "multicall",
                            args: [s]
                        });
                        throw Error("Contract does not support multicall")
                    }
                })());
                update = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.getAll(t),
                        n = await updateExistingClaimConditions(e, r, a);
                    return await this.set.prepare(t, n)
                });
                async prepareClaim(t, e, r, a) {
                    let n = await resolveAddress(a || await this.contractWrapper.getSignerAddress());
                    return prepareClaim(n, e, await this.getActive(t), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, r, this.getSnapshotFormatVersion())
                }
                async getClaimArguments(t, e, r, a) {
                    let n = await resolveAddress(e);
                    return this.isLegacyMultiPhaseDrop(this.contractWrapper) ? [n, t, r, a.currencyAddress, a.price, a.proofs, a.maxClaimable] : this.isLegacySinglePhaseDrop(this.contractWrapper) ? [n, t, r, a.currencyAddress, a.price, {
                        proof: a.proofs,
                        maxQuantityInAllowlist: a.maxClaimable
                    }, M.Y0("")] : [n, t, r, a.currencyAddress, a.price, {
                        proof: a.proofs,
                        quantityLimitPerWallet: a.maxClaimable,
                        pricePerToken: a.priceInProof,
                        currency: a.currencyAddressInProof
                    }, M.Y0("")]
                }
                async getClaimTransaction(t, e, r, a) {
                    if (a ? .pricePerToken) throw Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");
                    let n = await this.prepareClaim(e, r, a ? .checkERC20Allowance || !0);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "claim",
                        args: await this.getClaimArguments(e, t, r, n),
                        overrides: n.overrides
                    })
                }
                isNewSinglePhaseDrop(t) {
                    return detectContractFeature(t, "ERC1155ClaimConditionsV2")
                }
                isNewMultiphaseDrop(t) {
                    return detectContractFeature(t, "ERC1155ClaimPhasesV2")
                }
                isLegacySinglePhaseDrop(t) {
                    return detectContractFeature(t, "ERC1155ClaimConditionsV1")
                }
                isLegacyMultiPhaseDrop(t) {
                    return detectContractFeature(t, "ERC1155ClaimPhasesV1")
                }
                getSnapshotFormatVersion() {
                    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? n7.V1 : n7.V2
                }
            };
            let Erc20BatchMintable = class Erc20BatchMintable {
                featureName = rM.name;
                constructor(t, e) {
                    this.erc20 = t, this.contractWrapper = e
                }
                to = buildTransactionFunction(async t => {
                    let e = [],
                        r = new ContractEncoder(this.contractWrapper);
                    for (let a of t) e.push(r.encode("mintTo", [await resolveAddress(a.toAddress), await this.erc20.normalizeAmount(a.amount)]));
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [e]
                    })
                })
            };
            let Erc20Burnable = class Erc20Burnable {
                featureName = rI.name;
                constructor(t, e) {
                    this.erc20 = t, this.contractWrapper = e
                }
                tokens = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "burn",
                    args: [await this.erc20.normalizeAmount(t)]
                }));
                from = buildTransactionFunction(async (t, e) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "burnFrom",
                    args: [await resolveAddress(t), await this.erc20.normalizeAmount(e)]
                }))
            };
            let Erc20ClaimableWithConditions = class Erc20ClaimableWithConditions {
                featureName = rS.name;
                constructor(t, e, r) {
                    this.erc20 = t, this.contractWrapper = e, this.storage = r;
                    let a = new ContractMetadata(this.contractWrapper, ra, this.storage);
                    this.conditions = new DropClaimConditions(this.contractWrapper, a, this.storage)
                }
                to = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.erc20.normalizeAmount(e);
                    return await this.conditions.getClaimTransaction(t, a, r)
                })
            };
            let Erc20Droppable = class Erc20Droppable {
                constructor(t, e, r) {
                    this.erc20 = t, this.contractWrapper = e, this.storage = r, this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage)
                }
            };
            let Erc20Mintable = class Erc20Mintable {
                featureName = rR.name;
                constructor(t, e) {
                    this.erc20 = t, this.contractWrapper = e, this.batch = this.detectErc20BatchMintable()
                }
                to = buildTransactionFunction(async (t, e) => await this.getMintTransaction(t, e));
                async getMintTransaction(t, e) {
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "mintTo",
                        args: [await resolveAddress(t), await this.erc20.normalizeAmount(e)]
                    })
                }
                detectErc20BatchMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC20BatchMintable")) return new Erc20BatchMintable(this.erc20, this.contractWrapper)
                }
            };
            async function setErc20Allowance(t, e, r, a) {
                if (isNativeToken(r)) a.value = e;
                else {
                    let n = t.getSigner(),
                        i = t.getProvider(),
                        s = new ContractWrapper(n || i, r, K, t.options, t.storage),
                        o = await t.getSignerAddress(),
                        c = t.address,
                        l = await s.read("allowance", [o, c]);
                    return l.lt(e) && await s.sendTransaction("approve", [c, e]), a
                }
            }
            let Erc20SignatureMintable = class Erc20SignatureMintable {
                featureName = rx.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.roles = e
                }
                mint = buildTransactionFunction(async t => {
                    let e = t.payload,
                        r = t.signature,
                        a = await this.mapPayloadToContractStruct(e),
                        n = await this.contractWrapper.getCallOverrides();
                    return await setErc20Allowance(this.contractWrapper, v.O$.from(a.price), e.currencyAddress, n), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "mintWithSignature",
                        args: [a, r],
                        overrides: n
                    })
                });
                mintBatch = buildTransactionFunction(async t => {
                    let e = await Promise.all(t.map(async t => {
                            let e = await this.mapPayloadToContractStruct(t.payload),
                                r = t.signature,
                                a = t.payload.price;
                            if (v.O$.from(a).gt(0)) throw Error("Can only batch free mints. For mints with a price, use regular mint()");
                            return {
                                message: e,
                                signature: r
                            }
                        })),
                        r = new ContractEncoder(this.contractWrapper),
                        a = e.map(t => r.encode("mintWithSignature", [t.message, t.signature]));
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [a]
                    })
                });
                async verify(t) {
                    let e = t.payload,
                        r = t.signature,
                        a = await this.mapPayloadToContractStruct(e),
                        n = await this.contractWrapper.read("verify", [a, r]);
                    return n[0]
                }
                async generate(t) {
                    return (await this.generateBatch([t]))[0]
                }
                async generateBatch(t) {
                    await this.roles ? .verify(["minter"], await this.contractWrapper.getSignerAddress());
                    let e = await Promise.all(t.map(t => eV.parseAsync(t))),
                        r = await this.contractWrapper.getChainID(),
                        a = this.contractWrapper.getSigner();
                    (0, j.Z)(a, "No signer available");
                    let n = await this.contractWrapper.read("name", []);
                    return await Promise.all(e.map(async t => {
                        let e = await e_.parseAsync(t),
                            i = await this.contractWrapper.signTypedData(a, {
                                name: n,
                                version: "1",
                                chainId: r,
                                verifyingContract: this.contractWrapper.address
                            }, {
                                MintRequest: eQ
                            }, await this.mapPayloadToContractStruct(e));
                        return {
                            payload: e,
                            signature: i.toString()
                        }
                    }))
                }
                async mapPayloadToContractStruct(t) {
                    let e = await normalizePriceValue(this.contractWrapper.getProvider(), t.price, t.currencyAddress),
                        r = R.parseUnits(t.quantity, await this.contractWrapper.read("decimals", []));
                    return {
                        to: t.to,
                        primarySaleRecipient: t.primarySaleRecipient,
                        quantity: r,
                        price: e,
                        currency: t.currencyAddress,
                        validityEndTimestamp: t.mintEndTime,
                        validityStartTimestamp: t.mintStartTime,
                        uid: t.uid
                    }
                }
            };

            function assertEnabled(t, e) {
                if (!t) throw new ExtensionNotImplementedError(e);
                return t
            }
            async function normalizeAmount(t, e) {
                let r = await t.read("decimals", []);
                return R.parseUnits(C.A.parse(e), r)
            }
            let Erc20 = class Erc20 {
                featureName = rN.name;
                get chainId() {
                    return this._chainId
                }
                constructor(t, e, r) {
                    this.contractWrapper = t, this.storage = e, this.mintable = this.detectErc20Mintable(), this.burnable = this.detectErc20Burnable(), this.droppable = this.detectErc20Droppable(), this.signatureMintable = this.detectErc20SignatureMintable(), this._chainId = r
                }
                onNetworkUpdated(t) {
                    this.contractWrapper.updateSignerOrProvider(t)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async get() {
                    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress())
                }
                async balance() {
                    return await this.balanceOf(await this.contractWrapper.getSignerAddress())
                }
                async balanceOf(t) {
                    return this.getValue(await this.contractWrapper.read("balanceOf", [await resolveAddress(t)]))
                }
                async totalSupply() {
                    return await this.getValue(await this.contractWrapper.read("totalSupply", []))
                }
                async allowance(t) {
                    let [e, r] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(t)]);
                    return await this.allowanceOf(e, r)
                }
                async allowanceOf(t, e) {
                    let r = await Promise.all([resolveAddress(t), resolveAddress(e)]);
                    return await this.getValue(await this.contractWrapper.read("allowance", r))
                }
                transfer = buildTransactionFunction(async (t, e) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "transfer",
                    args: await Promise.all([resolveAddress(t), this.normalizeAmount(e)])
                }));
                transferFrom = buildTransactionFunction(async (t, e, r) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "transferFrom",
                    args: await Promise.all([resolveAddress(t), resolveAddress(e), this.normalizeAmount(r)])
                }));
                setAllowance = buildTransactionFunction(async (t, e) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "approve",
                    args: await Promise.all([resolveAddress(t), this.normalizeAmount(e)])
                }));
                transferBatch = buildTransactionFunction(async t => {
                    let e = new ContractEncoder(this.contractWrapper),
                        r = (await Promise.all(t.map(t => Promise.all([this.normalizeAmount(t.amount), resolveAddress(t.toAddress)])))).map(t => {
                            let [r, a] = t;
                            return e.encode("transfer", [a, r])
                        });
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [r]
                    })
                });
                mint = buildTransactionFunction(async t => this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), t));
                mintTo = buildTransactionFunction(async (t, e) => assertEnabled(this.mintable, rR).to.prepare(t, e));
                async getMintTransaction(t, e) {
                    return assertEnabled(this.mintable, rR).getMintTransaction(t, e)
                }
                mintBatchTo = buildTransactionFunction(async t => assertEnabled(this.mintable ? .batch, rM).to.prepare(t));
                burn = buildTransactionFunction(async t => assertEnabled(this.burnable, rI).tokens.prepare(t));
                burnFrom = buildTransactionFunction(async (t, e) => assertEnabled(this.burnable, rI).from.prepare(t, e));
                claim = buildTransactionFunction(async (t, e) => this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), t, e));
                claimTo = buildTransactionFunction(async (t, e, r) => assertEnabled(this.droppable ? .claim, rS).to.prepare(t, e, r));
                get claimConditions() {
                    return assertEnabled(this.droppable ? .claim, rS).conditions
                }
                get signature() {
                    return assertEnabled(this.signatureMintable, rx)
                }
                async normalizeAmount(t) {
                    return normalizeAmount(this.contractWrapper, t)
                }
                async getValue(t) {
                    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), v.O$.from(t))
                }
                detectErc20Mintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC20")) return new Erc20Mintable(this, this.contractWrapper)
                }
                detectErc20Burnable() {
                    if (detectContractFeature(this.contractWrapper, "ERC20Burnable")) return new Erc20Burnable(this, this.contractWrapper)
                }
                detectErc20Droppable() {
                    if (detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV2")) return new Erc20Droppable(this, this.contractWrapper, this.storage)
                }
                detectErc20SignatureMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC20SignatureMintable")) return new Erc20SignatureMintable(this.contractWrapper)
                }
            };
            let Erc721BatchMintable = class Erc721BatchMintable {
                featureName = rG.name;
                constructor(t, e, r) {
                    this.erc721 = t, this.contractWrapper = e, this.storage = r
                }
                to = buildTransactionFunction(async (t, e) => {
                    let [r, a] = await Promise.all([uploadOrExtractURIs(e, this.storage), resolveAddress(t)]), n = new ContractEncoder(this.contractWrapper), i = r.map(t => n.encode("mintTo", [a, t]));
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [i],
                        parse: t => {
                            let r = this.contractWrapper.parseLogs("TokensMinted", t.logs);
                            if (0 === r.length || r.length < e.length) throw Error("TokenMinted event not found, minting failed");
                            return r.map(e => {
                                let r = e.args.tokenIdMinted;
                                return {
                                    id: r,
                                    receipt: t,
                                    data: () => this.erc721.get(r)
                                }
                            })
                        }
                    })
                })
            };
            let Erc721ClaimableWithConditions = class Erc721ClaimableWithConditions {
                featureName = r$.name;
                constructor(t, e, r) {
                    this.erc721 = t, this.contractWrapper = e, this.storage = r;
                    let a = new ContractMetadata(this.contractWrapper, ra, this.storage);
                    this.conditions = new DropClaimConditions(this.contractWrapper, a, this.storage)
                }
                to = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.conditions.getClaimTransaction(t, e, r);
                    return a.setParse(t => {
                        let r = this.contractWrapper.parseLogs("TokensClaimed", t ? .logs),
                            a = r[0].args.startTokenId,
                            n = a.add(e),
                            i = [];
                        for (let e = a; e.lt(n); e = e.add(1)) i.push({
                            id: e,
                            receipt: t,
                            data: () => this.erc721.get(e)
                        });
                        return i
                    }), a
                })
            };
            async function calculateClaimCost(t, e, r, a, n) {
                let i = {},
                    s = a || eT,
                    o = await normalizePriceValue(t.getProvider(), e, s),
                    c = o.mul(r);
                return c.gt(0) && (s === eT ? i = {
                    value: c
                } : s !== eT && n && await approveErc20Allowance(t, s, c, r, 0)), i
            }
            let Erc721Claimable = class Erc721Claimable {
                featureName = r_.name;
                constructor(t, e) {
                    this.erc721 = t, this.contractWrapper = e
                }
                async getClaimTransaction(t, e, r) {
                    let a = {};
                    return r && r.pricePerToken && (a = await calculateClaimCost(this.contractWrapper, r.pricePerToken, e, r.currencyAddress, r.checkERC20Allowance)), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "claim",
                        args: [t, e],
                        overrides: a
                    })
                }
                to = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.getClaimTransaction(t, e, r);
                    return a.setParse(t => {
                        let r = this.contractWrapper.parseLogs("TokensClaimed", t ? .logs),
                            a = r[0].args.startTokenId,
                            n = a.add(e),
                            i = [];
                        for (let e = a; e.lt(n); e = e.add(1)) i.push({
                            id: e,
                            receipt: t,
                            data: () => this.erc721.get(e)
                        });
                        return i
                    }), a
                })
            };
            let Erc721LazyMintable = class Erc721LazyMintable {
                featureName = rq.name;
                constructor(t, e, r) {
                    this.erc721 = t, this.contractWrapper = e, this.storage = r, this.revealer = this.detectErc721Revealable()
                }
                lazyMint = buildTransactionFunction(async (t, e) => {
                    let r = await this.erc721.nextTokenIdToMint(),
                        a = await uploadOrExtractURIs(t, this.storage, r.toNumber(), e),
                        n = getBaseUriFromBatch(a);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "lazyMint",
                        args: [a.length, n.endsWith("/") ? n : `${n}/`, M.Y0("")],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensLazyMinted", t ? .logs),
                                r = e[0].args.startTokenId,
                                a = e[0].args.endTokenId,
                                n = [];
                            for (let e = r; e.lte(a); e = e.add(1)) n.push({
                                id: e,
                                receipt: t,
                                data: () => this.erc721.getTokenMetadata(e)
                            });
                            return n
                        }
                    })
                });
                detectErc721Revealable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721Revealable")) return new DelayedReveal(this.contractWrapper, this.storage, rB.name, () => this.erc721.nextTokenIdToMint())
                }
            };
            let Erc721Mintable = class Erc721Mintable {
                featureName = rH.name;
                constructor(t, e, r) {
                    this.erc721 = t, this.contractWrapper = e, this.storage = r, this.batch = this.detectErc721BatchMintable()
                }
                to = buildTransactionFunction(async (t, e) => {
                    let [r, a] = await Promise.all([uploadOrExtractURI(e, this.storage), resolveAddress(t)]);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "mintTo",
                        args: [a, r],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("Transfer", t ? .logs);
                            if (0 === e.length) throw Error("TransferEvent event not found");
                            let r = e[0].args.tokenId;
                            return {
                                id: r,
                                receipt: t,
                                data: () => this.erc721.get(r)
                            }
                        }
                    })
                });
                async getMintTransaction(t, e) {
                    return this.to.prepare(await resolveAddress(t), e)
                }
                detectErc721BatchMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721BatchMintable")) return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage)
                }
            };
            let Erc721Enumerable = class Erc721Enumerable {
                featureName = rK.name;
                constructor(t, e) {
                    this.erc721 = t, this.contractWrapper = e
                }
                async all(t) {
                    let e = await this.tokenIds(t);
                    return await Promise.all(e.map(t => this.erc721.get(t.toString())))
                }
                async tokenIds(t) {
                    let e = await resolveAddress(t || await this.contractWrapper.getSignerAddress()),
                        r = await this.contractWrapper.read("balanceOf", [e]),
                        a = Array.from(Array(r.toNumber()).keys());
                    return await Promise.all(a.map(t => this.contractWrapper.read("tokenOfOwnerByIndex", [e, t])))
                }
            };
            let Erc721AQueryable = class Erc721AQueryable {
                featureName = rQ.name;
                constructor(t, e) {
                    this.erc721 = t, this.contractWrapper = e
                }
                async all(t) {
                    let e = await this.tokenIds(t);
                    return await Promise.all(e.map(t => this.erc721.get(t.toString())))
                }
                async tokenIds(t) {
                    let e = await resolveAddress(t || await this.contractWrapper.getSignerAddress());
                    return await this.contractWrapper.read("tokensOfOwner", [e])
                }
            };
            let Erc721Supply = class Erc721Supply {
                featureName = rY.name;
                constructor(t, e) {
                    this.erc721 = t, this.contractWrapper = e, this.owned = this.detectErc721Owned()
                }
                async all(t) {
                    let e = v.O$.from(0);
                    hasFunction("startTokenId", this.contractWrapper) && (e = await this.contractWrapper.read("startTokenId", []));
                    let r = v.O$.from(t ? .start || 0).add(e).toNumber(),
                        a = v.O$.from(t ? .count || C.D).toNumber(),
                        n = await this.erc721.nextTokenIdToMint(),
                        i = Math.min(n.add(e).toNumber(), r + a);
                    return await Promise.all([...Array(i - r).keys()].map(t => this.erc721.get((r + t).toString())))
                }
                async allOwners() {
                    let t;
                    let e = v.O$.from(0);
                    hasFunction("startTokenId", this.contractWrapper) && (e = await this.contractWrapper.read("startTokenId", []));
                    try {
                        t = await this.erc721.totalClaimedSupply()
                    } catch (e) {
                        t = await this.totalCount()
                    }
                    t = t.add(e);
                    let r = [...Array(t.toNumber()).keys()],
                        a = await Promise.all(r.map(t => this.erc721.ownerOf(t).catch(() => I.d)));
                    return r.map(t => ({
                        tokenId: t,
                        owner: a[t]
                    })).filter(t => t.owner !== I.d)
                }
                async totalCount() {
                    return await this.erc721.nextTokenIdToMint()
                }
                async totalCirculatingSupply() {
                    return await this.contractWrapper.read("totalSupply", [])
                }
                detectErc721Owned() {
                    return detectContractFeature(this.contractWrapper, "ERC721Enumerable") ? new Erc721Enumerable(this.erc721, this.contractWrapper) : detectContractFeature(this.contractWrapper, "ERC721AQueryable") ? new Erc721AQueryable(this.erc721, this.contractWrapper) : void 0
                }
            };
            let it = eU.extend({
                tierPriority: A.z.array(A.z.string()),
                royaltyRecipient: eA.default(I.d),
                royaltyBps: C.a.default(0),
                quantity: ed.default(1)
            });
            let Erc721TieredDrop = class Erc721TieredDrop {
                featureName = rL.name;
                constructor(t, e, r) {
                    this.erc721 = t, this.contractWrapper = e, this.storage = r
                }
                async getMetadataInTier(t) {
                    let e = await this.contractWrapper.read("getMetadataForAllTiers", []),
                        r = e.find(e => e.tier === t);
                    if (!r) throw Error("Tier not found in contract.");
                    let a = await Promise.all(r.ranges.map((t, e) => {
                        let a = [],
                            n = r.baseURIs[e];
                        for (let e = t.startIdInclusive.toNumber(); e < t.endIdNonInclusive.toNumber(); e++) {
                            let t = n.endsWith("/") ? `${n}${e}` : `${n}/${e}`,
                                r = this.storage.downloadJSON(t);
                            a.push(r)
                        }
                        return a
                    }).flat());
                    return a
                }
                async getTokensInTier(t) {
                    let e = await this.contractWrapper.read("getTokensInTierLen", []);
                    if (e.eq(0)) return [];
                    let r = await this.contractWrapper.read("getTokensInTier", [t, 0, e]),
                        a = await Promise.all(r.map(t => {
                            let e = [];
                            for (let r = t.startIdInclusive.toNumber(); r < t.endIdNonInclusive.toNumber(); r++) e.push(this.erc721.get(r));
                            return e
                        }).flat());
                    return a
                }
                createBatchWithTier = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.erc721.nextTokenIdToMint(),
                        n = await uploadOrExtractURIs(t, this.storage, a.toNumber(), r),
                        i = getBaseUriFromBatch(n);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "lazyMint",
                        args: [n.length, i.endsWith("/") ? i : `${i}/`, e, M.Y0("")],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensLazyMinted", t ? .logs),
                                r = e[0].args[1],
                                a = e[0].args[2],
                                n = [];
                            for (let e = r; e.lte(a); e = e.add(1)) n.push({
                                id: e,
                                receipt: t,
                                data: () => this.erc721.getTokenMetadata(e)
                            });
                            return n
                        }
                    })
                });
                createDelayedRevealBatchWithTier = buildTransactionFunction(async (t, e, r, a, n) => {
                    if (!r) throw Error("Password is required");
                    let i = await this.storage.uploadBatch([C.b.parse(t)], {
                            rewriteFileNames: {
                                fileStartNumber: 0
                            }
                        }),
                        s = getBaseUriFromBatch(i),
                        o = await this.erc721.nextTokenIdToMint(),
                        c = await this.storage.uploadBatch(e.map(t => C.b.parse(t)), {
                            onProgress: n ? .onProgress,
                            rewriteFileNames: {
                                fileStartNumber: o.toNumber()
                            }
                        }),
                        l = getBaseUriFromBatch(c),
                        d = await this.contractWrapper.read("getBaseURICount", []),
                        p = await this.contractWrapper.getChainID(),
                        u = L.keccak256(["string", "uint256", "uint256", "address"], [r, p, d, this.contractWrapper.address]),
                        f = await this.contractWrapper.read("encryptDecrypt", [M.Y0(l), u]),
                        m = L.keccak256(["bytes", "bytes", "uint256"], [M.Y0(l), u, p]),
                        h = $.$.encode(["bytes", "bytes32"], [f, m]);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "lazyMint",
                        args: [c.length, s.endsWith("/") ? s : `${s}/`, a, h],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensLazyMinted", t ? .logs),
                                r = e[0].args[1],
                                a = e[0].args[2],
                                n = [];
                            for (let e = r; e.lte(a); e = e.add(1)) n.push({
                                id: e,
                                receipt: t,
                                data: () => this.erc721.getTokenMetadata(e)
                            });
                            return n
                        }
                    })
                });
                reveal = buildTransactionFunction(async (t, e) => {
                    if (!e) throw Error("Password is required");
                    let r = await this.contractWrapper.getChainID(),
                        a = L.keccak256(["string", "uint256", "uint256", "address"], [e, r, t, this.contractWrapper.address]);
                    try {
                        let e = await this.contractWrapper.callStatic().reveal(t, a);
                        if (!e.includes("://") || !e.endsWith("/")) throw Error("invalid password")
                    } catch (t) {
                        throw Error("invalid password")
                    }
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "reveal",
                        args: [t, a]
                    })
                });
                async generate(t) {
                    let [e] = await this.generateBatch([t]);
                    return e
                }
                async generateBatch(t) {
                    let e = await Promise.all(t.map(t => it.parseAsync(t))),
                        r = await this.contractWrapper.getChainID(),
                        a = this.contractWrapper.getSigner();
                    return (0, j.Z)(a, "No signer available"), await Promise.all(e.map(async t => {
                        let e = await this.contractWrapper.signTypedData(a, {
                            name: "SignatureAction",
                            version: "1",
                            chainId: r,
                            verifyingContract: this.contractWrapper.address
                        }, {
                            GenericRequest: e1
                        }, await this.mapPayloadToContractStruct(t));
                        return {
                            payload: t,
                            signature: e.toString()
                        }
                    }))
                }
                async verify(t) {
                    let e = await this.mapPayloadToContractStruct(t.payload),
                        r = await this.contractWrapper.read("verify", [e, t.signature]);
                    return r[0]
                }
                async claimWithSignature(t) {
                    let e = await this.mapPayloadToContractStruct(t.payload),
                        r = await normalizePriceValue(this.contractWrapper.getProvider(), t.payload.price, t.payload.currencyAddress),
                        a = await this.contractWrapper.getCallOverrides();
                    await setErc20Allowance(this.contractWrapper, r, t.payload.currencyAddress, a);
                    let n = await this.contractWrapper.sendTransaction("claimWithSignature", [e, t.signature], a),
                        i = this.contractWrapper.parseLogs("TokensClaimed", n ? .logs),
                        s = i[0].args.startTokenId,
                        o = s.add(i[0].args.quantityClaimed),
                        c = [];
                    for (let t = s; t.lt(o); t = t.add(1)) c.push({
                        id: t,
                        receipt: n,
                        data: () => this.erc721.get(t)
                    });
                    return c
                }
                async mapPayloadToContractStruct(t) {
                    let e = await normalizePriceValue(this.contractWrapper.getProvider(), t.price, t.currencyAddress),
                        r = $.$.encode(["string[]", "address", "address", "uint256", "address", "uint256", "uint256", "address"], [t.tierPriority, t.to, t.royaltyRecipient, t.royaltyBps, t.primarySaleRecipient, t.quantity, e, t.currencyAddress]);
                    return {
                        uid: t.uid,
                        validityStartTimestamp: t.mintStartTime,
                        validityEndTimestamp: t.mintEndTime,
                        data: r
                    }
                }
            };
            let Erc721Burnable = class Erc721Burnable {
                featureName = rD.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                token = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "burn",
                    args: [t]
                }))
            };

            function toWei(t) {
                return R.parseEther(C.A.parse(t))
            }
            let Erc721ClaimableZora = class Erc721ClaimableZora {
                featureName = rj.name;
                constructor(t, e) {
                    this.erc721 = t, this.contractWrapper = e
                }
                to = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.contractWrapper.getSigner() ? .getAddress();
                    if (t !== a) throw Error("Zora Drop: Destination address must match connected wallet address");
                    if (r ? .pricePerToken) throw Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");
                    let n = await this.getSaleDetails(),
                        i = n.publicSalePrice,
                        s = toWei("0.000777"),
                        o = v.O$.from(i).add(s).mul(e),
                        c = Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "purchase",
                            args: [e],
                            overrides: {
                                value: o
                            }
                        });
                    return c.setParse(t => {
                        let r = this.contractWrapper.parseLogs("Sale", t ? .logs),
                            a = r[0].args.firstPurchasedTokenId,
                            n = a.add(e),
                            i = [];
                        for (let e = a; e.lt(n); e = e.add(1)) i.push({
                            id: e,
                            receipt: t,
                            data: () => this.erc721.get(e)
                        });
                        return i
                    }), c
                });
                async getSaleDetails() {
                    return this.contractWrapper.read("saleDetails", [])
                }
            };
            let Erc721LoyaltyCard = class Erc721LoyaltyCard {
                featureName = r0.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                cancel = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "cancel",
                    args: [t]
                }));
                revoke = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "revoke",
                    args: [t]
                }))
            };
            let Erc721UpdatableMetadata = class Erc721UpdatableMetadata {
                featureName = r1.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e
                }
                update = buildTransactionFunction(async (t, e) => {
                    let r = await uploadOrExtractURI(e, this.storage);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setTokenURI",
                        args: [t, r]
                    })
                })
            };
            let Erc721SharedMetadata = class Erc721SharedMetadata {
                featureName = rX.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e
                }
                async get() {
                    let t = await this.contractWrapper.read("sharedMetadata", []);
                    if (!t.every(t => "" === t)) return {
                        name: t.name,
                        description: t.description,
                        image: t.imageURI,
                        animation_url: t.animationURI
                    }
                }
                set = buildTransactionFunction(async t => {
                    let e = C.c.parse(t);
                    e.description = this.sanitizeJSONString(e.description);
                    let r = [];
                    (0, G.XT)(e.image) ? r.push(this.storage.upload(e.image)): "string" == typeof e.image ? r.push(Promise.resolve(e.image)) : r.push(Promise.resolve(void 0)), (0, G.XT)(e.animation_url) ? r.push(this.storage.upload(e.animation_url)) : "string" == typeof e.animation_url ? r.push(Promise.resolve(e.animation_url)) : r.push(Promise.resolve(void 0));
                    let [a, n] = await Promise.all(r);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setSharedMetadata",
                        args: [{
                            name: `${e.name||""}`,
                            description: e.description || "",
                            imageURI: a || "",
                            animationURI: n || ""
                        }]
                    })
                });
                sanitizeJSONString(t) {
                    if (!t) return t;
                    let e = JSON.stringify(t);
                    return e.slice(1, e.length - 1)
                }
            };
            let Erc721WithQuantitySignatureMintable = class Erc721WithQuantitySignatureMintable {
                featureName = rZ.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e
                }
                mint = buildTransactionFunction(async t => {
                    let e = t.payload,
                        r = t.signature,
                        a = await this.contractWrapper.getCallOverrides(),
                        parse = t => {
                            let e = this.contractWrapper.parseLogs("TokensMintedWithSignature", t.logs);
                            if (0 === e.length) throw Error("No MintWithSignature event found");
                            let r = e[0].args.tokenIdMinted;
                            return {
                                id: r,
                                receipt: t
                            }
                        };
                    if (await this.isLegacyNFTContract()) {
                        let t = await this.mapLegacyPayloadToContractStruct(e),
                            n = t.price;
                        return await setErc20Allowance(this.contractWrapper, n, e.currencyAddress, a), Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "mintWithSignature",
                            args: [t, r],
                            overrides: a,
                            parse
                        })
                    } {
                        let t = await this.mapPayloadToContractStruct(e),
                            n = t.pricePerToken.mul(t.quantity);
                        return await setErc20Allowance(this.contractWrapper, n, e.currencyAddress, a), Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "mintWithSignature",
                            args: [t, r],
                            overrides: a,
                            parse
                        })
                    }
                });
                mintBatch = buildTransactionFunction(async t => {
                    let e = await this.isLegacyNFTContract(),
                        r = (await Promise.all(t.map(t => e ? this.mapLegacyPayloadToContractStruct(t.payload) : this.mapPayloadToContractStruct(t.payload)))).map((e, r) => {
                            let a = t[r],
                                n = a.signature,
                                i = a.payload.price;
                            if (v.O$.from(i).gt(0)) throw Error("Can only batch free mints. For mints with a price, use regular mint()");
                            return {
                                message: e,
                                signature: n
                            }
                        }),
                        a = new ContractEncoder(this.contractWrapper),
                        n = r.map(t => a.encode("mintWithSignature", [t.message, t.signature]));
                    if (hasFunction("multicall", this.contractWrapper)) return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [n],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensMintedWithSignature", t.logs);
                            if (0 === e.length) throw Error("No MintWithSignature event found");
                            return e.map(e => ({
                                id: e.args.tokenIdMinted,
                                receipt: t
                            }))
                        }
                    });
                    throw Error("Multicall not available on this contract!")
                });
                async verify(t) {
                    let e;
                    let r = await this.isLegacyNFTContract(),
                        a = t.payload,
                        n = t.signature;
                    return e = r ? await this.mapLegacyPayloadToContractStruct(a) : await this.mapPayloadToContractStruct(a), (await this.contractWrapper.read("verify", [e, n]))[0]
                }
                async generate(t) {
                    return (await this.generateBatch([t]))[0]
                }
                async generateBatch(t) {
                    let e = await this.isLegacyNFTContract(),
                        r = await Promise.all(t.map(t => eJ.parseAsync(t))),
                        a = r.map(t => t.metadata),
                        n = await uploadOrExtractURIs(a, this.storage),
                        i = await this.contractWrapper.getChainID(),
                        s = this.contractWrapper.getSigner();
                    return (0, j.Z)(s, "No signer available"), await Promise.all(r.map(async (t, r) => {
                        let a;
                        let o = n[r],
                            c = await eK.parseAsync({ ...t,
                                uri: o
                            });
                        return a = e ? await this.contractWrapper.signTypedData(s, {
                            name: "TokenERC721",
                            version: "1",
                            chainId: i,
                            verifyingContract: this.contractWrapper.address
                        }, {
                            MintRequest: eY
                        }, await this.mapLegacyPayloadToContractStruct(c)) : await this.contractWrapper.signTypedData(s, {
                            name: "SignatureMintERC721",
                            version: "1",
                            chainId: i,
                            verifyingContract: await this.contractWrapper.address
                        }, {
                            MintRequest: e0
                        }, await this.mapPayloadToContractStruct(c)), {
                            payload: c,
                            signature: a.toString()
                        }
                    }))
                }
                async mapPayloadToContractStruct(t) {
                    let e = await normalizePriceValue(this.contractWrapper.getProvider(), t.price, t.currencyAddress);
                    return {
                        to: t.to,
                        royaltyRecipient: t.royaltyRecipient,
                        royaltyBps: t.royaltyBps,
                        primarySaleRecipient: t.primarySaleRecipient,
                        uri: t.uri,
                        quantity: t.quantity,
                        pricePerToken: e,
                        currency: t.currencyAddress,
                        validityStartTimestamp: t.mintStartTime,
                        validityEndTimestamp: t.mintEndTime,
                        uid: t.uid
                    }
                }
                async mapLegacyPayloadToContractStruct(t) {
                    let e = await normalizePriceValue(this.contractWrapper.getProvider(), t.price, t.currencyAddress);
                    return {
                        to: t.to,
                        price: e,
                        uri: t.uri,
                        currency: t.currencyAddress,
                        validityEndTimestamp: t.mintEndTime,
                        validityStartTimestamp: t.mintStartTime,
                        uid: t.uid,
                        royaltyRecipient: t.royaltyRecipient,
                        royaltyBps: t.royaltyBps,
                        primarySaleRecipient: t.primarySaleRecipient
                    }
                }
                async isLegacyNFTContract() {
                    return detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1")
                }
            };
            let Erc721 = class Erc721 {
                featureName = r2.name;
                get chainId() {
                    return this._chainId
                }
                constructor(t, e, r) {
                    this.contractWrapper = t, this.storage = e, this.query = this.detectErc721Enumerable(), this.mintable = this.detectErc721Mintable(), this.burnable = this.detectErc721Burnable(), this.lazyMintable = this.detectErc721LazyMintable(), this.tieredDropable = this.detectErc721TieredDrop(), this.signatureMintable = this.detectErc721SignatureMintable(), this.claimWithConditions = this.detectErc721ClaimableWithConditions(), this.claimCustom = this.detectErc721Claimable(), this.claimZora = this.detectErc721ClaimableZora(), this.erc721SharedMetadata = this.detectErc721SharedMetadata(), this.loyaltyCard = this.detectErc721LoyaltyCard(), this.updatableMetadata = this.detectErc721UpdatableMetadata(), this._chainId = r
                }
                onNetworkUpdated(t) {
                    this.contractWrapper.updateSignerOrProvider(t)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async get(t) {
                    let [e, r] = await Promise.all([this.ownerOf(t).catch(() => I.d), this.getTokenMetadata(t).catch(() => ({
                        id: t.toString(),
                        uri: "",
                        ...n3
                    }))]);
                    return {
                        owner: e,
                        metadata: r,
                        type: "ERC721",
                        supply: "1"
                    }
                }
                async ownerOf(t) {
                    return await this.contractWrapper.read("ownerOf", [t])
                }
                async balanceOf(t) {
                    return await this.contractWrapper.read("balanceOf", [await resolveAddress(t)])
                }
                async balance() {
                    return await this.balanceOf(await this.contractWrapper.getSignerAddress())
                }
                async isApproved(t, e) {
                    let [r, a] = await Promise.all([resolveAddress(t), resolveAddress(e)]);
                    return await this.contractWrapper.read("isApprovedForAll", [r, a])
                }
                transfer = buildTransactionFunction(async (t, e) => {
                    let [r, a] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(t)]);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "transferFrom(address,address,uint256)",
                        args: [r, a, e]
                    })
                });
                transferFrom = buildTransactionFunction(async (t, e, r) => {
                    let [a, n] = await Promise.all([resolveAddress(t), resolveAddress(e)]);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "transferFrom(address,address,uint256)",
                        args: [a, n, r]
                    })
                });
                setApprovalForAll = buildTransactionFunction(async (t, e) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "setApprovalForAll",
                    args: [await resolveAddress(t), e]
                }));
                setApprovalForToken = buildTransactionFunction(async (t, e) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "approve",
                    args: [await resolveAddress(t), e]
                }));
                async getAll(t) {
                    return assertEnabled(this.query, rY).all(t)
                }
                async getAllOwners() {
                    return assertEnabled(this.query, rY).allOwners()
                }
                async totalCount() {
                    return this.nextTokenIdToMint()
                }
                async totalCirculatingSupply() {
                    return assertEnabled(this.query, rY).totalCirculatingSupply()
                }
                async getOwned(t) {
                    if (t && (t = await resolveAddress(t)), this.query ? .owned) return this.query.owned.all(t); {
                        let [e, r] = await Promise.all([t || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);
                        return await Promise.all((r || []).filter(t => e ? .toLowerCase() === t.owner ? .toLowerCase()).map(t => this.get(t.tokenId)))
                    }
                }
                async getOwnedTokenIds(t) {
                    if (t && (t = await resolveAddress(t)), this.query ? .owned) return this.query.owned.tokenIds(t); {
                        let [e, r] = await Promise.all([t || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);
                        return (r || []).filter(t => e ? .toLowerCase() === t.owner ? .toLowerCase()).map(t => v.O$.from(t.tokenId))
                    }
                }
                mint = buildTransactionFunction(async t => this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), t));
                mintTo = buildTransactionFunction(async (t, e) => assertEnabled(this.mintable, rH).to.prepare(t, e));
                async getMintTransaction(t, e) {
                    return this.mintTo.prepare(t, e)
                }
                mintBatch = buildTransactionFunction(async t => this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), t));
                mintBatchTo = buildTransactionFunction(async (t, e) => assertEnabled(this.mintable ? .batch, rG).to.prepare(t, e));
                burn = buildTransactionFunction(async t => assertEnabled(this.burnable, rD).token.prepare(t));
                cancel = buildTransactionFunction(async t => assertEnabled(this.loyaltyCard, r0).cancel.prepare(t));
                revoke = buildTransactionFunction(async t => assertEnabled(this.loyaltyCard, r0).revoke.prepare(t));
                lazyMint = buildTransactionFunction(async (t, e) => assertEnabled(this.lazyMintable, rq).lazyMint.prepare(t, e));
                update = buildTransactionFunction(async (t, e) => assertEnabled(this.updatableMetadata, r1).update.prepare(t, e));
                claim = buildTransactionFunction(async (t, e) => this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), t, e));
                claimTo = buildTransactionFunction(async (t, e, r) => {
                    let a = this.claimWithConditions,
                        n = this.claimCustom,
                        i = this.claimZora;
                    if (a) return a.to.prepare(t, e, r);
                    if (n) return n.to.prepare(t, e, r);
                    if (i) return i.to.prepare(t, e, r);
                    throw new ExtensionNotImplementedError(r_)
                });
                async getClaimTransaction(t, e, r) {
                    let a = this.claimWithConditions,
                        n = this.claimCustom;
                    if (a) return a.conditions.getClaimTransaction(t, e, r);
                    if (n) return n.getClaimTransaction(t, e, r);
                    throw new ExtensionNotImplementedError(r_)
                }
                async totalClaimedSupply() {
                    let t = this.contractWrapper;
                    if (hasFunction("totalMinted", t)) return this.contractWrapper.read("totalMinted", []);
                    if (hasFunction("nextTokenIdToClaim", t)) return this.contractWrapper.read("nextTokenIdToClaim", []);
                    throw Error("No function found on contract to get total claimed supply")
                }
                async totalUnclaimedSupply() {
                    let [t, e] = await Promise.all([this.nextTokenIdToMint(), this.totalClaimedSupply()]);
                    return t.sub(e)
                }
                get claimConditions() {
                    return assertEnabled(this.claimWithConditions, r$).conditions
                }
                get tieredDrop() {
                    return assertEnabled(this.tieredDropable, rL)
                }
                get signature() {
                    return assertEnabled(this.signatureMintable, rZ)
                }
                get revealer() {
                    return assertEnabled(this.lazyMintable ? .revealer, rB)
                }
                get sharedMetadata() {
                    return assertEnabled(this.erc721SharedMetadata, rX)
                }
                async getTokenMetadata(t) {
                    let e = await this.contractWrapper.read("tokenURI", [t]);
                    if (!e) throw new NotFoundError;
                    return fetchTokenMetadata(t, e, this.storage)
                }
                async nextTokenIdToMint() {
                    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
                        let t = await this.contractWrapper.read("nextTokenIdToMint", []);
                        return hasFunction("startTokenId", this.contractWrapper) && (t = t.sub(await this.contractWrapper.read("startTokenId", []))), t
                    }
                    if (hasFunction("totalSupply", this.contractWrapper)) return await this.contractWrapper.read("totalSupply", []);
                    throw Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")
                }
                detectErc721Enumerable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721Supply") || hasFunction("nextTokenIdToMint", this.contractWrapper)) return new Erc721Supply(this, this.contractWrapper)
                }
                detectErc721Mintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721Mintable")) return new Erc721Mintable(this, this.contractWrapper, this.storage)
                }
                detectErc721Burnable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721Burnable")) return new Erc721Burnable(this.contractWrapper)
                }
                detectErc721LazyMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721LazyMintable")) return new Erc721LazyMintable(this, this.contractWrapper, this.storage)
                }
                detectErc721TieredDrop() {
                    if (detectContractFeature(this.contractWrapper, "ERC721TieredDrop")) return new Erc721TieredDrop(this, this.contractWrapper, this.storage)
                }
                detectErc721SignatureMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1") || detectContractFeature(this.contractWrapper, "ERC721SignatureMintV2")) return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage)
                }
                detectErc721ClaimableWithConditions() {
                    if (detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV2")) return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage)
                }
                detectErc721Claimable() {
                    if (detectContractFeature(this.contractWrapper, "ERC721ClaimCustom")) return new Erc721Claimable(this, this.contractWrapper)
                }
                detectErc721ClaimableZora() {
                    if (detectContractFeature(this.contractWrapper, "ERC721ClaimZora")) return new Erc721ClaimableZora(this, this.contractWrapper)
                }
                detectErc721SharedMetadata() {
                    if (detectContractFeature(this.contractWrapper, "ERC721SharedMetadata")) return new Erc721SharedMetadata(this.contractWrapper, this.storage)
                }
                detectErc721LoyaltyCard() {
                    if (detectContractFeature(this.contractWrapper, "ERC721LoyaltyCard")) return new Erc721LoyaltyCard(this.contractWrapper)
                }
                detectErc721UpdatableMetadata() {
                    if (detectContractFeature(this.contractWrapper, "ERC721UpdatableMetadata")) return new Erc721UpdatableMetadata(this.contractWrapper, this.storage)
                }
            };
            let Erc1155BatchMintable = class Erc1155BatchMintable {
                featureName = aa.name;
                constructor(t, e, r) {
                    this.erc1155 = t, this.contractWrapper = e, this.storage = r
                }
                to = buildTransactionFunction(async (t, e) => {
                    let r = e.map(t => t.metadata),
                        a = e.map(t => t.supply),
                        n = await uploadOrExtractURIs(r, this.storage),
                        i = await resolveAddress(t),
                        s = new ContractEncoder(this.contractWrapper),
                        o = await Promise.all(n.map(async (t, e) => s.encode("mintTo", [i, V.Bz, t, a[e]])));
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [o],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensMinted", t.logs);
                            if (0 === e.length || e.length < r.length) throw Error("TokenMinted event not found, minting failed");
                            return e.map(e => {
                                let r = e.args.tokenIdMinted;
                                return {
                                    id: r,
                                    receipt: t,
                                    data: () => this.erc1155.get(r)
                                }
                            })
                        }
                    })
                })
            };
            let Erc1155Burnable = class Erc1155Burnable {
                featureName = r5.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                tokens = buildTransactionFunction(async (t, e) => {
                    let r = await this.contractWrapper.getSignerAddress();
                    return this.from.prepare(r, t, e)
                });
                from = buildTransactionFunction(async (t, e, r) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "burn",
                    args: [await resolveAddress(t), e, r]
                }));
                batch = buildTransactionFunction(async (t, e) => {
                    let r = await this.contractWrapper.getSignerAddress();
                    return this.batchFrom.prepare(r, t, e)
                });
                batchFrom = buildTransactionFunction(async (t, e, r) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "burnBatch",
                    args: [await resolveAddress(t), e, r]
                }))
            };
            let Erc1155Enumerable = class Erc1155Enumerable {
                featureName = ai.name;
                constructor(t, e) {
                    this.erc1155 = t, this.contractWrapper = e
                }
                async all(t) {
                    let e = v.O$.from(t ? .start || 0).toNumber(),
                        r = v.O$.from(t ? .count || C.D).toNumber(),
                        a = Math.min((await this.totalCount()).toNumber(), e + r);
                    return await Promise.all([...Array(a - e).keys()].map(t => this.erc1155.get((e + t).toString())))
                }
                async totalCount() {
                    return await this.contractWrapper.read("nextTokenIdToMint", [])
                }
                async totalCirculatingSupply(t) {
                    return await this.contractWrapper.read("totalSupply", [t])
                }
                async owned(t) {
                    let [e, r] = await Promise.all([resolveAddress(t || await this.contractWrapper.getSignerAddress()), this.contractWrapper.read("nextTokenIdToMint", [])]), a = await this.contractWrapper.read("balanceOfBatch", [Array(r.toNumber()).fill(e), Array.from(Array(r.toNumber()).keys())]), n = a.map((t, e) => ({
                        tokenId: e,
                        balance: t
                    })).filter(t => t.balance.gt(0)), i = (await Promise.all(n.map(t => this.erc1155.get(t.tokenId.toString())))).map((t, r) => ({ ...t,
                        owner: e,
                        quantityOwned: n[r].balance.toString()
                    }));
                    return i
                }
            };
            async function getPrebuiltInfo(t, e) {
                try {
                    let r = new O.CH(t, te, e),
                        [a, n] = await Promise.all([M.ZN(await r.contractType()).replace(/\x00/g, ""), await r.contractVersion()]);
                    return {
                        type: a,
                        version: n
                    }
                } catch (t) {
                    return
                }
            }
            let Erc1155LazyMintable = class Erc1155LazyMintable {
                featureName = at.name;
                constructor(t, e, r) {
                    this.erc1155 = t, this.contractWrapper = e, this.storage = r, this.revealer = this.detectErc1155Revealable()
                }
                lazyMint = buildTransactionFunction(async (t, e) => {
                    let r = await this.erc1155.nextTokenIdToMint(),
                        a = await uploadOrExtractURIs(t, this.storage, r.toNumber(), e),
                        n = a[0].substring(0, a[0].lastIndexOf("/"));
                    for (let t = 0; t < a.length; t++) {
                        let e = a[t].substring(0, a[t].lastIndexOf("/"));
                        if (n !== e) throw Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${n}' but got '${e}'`)
                    }
                    let parse = t => {
                            let e = this.contractWrapper.parseLogs("TokensLazyMinted", t ? .logs),
                                r = e[0].args.startTokenId,
                                a = e[0].args.endTokenId,
                                n = [];
                            for (let e = r; e.lte(a); e = e.add(1)) n.push({
                                id: e,
                                receipt: t,
                                data: () => this.erc1155.getTokenMetadata(e)
                            });
                            return n
                        },
                        i = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());
                    return this.isLegacyEditionDropContract(this.contractWrapper, i) ? Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "lazyMint",
                        args: [a.length, `${n.endsWith("/")?n:`${n}/`}`],
                        parse
                    }) : Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "lazyMint",
                        args: [a.length, `${n.endsWith("/")?n:`${n}/`}`, M.Y0("")],
                        parse
                    })
                });
                detectErc1155Revealable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155Revealable")) return new DelayedReveal(this.contractWrapper, this.storage, r9.name, () => this.erc1155.nextTokenIdToMint())
                }
                isLegacyEditionDropContract(t, e) {
                    return e && "DropERC1155" === e.type && e.version < 3 || !1
                }
            };
            let Erc1155Mintable = class Erc1155Mintable {
                featureName = an.name;
                constructor(t, e, r) {
                    this.erc1155 = t, this.contractWrapper = e, this.storage = r, this.batch = this.detectErc1155BatchMintable()
                }
                to = buildTransactionFunction(async (t, e) => {
                    let r = await this.getMintTransaction(t, e);
                    return r.setParse(t => {
                        let e = this.contractWrapper.parseLogs("TransferSingle", t ? .logs);
                        if (0 === e.length) throw Error("TransferSingleEvent event not found");
                        let r = e[0].args.id;
                        return {
                            id: r,
                            receipt: t,
                            data: () => this.erc1155.get(r.toString())
                        }
                    }), r
                });
                async getMintTransaction(t, e) {
                    let r = await uploadOrExtractURI(e.metadata, this.storage);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "mintTo",
                        args: [await resolveAddress(t), V.Bz, r, e.supply]
                    })
                }
                additionalSupplyTo = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.erc1155.getTokenMetadata(e);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "mintTo",
                        args: [await resolveAddress(t), e, a.uri, r],
                        parse: t => ({
                            id: v.O$.from(e),
                            receipt: t,
                            data: () => this.erc1155.get(e)
                        })
                    })
                });
                detectErc1155BatchMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155BatchMintable")) return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage)
                }
            };
            let ie = A.z.object({
                    address: eA,
                    quantity: C.A.default(1)
                }),
                ir = A.z.union([A.z.array(A.z.string()).transform(async t => await Promise.all(t.map(t => ie.parseAsync({
                    address: t
                })))), A.z.array(ie)]);
            let ERC1155Claimable = class ERC1155Claimable {
                featureName = r4.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                async getClaimTransaction(t, e, r, a) {
                    let n = {};
                    return a && a.pricePerToken && (n = await calculateClaimCost(this.contractWrapper, a.pricePerToken, r, a.currencyAddress, a.checkERC20Allowance)), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "claim",
                        args: [await resolveAddress(t), e, r],
                        overrides: n
                    })
                }
                to = buildTransactionFunction(async (t, e, r, a) => await this.getClaimTransaction(t, e, r, a))
            };
            let Erc1155ClaimableWithConditions = class Erc1155ClaimableWithConditions {
                featureName = r8.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e;
                    let r = new ContractMetadata(this.contractWrapper, ra, this.storage);
                    this.conditions = new DropErc1155ClaimConditions(t, r, this.storage)
                }
                to = buildTransactionFunction(async (t, e, r, a) => await this.conditions.getClaimTransaction(t, e, r, a))
            };
            let Erc1155SignatureMintable = class Erc1155SignatureMintable {
                featureName = ar.name;
                constructor(t, e, r) {
                    this.contractWrapper = t, this.storage = e, this.roles = r
                }
                mint = buildTransactionFunction(async t => {
                    let e = t.payload,
                        r = t.signature,
                        a = await this.mapPayloadToContractStruct(e),
                        n = await this.contractWrapper.getCallOverrides();
                    return await setErc20Allowance(this.contractWrapper, a.pricePerToken.mul(a.quantity), e.currencyAddress, n), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "mintWithSignature",
                        args: [a, r],
                        overrides: n,
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensMintedWithSignature", t.logs);
                            if (0 === e.length) throw Error("No MintWithSignature event found");
                            let r = e[0].args.tokenIdMinted;
                            return {
                                id: r,
                                receipt: t
                            }
                        }
                    })
                });
                mintBatch = buildTransactionFunction(async t => {
                    let e = await Promise.all(t.map(async t => {
                            let e = await this.mapPayloadToContractStruct(t.payload),
                                r = t.signature,
                                a = t.payload.price;
                            if (v.O$.from(a).gt(0)) throw Error("Can only batch free mints. For mints with a price, use regular mint()");
                            return {
                                message: e,
                                signature: r
                            }
                        })),
                        r = new ContractEncoder(this.contractWrapper),
                        a = e.map(t => r.encode("mintWithSignature", [t.message, t.signature]));
                    if (hasFunction("multicall", this.contractWrapper)) return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [a],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("TokensMintedWithSignature", t.logs);
                            if (0 === e.length) throw Error("No MintWithSignature event found");
                            return e.map(e => ({
                                id: e.args.tokenIdMinted,
                                receipt: t
                            }))
                        }
                    });
                    throw Error("Multicall not supported on this contract!")
                });
                async verify(t) {
                    let e = t.payload,
                        r = t.signature,
                        a = await this.mapPayloadToContractStruct(e),
                        n = await this.contractWrapper.read("verify", [a, r]);
                    return n[0]
                }
                async generate(t) {
                    let e = { ...t,
                        tokenId: V.Bz
                    };
                    return this.generateFromTokenId(e)
                }
                async generateFromTokenId(t) {
                    let e = await this.generateBatchFromTokenIds([t]);
                    return e[0]
                }
                async generateBatch(t) {
                    let e = t.map(t => ({ ...t,
                        tokenId: V.Bz
                    }));
                    return this.generateBatchFromTokenIds(e)
                }
                async generateBatchFromTokenIds(t) {
                    await this.roles ? .verify(["minter"], await this.contractWrapper.getSignerAddress());
                    let e = await Promise.all(t.map(t => eH.parseAsync(t))),
                        r = e.map(t => t.metadata),
                        a = await uploadOrExtractURIs(r, this.storage),
                        n = await this.contractWrapper.getChainID(),
                        i = this.contractWrapper.getSigner();
                    (0, j.Z)(i, "No signer available");
                    let s = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider()),
                        o = s ? .type === "TokenERC1155";
                    return await Promise.all(e.map(async (t, e) => {
                        let r = a[e],
                            s = await eZ.parseAsync({ ...t,
                                uri: r
                            }),
                            c = await this.contractWrapper.signTypedData(i, {
                                name: o ? "TokenERC1155" : "SignatureMintERC1155",
                                version: "1",
                                chainId: n,
                                verifyingContract: this.contractWrapper.address
                            }, {
                                MintRequest: eX
                            }, await this.mapPayloadToContractStruct(s));
                        return {
                            payload: s,
                            signature: c.toString()
                        }
                    }))
                }
                async mapPayloadToContractStruct(t) {
                    let e = await normalizePriceValue(this.contractWrapper.getProvider(), t.price, t.currencyAddress);
                    return {
                        to: t.to,
                        tokenId: t.tokenId,
                        uri: t.uri,
                        quantity: t.quantity,
                        pricePerToken: e,
                        currency: t.currencyAddress,
                        validityStartTimestamp: t.mintStartTime,
                        validityEndTimestamp: t.mintEndTime,
                        uid: t.uid,
                        royaltyRecipient: t.royaltyRecipient,
                        royaltyBps: t.royaltyBps,
                        primarySaleRecipient: t.primarySaleRecipient
                    }
                }
            };
            let Erc1155 = class Erc1155 {
                featureName = ac.name;
                get chainId() {
                    return this._chainId
                }
                constructor(t, e, r) {
                    this.contractWrapper = t, this.storage = e, this.query = this.detectErc1155Enumerable(), this.mintable = this.detectErc1155Mintable(), this.burnable = this.detectErc1155Burnable(), this.lazyMintable = this.detectErc1155LazyMintable(), this.signatureMintable = this.detectErc1155SignatureMintable(), this.claimCustom = this.detectErc1155Claimable(), this.claimWithConditions = this.detectErc1155ClaimableWithConditions(), this._chainId = r
                }
                onNetworkUpdated(t) {
                    this.contractWrapper.updateSignerOrProvider(t)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async get(t) {
                    let [e, r] = await Promise.all([this.contractWrapper.read("totalSupply", [t]).catch(() => v.O$.from(0)), this.getTokenMetadata(t).catch(() => ({
                        id: t.toString(),
                        uri: "",
                        ...n3
                    }))]);
                    return {
                        owner: I.d,
                        metadata: r,
                        type: "ERC1155",
                        supply: e.toString()
                    }
                }
                async totalSupply(t) {
                    if (detectContractFeature(this.contractWrapper, "ERC1155Supply")) return await this.contractWrapper.read("totalSupply", [t]);
                    throw new ExtensionNotImplementedError(ao)
                }
                async balanceOf(t, e) {
                    return await this.contractWrapper.read("balanceOf", [await resolveAddress(t), e])
                }
                async balance(t) {
                    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), t)
                }
                async isApproved(t, e) {
                    return await this.contractWrapper.read("isApprovedForAll", [await resolveAddress(t), await resolveAddress(e)])
                }
                transfer = buildTransactionFunction((() => {
                    var t = this;
                    return async function(e, r, a) {
                        let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [0],
                            i = await t.contractWrapper.getSignerAddress();
                        return Transaction.fromContractWrapper({
                            contractWrapper: t.contractWrapper,
                            method: "safeTransferFrom",
                            args: [i, await resolveAddress(e), r, a, n]
                        })
                    }
                })());
                transferFrom = buildTransactionFunction((() => {
                    var t = this;
                    return async function(e, r, a, n) {
                        let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [0];
                        return Transaction.fromContractWrapper({
                            contractWrapper: t.contractWrapper,
                            method: "safeTransferFrom",
                            args: [await resolveAddress(e), await resolveAddress(r), a, n, i]
                        })
                    }
                })());
                setApprovalForAll = buildTransactionFunction(async (t, e) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "setApprovalForAll",
                    args: [t, e]
                }));
                airdrop = buildTransactionFunction((() => {
                    var t = this;
                    return async function(e, r, a) {
                        let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [0],
                            i = a ? await resolveAddress(a) : await t.contractWrapper.getSignerAddress(),
                            s = await t.balanceOf(i, e),
                            o = await ir.parseAsync(r),
                            c = o.reduce((t, e) => v.O$.from(t).add(v.O$.from(e ? .quantity || 1)), v.O$.from(0));
                        if (s.lt(v.O$.from(c))) throw Error(`The caller owns ${s.toString()} NFTs, but wants to airdrop ${c.toString()} NFTs.`);
                        let l = new ContractEncoder(t.contractWrapper),
                            d = o.map(t => {
                                let {
                                    address: r,
                                    quantity: a
                                } = t;
                                return l.encode("safeTransferFrom", [i, r, e, a, n])
                            });
                        return Transaction.fromContractWrapper({
                            contractWrapper: t.contractWrapper,
                            method: "multicall",
                            args: [d]
                        })
                    }
                })());
                async nextTokenIdToMint() {
                    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) return await this.contractWrapper.read("nextTokenIdToMint", []);
                    throw Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")
                }
                async getAll(t) {
                    return assertEnabled(this.query, ai).all(t)
                }
                async totalCount() {
                    return assertEnabled(this.query, ai).totalCount()
                }
                async totalCirculatingSupply(t) {
                    return assertEnabled(this.query, ai).totalCirculatingSupply(t)
                }
                async getOwned(t) {
                    return t && (t = await resolveAddress(t)), assertEnabled(this.query, ai).owned(t)
                }
                mint = buildTransactionFunction(async t => this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), t));
                mintTo = buildTransactionFunction(async (t, e) => assertEnabled(this.mintable, an).to.prepare(t, e));
                async getMintTransaction(t, e) {
                    return assertEnabled(this.mintable, an).getMintTransaction(t, e)
                }
                mintAdditionalSupply = buildTransactionFunction(async (t, e) => assertEnabled(this.mintable, an).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), t, e));
                mintAdditionalSupplyTo = buildTransactionFunction(async (t, e, r) => assertEnabled(this.mintable, an).additionalSupplyTo.prepare(t, e, r));
                mintBatch = buildTransactionFunction(async t => this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), t));
                mintBatchTo = buildTransactionFunction(async (t, e) => assertEnabled(this.mintable ? .batch, aa).to.prepare(t, e));
                burn = buildTransactionFunction(async (t, e) => assertEnabled(this.burnable, r5).tokens.prepare(t, e));
                burnFrom = buildTransactionFunction(async (t, e, r) => assertEnabled(this.burnable, r5).from.prepare(t, e, r));
                burnBatch = buildTransactionFunction(async (t, e) => assertEnabled(this.burnable, r5).batch.prepare(t, e));
                burnBatchFrom = buildTransactionFunction(async (t, e, r) => assertEnabled(this.burnable, r5).batchFrom.prepare(t, e, r));
                lazyMint = buildTransactionFunction(async (t, e) => assertEnabled(this.lazyMintable, at).lazyMint.prepare(t, e));
                async getClaimTransaction(t, e, r, a) {
                    let n = this.claimWithConditions,
                        i = this.claimCustom;
                    if (n) return n.conditions.getClaimTransaction(t, e, r, a);
                    if (i) return i.getClaimTransaction(t, e, r, a);
                    throw new ExtensionNotImplementedError(r4)
                }
                claim = buildTransactionFunction(async (t, e, r) => this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), t, e, r));
                claimTo = buildTransactionFunction(async (t, e, r, a) => {
                    let n = this.claimWithConditions,
                        i = this.claimCustom;
                    if (n) return n.to.prepare(t, e, r, a);
                    if (i) return i.to.prepare(t, e, r, a);
                    throw new ExtensionNotImplementedError(r4)
                });
                get claimConditions() {
                    return assertEnabled(this.claimWithConditions, r8).conditions
                }
                get signature() {
                    return assertEnabled(this.signatureMintable, ar)
                }
                get revealer() {
                    return assertEnabled(this.lazyMintable ? .revealer, r9)
                }
                async getTokenMetadata(t) {
                    let e = await this.contractWrapper.read("uri", [t]);
                    if (!e) throw new NotFoundError;
                    return fetchTokenMetadata(t, e, this.storage)
                }
                detectErc1155Enumerable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155Enumerable")) return new Erc1155Enumerable(this, this.contractWrapper)
                }
                detectErc1155Mintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155Mintable")) return new Erc1155Mintable(this, this.contractWrapper, this.storage)
                }
                detectErc1155Burnable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155Burnable")) return new Erc1155Burnable(this.contractWrapper)
                }
                detectErc1155LazyMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV1") || detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV2")) return new Erc1155LazyMintable(this, this.contractWrapper, this.storage)
                }
                detectErc1155SignatureMintable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155SignatureMintable")) return new Erc1155SignatureMintable(this.contractWrapper, this.storage)
                }
                detectErc1155Claimable() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimCustom")) return new ERC1155Claimable(this.contractWrapper)
                }
                detectErc1155ClaimableWithConditions() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV2")) return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage)
                }
            };

            function cleanCurrencyAddress(t) {
                return isNativeToken(t) ? eT : t
            }
            async function isTokenApprovedForTransfer(t, e, r, a, n) {
                try {
                    let i = new O.CH(r, H, t),
                        s = await i.supportsInterface(nj),
                        o = await i.supportsInterface(nq);
                    if (s) {
                        let i;
                        let s = new O.CH(r, tn, t),
                            o = await s.isApprovedForAll(n, e);
                        if (o) return !0;
                        try {
                            i = await s.getApproved(a)
                        } catch (t) {}
                        return i ? .toLowerCase() === e.toLowerCase()
                    }
                    if (!o) return console.error("Contract does not implement ERC 1155 or ERC 721."), !1; {
                        let a = new O.CH(r, ta, t);
                        return await a.isApprovedForAll(n, e)
                    }
                } catch (t) {
                    return console.error("Failed to check if token is approved", t), !1
                }
            }
            async function handleTokenApproval(t, e, r, a, n) {
                let i = new ContractWrapper(t.getSignerOrProvider(), r, H, t.options, t.storage),
                    s = await i.read("supportsInterface", [nj]),
                    o = await i.read("supportsInterface", [nq]);
                if (s) {
                    let i = new ContractWrapper(t.getSignerOrProvider(), r, tn, t.options, t.storage),
                        s = await i.read("isApprovedForAll", [n, e]);
                    if (!s) {
                        let t = (await i.read("getApproved", [a])).toLowerCase() === e.toLowerCase();
                        t || await i.sendTransaction("setApprovalForAll", [e, !0])
                    }
                } else if (o) {
                    let a = new ContractWrapper(t.getSignerOrProvider(), r, ta, t.options, t.storage),
                        i = await a.read("isApprovedForAll", [n, e]);
                    i || await a.sendTransaction("setApprovalForAll", [e, !0])
                } else throw Error("Contract must implement ERC 1155 or ERC 721.")
            }

            function validateNewListingParam(t) {
                (0, j.Z)(void 0 !== t.assetContractAddress && null !== t.assetContractAddress, "Asset contract address is required"), (0, j.Z)(void 0 !== t.buyoutPricePerToken && null !== t.buyoutPricePerToken, "Buyout price is required"), (0, j.Z)(void 0 !== t.listingDurationInSeconds && null !== t.listingDurationInSeconds, "Listing duration is required"), (0, j.Z)(void 0 !== t.startTimestamp && null !== t.startTimestamp, "Start time is required"), (0, j.Z)(void 0 !== t.tokenId && null !== t.tokenId, "Token ID is required"), (0, j.Z)(void 0 !== t.quantity && null !== t.quantity, "Quantity is required"), "NewAuctionListing" === t.type && (0, j.Z)(void 0 !== t.reservePricePerToken && null !== t.reservePricePerToken, "Reserve price is required")
            }
            async function mapOffer(t, e, r) {
                return {
                    quantity: r.quantityDesired,
                    pricePerToken: r.pricePerToken,
                    currencyContractAddress: r.currency,
                    buyerAddress: r.offeror,
                    quantityDesired: r.quantityWanted,
                    currencyValue: await fetchCurrencyValue(t, r.currency, r.quantityWanted.mul(r.pricePerToken)),
                    listingId: e
                }
            }

            function isWinningBid(t, e, r) {
                if (r = v.O$.from(r), t = v.O$.from(t), e = v.O$.from(e), t.eq(v.O$.from(0))) return !1;
                let a = e.sub(t).mul(C.M).div(t);
                return a.gte(r)
            }
            async function getAllInBatches(t, e, r) {
                let a = [];
                for (; e - t > C.D;) a.push(r(t, t + C.D - 1)), t += C.D;
                return a.push(r(t, e - 1)), await Promise.all(a)
            }
            let ContractEvents = class ContractEvents {
                constructor(t) {
                    this.contractWrapper = t
                }
                addTransactionListener(t) {
                    this.contractWrapper.addListener(nG.Transaction, t)
                }
                removeTransactionListener(t) {
                    this.contractWrapper.off(nG.Transaction, t)
                }
                addEventListener(t, e) {
                    let r = this.contractWrapper.readContract.interface.getEvent(t),
                        a = this.contractWrapper.address,
                        n = {
                            address: a,
                            topics: [this.contractWrapper.readContract.interface.getEventTopic(r)]
                        },
                        wrappedListener = t => {
                            let r = this.contractWrapper.readContract.interface.parseLog(t);
                            e(this.toContractEvent(r.eventFragment, r.args, t))
                        };
                    return this.contractWrapper.getProvider().on(n, wrappedListener), () => {
                        this.contractWrapper.getProvider().off(n, wrappedListener)
                    }
                }
                listenToAllEvents(t) {
                    let e = this.contractWrapper.address,
                        r = {
                            address: e
                        },
                        wrappedListener = e => {
                            try {
                                let r = this.contractWrapper.readContract.interface.parseLog(e);
                                t(this.toContractEvent(r.eventFragment, r.args, e))
                            } catch (t) {
                                console.error("Could not parse event:", e, t)
                            }
                        };
                    return this.contractWrapper.getProvider().on(r, wrappedListener), () => {
                        this.contractWrapper.getProvider().off(r, wrappedListener)
                    }
                }
                removeEventListener(t, e) {
                    let r = this.contractWrapper.readContract.interface.getEvent(t);
                    this.contractWrapper.readContract.off(r.name, e)
                }
                removeAllListeners() {
                    this.contractWrapper.readContract.removeAllListeners();
                    let t = this.contractWrapper.address;
                    this.contractWrapper.getProvider().removeAllListeners({
                        address: t
                    })
                }
                async getAllEvents() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                            fromBlock: 0,
                            toBlock: "latest",
                            order: "desc"
                        },
                        e = await this.contractWrapper.readContract.queryFilter({}, t.fromBlock, t.toBlock),
                        r = e.sort((e, r) => "desc" === t.order ? r.blockNumber - e.blockNumber : e.blockNumber - r.blockNumber);
                    return this.parseEvents(r)
                }
                async getEvents(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                            fromBlock: 0,
                            toBlock: "latest",
                            order: "desc"
                        },
                        r = this.contractWrapper.readContract.interface.getEvent(t),
                        a = e.filters ? r.inputs.map(t => e.filters[t.name]) : [],
                        n = this.contractWrapper.readContract.filters[r.name](...a),
                        i = await this.contractWrapper.readContract.queryFilter(n, e.fromBlock, e.toBlock),
                        s = i.sort((t, r) => "desc" === e.order ? r.blockNumber - t.blockNumber : t.blockNumber - r.blockNumber);
                    return this.parseEvents(s)
                }
                parseEvents(t) {
                    return t.map(t => {
                        let e = Object.fromEntries(Object.entries(t).filter(t => "function" != typeof t[1] && "args" !== t[0]));
                        if (t.args) {
                            let r = Object.entries(t.args),
                                a = r.slice(r.length / 2, r.length),
                                n = {};
                            for (let [t, e] of a) n[t] = e;
                            return {
                                eventName: t.event || "",
                                data: n,
                                transaction: e
                            }
                        }
                        return {
                            eventName: t.event || "",
                            data: {},
                            transaction: e
                        }
                    })
                }
                toContractEvent(t, e, r) {
                    let a = Object.fromEntries(Object.entries(r).filter(t => "function" != typeof t[1] && "args" !== t[0])),
                        n = {};
                    return t.inputs.forEach((t, r) => {
                        if (Array.isArray(e[r])) {
                            let a = t.components;
                            if (a) {
                                let i = e[r];
                                if ("tuple[]" === t.type) {
                                    let e = [];
                                    for (let t = 0; t < i.length; t++) {
                                        let r = i[t],
                                            n = {};
                                        for (let t = 0; t < a.length; t++) {
                                            let e = a[t].name;
                                            n[e] = r[t]
                                        }
                                        e.push(n)
                                    }
                                    n[t.name] = e
                                } else {
                                    let e = {};
                                    for (let t = 0; t < a.length; t++) {
                                        let r = a[t].name;
                                        e[r] = i[t]
                                    }
                                    n[t.name] = e
                                }
                            }
                        } else n[t.name] = e[r]
                    }), {
                        eventName: t.name,
                        data: n,
                        transaction: a
                    }
                }
            };
            let ia = A.z.object({
                assetContractAddress: eA,
                tokenId: ep,
                quantity: ep.default(1),
                currencyContractAddress: eA.default(eT),
                pricePerToken: C.A,
                startTimestamp: eS.default(new Date),
                endTimestamp: eF,
                isReservedListing: A.z.boolean().default(!1)
            });
            let ContractInterceptor = class ContractInterceptor {
                constructor(t) {
                    this.contractWrapper = t
                }
                overrideNextTransaction(t) {
                    this.contractWrapper.withTransactionOverride(t)
                }
            };
            let GasCostEstimator = class GasCostEstimator {
                constructor(t) {
                    this.contractWrapper = t
                }
                async gasCostOf(t, e) {
                    let [r, a] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(t, e)]);
                    return R.formatEther(a.mul(r))
                }
                async gasLimitOf(t, e) {
                    return this.contractWrapper.estimateGas(t, e)
                }
                async currentGasPriceInGwei() {
                    let t = await this.contractWrapper.getProvider().getGasPrice();
                    return R.formatUnits(t, "gwei")
                }
            };
            let MarketplaceV3DirectListings = class MarketplaceV3DirectListings {
                featureName = aW.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e, this.events = new ContractEvents(this.contractWrapper), this.encoder = new ContractEncoder(this.contractWrapper), this.interceptor = new ContractInterceptor(this.contractWrapper), this.estimator = new GasCostEstimator(this.contractWrapper)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async getTotalCount() {
                    return await this.contractWrapper.read("totalListings", [])
                }
                async getAll(t) {
                    let e = await this.getTotalCount(),
                        r = v.O$.from(t ? .start || 0).toNumber(),
                        a = e.toNumber();
                    if (0 === a) throw Error("No listings exist on the contract.");
                    let n = [],
                        i = await getAllInBatches(r, a, (t, e) => this.contractWrapper.read("getAllListings", [t, e]));
                    n = i.flat();
                    let s = await this.applyFilter(n, t);
                    return await Promise.all(s.map(t => this.mapListing(t)))
                }
                async getAllValid(t) {
                    let e = await this.getTotalCount(),
                        r = v.O$.from(t ? .start || 0).toNumber(),
                        a = e.toNumber();
                    if (0 === a) throw Error("No listings exist on the contract.");
                    let n = [],
                        i = await getAllInBatches(r, a, (t, e) => this.contractWrapper.read("getAllValidListings", [t, e]));
                    n = i.flat();
                    let s = await this.applyFilter(n, t);
                    return await Promise.all(s.map(t => this.mapListing(t)))
                }
                async getListing(t) {
                    let e = await this.contractWrapper.read("getListing", [t]);
                    return await this.mapListing(e)
                }
                async isBuyerApprovedForListing(t, e) {
                    let r = await this.validateListing(v.O$.from(t));
                    if (!r.isReservedListing) throw Error(`Listing ${t} is not a reserved listing.`);
                    return await this.contractWrapper.read("isBuyerApprovedForListing", [t, await resolveAddress(e)])
                }
                async isCurrencyApprovedForListing(t, e) {
                    return await this.validateListing(v.O$.from(t)), await this.contractWrapper.read("isCurrencyApprovedForListing", [t, await resolveAddress(e)])
                }
                async currencyPriceForListing(t, e) {
                    let r = await this.validateListing(v.O$.from(t)),
                        a = await resolveAddress(e);
                    if (a === r.currencyContractAddress) return r.pricePerToken;
                    let n = await this.isCurrencyApprovedForListing(t, a);
                    if (!n) throw Error(`Currency ${a} is not approved for Listing ${t}.`);
                    return await this.contractWrapper.read("currencyPriceForListing", [t, a])
                }
                createListing = buildTransactionFunction(async t => {
                    let e = await ia.parseAsync(t);
                    await handleTokenApproval(this.contractWrapper, this.getAddress(), e.assetContractAddress, e.tokenId, await this.contractWrapper.getSignerAddress());
                    let r = await normalizePriceValue(this.contractWrapper.getProvider(), e.pricePerToken, e.currencyContractAddress),
                        a = await this.contractWrapper.getProvider().getBlock("latest"),
                        n = a.timestamp;
                    return e.startTimestamp.lt(n) && (e.startTimestamp = v.O$.from(n)), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "createListing",
                        args: [{
                            assetContract: e.assetContractAddress,
                            tokenId: e.tokenId,
                            quantity: e.quantity,
                            currency: cleanCurrencyAddress(e.currencyContractAddress),
                            pricePerToken: r,
                            startTimestamp: e.startTimestamp,
                            endTimestamp: e.endTimestamp,
                            reserved: e.isReservedListing
                        }],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("NewListing", t ? .logs);
                            return {
                                id: e[0].args.listingId,
                                receipt: t
                            }
                        }
                    })
                });
                createListingsBatch = buildTransactionFunction(async t => {
                    let e = await Promise.all(t.map(async t => {
                        let e = await this.createListing.prepare(t);
                        return e.encode()
                    }));
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [e],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("NewListing", t ? .logs);
                            return e.map(e => ({
                                id: e.args.listingId,
                                receipt: t
                            }))
                        }
                    })
                });
                updateListing = buildTransactionFunction(async (t, e) => {
                    let r = await ia.parseAsync(e);
                    await handleTokenApproval(this.contractWrapper, this.getAddress(), r.assetContractAddress, r.tokenId, await this.contractWrapper.getSignerAddress());
                    let a = await normalizePriceValue(this.contractWrapper.getProvider(), r.pricePerToken, r.currencyContractAddress);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "updateListing",
                        args: [t, {
                            assetContract: r.assetContractAddress,
                            tokenId: r.tokenId,
                            quantity: r.quantity,
                            currency: cleanCurrencyAddress(r.currencyContractAddress),
                            pricePerToken: a,
                            startTimestamp: r.startTimestamp,
                            endTimestamp: r.endTimestamp,
                            reserved: r.isReservedListing
                        }],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("UpdatedListing", t ? .logs);
                            return {
                                id: e[0].args.listingId,
                                receipt: t
                            }
                        }
                    })
                });
                cancelListing = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "cancelListing",
                    args: [t]
                }));
                buyFromListing = buildTransactionFunction(async (t, e, r) => {
                    r && (r = await resolveAddress(r));
                    let a = await this.validateListing(v.O$.from(t)),
                        {
                            valid: n,
                            error: i
                        } = await this.isStillValidListing(a, e);
                    if (!n) throw Error(`Listing ${t} is no longer valid. ${i}`);
                    let s = r || await this.contractWrapper.getSignerAddress(),
                        o = v.O$.from(e),
                        c = v.O$.from(a.pricePerToken).mul(o),
                        l = await this.contractWrapper.getCallOverrides() || {};
                    return await setErc20Allowance(this.contractWrapper, c, a.currencyContractAddress, l), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "buyFromListing",
                        args: [t, s, o, a.currencyContractAddress, c],
                        overrides: l
                    })
                });
                approveBuyerForReservedListing = buildTransactionFunction(async (t, e) => {
                    let r = await this.isBuyerApprovedForListing(t, e);
                    if (!r) return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "approveBuyerForListing",
                        args: [t, e, !0]
                    });
                    throw Error(`Buyer ${e} already approved for listing ${t}.`)
                });
                revokeBuyerApprovalForReservedListing = buildTransactionFunction(async (t, e) => {
                    let r = await this.isBuyerApprovedForListing(t, e);
                    if (r) return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "approveBuyerForListing",
                        args: [t, e, !1]
                    });
                    throw Error(`Buyer ${e} not approved for listing ${t}.`)
                });
                approveCurrencyForListing = buildTransactionFunction(async (t, e, r) => {
                    let a = await this.validateListing(v.O$.from(t)),
                        n = await resolveAddress(e);
                    n === a.currencyContractAddress && (0, j.Z)(r === a.pricePerToken, "Approving listing currency with a different price.");
                    let i = await this.contractWrapper.read("currencyPriceForListing", [t, n]);
                    return (0, j.Z)(r === i, "Currency already approved with this price."), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "approveCurrencyForListing",
                        args: [t, n, r]
                    })
                });
                revokeCurrencyApprovalForListing = buildTransactionFunction(async (t, e) => {
                    let r = await this.validateListing(v.O$.from(t)),
                        a = await resolveAddress(e);
                    if (a === r.currencyContractAddress) throw Error("Can't revoke approval for main listing currency.");
                    let n = await this.contractWrapper.read("currencyPriceForListing", [t, a]);
                    return (0, j.Z)(!n.isZero(), "Currency not approved."), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "approveCurrencyForListing",
                        args: [t, a, v.O$.from(0)]
                    })
                });
                async validateListing(t) {
                    try {
                        return await this.getListing(t)
                    } catch (e) {
                        throw console.error(`Error getting the listing with id ${t}`), e
                    }
                }
                async mapListing(t) {
                    let e = n4.UNSET,
                        r = await this.contractWrapper.getProvider().getBlock("latest"),
                        a = r.timestamp;
                    switch (t.status) {
                        case 1:
                            e = v.O$.from(t.startTimestamp).gt(a) ? n4.Created : v.O$.from(t.endTimestamp).lt(a) ? n4.Expired : n4.Active;
                            break;
                        case 2:
                            e = n4.Completed;
                            break;
                        case 3:
                            e = n4.Cancelled
                    }
                    return {
                        assetContractAddress: t.assetContract,
                        currencyContractAddress: t.currency,
                        pricePerToken: t.pricePerToken.toString(),
                        currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), t.currency, t.pricePerToken),
                        id: t.listingId.toString(),
                        tokenId: t.tokenId.toString(),
                        quantity: t.quantity.toString(),
                        startTimeInSeconds: v.O$.from(t.startTimestamp).toNumber(),
                        asset: await fetchTokenMetadataForContract(t.assetContract, this.contractWrapper.getProvider(), t.tokenId, this.storage),
                        endTimeInSeconds: v.O$.from(t.endTimestamp).toNumber(),
                        creatorAddress: t.listingCreator,
                        isReservedListing: t.reserved,
                        status: e
                    }
                }
                async isStillValidListing(t, e) {
                    let r = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), t.assetContractAddress, t.tokenId, t.creatorAddress);
                    if (!r) return {
                        valid: !1,
                        error: `Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`
                    };
                    let a = this.contractWrapper.getProvider(),
                        n = new O.CH(t.assetContractAddress, H, a),
                        i = await n.supportsInterface(nj),
                        s = await n.supportsInterface(nq);
                    if (i) {
                        let e;
                        let r = new O.CH(t.assetContractAddress, tn, a);
                        try {
                            e = await r.ownerOf(t.tokenId)
                        } catch (t) {}
                        let n = e ? .toLowerCase() === t.creatorAddress.toLowerCase();
                        return {
                            valid: n,
                            error: n ? void 0 : `Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`
                        }
                    }
                    if (!s) return {
                        valid: !1,
                        error: "Contract does not implement ERC 1155 or ERC 721."
                    }; {
                        let r = new O.CH(t.assetContractAddress, ta, a),
                            n = await r.balanceOf(t.creatorAddress, t.tokenId),
                            i = n.gte(e || t.quantity);
                        return {
                            valid: i,
                            error: i ? void 0 : `Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`
                        }
                    }
                }
                async applyFilter(t, e) {
                    let r = [...t];
                    if (e) {
                        if (e.seller) {
                            let t = await resolveAddress(e.seller);
                            r = r.filter(e => e.listingCreator.toString().toLowerCase() === t ? .toString().toLowerCase())
                        }
                        if (e.tokenContract) {
                            let t = await resolveAddress(e.tokenContract);
                            r = r.filter(e => e.assetContract.toString().toLowerCase() === t ? .toString().toLowerCase())
                        }
                        void 0 !== e.tokenId && (r = r.filter(t => t.tokenId.toString() === e ? .tokenId ? .toString()))
                    }
                    return e ? .count && e.count < r.length ? r.slice(0, e.count) : r
                }
            };
            let ii = A.z.object({
                assetContractAddress: eA,
                tokenId: ep,
                quantity: ep.default(1),
                currencyContractAddress: eA.default(eT),
                minimumBidAmount: C.A,
                buyoutBidAmount: C.A,
                timeBufferInSeconds: ep.default(900),
                bidBufferBps: ep.default(500),
                startTimestamp: eS.default(new Date),
                endTimestamp: eF
            });
            let MarketplaceV3EnglishAuctions = class MarketplaceV3EnglishAuctions {
                featureName = aT.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e, this.events = new ContractEvents(this.contractWrapper), this.encoder = new ContractEncoder(this.contractWrapper), this.interceptor = new ContractInterceptor(this.contractWrapper), this.estimator = new GasCostEstimator(this.contractWrapper)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async getTotalCount() {
                    return await this.contractWrapper.read("totalAuctions", [])
                }
                async getAll(t) {
                    let e = await this.getTotalCount(),
                        r = v.O$.from(t ? .start || 0).toNumber(),
                        a = e.toNumber();
                    if (0 === a) throw Error("No auctions exist on the contract.");
                    let n = [],
                        i = await getAllInBatches(r, a, (t, e) => this.contractWrapper.read("getAllAuctions", [t, e]));
                    n = i.flat();
                    let s = await this.applyFilter(n, t);
                    return await Promise.all(s.map(t => this.mapAuction(t)))
                }
                async getAllValid(t) {
                    let e = await this.getTotalCount(),
                        r = v.O$.from(t ? .start || 0).toNumber(),
                        a = e.toNumber();
                    if (0 === a) throw Error("No auctions exist on the contract.");
                    let n = [],
                        i = await getAllInBatches(r, a, (t, e) => this.contractWrapper.read("getAllValidAuctions", [t, e]));
                    n = i.flat();
                    let s = await this.applyFilter(n, t);
                    return await Promise.all(s.map(t => this.mapAuction(t)))
                }
                async getAuction(t) {
                    let e = await this.contractWrapper.read("getAuction", [t]);
                    return await this.mapAuction(e)
                }
                async getWinningBid(t) {
                    await this.validateAuction(v.O$.from(t));
                    let e = await this.contractWrapper.read("getWinningBid", [t]);
                    if (e._bidder !== I.d) return await this.mapBid(t.toString(), e._bidder, e._currency, e._bidAmount.toString())
                }
                async isWinningBid(t, e) {
                    return await this.contractWrapper.read("isNewWinningBid", [t, e])
                }
                async getWinner(t) {
                    let e = await this.validateAuction(v.O$.from(t)),
                        r = await this.contractWrapper.read("getWinningBid", [t]),
                        a = v.O$.from(Math.floor(Date.now() / 1e3)),
                        n = v.O$.from(e.endTimeInSeconds);
                    if (a.gt(n) && r._bidder !== I.d) return r._bidder;
                    let i = new ContractEvents(this.contractWrapper),
                        s = await i.getEvents("AuctionClosed"),
                        o = s.find(e => e.data.auctionId.eq(v.O$.from(t)));
                    if (!o) throw Error(`Could not find auction with ID ${t} in closed auctions`);
                    return o.data.winningBidder
                }
                createAuction = buildTransactionFunction(async t => {
                    let e = ii.parse(t);
                    await handleTokenApproval(this.contractWrapper, this.getAddress(), e.assetContractAddress, e.tokenId, await this.contractWrapper.getSignerAddress());
                    let r = await normalizePriceValue(this.contractWrapper.getProvider(), e.buyoutBidAmount, e.currencyContractAddress),
                        a = await normalizePriceValue(this.contractWrapper.getProvider(), e.minimumBidAmount, e.currencyContractAddress),
                        n = await this.contractWrapper.getProvider().getBlock("latest"),
                        i = n.timestamp;
                    return e.startTimestamp.lt(i) && (e.startTimestamp = v.O$.from(i)), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "createAuction",
                        args: [{
                            assetContract: e.assetContractAddress,
                            tokenId: e.tokenId,
                            quantity: e.quantity,
                            currency: cleanCurrencyAddress(e.currencyContractAddress),
                            minimumBidAmount: a,
                            buyoutBidAmount: r,
                            timeBufferInSeconds: e.timeBufferInSeconds,
                            bidBufferBps: e.bidBufferBps,
                            startTimestamp: e.startTimestamp,
                            endTimestamp: e.endTimestamp
                        }],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("NewAuction", t.logs)[0];
                            return {
                                id: e.args.auctionId,
                                receipt: t
                            }
                        }
                    })
                });
                createAuctionsBatch = buildTransactionFunction(async t => {
                    let e = await Promise.all(t.map(async t => {
                        let e = await this.createAuction.prepare(t);
                        return e.encode()
                    }));
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [e],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("NewAuction", t ? .logs);
                            return e.map(e => ({
                                id: e.args.auctionId,
                                receipt: t
                            }))
                        }
                    })
                });
                buyoutAuction = buildTransactionFunction(async t => {
                    let e = await this.validateAuction(v.O$.from(t)),
                        r = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), e.currencyContractAddress);
                    return this.makeBid.prepare(t, R.formatUnits(e.buyoutBidAmount, r.decimals))
                });
                makeBid = buildTransactionFunction(async (t, e) => {
                    let r = await this.validateAuction(v.O$.from(t)),
                        a = await normalizePriceValue(this.contractWrapper.getProvider(), e, r.currencyContractAddress);
                    if (a.eq(v.O$.from(0))) throw Error("Cannot make a bid with 0 value");
                    if (v.O$.from(r.buyoutBidAmount).gt(0) && a.gt(r.buyoutBidAmount)) throw Error("Bid amount must be less than or equal to buyoutBidAmount");
                    let n = await this.getWinningBid(t);
                    if (n) {
                        let e = await this.isWinningBid(t, a);
                        (0, j.Z)(e, "Bid price is too low based on the current winning bid and the bid buffer")
                    } else {
                        let t = v.O$.from(r.minimumBidAmount);
                        (0, j.Z)(a.gte(t), "Bid price is too low based on minimum bid amount")
                    }
                    let i = await this.contractWrapper.getCallOverrides() || {};
                    return await setErc20Allowance(this.contractWrapper, a, r.currencyContractAddress, i), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "bidInAuction",
                        args: [t, a],
                        overrides: i
                    })
                });
                cancelAuction = buildTransactionFunction(async t => {
                    let e = await this.getWinningBid(t);
                    if (e) throw Error("Bids already made.");
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "cancelAuction",
                        args: [t]
                    })
                });
                closeAuctionForBidder = buildTransactionFunction(async (t, e) => {
                    e || (e = await this.contractWrapper.getSignerAddress());
                    let r = await this.validateAuction(v.O$.from(t));
                    try {
                        return Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "collectAuctionTokens",
                            args: [v.O$.from(t)]
                        })
                    } catch (e) {
                        if (e.message.includes("Marketplace: auction still active.")) throw new AuctionHasNotEndedError(t.toString(), r.endTimeInSeconds.toString());
                        throw e
                    }
                });
                closeAuctionForSeller = buildTransactionFunction(async t => {
                    let e = await this.validateAuction(v.O$.from(t));
                    try {
                        return Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "collectAuctionPayout",
                            args: [v.O$.from(t)]
                        })
                    } catch (r) {
                        if (r.message.includes("Marketplace: auction still active.")) throw new AuctionHasNotEndedError(t.toString(), e.endTimeInSeconds.toString());
                        throw r
                    }
                });
                executeSale = buildTransactionFunction(async t => {
                    let e = await this.validateAuction(v.O$.from(t));
                    try {
                        let e = await this.getWinningBid(t);
                        (0, j.Z)(e, "No winning bid found");
                        let r = this.encoder.encode("collectAuctionPayout", [t]),
                            a = this.encoder.encode("collectAuctionTokens", [t]);
                        return Transaction.fromContractWrapper({
                            contractWrapper: this.contractWrapper,
                            method: "multicall",
                            args: [
                                [r, a]
                            ]
                        })
                    } catch (r) {
                        if (r.message.includes("Marketplace: auction still active.")) throw new AuctionHasNotEndedError(t.toString(), e.endTimeInSeconds.toString());
                        throw r
                    }
                });
                async getBidBufferBps(t) {
                    return (await this.getAuction(t)).bidBufferBps
                }
                async getMinimumNextBid(t) {
                    let [e, r, a] = await Promise.all([this.getBidBufferBps(t), this.getWinningBid(t), this.validateAuction(v.O$.from(t))]), n = r ? v.O$.from(r.bidAmount) : v.O$.from(a.minimumBidAmount), i = n.add(n.mul(e).div(1e4));
                    return fetchCurrencyValue(this.contractWrapper.getProvider(), a.currencyContractAddress, i)
                }
                async validateAuction(t) {
                    try {
                        return await this.getAuction(t)
                    } catch (e) {
                        throw console.error(`Error getting the auction with id ${t}`), e
                    }
                }
                async mapAuction(t) {
                    let e = n4.UNSET,
                        r = await this.contractWrapper.getProvider().getBlock("latest"),
                        a = r.timestamp;
                    switch (t.status) {
                        case 1:
                            e = v.O$.from(t.startTimestamp).gt(a) ? n4.Created : v.O$.from(t.endTimestamp).lt(a) ? n4.Expired : n4.Active;
                            break;
                        case 2:
                            e = n4.Completed;
                            break;
                        case 3:
                            e = n4.Cancelled
                    }
                    return {
                        id: t.auctionId.toString(),
                        creatorAddress: t.auctionCreator,
                        assetContractAddress: t.assetContract,
                        tokenId: t.tokenId.toString(),
                        quantity: t.quantity.toString(),
                        currencyContractAddress: t.currency,
                        minimumBidAmount: t.minimumBidAmount.toString(),
                        minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), t.currency, t.minimumBidAmount),
                        buyoutBidAmount: t.buyoutBidAmount.toString(),
                        buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), t.currency, t.buyoutBidAmount),
                        timeBufferInSeconds: v.O$.from(t.timeBufferInSeconds).toNumber(),
                        bidBufferBps: v.O$.from(t.bidBufferBps).toNumber(),
                        startTimeInSeconds: v.O$.from(t.startTimestamp).toNumber(),
                        endTimeInSeconds: v.O$.from(t.endTimestamp).toNumber(),
                        asset: await fetchTokenMetadataForContract(t.assetContract, this.contractWrapper.getProvider(), t.tokenId, this.storage),
                        status: e
                    }
                }
                async mapBid(t, e, r, a) {
                    let n = await resolveAddress(e),
                        i = await resolveAddress(r);
                    return {
                        auctionId: t,
                        bidderAddress: n,
                        currencyContractAddress: i,
                        bidAmount: a,
                        bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), i, a)
                    }
                }
                async applyFilter(t, e) {
                    let r = [...t];
                    if (e) {
                        if (e.seller) {
                            let t = await resolveAddress(e.seller);
                            r = r.filter(e => e.auctionCreator.toString().toLowerCase() === t ? .toString().toLowerCase())
                        }
                        if (e.tokenContract) {
                            let t = await resolveAddress(e.tokenContract);
                            r = r.filter(e => e.assetContract.toString().toLowerCase() === t ? .toString().toLowerCase())
                        }
                        void 0 !== e.tokenId && (r = r.filter(t => t.tokenId.toString() === e ? .tokenId ? .toString()))
                    }
                    return e ? .count && e.count < r.length ? r.slice(0, e.count) : r
                }
            };
            let is = A.z.object({
                assetContractAddress: eA,
                tokenId: ep,
                quantity: ep.default(1),
                currencyContractAddress: eA.default(eT),
                totalPrice: C.A,
                endTimestamp: eF
            });
            let MarketplaceV3Offers = class MarketplaceV3Offers {
                featureName = aE.name;
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e, this.events = new ContractEvents(this.contractWrapper), this.encoder = new ContractEncoder(this.contractWrapper), this.interceptor = new ContractInterceptor(this.contractWrapper), this.estimator = new GasCostEstimator(this.contractWrapper)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async getTotalCount() {
                    return await this.contractWrapper.read("totalOffers", [])
                }
                async getAll(t) {
                    let e = await this.getTotalCount(),
                        r = v.O$.from(t ? .start || 0).toNumber(),
                        a = e.toNumber();
                    if (0 === a) throw Error("No offers exist on the contract.");
                    let n = [],
                        i = await getAllInBatches(r, a, (t, e) => this.contractWrapper.read("getAllOffers", [t, e]));
                    n = i.flat();
                    let s = await this.applyFilter(n, t);
                    return await Promise.all(s.map(t => this.mapOffer(t)))
                }
                async getAllValid(t) {
                    let e = await this.getTotalCount(),
                        r = v.O$.from(t ? .start || 0).toNumber(),
                        a = e.toNumber();
                    if (0 === a) throw Error("No offers exist on the contract.");
                    let n = [],
                        i = await getAllInBatches(r, a, (t, e) => this.contractWrapper.read("getAllValidOffers", [t, e]));
                    n = i.flat();
                    let s = await this.applyFilter(n, t);
                    return await Promise.all(s.map(t => this.mapOffer(t)))
                }
                async getOffer(t) {
                    let e = await this.contractWrapper.read("getOffer", [t]);
                    return await this.mapOffer(e)
                }
                makeOffer = buildTransactionFunction(async t => {
                    let e = await is.parseAsync(t),
                        r = await this.contractWrapper.getChainID(),
                        a = isNativeToken(e.currencyContractAddress) ? eE[r].wrapped.address : e.currencyContractAddress,
                        n = await normalizePriceValue(this.contractWrapper.getProvider(), e.totalPrice, a),
                        i = await this.contractWrapper.getCallOverrides();
                    return await setErc20Allowance(this.contractWrapper, n, a, i), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "makeOffer",
                        args: [{
                            assetContract: e.assetContractAddress,
                            tokenId: e.tokenId,
                            quantity: e.quantity,
                            currency: a,
                            totalPrice: n,
                            expirationTimestamp: e.endTimestamp
                        }],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("NewOffer", t ? .logs);
                            return {
                                id: e[0].args.offerId,
                                receipt: t
                            }
                        }
                    })
                });
                cancelOffer = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "cancelOffer",
                    args: [t]
                }));
                acceptOffer = buildTransactionFunction(async t => {
                    let e = await this.validateOffer(v.O$.from(t)),
                        {
                            valid: r,
                            error: a
                        } = await this.isStillValidOffer(e);
                    if (!r) throw Error(`Offer ${t} is no longer valid. ${a}`);
                    let n = await this.contractWrapper.getCallOverrides() || {};
                    return await handleTokenApproval(this.contractWrapper, this.getAddress(), e.assetContractAddress, e.tokenId, await this.contractWrapper.getSignerAddress()), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "acceptOffer",
                        args: [t],
                        overrides: n
                    })
                });
                async validateOffer(t) {
                    try {
                        return await this.getOffer(t)
                    } catch (e) {
                        throw console.error(`Error getting the offer with id ${t}`), e
                    }
                }
                async mapOffer(t) {
                    let e = n4.UNSET,
                        r = await this.contractWrapper.getProvider().getBlock("latest"),
                        a = r.timestamp;
                    switch (t.status) {
                        case 1:
                            e = v.O$.from(t.expirationTimestamp).lt(a) ? n4.Expired : n4.Active;
                            break;
                        case 2:
                            e = n4.Completed;
                            break;
                        case 3:
                            e = n4.Cancelled
                    }
                    return {
                        id: t.offerId.toString(),
                        offerorAddress: t.offeror,
                        assetContractAddress: t.assetContract,
                        currencyContractAddress: t.currency,
                        tokenId: t.tokenId.toString(),
                        quantity: t.quantity.toString(),
                        totalPrice: t.totalPrice.toString(),
                        currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), t.currency, t.totalPrice),
                        asset: await fetchTokenMetadataForContract(t.assetContract, this.contractWrapper.getProvider(), t.tokenId, this.storage),
                        endTimeInSeconds: v.O$.from(t.expirationTimestamp).toNumber(),
                        status: e
                    }
                }
                async isStillValidOffer(t) {
                    let e = v.O$.from(Math.floor(Date.now() / 1e3));
                    if (e.gt(t.endTimeInSeconds)) return {
                        valid: !1,
                        error: `Offer with ID ${t.id} has expired`
                    };
                    let r = await this.contractWrapper.getChainID(),
                        a = isNativeToken(t.currencyContractAddress) ? eE[r].wrapped.address : t.currencyContractAddress,
                        n = this.contractWrapper.getProvider(),
                        i = new ContractWrapper(n, a, K, {}, this.storage),
                        s = await i.read("balanceOf", [t.offerorAddress]);
                    if (s.lt(t.totalPrice)) return {
                        valid: !1,
                        error: `Offeror ${t.offerorAddress} doesn't have enough balance of token ${a}`
                    };
                    let o = await i.read("allowance", [t.offerorAddress, this.getAddress()]);
                    return o.lt(t.totalPrice) ? {
                        valid: !1,
                        error: `Offeror ${t.offerorAddress} hasn't approved enough amount of token ${a}`
                    } : {
                        valid: !0,
                        error: ""
                    }
                }
                async applyFilter(t, e) {
                    let r = [...t];
                    if (e) {
                        if (e.offeror) {
                            let t = await resolveAddress(e.offeror);
                            r = r.filter(e => e.offeror.toString().toLowerCase() === t ? .toString().toLowerCase())
                        }
                        if (e.tokenContract) {
                            let t = await resolveAddress(e.tokenContract);
                            r = r.filter(e => e.assetContract.toString().toLowerCase() === t ? .toString().toLowerCase())
                        }
                        void 0 !== e.tokenId && (r = r.filter(t => t.tokenId.toString() === e ? .tokenId ? .toString()))
                    }
                    return e ? .count && e.count < r.length ? r.slice(0, e.count) : r
                }
            };
            let ContractPlatformFee = class ContractPlatformFee {
                featureName = af.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                async get() {
                    let [t, e] = await this.contractWrapper.read("getPlatformFeeInfo", []);
                    return e3.parseAsync({
                        platform_fee_recipient: t,
                        platform_fee_basis_points: e
                    })
                }
                set = buildTransactionFunction(async t => {
                    let e = await e3.parseAsync(t);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setPlatformFeeInfo",
                        args: [e.platform_fee_recipient, e.platform_fee_basis_points]
                    })
                })
            };
            let ContractPublishedMetadata = class ContractPublishedMetadata {
                constructor(t, e) {
                    this.contractWrapper = t, this.storage = e
                }
                async get() {
                    return this._cachedMetadata || (this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options)), this._cachedMetadata
                }
                async extractFunctions() {
                    let t;
                    try {
                        t = await this.get()
                    } catch (t) {}
                    return extractFunctionsFromAbi(ro.parse(this.contractWrapper.abi), t ? .metadata)
                }
                async extractEvents() {
                    let t;
                    try {
                        t = await this.get()
                    } catch (t) {}
                    return function(t, e) {
                        let r = ro.parse(t || []),
                            a = r.filter(t => "event" === t.type),
                            n = [];
                        for (let t of a) {
                            let r = extractCommentFromMetadata(t.name, e, "events");
                            n.push({
                                inputs: t.inputs || [],
                                outputs: t.outputs || [],
                                name: t.name || "unknown",
                                comment: r
                            })
                        }
                        return n
                    }(ro.parse(this.contractWrapper.abi), t ? .metadata)
                }
            };
            let ContractOwner = class ContractOwner {
                featureName = aw.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                async get() {
                    return this.contractWrapper.read("owner", [])
                }
                set = buildTransactionFunction(async t => {
                    let e = await resolveAddress(t);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setOwner",
                        args: [e]
                    })
                })
            };
            let ContractAppURI = class ContractAppURI {
                featureName = ay.name;
                constructor(t, e, r) {
                    this.contractWrapper = t, this.metadata = e, this.storage = r
                }
                async get() {
                    return detectContractFeature(this.contractWrapper, "AppURI") ? await this.contractWrapper.read("appURI", []) : (0, G.ov)((await this.metadata.get()).app_uri || "", this.storage.getGatewayUrls())
                }
                set = buildTransactionFunction(async t => detectContractFeature(this.contractWrapper, "AppURI") ? Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "setAppURI",
                    args: [t]
                }) : await this.metadata.update.prepare({
                    app_uri: t
                }))
            };
            async function extractConstructorParams(t, e) {
                let r = await fetchPreDeployMetadata(t, e);
                return extractConstructorParamsFromAbi(r.abi)
            }
            async function extractFunctions(t, e) {
                let r = await fetchPreDeployMetadata(t, e);
                return extractFunctionsFromAbi(r.abi, r.metadata)
            }

            function getFunctionSignature(t) {
                return "(" + t.map(t => "tuple" === t.type ? getFunctionSignature(t.components) : "tuple[]" === t.type ? getFunctionSignature(t.components) + "[]" : t.type).join(",") + ")"
            }

            function generateExtensionFunctions(t) {
                let e = new _.vU(t),
                    r = [];
                for (let t of Object.values(e.functions)) {
                    let a = e.getFunction(e.getSighash(t));
                    a.name.startsWith("_") || r.push({
                        functionSelector: e.getSighash(a),
                        functionSignature: a.name + getFunctionSignature(a.inputs)
                    })
                }
                return r
            }
            async function getDeploymentInfo(t, e, r, a, n, i) {
                nZ.deploymentPresets = {};
                let s = a || await getCreate2FactoryAddress(r),
                    o = {},
                    c = [],
                    {
                        compilerMetadata: l,
                        extendedMetadata: d
                    } = await fetchAndCacheDeployMetadata(t, e),
                    p = d ? .defaultExtensions;
                if (d ? .routerType === "plugin" && p) {
                    (0, j.Z)(n || i, "Require Client Id / Secret Key");
                    let t = await Promise.all(p.map(t => fetchPublishedContractFromPolygon(t.publisherAddress, t.extensionName, t.extensionVersion, e, n, i))),
                        a = (await Promise.all(t.map(async t => fetchAndCacheDeployMetadata(t.metadataUri, e)))).map(t => t.compilerMetadata),
                        l = await Promise.all(a.map(async t => {
                            let a = await computeDeploymentInfo("plugin", r, e, s, {
                                metadata: t
                            }, n, i);
                            return a
                        })),
                        d = [];
                    a.forEach((t, e) => {
                        let r = function(t, e) {
                            let r = new _.vU(e),
                                a = [];
                            for (let e of Object.values(r.functions)) {
                                let n = r.getFunction(r.getSighash(e));
                                n.name.includes("_") || a.push({
                                    functionSelector: r.getSighash(n),
                                    functionSignature: n.name + getFunctionSignature(n.inputs),
                                    pluginAddress: t
                                })
                            }
                            return a
                        }(l[e].transaction.predictedAddress, t.abi);
                        d.push(...r)
                    });
                    let u = await computeDeploymentInfo("plugin", r, e, s, {
                        contractName: "PluginMap",
                        constructorParams: {
                            _pluginsToAdd: {
                                value: d
                            }
                        }
                    }, n, i);
                    o._pluginMap = {
                        value: u.transaction.predictedAddress
                    }, c.push(...l, u)
                } else if (d ? .routerType === "dynamic" && p) {
                    (0, j.Z)(n || i, "Require Client Id / Secret Key");
                    let t = await Promise.all(p.map(t => fetchPublishedContractFromPolygon(t.publisherAddress, t.extensionName, t.extensionVersion, e, n, i))),
                        a = (await Promise.all(t.map(async t => fetchAndCacheDeployMetadata(t.metadataUri, e)))).map(t => t.compilerMetadata),
                        l = await Promise.all(a.map(async t => {
                            let a = await computeDeploymentInfo("extension", r, e, s, {
                                metadata: t
                            }, n, i);
                            return a
                        })),
                        d = [];
                    a.forEach((t, e) => {
                        let r = generateExtensionFunctions(t.abi);
                        d.push({
                            metadata: {
                                name: t.name,
                                metadataURI: "",
                                implementation: l[e].transaction.predictedAddress
                            },
                            functions: r
                        })
                    }), o._extensions = {
                        value: d
                    }, c.push(...l)
                }
                let u = await computeDeploymentInfo("implementation", r, e, s, {
                        metadata: l,
                        constructorParams: o
                    }, n, i),
                    f = await computeDeploymentInfo("infra", r, e, s, {
                        contractName: "TWCloneFactory"
                    }, n, i);
                return c.push(f), c.push(...Object.values(nZ.deploymentPresets)), c.push(u), c
            }
            async function deployContractDeterministic(t, e, r) {
                let a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 7e6;
                (0, j.Z)(t.provider, "Provider required");
                let n = await isContractDeployed(e.predictedAddress, t.provider);
                if (!n) {
                    console.debug(`deploying contract via create2 factory at: ${e.predictedAddress}`);
                    let n = {
                        to: e.to,
                        data: e.data
                    };
                    try {
                        await t.estimateGas(n)
                    } catch (t) {
                        console.debug("error estimating gas while deploying prebuilt: ", t), n.gasLimit = v.O$.from(a)
                    }
                    r ? .notifier ? .("deploying", "preset"), await (await t.sendTransaction(n)).wait(), r ? .notifier ? .("deployed", "preset")
                }
            }

            function createTransactionBatches(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e6;
                if (0 === (t = t.filter(t => t.data.length > 0)).length) return [];
                let r = [],
                    a = 0,
                    n = [];
                return t.forEach(t => {
                    var i;
                    let s;
                    let o = (i = t.data, s = Math.floor(64 * (s = x.arrayify(i).map(t => 0 === t ? 4 : 16).reduce((t, e) => t + e) + 200 * i.length / 2 + 6 * Math.ceil(i.length / 64) + 32e3 + 21e3) / 63));
                    a + o > e ? 0 === n.length ? r.push([t]) : (r.push(n), a = o, n = [t]) : (a += o, n.push(t))
                }), n.length > 0 && r.push(n), r
            }
            async function deployWithThrowawayDeployer(t, e, r) {
                let a = createTransactionBatches(e);
                if (0 === a.length) return;
                r ? .notifier ? .("deploying", "infra");
                let n = await Promise.all(a.map(e => {
                    let r = new O.lV(a4, "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033").connect(t).deploy(e);
                    return r
                }));
                await Promise.all(n.map(t => t.deployed())), r ? .notifier ? .("deployed", "infra")
            }
            async function getCompositeABIfromRelease(t, e) {
                let {
                    extendedMetadata: r
                } = await fetchAndCacheDeployMetadata(t, e), a = r ? .compositeAbi || [];
                return a
            }
            async function getPluginABI(t, e, r) {
                return (await Promise.all(t.map(t => fetchContractMetadataFromAddress(t, e, r).catch(e => (console.error(`Failed to fetch plug-in for ${t}`, e), {
                    abi: []
                }))))).map(t => t.abi)
            }
            async function getCompositePluginABI(t, e, r, a, n) {
                let i = [];
                try {
                    let s = isFeatureEnabled(ro.parse(e), "PluginRouter"),
                        o = isFeatureEnabled(ro.parse(e), "DynamicContract");
                    if (o) {
                        let e = new ContractWrapper(r, t, ad, a, n),
                            s = await e.call("getAllExtensions"),
                            o = s.map(t => t.metadata.implementation);
                        i = await getPluginABI(o, r, n)
                    } else if (s) {
                        let e = new ContractWrapper(r, t, al, a, n),
                            s = await e.call("getAllPlugins"),
                            o = s.map(t => t.pluginAddress),
                            c = Array.from(new Set(o));
                        i = await getPluginABI(c, r, n)
                    }
                } catch (t) {}
                return i.length > 0 ? joinABIs([e, ...i]) : e
            }
            let io = e2.merge(eM).merge(e4),
                ic = e5.merge(eM).merge(e4),
                il = io.merge(e3).merge(e8).merge(e7),
                id = {
                    deploy: il,
                    output: ic,
                    input: io
                },
                ip = e2.merge(e6).merge(e4),
                iu = e5.merge(e6).merge(e4),
                im = ip.merge(e7),
                ih = {
                    deploy: im,
                    output: iu,
                    input: ip
                },
                ig = ["admin"],
                iy = ["admin", "minter", "transfer"],
                iw = ["admin", "lister", "asset"],
                ib = ["admin", "minter", "asset", "transfer"],
                iC = ["admin", "transfer"],
                iA = ["admin", "transfer", "minter", "unwrap", "asset"],
                iv = {
                    vote: "vote",
                    token: "token",
                    "edition-drop": "edition-drop",
                    edition: "edition",
                    marketplace: "marketplace",
                    "marketplace-v3": "marketplace-v3",
                    multiwrap: "multiwrap",
                    "nft-collection": "nft-collection",
                    "nft-drop": "nft-drop",
                    pack: "pack",
                    "signature-drop": "signature-drop",
                    split: "split",
                    "token-drop": "token-drop"
                },
                iW = {
                    name: "DropERC1155",
                    contractType: iv["edition-drop"],
                    schema: no,
                    roles: iy,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iW.getAbi(i, c, s), r.e(2362).then(r.bind(r, 82362)), c.getNetwork()]);
                        return new d.EditionDrop(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        if (n) return n;
                        let i = await getContractInfo(t, e);
                        return !i || i.version > 2 ? (await r.e(794).then(r.t.bind(r, 30794, 19))).default : (await r.e(2919).then(r.t.bind(r, 12919, 19))).default
                    }
                },
                iT = {
                    name: "TokenERC1155",
                    contractType: iv.edition,
                    schema: nx,
                    roles: iy,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iT.getAbi(i, c, s), r.e(6142).then(r.bind(r, 6142)), c.getNetwork()]);
                        return new d.Edition(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(8469).then(r.t.bind(r, 38469, 19))).default
                    }
                },
                iE = {
                    name: "Marketplace",
                    contractType: iv.marketplace,
                    schema: nl,
                    roles: iw,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iE.getAbi(i, c, s), r.e(535).then(r.bind(r, 40535)), c.getNetwork()]);
                        return new d.Marketplace(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(8838).then(r.t.bind(r, 38838, 19))).default
                    }
                },
                ik = {
                    name: "MarketplaceV3",
                    contractType: iv["marketplace-v3"],
                    schema: nl,
                    roles: iw,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([ik.getAbi(i, c, s, o), r.e(9314).then(r.bind(r, 69314)), c.getNetwork()]);
                        return new d.MarketplaceV3(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a, n) => {
                        let i = (await e.getNetwork()).chainId;
                        if (280 === i || 324 === i) {
                            let t = await fetchPublishedContractFromPolygon(nH, "MarketplaceV3", "latest", a, n ? .clientId, n ? .secretKey),
                                e = t.metadataUri,
                                r = await getCompositeABIfromRelease(e, a);
                            return r
                        }
                        let s = await fetchAbiFromAddress(t, e, a);
                        if (s) return await getCompositePluginABI(t, s, e, {}, a);
                        let o = (await r.e(6079).then(r.t.bind(r, 86079, 19))).default;
                        return await getCompositePluginABI(t, ro.parse(o || []), e, {}, a)
                    }
                },
                iS = {
                    name: "Multiwrap",
                    contractType: iv.multiwrap,
                    schema: ih,
                    roles: iA,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iS.getAbi(i, c, s), r.e(6063).then(r.bind(r, 96063)), c.getNetwork()]);
                        return new d.Multiwrap(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(8133).then(r.t.bind(r, 18133, 19))).default
                    }
                },
                iP = {
                    name: "TokenERC721",
                    contractType: iv["nft-collection"],
                    schema: nS,
                    roles: iy,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iP.getAbi(i, c, s), r.e(9468).then(r.bind(r, 49468)), c.getNetwork()]);
                        return new d.NFTCollection(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(7505).then(r.t.bind(r, 27505, 19))).default
                    }
                },
                iF = {
                    name: "DropERC721",
                    contractType: iv["nft-drop"],
                    schema: na,
                    roles: iy,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iF.getAbi(i, c, s), r.e(7359).then(r.bind(r, 77359)), c.getNetwork()]);
                        return new d.NFTDrop(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        if (n) return n;
                        let i = await getContractInfo(t, e);
                        return !i || i.version > 3 ? (await r.e(4380).then(r.t.bind(r, 14380, 19))).default : (await r.e(4867).then(r.t.bind(r, 54867, 19))).default
                    }
                },
                iI = {
                    name: "Pack",
                    contractType: iv.pack,
                    schema: nf,
                    roles: ib,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iI.getAbi(i, c, s), r.e(7122).then(r.bind(r, 77122)), c.getNetwork()]);
                        return new d.Pack(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || ro.parse((await r.e(6482).then(r.t.bind(r, 16482, 19))).default || [])
                    }
                },
                ix = {
                    name: "SignatureDrop",
                    contractType: iv["signature-drop"],
                    schema: na,
                    roles: iy,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([ix.getAbi(i, c, s), r.e(6882).then(r.bind(r, 86882)), c.getNetwork()]);
                        return new d.SignatureDrop(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        if (n) return n;
                        let i = await getContractInfo(t, e);
                        return !i || i.version > 4 ? (await r.e(2184).then(r.t.bind(r, 42184, 19))).default : (await r.e(2717).then(r.t.bind(r, 32717, 19))).default
                    }
                },
                iM = {
                    name: "Split",
                    contractType: iv.split,
                    schema: nb,
                    roles: ig,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iM.getAbi(i, c, s), r.e(942).then(r.bind(r, 10942)), c.getNetwork()]);
                        return new d.Split(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(4338).then(r.t.bind(r, 54338, 19))).default
                    }
                },
                iR = {
                    name: "DropERC20",
                    contractType: iv["token-drop"],
                    schema: id,
                    roles: iC,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iR.getAbi(i, c, s), r.e(1432).then(r.bind(r, 11432)), c.getNetwork()]);
                        return new d.TokenDrop(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        if (n) return n;
                        let i = await getContractInfo(t, e);
                        return !i || i.version > 2 ? (await r.e(4279).then(r.t.bind(r, 4279, 19))).default : (await r.e(562).then(r.t.bind(r, 70562, 19))).default
                    }
                },
                iO = {
                    name: "TokenERC20",
                    contractType: iv.token,
                    schema: nW,
                    roles: iy,
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iO.getAbi(i, c, s), r.e(224).then(r.bind(r, 60224)), c.getNetwork()]);
                        return new d.Token(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(2687).then(r.t.bind(r, 22687, 19))).default
                    }
                },
                iN = {
                    name: "VoteERC20",
                    contractType: iv.vote,
                    schema: nB,
                    roles: [],
                    initialize: async function() {
                        for (var t = arguments.length, e = Array(t), a = 0; a < t; a++) e[a] = arguments[a];
                        let [n, i, s, o] = e, [, c] = getSignerAndProvider(n, o), [l, d, p] = await Promise.all([iN.getAbi(i, c, s), r.e(3863).then(r.bind(r, 33863)), c.getNetwork()]);
                        return new d.Vote(n, i, s, o, l, p.chainId)
                    },
                    getAbi: async (t, e, a) => {
                        let n = await fetchAbiFromAddress(t, e, a);
                        return n || (await r.e(5311).then(r.t.bind(r, 75311, 19))).default
                    }
                };
            async function getContractInfo(t, e) {
                try {
                    return await getPrebuiltInfo(t, e)
                } catch (t) {
                    return
                }
            }
            let iD = {
                    [iv["edition-drop"]]: iW,
                    [iv.edition]: iT,
                    [iv.marketplace]: iE,
                    [iv["marketplace-v3"]]: ik,
                    [iv.multiwrap]: iS,
                    [iv["nft-collection"]]: iP,
                    [iv["nft-drop"]]: iF,
                    [iv.pack]: iI,
                    [iv["signature-drop"]]: ix,
                    [iv.split]: iM,
                    [iv["token-drop"]]: iR,
                    [iv.token]: iO,
                    [iv.vote]: iN
                },
                iB = {
                    [iv["edition-drop"]]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
                    [iv.edition]: "",
                    [iv.marketplace]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
                    [iv["marketplace-v3"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
                    [iv.multiwrap]: "",
                    [iv["nft-collection"]]: "",
                    [iv["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
                    [iv.pack]: "",
                    [iv["signature-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
                    [iv.split]: "",
                    [iv["token-drop"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
                    [iv.token]: "",
                    [iv.vote]: ""
                },
                iL = {
                    name: "SmartContract",
                    contractType: "custom",
                    schema: {},
                    roles: n8
                },
                iz = { ...iD,
                    [iL.contractType]: iL
                };

            function getContractTypeForRemoteName(t) {
                return Object.values(iz).find(e => e.name === t) ? .contractType || "custom"
            }

            function getContractName(t) {
                return Object.values(iz).find(e => e.contractType === t) ? .name
            }
            let i$ = A.z.object({
                    startDate: eP,
                    expirationDate: eF,
                    nativeTokenLimitPerTransaction: C.A.default(0),
                    approvedCallTargets: A.z.array(eA)
                }),
                iU = A.z.array(A.z.object({
                    signer: eA,
                    makeAdmin: A.z.boolean(),
                    permissions: i$
                })),
                iV = [{
                    name: "signer",
                    type: "address"
                }, {
                    name: "approvedTargets",
                    type: "address[]"
                }, {
                    name: "nativeTokenLimitPerTransaction",
                    type: "uint256"
                }, {
                    name: "permissionStartTimestamp",
                    type: "uint128"
                }, {
                    name: "permissionEndTimestamp",
                    type: "uint128"
                }, {
                    name: "reqValidityStartTimestamp",
                    type: "uint128"
                }, {
                    name: "reqValidityEndTimestamp",
                    type: "uint128"
                }, {
                    name: "uid",
                    type: "bytes32"
                }];
            let AccountPermissions = class AccountPermissions {
                featureName = aS.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                hasDuplicateSigners(t) {
                    let e = {},
                        r = t.map(t => t.signer);
                    for (let t of r) {
                        if (e[t]) return !0;
                        e[t] = !0
                    }
                    return !1
                }
                parseSignerPermissionsStruct(t) {
                    return {
                        startDate: new Date(1e3 * parseInt(t.startTimestamp.toString())),
                        expirationDate: new Date(1e3 * parseInt(t.endTimestamp.toString())),
                        nativeTokenLimitPerTransaction: v.O$.from(t.nativeTokenLimitPerTransaction),
                        approvedCallTargets: t.approvedTargets
                    }
                }
                async sendSignerPermissionRequest(t, e) {
                    let {
                        payload: r,
                        signature: a
                    } = await this.generatePayload(t, e), [n] = await this.contractWrapper.read("verifySignerPermissionRequest", [r, a]);
                    if (!n) throw Error("Invalid signature.");
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setPermissionsForSigner",
                        args: [r, a]
                    })
                }
                async buildSignerPermissionRequest(t, e) {
                    let {
                        payload: r,
                        signature: a
                    } = await this.generatePayload(t, e), n = await this.contractWrapper.read("verifySignerPermissionRequest", [r, a]);
                    if (!n) throw Error("Invalid signature.");
                    return this.contractWrapper.writeContract.interface.encodeFunctionData("setPermissionsForSigner", [r, a])
                }
                async generatePayload(t, e) {
                    let r = {
                            signer: t,
                            approvedTargets: e.approvedCallTargets,
                            nativeTokenLimitPerTransaction: R.parseEther(e.nativeTokenLimitPerTransaction),
                            permissionStartTimestamp: e.startDate,
                            permissionEndTimestamp: e.expirationDate,
                            reqValidityStartTimestamp: 0,
                            reqValidityEndTimestamp: v.O$.from(Math.floor(new Date(Date.now() + 31536e7).getTime() / 1e3)),
                            uid: resolveOrGenerateId(void 0)
                        },
                        a = await this.contractWrapper.getChainID(),
                        n = this.contractWrapper.getSigner();
                    (0, j.Z)(n, "No signer available");
                    let i = await this.contractWrapper.signTypedData(n, {
                        name: "Account",
                        version: "1",
                        chainId: a,
                        verifyingContract: this.getAddress()
                    }, {
                        SignerPermissionRequest: iV
                    }, r);
                    return {
                        payload: r,
                        signature: i
                    }
                }
                async isAdmin(t) {
                    let e = await resolveAddress(t);
                    return await this.contractWrapper.read("isAdmin", [e])
                }
                async isSigner(t) {
                    let e = await resolveAddress(t);
                    return await this.contractWrapper.read("isActiveSigner", [e])
                }
                async getAllAdmins() {
                    return await this.contractWrapper.read("getAllAdmins", [])
                }
                async getAllSigners() {
                    let t = await this.contractWrapper.read("getAllActiveSigners", []);
                    return await Promise.all(t.map(async t => {
                        let e = t.signer,
                            r = this.parseSignerPermissionsStruct(t);
                        return {
                            signer: e,
                            permissions: r
                        }
                    }))
                }
                async getAllAdminsAndSigners() {
                    let t = await this.getAllAdmins(),
                        e = t.map(t => ({
                            isAdmin: !0,
                            signer: t,
                            permissions: {
                                startDate: new Date(0),
                                expirationDate: new Date(0),
                                nativeTokenLimitPerTransaction: v.O$.from(0),
                                approvedCallTargets: []
                            }
                        })),
                        r = await this.getAllSigners();
                    return [...e, ...r]
                }
                grantAdminPermissions = buildTransactionFunction(async t => {
                    let e = await resolveAddress(t);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setAdmin",
                        args: [e, !0]
                    })
                });
                revokeAdminPermissions = buildTransactionFunction(async t => {
                    let e = await resolveAddress(t);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "setAdmin",
                        args: [e, !1]
                    })
                });
                grantPermissions = buildTransactionFunction(async (t, e) => {
                    let r = await resolveAddress(t),
                        a = await i$.parseAsync(e);
                    if (await this.isAdmin(r)) throw Error("Signer is already an admin. Cannot grant permissions to an existing admin.");
                    if (await this.isSigner(r)) throw Error("Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.");
                    return await this.sendSignerPermissionRequest(r, a)
                });
                updatePermissions = buildTransactionFunction(async (t, e) => {
                    let r = await resolveAddress(t),
                        a = await i$.parseAsync(e);
                    if (await this.isAdmin(r)) throw Error("Signer is already an admin. Cannot update permissions of an existing admin.");
                    if (!await this.isSigner(r)) throw Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
                    return await this.sendSignerPermissionRequest(r, a)
                });
                revokeAccess = buildTransactionFunction(async t => {
                    let e = await resolveAddress(t);
                    if (await this.isAdmin(e)) throw Error("Signer is already an admin. Cannot revoke permissions of an admin.");
                    if (!await this.isSigner(e)) throw Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
                    return await this.sendSignerPermissionRequest(e, {
                        startDate: v.O$.from(0),
                        expirationDate: v.O$.from(0),
                        approvedCallTargets: [],
                        nativeTokenLimitPerTransaction: "0"
                    })
                });
                approveTargetForSigner = buildTransactionFunction(async (t, e) => {
                    let r = await resolveAddress(t),
                        a = await resolveAddress(e);
                    if (await this.isAdmin(r)) throw Error("Signer is already an admin. Cannot approve targets for an admin.");
                    if (!await this.isSigner(r)) throw Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
                    let n = await this.contractWrapper.read("getPermissionsForSigner", [r]);
                    if (n.approvedTargets.includes(e)) throw Error("Target is already approved");
                    let i = [...n.approvedTargets, a];
                    return await this.sendSignerPermissionRequest(r, {
                        startDate: v.O$.from(n.startTimestamp),
                        expirationDate: v.O$.from(n.endTimestamp),
                        approvedCallTargets: i,
                        nativeTokenLimitPerTransaction: n.nativeTokenLimitPerTransaction.toString()
                    })
                });
                disapproveTargetForSigner = buildTransactionFunction(async (t, e) => {
                    let r = await resolveAddress(t),
                        a = await resolveAddress(e);
                    if (await this.isAdmin(r)) throw Error("Signer is already an admin. Cannot approve targets for an admin.");
                    if (!await this.isSigner(r)) throw Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
                    let n = await this.contractWrapper.read("getPermissionsForSigner", [r]);
                    if (!n.approvedTargets.includes(a)) throw Error("Target is currently not approved");
                    let i = n.approvedTargets.filter(t => F.getAddress(t) !== F.getAddress(a));
                    return await this.sendSignerPermissionRequest(r, {
                        startDate: v.O$.from(n.startTimestamp),
                        expirationDate: v.O$.from(n.endTimestamp),
                        approvedCallTargets: i,
                        nativeTokenLimitPerTransaction: n.nativeTokenLimitPerTransaction.toString()
                    })
                });
                resetAllPermissions = buildTransactionFunction(async t => {
                    let e = await iU.parseAsync(t);
                    if (this.hasDuplicateSigners(e)) throw Error("Duplicate signers found in input.");
                    let r = [],
                        a = [],
                        n = [],
                        i = [],
                        s = await this.getAllAdmins(),
                        o = e.filter(t => t.makeAdmin).map(t => t.signer);
                    s.forEach(t => {
                        o.includes(t) || a.push(this.contractWrapper.writeContract.interface.encodeFunctionData("setAdmin", [t, !1]))
                    });
                    let c = await this.getAllSigners(),
                        l = e.filter(t => !t.makeAdmin).map(t => t.signer);
                    for (let t of (await Promise.all(c.map(async t => {
                            if (!l.includes(t.signer)) {
                                let e = await this.buildSignerPermissionRequest(t.signer, {
                                    startDate: v.O$.from(0),
                                    expirationDate: v.O$.from(0),
                                    approvedCallTargets: [],
                                    nativeTokenLimitPerTransaction: "0"
                                });
                                i.push(e)
                            }
                        })), e))
                        if (t.makeAdmin) r.push(this.contractWrapper.writeContract.interface.encodeFunctionData("setAdmin", [t.signer, !0]));
                        else {
                            let e = await this.buildSignerPermissionRequest(t.signer, t.permissions);
                            n.push(e)
                        }
                    let d = [];
                    return a.forEach(t => {
                        d.push(t)
                    }), i.forEach(t => {
                        d.push(t)
                    }), n.forEach(t => {
                        d.push(t)
                    }), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "multicall",
                        args: [d]
                    })
                })
            };
            let Account = class Account {
                featureName = aP.name;
                constructor(t) {
                    this.contractWrapper = t, this.accountPermissions = this.detectAccountPermissions()
                }
                detectAccountPermissions() {
                    if (detectContractFeature(this.contractWrapper, "AccountPermissions")) return new AccountPermissions(this.contractWrapper)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async isAdmin(t) {
                    return assertEnabled(this.accountPermissions, aS).isAdmin(t)
                }
                async isSigner(t) {
                    return assertEnabled(this.accountPermissions, aS).isSigner(t)
                }
                async getAllAdmins() {
                    return assertEnabled(this.accountPermissions, aS).getAllAdmins()
                }
                async getAllSigners() {
                    return assertEnabled(this.accountPermissions, aS).getAllSigners()
                }
                async getAllAdminsAndSigners() {
                    return assertEnabled(this.accountPermissions, aS).getAllAdminsAndSigners()
                }
                grantAdminPermissions = buildTransactionFunction(async t => assertEnabled(this.accountPermissions, aS).grantAdminPermissions.prepare(t));
                revokeAdminPermissions = buildTransactionFunction(async t => assertEnabled(this.accountPermissions, aS).revokeAdminPermissions.prepare(t));
                grantPermissions = buildTransactionFunction(async (t, e) => assertEnabled(this.accountPermissions, aS).grantPermissions.prepare(t, e));
                updatePermissions = buildTransactionFunction(async (t, e) => assertEnabled(this.accountPermissions, aS).updatePermissions.prepare(t, e));
                revokeAccess = buildTransactionFunction(async t => assertEnabled(this.accountPermissions, aS).revokeAccess.prepare(t));
                approveTargetForSigner = buildTransactionFunction(async (t, e) => assertEnabled(this.accountPermissions, aS).approveTargetForSigner.prepare(t, e));
                disapproveTargetForSigner = buildTransactionFunction(async (t, e) => assertEnabled(this.accountPermissions, aS).disapproveTargetForSigner.prepare(t, e));
                resetAllPermissions = buildTransactionFunction(async t => assertEnabled(this.accountPermissions, aS).resetAllPermissions.prepare(t))
            };
            let AccountFactory = class AccountFactory {
                featureName = ak.name;
                constructor(t) {
                    this.contractWrapper = t, this.events = new ContractEvents(this.contractWrapper)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                async predictAccountAddress(t, e) {
                    let r = M.Y0("");
                    return e && (r = e), this.contractWrapper.read("getAddress", [t, r])
                }
                async getAssociatedAccounts(t) {
                    return this.contractWrapper.read("getAccountsOfSigner", [t])
                }
                async getAllAccounts() {
                    return await this.contractWrapper.read("getAllAccounts", [])
                }
                async isAccountDeployed(t, e) {
                    let r = await this.predictAccountAddress(t, e);
                    return isContractDeployed(r, this.contractWrapper.getProvider())
                }
                createAccount = buildTransactionFunction(async (t, e) => {
                    if (await this.isAccountDeployed(t, e)) throw Error(`Account already deployed for admin: ${t}`);
                    let r = M.Y0("");
                    return e && (r = e), Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "createAccount",
                        args: [t, r],
                        parse: t => {
                            let e = this.contractWrapper.parseLogs("AccountCreated", t ? .logs);
                            return {
                                address: e[0].args.account,
                                receipt: t
                            }
                        }
                    })
                })
            };
            let Airdrop1155 = class Airdrop1155 {
                featureName = ax.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                drop = buildTransactionFunction(async (t, e, r) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "airdropERC1155",
                    args: [t, e, r],
                    parse: t => {
                        let e = this.contractWrapper.parseLogs("AirdropFailed", t.logs),
                            a = e.map(t => ({
                                recipient: t.args.recipient,
                                tokenId: t.args.tokenId.toNumber(),
                                amount: t.args.amount.toString()
                            }));
                        return {
                            successfulDropCount: r.length - a.length,
                            failedDropCount: a.length,
                            failedDrops: a
                        }
                    }
                }))
            };
            let Airdrop20 = class Airdrop20 {
                featureName = aF.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                drop = buildTransactionFunction(async (t, e, r) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "airdropERC20",
                    args: [t, e, r],
                    parse: t => {
                        let e = this.contractWrapper.parseLogs("AirdropFailed", t.logs),
                            a = e.map(t => ({
                                recipient: t.args.recipient,
                                amount: t.args.amount.toString()
                            }));
                        return {
                            successfulDropCount: r.length - a.length,
                            failedDropCount: a.length,
                            failedDrops: a
                        }
                    }
                }))
            };
            let Airdrop721 = class Airdrop721 {
                featureName = aI.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                drop = buildTransactionFunction(async (t, e, r) => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "airdropERC721",
                    args: [t, e, r],
                    parse: t => {
                        let e = this.contractWrapper.parseLogs("AirdropFailed", t.logs),
                            a = e.map(t => ({
                                recipient: t.args.recipient,
                                tokenId: t.args.tokenId.toNumber()
                            }));
                        return {
                            successfulDropCount: r.length - a.length,
                            failedDropCount: a.length,
                            failedDrops: a
                        }
                    }
                }))
            };
            let ExtensionManager = class ExtensionManager {
                featureName = av.name;
                constructor(t) {
                    this.contractWrapper = t
                }
                getAddress() {
                    return this.contractWrapper.readContract.address
                }
                async getAll() {
                    let t = await this.contractWrapper.readContract.getAllExtensions();
                    return t
                }
                async get(t) {
                    let e = await this.contractWrapper.readContract.getExtension(t);
                    return e
                }
                async getExtensionAddress(t) {
                    let e = await this.get(t);
                    return e.metadata.implementation
                }
                async getAllFunctions(t) {
                    let e = await this.get(t);
                    return e.functions
                }
                async getExtensionForFunction(t) {
                    let e = t.functionSelector;
                    e || ((0, j.Z)(t.functionSignature, "Atleast one of function selector and signature must be provided"), e = B.id(t.functionSignature).substring(0, 10));
                    let r = await this.contractWrapper.readContract.getMetadataForFunction(e);
                    return r
                }
                async getExtensionAddressForFunction(t) {
                    let e = await this.getExtensionForFunction(t);
                    return e.implementation
                }
                add = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "addExtension",
                    args: [t.extension],
                    parse: async e => {
                        let r = this.contractWrapper.parseLogs("ExtensionAdded", e.logs);
                        if (r.length < 1) throw Error("No ExtensionAdded event found");
                        let a = t.extensionAbi ? ro.parse(t.extensionAbi) : (await fetchContractMetadataFromAddress(t.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi,
                            n = this.filterAbiForAdd(a, t.extension),
                            i = joinABIs([ro.parse(this.contractWrapper.abi), n]);
                        return this.contractWrapper.updateAbi(i), e
                    }
                }));
                addDeployed = buildTransactionFunction(async t => {
                    let e = t.extensionAbi;
                    if (!e) {
                        let r = await fetchContractMetadataFromAddress(t.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
                        e = r.abi
                    }(0, j.Z)(e, "Require extension ABI");
                    let r = "";
                    if (t.extensionMetadata) {
                        if ("string" == typeof t.extensionMetadata) r = t.extensionMetadata;
                        else {
                            let e = await e2.parseAsync(t.extensionMetadata);
                            r = await this.contractWrapper.storage.upload(e)
                        }
                    }
                    let a = generateExtensionFunctions(ro.parse(e)),
                        n = {
                            metadata: {
                                name: t.extensionName,
                                metadataURI: r,
                                implementation: t.extensionAddress
                            },
                            functions: a
                        };
                    return this.add.prepare({
                        extension: n,
                        extensionAbi: e
                    })
                });
                addPublished = buildTransactionFunction(async t => {
                    let e = t.version || "latest",
                        {
                            deployedExtensionAddress: r,
                            extensionMetadata: a
                        } = await this.deployExtension(t.extensionName, t.publisherAddress || nH, e);
                    return this.addDeployed.prepare({
                        extensionName: t.extensionName,
                        extensionAddress: r,
                        extensionMetadata: t.extensionMetadataOverride || a
                    })
                });
                replace = buildTransactionFunction(async t => Transaction.fromContractWrapper({
                    contractWrapper: this.contractWrapper,
                    method: "replaceExtension",
                    args: [t.extension],
                    parse: async e => {
                        let r = this.contractWrapper.parseLogs("ExtensionReplaced", e.logs);
                        if (r.length < 1) throw Error("No ExtensionReplaced event found");
                        let a = t.extensionAbi ? ro.parse(t.extensionAbi) : (await fetchContractMetadataFromAddress(t.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi,
                            n = this.filterAbiForRemove(ro.parse(this.contractWrapper.abi), a),
                            i = this.filterAbiForAdd(a, t.extension),
                            s = joinABIs([n, i]);
                        return this.contractWrapper.updateAbi(s), e
                    }
                }));
                replaceDeployed = buildTransactionFunction(async t => {
                    let e = t.extensionAbi;
                    if (!e) {
                        let r = await fetchContractMetadataFromAddress(t.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
                        e = r.abi
                    }(0, j.Z)(e, "Require extension ABI");
                    let r = "";
                    if (t.extensionMetadata) {
                        if ("string" == typeof t.extensionMetadata) r = t.extensionMetadata;
                        else {
                            let e = await e2.parseAsync(t.extensionMetadata);
                            r = await this.contractWrapper.storage.upload(e)
                        }
                    }
                    let a = generateExtensionFunctions(ro.parse(e)),
                        n = {
                            metadata: {
                                name: t.extensionName,
                                metadataURI: r,
                                implementation: t.extensionAddress
                            },
                            functions: a
                        };
                    return this.replace.prepare({
                        extension: n,
                        extensionAbi: e
                    })
                });
                replacePublished = buildTransactionFunction(async t => {
                    let e = t.version || "latest",
                        {
                            deployedExtensionAddress: r,
                            extensionMetadata: a
                        } = await this.deployExtension(t.extensionName, t.publisherAddress || nH, e);
                    return this.replaceDeployed.prepare({
                        extensionName: t.extensionName,
                        extensionAddress: r,
                        extensionMetadata: t.extensionMetadataOverride || a
                    })
                });
                remove = buildTransactionFunction(async t => {
                    let e = await this.getExtensionAddress(t.extensionName);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: "removeExtension",
                        args: [t.extensionName],
                        parse: async t => {
                            let r = this.contractWrapper.parseLogs("ExtensionRemoved", t.logs);
                            if (r.length < 1) throw Error("No ExtensionRemoved event found");
                            let a = (await fetchContractMetadataFromAddress(e, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi,
                                n = this.filterAbiForRemove(ro.parse(this.contractWrapper.abi), a);
                            return this.contractWrapper.updateAbi(n), t
                        }
                    })
                });
                filterAbiForAdd(t, e) {
                    let r = new _.vU(t),
                        a = e.functions.map(t => t.functionSelector),
                        n = t.filter(t => {
                            let e = Object.values(new _.vU([t]).functions);
                            if (0 === e.length) return !1;
                            let n = r.getSighash(e[0]);
                            return a.includes(n)
                        });
                    return n
                }
                filterAbiForRemove(t, e) {
                    let r = new _.vU(t),
                        a = new _.vU(e),
                        n = Object.values(a.functions).map(t => a.getSighash(t)),
                        i = t.filter(t => {
                            let e = Object.values(new _.vU([t]).functions);
                            if (0 === e.length) return !1;
                            let a = r.getSighash(e[0]);
                            return !n.includes(a)
                        });
                    return i
                }
                async deployExtension(t, e) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                        a = await fetchPublishedContractFromPolygon(e, t, r, this.contractWrapper.storage, this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey),
                        n = await getDeploymentInfo(a.metadataUri, this.contractWrapper.storage, this.contractWrapper.getProvider(), "", this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey),
                        i = n.find(t => "implementation" === t.type) ? .transaction.predictedAddress,
                        s = n.filter(t => t.transaction.data && t.transaction.data.length > 0),
                        o = s.filter(t => "infra" !== t.type).map(t => t.transaction),
                        c = s.filter(t => "infra" === t.type).map(t => t.transaction),
                        l = this.contractWrapper.getSigner();
                    for (let t of ((0, j.Z)(l, "Signer is required"), await deployWithThrowawayDeployer(l, c, {}), o)) try {
                        await deployContractDeterministic(l, t)
                    } catch (e) {
                        console.debug(`Error deploying contract at ${t.predictedAddress}`, e ? .message)
                    }
                    return {
                        deployedExtensionAddress: i,
                        extensionMetadata: a.metadataUri
                    }
                }
            };
            let SmartContract = class SmartContract {
                get abi() {
                    return ro.parse(this.contractWrapper.abi || [])
                }
                get royalties() {
                    return assertEnabled(this.detectRoyalties(), ap)
                }
                get roles() {
                    return assertEnabled(this.detectRoles(), ah)
                }
                get sales() {
                    return assertEnabled(this.detectPrimarySales(), au)
                }
                get platformFees() {
                    return assertEnabled(this.detectPlatformFees(), af)
                }
                get owner() {
                    return assertEnabled(this.detectOwnable(), aw)
                }
                get erc20() {
                    return assertEnabled(this.detectErc20(), rN)
                }
                get erc721() {
                    return assertEnabled(this.detectErc721(), r2)
                }
                get erc1155() {
                    return assertEnabled(this.detectErc1155(), ac)
                }
                get app() {
                    return assertEnabled(this.detectApp(), ay)
                }
                get directListings() {
                    return assertEnabled(this.detectDirectListings(), aW)
                }
                get englishAuctions() {
                    return assertEnabled(this.detectEnglishAuctions(), aT)
                }
                get offers() {
                    return assertEnabled(this.detectOffers(), aE)
                }
                get airdrop20() {
                    return assertEnabled(this.detectAirdrop20(), aF)
                }
                get airdrop721() {
                    return assertEnabled(this.detectAirdrop721(), aI)
                }
                get airdrop1155() {
                    return assertEnabled(this.detectAirdrop1155(), ax)
                }
                get accountFactory() {
                    return assertEnabled(this.detectAccountFactory(), ak)
                }
                get account() {
                    return assertEnabled(this.detectAccount(), aP)
                }
                get extensions() {
                    return assertEnabled(this.detectBaseRouter(), av)
                }
                get chainId() {
                    return this._chainId
                }
                constructor(t, e, r, a) {
                    let n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
                        i = arguments.length > 5 ? arguments[5] : void 0,
                        s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : new ContractWrapper(t, e, r, n, a);
                    this._chainId = i, this.storage = a, this.contractWrapper = s, this.events = new ContractEvents(this.contractWrapper), this.encoder = new ContractEncoder(this.contractWrapper), this.interceptor = new ContractInterceptor(this.contractWrapper), this.estimator = new GasCostEstimator(this.contractWrapper), this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage), this.metadata = new ContractMetadata(this.contractWrapper, ra, this.storage)
                }
                onNetworkUpdated(t) {
                    this.contractWrapper.updateSignerOrProvider(t)
                }
                getAddress() {
                    return this.contractWrapper.address
                }
                prepare(t, e, r) {
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.contractWrapper,
                        method: t,
                        args: e,
                        overrides: r
                    })
                }
                async call(t, e, r) {
                    return this.contractWrapper.call(t, e, r)
                }
                detectRoyalties() {
                    if (detectContractFeature(this.contractWrapper, "Royalty")) {
                        let t = new ContractMetadata(this.contractWrapper, ra, this.storage);
                        return new ContractRoyalty(this.contractWrapper, t)
                    }
                }
                detectRoles() {
                    if (detectContractFeature(this.contractWrapper, "Permissions")) return new ContractRoles(this.contractWrapper, n8)
                }
                detectPrimarySales() {
                    if (detectContractFeature(this.contractWrapper, "PrimarySale")) return new ContractPrimarySale(this.contractWrapper)
                }
                detectPlatformFees() {
                    if (detectContractFeature(this.contractWrapper, "PlatformFee")) return new ContractPlatformFee(this.contractWrapper)
                }
                detectErc20() {
                    if (detectContractFeature(this.contractWrapper, "ERC20")) return new Erc20(this.contractWrapper, this.storage, this.chainId)
                }
                detectErc721() {
                    if (detectContractFeature(this.contractWrapper, "ERC721")) return new Erc721(this.contractWrapper, this.storage, this.chainId)
                }
                detectErc1155() {
                    if (detectContractFeature(this.contractWrapper, "ERC1155")) return new Erc1155(this.contractWrapper, this.storage, this.chainId)
                }
                detectOwnable() {
                    if (detectContractFeature(this.contractWrapper, "Ownable")) return new ContractOwner(this.contractWrapper)
                }
                detectApp() {
                    let t = new ContractMetadata(this.contractWrapper, ra, this.storage);
                    return detectContractFeature(this.contractWrapper, "AppURI") ? new ContractAppURI(this.contractWrapper, t, this.storage) : detectContractFeature(this.contractWrapper, "ContractMetadata") ? new ContractAppURI(this.contractWrapper, t, this.storage) : void 0
                }
                detectDirectListings() {
                    if (detectContractFeature(this.contractWrapper, "DirectListings")) return new MarketplaceV3DirectListings(this.contractWrapper, this.storage)
                }
                detectEnglishAuctions() {
                    if (detectContractFeature(this.contractWrapper, "EnglishAuctions")) return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage)
                }
                detectOffers() {
                    if (detectContractFeature(this.contractWrapper, "Offers")) return new MarketplaceV3Offers(this.contractWrapper, this.storage)
                }
                detectBaseRouter() {
                    if (detectContractFeature(this.contractWrapper, av.name)) return new ExtensionManager(this.contractWrapper)
                }
                detectAirdrop20() {
                    if (detectContractFeature(this.contractWrapper, "AirdropERC20")) return new Airdrop20(this.contractWrapper)
                }
                detectAirdrop721() {
                    if (detectContractFeature(this.contractWrapper, "AirdropERC721")) return new Airdrop721(this.contractWrapper)
                }
                detectAirdrop1155() {
                    if (detectContractFeature(this.contractWrapper, "AirdropERC1155")) return new Airdrop1155(this.contractWrapper)
                }
                detectAccountFactory() {
                    if (detectContractFeature(this.contractWrapper, ak.name)) return new AccountFactory(this.contractWrapper)
                }
                detectAccount() {
                    if (detectContractFeature(this.contractWrapper, aP.name)) return new Account(this.contractWrapper)
                }
            };
            let ContractPublisher = class ContractPublisher extends RPCConnectionHandler {
                constructor(t, e, r) {
                    super(t, e), this.storage = r, this.publisher = new ContractWrapper(t, getContractPublisherAddress(), ti, e, r)
                }
                updateSignerOrProvider(t) {
                    super.updateSignerOrProvider(t), this.publisher.updateSignerOrProvider(t)
                }
                async extractConstructorParams(t) {
                    return extractConstructorParams(t, this.storage)
                }
                async extractFunctions(t) {
                    return extractFunctions(t, this.storage)
                }
                async fetchCompilerMetadataFromPredeployURI(t) {
                    return fetchPreDeployMetadata(t, this.storage)
                }
                async fetchPrePublishMetadata(t, e) {
                    let r = await fetchPreDeployMetadata(t, this.storage),
                        a = e ? await this.getLatest(e, r.name) : void 0,
                        n = a ? await this.fetchPublishedContractInfo(a) : void 0;
                    return {
                        preDeployMetadata: r,
                        latestPublishedContractMetadata: n
                    }
                }
                async fetchCompilerMetadataFromAddress(t) {
                    let e = await resolveAddress(t);
                    return fetchContractMetadataFromAddress(e, this.getProvider(), this.storage, this.options)
                }
                async fetchPublishedContractInfo(t) {
                    return {
                        name: t.id,
                        publishedTimestamp: t.timestamp,
                        publishedMetadata: await this.fetchFullPublishMetadata(t.metadataUri)
                    }
                }
                async fetchFullPublishMetadata(t) {
                    return fetchExtendedReleaseMetadata(t, this.storage)
                }
                async resolvePublishMetadataFromCompilerMetadata(t) {
                    let e = await this.publisher.read("getPublishedUriFromCompilerUri", [t]);
                    if (0 === e.length) throw Error(`Could not resolve published metadata URI from ${t}`);
                    return await Promise.all(e.filter(t => t.length > 0).map(t => this.fetchFullPublishMetadata(t)))
                }
                async resolveContractUriFromAddress(t) {
                    let e = await resolveAddress(t),
                        r = await resolveContractUriFromAddress(e, this.getProvider());
                    return (0, j.Z)(r, "Could not resolve contract URI from address"), r
                }
                async fetchContractSourcesFromAddress(t) {
                    let e = await resolveAddress(t),
                        r = await this.fetchCompilerMetadataFromAddress(e);
                    return await fetchSourceFilesFromMetadata(r, this.storage)
                }
                updatePublisherProfile = buildTransactionFunction(async t => {
                    let e = this.getSigner();
                    (0, j.Z)(e, "A signer is required");
                    let r = await e.getAddress(),
                        a = await this.storage.upload(t);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.publisher,
                        method: "setPublisherProfileUri",
                        args: [r, a]
                    })
                });
                async getPublisherProfile(t) {
                    let e = await resolveAddress(t),
                        r = await this.publisher.read("getPublisherProfileUri", [e]);
                    return r && 0 !== r.length ? rC.parse(await this.storage.downloadJSON(r)) : {}
                }
                async getAll(t) {
                    let e = await resolveAddress(t),
                        r = await this.publisher.read("getAllPublishedContracts", [e]),
                        a = r.reduce((t, e) => (t[e.contractId] = e, t), {});
                    return Object.entries(a).map(t => {
                        let [, e] = t;
                        return this.toPublishedContract(e)
                    })
                }
                async getAllVersions(t, e) {
                    let r = await resolveAddress(t),
                        a = await this.publisher.read("getPublishedContractVersions", [r, e]);
                    if (0 === a.length) throw Error("Not found");
                    return a.map(t => this.toPublishedContract(t))
                }
                async getVersion(t, e) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "latest",
                        a = await resolveAddress(t);
                    if ("latest" === r) return this.getLatest(a, e);
                    let n = await this.getAllVersions(a, e),
                        i = await Promise.all(n.map(t => this.fetchPublishedContractInfo(t))),
                        s = i.find(t => t.publishedMetadata.version === r);
                    return (0, j.Z)(s, "Contract version not found"), n.find(t => t.timestamp === s.publishedTimestamp)
                }
                async getLatest(t, e) {
                    let r = await resolveAddress(t),
                        a = await this.publisher.read("getPublishedContract", [r, e]);
                    if (a && a.publishMetadataUri) return this.toPublishedContract(a)
                }
                publish = buildTransactionFunction(async (t, e) => {
                    let r = this.getSigner();
                    (0, j.Z)(r, "A signer is required");
                    let a = await r.getAddress(),
                        n = await fetchRawPredeployMetadata(t, this.storage),
                        i = await fetchContractMetadata(n.metadataUri, this.storage),
                        s = isFeatureEnabled(ro.parse(i.abi), "PluginRouter"),
                        o = isFeatureEnabled(ro.parse(i.abi), "DynamicContract");
                    if (e.routerType = s ? "plugin" : o ? "dynamic" : "none", o || s) {
                        let t = e.defaultExtensions;
                        if (t && t.length > 0) try {
                            let r = await Promise.all(t.map(t => fetchPublishedContractFromPolygon(t.publisherAddress, t.extensionName, t.extensionVersion, this.storage, this.options.clientId, this.options.secretKey))),
                                a = r.map(t => t.metadataUri),
                                n = (await Promise.all(a.map(async t => fetchAndCacheDeployMetadata(t, this.storage)))).map(t => t.compilerMetadata.abi),
                                s = joinABIs([i.abi, ...n]);
                            e.compositeAbi = ro.parse(s)
                        } catch {}
                    }
                    let c = await this.getLatest(a, n.name);
                    if (c && c.metadataUri) {
                        let t = await this.fetchPublishedContractInfo(c),
                            r = t.publishedMetadata.version;
                        if (! function(t, e) {
                                let r = toSemver(t),
                                    a = toSemver(e);
                                if (a.major > r.major) return !0;
                                let n = a.major === r.major;
                                if (n && a.minor > r.minor) return !0;
                                let i = a.minor === r.minor;
                                return n && i && a.patch > r.patch
                            }(r, e.version)) throw Error(`Version ${e.version} is not greater than ${r}`)
                    }
                    let l = await (await this.storage.download(n.bytecodeUri)).text(),
                        d = l.startsWith("0x") ? l : `0x${l}`,
                        p = L.keccak256(["bytes"], [d]),
                        u = n.name,
                        f = await ry.parseAsync({ ...e,
                            metadataUri: n.metadataUri,
                            bytecodeUri: n.bytecodeUri,
                            name: n.name,
                            analytics: n.analytics,
                            publisher: a
                        }),
                        m = await this.storage.upload(f);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.publisher,
                        method: "publishContract",
                        args: [a, u, m, n.metadataUri, p, I.d],
                        parse: t => {
                            let e = this.publisher.parseLogs("ContractPublished", t.logs);
                            if (e.length < 1) throw Error("No ContractPublished event found");
                            let r = e[0].args.publishedContract;
                            return {
                                receipt: t,
                                data: async () => this.toPublishedContract(r)
                            }
                        }
                    })
                });
                unpublish = buildTransactionFunction(async (t, e) => {
                    let r = await resolveAddress(t);
                    return Transaction.fromContractWrapper({
                        contractWrapper: this.publisher,
                        method: "unpublishContract",
                        args: [r, e]
                    })
                });
                toPublishedContract(t) {
                    return rA.parse({
                        id: t.contractId,
                        timestamp: t.publishTimestamp,
                        metadataUri: t.publishMetadataUri
                    })
                }
            }
        }
    }
]);